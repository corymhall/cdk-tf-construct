"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod2) => function __require() {
  return mod2 || (0, cb[__getOwnPropNames(cb)[0]])((mod2 = { exports: {} }).exports, mod2), mod2.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod2, isNodeMode, target) => (target = mod2 != null ? __create(__getProtoOf(mod2)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod2 || !mod2.__esModule ? __defProp(target, "default", { value: mod2, enumerable: true }) : target,
  mod2
));
var __toCommonJS = (mod2) => __copyProps(__defProp({}, "__esModule", { value: true }), mod2);

// node_modules/msgpack-lite/lib/buffer-global.js
var require_buffer_global = __commonJS({
  "node_modules/msgpack-lite/lib/buffer-global.js"(exports2, module2) {
    module2.exports = c2("undefined" !== typeof Buffer && Buffer) || c2(exports2.Buffer) || c2("undefined" !== typeof window && window.Buffer) || exports2.Buffer;
    function c2(B) {
      return B && B.isBuffer && B;
    }
  }
});

// node_modules/isarray/index.js
var require_isarray = __commonJS({
  "node_modules/isarray/index.js"(exports2, module2) {
    var toString = {}.toString;
    module2.exports = Array.isArray || function(arr) {
      return toString.call(arr) == "[object Array]";
    };
  }
});

// node_modules/msgpack-lite/lib/bufferish-array.js
var require_bufferish_array = __commonJS({
  "node_modules/msgpack-lite/lib/bufferish-array.js"(exports2, module2) {
    var Bufferish = require_bufferish();
    var exports2 = module2.exports = alloc(0);
    exports2.alloc = alloc;
    exports2.concat = Bufferish.concat;
    exports2.from = from;
    function alloc(size) {
      return new Array(size);
    }
    function from(value) {
      if (!Bufferish.isBuffer(value) && Bufferish.isView(value)) {
        value = Bufferish.Uint8Array.from(value);
      } else if (Bufferish.isArrayBuffer(value)) {
        value = new Uint8Array(value);
      } else if (typeof value === "string") {
        return Bufferish.from.call(exports2, value);
      } else if (typeof value === "number") {
        throw new TypeError('"value" argument must not be a number');
      }
      return Array.prototype.slice.call(value);
    }
  }
});

// node_modules/msgpack-lite/lib/bufferish-buffer.js
var require_bufferish_buffer = __commonJS({
  "node_modules/msgpack-lite/lib/bufferish-buffer.js"(exports2, module2) {
    var Bufferish = require_bufferish();
    var Buffer2 = Bufferish.global;
    var exports2 = module2.exports = Bufferish.hasBuffer ? alloc(0) : [];
    exports2.alloc = Bufferish.hasBuffer && Buffer2.alloc || alloc;
    exports2.concat = Bufferish.concat;
    exports2.from = from;
    function alloc(size) {
      return new Buffer2(size);
    }
    function from(value) {
      if (!Bufferish.isBuffer(value) && Bufferish.isView(value)) {
        value = Bufferish.Uint8Array.from(value);
      } else if (Bufferish.isArrayBuffer(value)) {
        value = new Uint8Array(value);
      } else if (typeof value === "string") {
        return Bufferish.from.call(exports2, value);
      } else if (typeof value === "number") {
        throw new TypeError('"value" argument must not be a number');
      }
      if (Buffer2.from && Buffer2.from.length !== 1) {
        return Buffer2.from(value);
      } else {
        return new Buffer2(value);
      }
    }
  }
});

// node_modules/msgpack-lite/lib/bufferish-uint8array.js
var require_bufferish_uint8array = __commonJS({
  "node_modules/msgpack-lite/lib/bufferish-uint8array.js"(exports2, module2) {
    var Bufferish = require_bufferish();
    var exports2 = module2.exports = Bufferish.hasArrayBuffer ? alloc(0) : [];
    exports2.alloc = alloc;
    exports2.concat = Bufferish.concat;
    exports2.from = from;
    function alloc(size) {
      return new Uint8Array(size);
    }
    function from(value) {
      if (Bufferish.isView(value)) {
        var byteOffset = value.byteOffset;
        var byteLength = value.byteLength;
        value = value.buffer;
        if (value.byteLength !== byteLength) {
          if (value.slice) {
            value = value.slice(byteOffset, byteOffset + byteLength);
          } else {
            value = new Uint8Array(value);
            if (value.byteLength !== byteLength) {
              value = Array.prototype.slice.call(value, byteOffset, byteOffset + byteLength);
            }
          }
        }
      } else if (typeof value === "string") {
        return Bufferish.from.call(exports2, value);
      } else if (typeof value === "number") {
        throw new TypeError('"value" argument must not be a number');
      }
      return new Uint8Array(value);
    }
  }
});

// node_modules/msgpack-lite/lib/buffer-lite.js
var require_buffer_lite = __commonJS({
  "node_modules/msgpack-lite/lib/buffer-lite.js"(exports2) {
    exports2.copy = copy;
    exports2.toString = toString;
    exports2.write = write;
    function write(string, offset) {
      var buffer = this;
      var index = offset || (offset |= 0);
      var length = string.length;
      var chr = 0;
      var i = 0;
      while (i < length) {
        chr = string.charCodeAt(i++);
        if (chr < 128) {
          buffer[index++] = chr;
        } else if (chr < 2048) {
          buffer[index++] = 192 | chr >>> 6;
          buffer[index++] = 128 | chr & 63;
        } else if (chr < 55296 || chr > 57343) {
          buffer[index++] = 224 | chr >>> 12;
          buffer[index++] = 128 | chr >>> 6 & 63;
          buffer[index++] = 128 | chr & 63;
        } else {
          chr = (chr - 55296 << 10 | string.charCodeAt(i++) - 56320) + 65536;
          buffer[index++] = 240 | chr >>> 18;
          buffer[index++] = 128 | chr >>> 12 & 63;
          buffer[index++] = 128 | chr >>> 6 & 63;
          buffer[index++] = 128 | chr & 63;
        }
      }
      return index - offset;
    }
    function toString(encoding, start, end) {
      var buffer = this;
      var index = start | 0;
      if (!end)
        end = buffer.length;
      var string = "";
      var chr = 0;
      while (index < end) {
        chr = buffer[index++];
        if (chr < 128) {
          string += String.fromCharCode(chr);
          continue;
        }
        if ((chr & 224) === 192) {
          chr = (chr & 31) << 6 | buffer[index++] & 63;
        } else if ((chr & 240) === 224) {
          chr = (chr & 15) << 12 | (buffer[index++] & 63) << 6 | buffer[index++] & 63;
        } else if ((chr & 248) === 240) {
          chr = (chr & 7) << 18 | (buffer[index++] & 63) << 12 | (buffer[index++] & 63) << 6 | buffer[index++] & 63;
        }
        if (chr >= 65536) {
          chr -= 65536;
          string += String.fromCharCode((chr >>> 10) + 55296, (chr & 1023) + 56320);
        } else {
          string += String.fromCharCode(chr);
        }
      }
      return string;
    }
    function copy(target, targetStart, start, end) {
      var i;
      if (!start)
        start = 0;
      if (!end && end !== 0)
        end = this.length;
      if (!targetStart)
        targetStart = 0;
      var len = end - start;
      if (target === this && start < targetStart && targetStart < end) {
        for (i = len - 1; i >= 0; i--) {
          target[i + targetStart] = this[i + start];
        }
      } else {
        for (i = 0; i < len; i++) {
          target[i + targetStart] = this[i + start];
        }
      }
      return len;
    }
  }
});

// node_modules/msgpack-lite/lib/bufferish-proto.js
var require_bufferish_proto = __commonJS({
  "node_modules/msgpack-lite/lib/bufferish-proto.js"(exports2) {
    var BufferLite = require_buffer_lite();
    exports2.copy = copy;
    exports2.slice = slice;
    exports2.toString = toString;
    exports2.write = gen("write");
    var Bufferish = require_bufferish();
    var Buffer2 = Bufferish.global;
    var isBufferShim = Bufferish.hasBuffer && "TYPED_ARRAY_SUPPORT" in Buffer2;
    var brokenTypedArray = isBufferShim && !Buffer2.TYPED_ARRAY_SUPPORT;
    function copy(target, targetStart, start, end) {
      var thisIsBuffer = Bufferish.isBuffer(this);
      var targetIsBuffer = Bufferish.isBuffer(target);
      if (thisIsBuffer && targetIsBuffer) {
        return this.copy(target, targetStart, start, end);
      } else if (!brokenTypedArray && !thisIsBuffer && !targetIsBuffer && Bufferish.isView(this) && Bufferish.isView(target)) {
        var buffer = start || end != null ? slice.call(this, start, end) : this;
        target.set(buffer, targetStart);
        return buffer.length;
      } else {
        return BufferLite.copy.call(this, target, targetStart, start, end);
      }
    }
    function slice(start, end) {
      var f2 = this.slice || !brokenTypedArray && this.subarray;
      if (f2)
        return f2.call(this, start, end);
      var target = Bufferish.alloc.call(this, end - start);
      copy.call(this, target, 0, start, end);
      return target;
    }
    function toString(encoding, start, end) {
      var f2 = !isBufferShim && Bufferish.isBuffer(this) ? this.toString : BufferLite.toString;
      return f2.apply(this, arguments);
    }
    function gen(method) {
      return wrap;
      function wrap() {
        var f2 = this[method] || BufferLite[method];
        return f2.apply(this, arguments);
      }
    }
  }
});

// node_modules/msgpack-lite/lib/bufferish.js
var require_bufferish = __commonJS({
  "node_modules/msgpack-lite/lib/bufferish.js"(exports2) {
    var Buffer2 = exports2.global = require_buffer_global();
    var hasBuffer = exports2.hasBuffer = Buffer2 && !!Buffer2.isBuffer;
    var hasArrayBuffer = exports2.hasArrayBuffer = "undefined" !== typeof ArrayBuffer;
    var isArray = exports2.isArray = require_isarray();
    exports2.isArrayBuffer = hasArrayBuffer ? isArrayBuffer : _false;
    var isBuffer = exports2.isBuffer = hasBuffer ? Buffer2.isBuffer : _false;
    var isView = exports2.isView = hasArrayBuffer ? ArrayBuffer.isView || _is("ArrayBuffer", "buffer") : _false;
    exports2.alloc = alloc;
    exports2.concat = concat;
    exports2.from = from;
    var BufferArray = exports2.Array = require_bufferish_array();
    var BufferBuffer = exports2.Buffer = require_bufferish_buffer();
    var BufferUint8Array = exports2.Uint8Array = require_bufferish_uint8array();
    var BufferProto = exports2.prototype = require_bufferish_proto();
    function from(value) {
      if (typeof value === "string") {
        return fromString.call(this, value);
      } else {
        return auto(this).from(value);
      }
    }
    function alloc(size) {
      return auto(this).alloc(size);
    }
    function concat(list, length) {
      if (!length) {
        length = 0;
        Array.prototype.forEach.call(list, dryrun);
      }
      var ref = this !== exports2 && this || list[0];
      var result = alloc.call(ref, length);
      var offset = 0;
      Array.prototype.forEach.call(list, append);
      return result;
      function dryrun(buffer) {
        length += buffer.length;
      }
      function append(buffer) {
        offset += BufferProto.copy.call(buffer, result, offset);
      }
    }
    var _isArrayBuffer = _is("ArrayBuffer");
    function isArrayBuffer(value) {
      return value instanceof ArrayBuffer || _isArrayBuffer(value);
    }
    function fromString(value) {
      var expected = value.length * 3;
      var that = alloc.call(this, expected);
      var actual = BufferProto.write.call(that, value);
      if (expected !== actual) {
        that = BufferProto.slice.call(that, 0, actual);
      }
      return that;
    }
    function auto(that) {
      return isBuffer(that) ? BufferBuffer : isView(that) ? BufferUint8Array : isArray(that) ? BufferArray : hasBuffer ? BufferBuffer : hasArrayBuffer ? BufferUint8Array : BufferArray;
    }
    function _false() {
      return false;
    }
    function _is(name, key) {
      name = "[object " + name + "]";
      return function(value) {
        return value != null && {}.toString.call(key ? value[key] : value) === name;
      };
    }
  }
});

// node_modules/msgpack-lite/lib/ext-buffer.js
var require_ext_buffer = __commonJS({
  "node_modules/msgpack-lite/lib/ext-buffer.js"(exports2) {
    exports2.ExtBuffer = ExtBuffer;
    var Bufferish = require_bufferish();
    function ExtBuffer(buffer, type) {
      if (!(this instanceof ExtBuffer))
        return new ExtBuffer(buffer, type);
      this.buffer = Bufferish.from(buffer);
      this.type = type;
    }
  }
});

// node_modules/msgpack-lite/lib/ext-packer.js
var require_ext_packer = __commonJS({
  "node_modules/msgpack-lite/lib/ext-packer.js"(exports2) {
    exports2.setExtPackers = setExtPackers;
    var Bufferish = require_bufferish();
    var Buffer2 = Bufferish.global;
    var packTypedArray = Bufferish.Uint8Array.from;
    var _encode;
    var ERROR_COLUMNS = { name: 1, message: 1, stack: 1, columnNumber: 1, fileName: 1, lineNumber: 1 };
    function setExtPackers(codec2) {
      codec2.addExtPacker(14, Error, [packError, encode3]);
      codec2.addExtPacker(1, EvalError, [packError, encode3]);
      codec2.addExtPacker(2, RangeError, [packError, encode3]);
      codec2.addExtPacker(3, ReferenceError, [packError, encode3]);
      codec2.addExtPacker(4, SyntaxError, [packError, encode3]);
      codec2.addExtPacker(5, TypeError, [packError, encode3]);
      codec2.addExtPacker(6, URIError, [packError, encode3]);
      codec2.addExtPacker(10, RegExp, [packRegExp, encode3]);
      codec2.addExtPacker(11, Boolean, [packValueOf, encode3]);
      codec2.addExtPacker(12, String, [packValueOf, encode3]);
      codec2.addExtPacker(13, Date, [Number, encode3]);
      codec2.addExtPacker(15, Number, [packValueOf, encode3]);
      if ("undefined" !== typeof Uint8Array) {
        codec2.addExtPacker(17, Int8Array, packTypedArray);
        codec2.addExtPacker(18, Uint8Array, packTypedArray);
        codec2.addExtPacker(19, Int16Array, packTypedArray);
        codec2.addExtPacker(20, Uint16Array, packTypedArray);
        codec2.addExtPacker(21, Int32Array, packTypedArray);
        codec2.addExtPacker(22, Uint32Array, packTypedArray);
        codec2.addExtPacker(23, Float32Array, packTypedArray);
        if ("undefined" !== typeof Float64Array) {
          codec2.addExtPacker(24, Float64Array, packTypedArray);
        }
        if ("undefined" !== typeof Uint8ClampedArray) {
          codec2.addExtPacker(25, Uint8ClampedArray, packTypedArray);
        }
        codec2.addExtPacker(26, ArrayBuffer, packTypedArray);
        codec2.addExtPacker(29, DataView, packTypedArray);
      }
      if (Bufferish.hasBuffer) {
        codec2.addExtPacker(27, Buffer2, Bufferish.from);
      }
    }
    function encode3(input) {
      if (!_encode)
        _encode = require_encode().encode;
      return _encode(input);
    }
    function packValueOf(value) {
      return value.valueOf();
    }
    function packRegExp(value) {
      value = RegExp.prototype.toString.call(value).split("/");
      value.shift();
      var out = [value.pop()];
      out.unshift(value.join("/"));
      return out;
    }
    function packError(value) {
      var out = {};
      for (var key in ERROR_COLUMNS) {
        out[key] = value[key];
      }
      return out;
    }
  }
});

// node_modules/int64-buffer/int64-buffer.js
var require_int64_buffer = __commonJS({
  "node_modules/int64-buffer/int64-buffer.js"(exports2) {
    var Uint64BE;
    var Int64BE;
    var Uint64LE;
    var Int64LE;
    !function(exports3) {
      var UNDEFINED = "undefined";
      var BUFFER = UNDEFINED !== typeof Buffer && Buffer;
      var UINT8ARRAY = UNDEFINED !== typeof Uint8Array && Uint8Array;
      var ARRAYBUFFER = UNDEFINED !== typeof ArrayBuffer && ArrayBuffer;
      var ZERO = [0, 0, 0, 0, 0, 0, 0, 0];
      var isArray = Array.isArray || _isArray;
      var BIT32 = 4294967296;
      var BIT24 = 16777216;
      var storage;
      Uint64BE = factory("Uint64BE", true, true);
      Int64BE = factory("Int64BE", true, false);
      Uint64LE = factory("Uint64LE", false, true);
      Int64LE = factory("Int64LE", false, false);
      function factory(name, bigendian, unsigned) {
        var posH = bigendian ? 0 : 4;
        var posL = bigendian ? 4 : 0;
        var pos0 = bigendian ? 0 : 3;
        var pos1 = bigendian ? 1 : 2;
        var pos2 = bigendian ? 2 : 1;
        var pos3 = bigendian ? 3 : 0;
        var fromPositive = bigendian ? fromPositiveBE : fromPositiveLE;
        var fromNegative = bigendian ? fromNegativeBE : fromNegativeLE;
        var proto2 = Int64.prototype;
        var isName = "is" + name;
        var _isInt64 = "_" + isName;
        proto2.buffer = void 0;
        proto2.offset = 0;
        proto2[_isInt64] = true;
        proto2.toNumber = toNumber;
        proto2.toString = toString;
        proto2.toJSON = toNumber;
        proto2.toArray = toArray;
        if (BUFFER)
          proto2.toBuffer = toBuffer;
        if (UINT8ARRAY)
          proto2.toArrayBuffer = toArrayBuffer;
        Int64[isName] = isInt64;
        exports3[name] = Int64;
        return Int64;
        function Int64(buffer, offset, value, raddix) {
          if (!(this instanceof Int64))
            return new Int64(buffer, offset, value, raddix);
          return init(this, buffer, offset, value, raddix);
        }
        function isInt64(b2) {
          return !!(b2 && b2[_isInt64]);
        }
        function init(that, buffer, offset, value, raddix) {
          if (UINT8ARRAY && ARRAYBUFFER) {
            if (buffer instanceof ARRAYBUFFER)
              buffer = new UINT8ARRAY(buffer);
            if (value instanceof ARRAYBUFFER)
              value = new UINT8ARRAY(value);
          }
          if (!buffer && !offset && !value && !storage) {
            that.buffer = newArray(ZERO, 0);
            return;
          }
          if (!isValidBuffer(buffer, offset)) {
            var _storage = storage || Array;
            raddix = offset;
            value = buffer;
            offset = 0;
            buffer = new _storage(8);
          }
          that.buffer = buffer;
          that.offset = offset |= 0;
          if (UNDEFINED === typeof value)
            return;
          if ("string" === typeof value) {
            fromString(buffer, offset, value, raddix || 10);
          } else if (isValidBuffer(value, raddix)) {
            fromArray(buffer, offset, value, raddix);
          } else if ("number" === typeof raddix) {
            writeInt32(buffer, offset + posH, value);
            writeInt32(buffer, offset + posL, raddix);
          } else if (value > 0) {
            fromPositive(buffer, offset, value);
          } else if (value < 0) {
            fromNegative(buffer, offset, value);
          } else {
            fromArray(buffer, offset, ZERO, 0);
          }
        }
        function fromString(buffer, offset, str, raddix) {
          var pos = 0;
          var len = str.length;
          var high = 0;
          var low = 0;
          if (str[0] === "-")
            pos++;
          var sign = pos;
          while (pos < len) {
            var chr = parseInt(str[pos++], raddix);
            if (!(chr >= 0))
              break;
            low = low * raddix + chr;
            high = high * raddix + Math.floor(low / BIT32);
            low %= BIT32;
          }
          if (sign) {
            high = ~high;
            if (low) {
              low = BIT32 - low;
            } else {
              high++;
            }
          }
          writeInt32(buffer, offset + posH, high);
          writeInt32(buffer, offset + posL, low);
        }
        function toNumber() {
          var buffer = this.buffer;
          var offset = this.offset;
          var high = readInt32(buffer, offset + posH);
          var low = readInt32(buffer, offset + posL);
          if (!unsigned)
            high |= 0;
          return high ? high * BIT32 + low : low;
        }
        function toString(radix) {
          var buffer = this.buffer;
          var offset = this.offset;
          var high = readInt32(buffer, offset + posH);
          var low = readInt32(buffer, offset + posL);
          var str = "";
          var sign = !unsigned && high & 2147483648;
          if (sign) {
            high = ~high;
            low = BIT32 - low;
          }
          radix = radix || 10;
          while (1) {
            var mod2 = high % radix * BIT32 + low;
            high = Math.floor(high / radix);
            low = Math.floor(mod2 / radix);
            str = (mod2 % radix).toString(radix) + str;
            if (!high && !low)
              break;
          }
          if (sign) {
            str = "-" + str;
          }
          return str;
        }
        function writeInt32(buffer, offset, value) {
          buffer[offset + pos3] = value & 255;
          value = value >> 8;
          buffer[offset + pos2] = value & 255;
          value = value >> 8;
          buffer[offset + pos1] = value & 255;
          value = value >> 8;
          buffer[offset + pos0] = value & 255;
        }
        function readInt32(buffer, offset) {
          return buffer[offset + pos0] * BIT24 + (buffer[offset + pos1] << 16) + (buffer[offset + pos2] << 8) + buffer[offset + pos3];
        }
      }
      function toArray(raw) {
        var buffer = this.buffer;
        var offset = this.offset;
        storage = null;
        if (raw !== false && offset === 0 && buffer.length === 8 && isArray(buffer))
          return buffer;
        return newArray(buffer, offset);
      }
      function toBuffer(raw) {
        var buffer = this.buffer;
        var offset = this.offset;
        storage = BUFFER;
        if (raw !== false && offset === 0 && buffer.length === 8 && Buffer.isBuffer(buffer))
          return buffer;
        var dest = new BUFFER(8);
        fromArray(dest, 0, buffer, offset);
        return dest;
      }
      function toArrayBuffer(raw) {
        var buffer = this.buffer;
        var offset = this.offset;
        var arrbuf = buffer.buffer;
        storage = UINT8ARRAY;
        if (raw !== false && offset === 0 && arrbuf instanceof ARRAYBUFFER && arrbuf.byteLength === 8)
          return arrbuf;
        var dest = new UINT8ARRAY(8);
        fromArray(dest, 0, buffer, offset);
        return dest.buffer;
      }
      function isValidBuffer(buffer, offset) {
        var len = buffer && buffer.length;
        offset |= 0;
        return len && offset + 8 <= len && "string" !== typeof buffer[offset];
      }
      function fromArray(destbuf, destoff, srcbuf, srcoff) {
        destoff |= 0;
        srcoff |= 0;
        for (var i = 0; i < 8; i++) {
          destbuf[destoff++] = srcbuf[srcoff++] & 255;
        }
      }
      function newArray(buffer, offset) {
        return Array.prototype.slice.call(buffer, offset, offset + 8);
      }
      function fromPositiveBE(buffer, offset, value) {
        var pos = offset + 8;
        while (pos > offset) {
          buffer[--pos] = value & 255;
          value /= 256;
        }
      }
      function fromNegativeBE(buffer, offset, value) {
        var pos = offset + 8;
        value++;
        while (pos > offset) {
          buffer[--pos] = -value & 255 ^ 255;
          value /= 256;
        }
      }
      function fromPositiveLE(buffer, offset, value) {
        var end = offset + 8;
        while (offset < end) {
          buffer[offset++] = value & 255;
          value /= 256;
        }
      }
      function fromNegativeLE(buffer, offset, value) {
        var end = offset + 8;
        value++;
        while (offset < end) {
          buffer[offset++] = -value & 255 ^ 255;
          value /= 256;
        }
      }
      function _isArray(val) {
        return !!val && "[object Array]" == Object.prototype.toString.call(val);
      }
    }(typeof exports2 === "object" && typeof exports2.nodeName !== "string" ? exports2 : exports2 || {});
  }
});

// node_modules/ieee754/index.js
var require_ieee754 = __commonJS({
  "node_modules/ieee754/index.js"(exports2) {
    exports2.read = function(buffer, offset, isLE, mLen, nBytes) {
      var e2, m;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var nBits = -7;
      var i = isLE ? nBytes - 1 : 0;
      var d2 = isLE ? -1 : 1;
      var s = buffer[offset + i];
      i += d2;
      e2 = s & (1 << -nBits) - 1;
      s >>= -nBits;
      nBits += eLen;
      for (; nBits > 0; e2 = e2 * 256 + buffer[offset + i], i += d2, nBits -= 8) {
      }
      m = e2 & (1 << -nBits) - 1;
      e2 >>= -nBits;
      nBits += mLen;
      for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d2, nBits -= 8) {
      }
      if (e2 === 0) {
        e2 = 1 - eBias;
      } else if (e2 === eMax) {
        return m ? NaN : (s ? -1 : 1) * Infinity;
      } else {
        m = m + Math.pow(2, mLen);
        e2 = e2 - eBias;
      }
      return (s ? -1 : 1) * m * Math.pow(2, e2 - mLen);
    };
    exports2.write = function(buffer, value, offset, isLE, mLen, nBytes) {
      var e2, m, c2;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
      var i = isLE ? 0 : nBytes - 1;
      var d2 = isLE ? 1 : -1;
      var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
      value = Math.abs(value);
      if (isNaN(value) || value === Infinity) {
        m = isNaN(value) ? 1 : 0;
        e2 = eMax;
      } else {
        e2 = Math.floor(Math.log(value) / Math.LN2);
        if (value * (c2 = Math.pow(2, -e2)) < 1) {
          e2--;
          c2 *= 2;
        }
        if (e2 + eBias >= 1) {
          value += rt / c2;
        } else {
          value += rt * Math.pow(2, 1 - eBias);
        }
        if (value * c2 >= 2) {
          e2++;
          c2 /= 2;
        }
        if (e2 + eBias >= eMax) {
          m = 0;
          e2 = eMax;
        } else if (e2 + eBias >= 1) {
          m = (value * c2 - 1) * Math.pow(2, mLen);
          e2 = e2 + eBias;
        } else {
          m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
          e2 = 0;
        }
      }
      for (; mLen >= 8; buffer[offset + i] = m & 255, i += d2, m /= 256, mLen -= 8) {
      }
      e2 = e2 << mLen | m;
      eLen += mLen;
      for (; eLen > 0; buffer[offset + i] = e2 & 255, i += d2, e2 /= 256, eLen -= 8) {
      }
      buffer[offset + i - d2] |= s * 128;
    };
  }
});

// node_modules/msgpack-lite/lib/write-uint8.js
var require_write_uint8 = __commonJS({
  "node_modules/msgpack-lite/lib/write-uint8.js"(exports2) {
    var constant = exports2.uint8 = new Array(256);
    for (i = 0; i <= 255; i++) {
      constant[i] = write0(i);
    }
    var i;
    function write0(type) {
      return function(encoder) {
        var offset = encoder.reserve(1);
        encoder.buffer[offset] = type;
      };
    }
  }
});

// node_modules/msgpack-lite/lib/write-token.js
var require_write_token = __commonJS({
  "node_modules/msgpack-lite/lib/write-token.js"(exports2) {
    var ieee754 = require_ieee754();
    var Int64Buffer = require_int64_buffer();
    var Uint64BE = Int64Buffer.Uint64BE;
    var Int64BE = Int64Buffer.Int64BE;
    var uint8 = require_write_uint8().uint8;
    var Bufferish = require_bufferish();
    var Buffer2 = Bufferish.global;
    var IS_BUFFER_SHIM = Bufferish.hasBuffer && "TYPED_ARRAY_SUPPORT" in Buffer2;
    var NO_TYPED_ARRAY = IS_BUFFER_SHIM && !Buffer2.TYPED_ARRAY_SUPPORT;
    var Buffer_prototype = Bufferish.hasBuffer && Buffer2.prototype || {};
    exports2.getWriteToken = getWriteToken;
    function getWriteToken(options) {
      if (options && options.uint8array) {
        return init_uint8array();
      } else if (NO_TYPED_ARRAY || Bufferish.hasBuffer && options && options.safe) {
        return init_safe();
      } else {
        return init_token();
      }
    }
    function init_uint8array() {
      var token = init_token();
      token[202] = writeN(202, 4, writeFloatBE);
      token[203] = writeN(203, 8, writeDoubleBE);
      return token;
    }
    function init_token() {
      var token = uint8.slice();
      token[196] = write1(196);
      token[197] = write2(197);
      token[198] = write4(198);
      token[199] = write1(199);
      token[200] = write2(200);
      token[201] = write4(201);
      token[202] = writeN(202, 4, Buffer_prototype.writeFloatBE || writeFloatBE, true);
      token[203] = writeN(203, 8, Buffer_prototype.writeDoubleBE || writeDoubleBE, true);
      token[204] = write1(204);
      token[205] = write2(205);
      token[206] = write4(206);
      token[207] = writeN(207, 8, writeUInt64BE);
      token[208] = write1(208);
      token[209] = write2(209);
      token[210] = write4(210);
      token[211] = writeN(211, 8, writeInt64BE);
      token[217] = write1(217);
      token[218] = write2(218);
      token[219] = write4(219);
      token[220] = write2(220);
      token[221] = write4(221);
      token[222] = write2(222);
      token[223] = write4(223);
      return token;
    }
    function init_safe() {
      var token = uint8.slice();
      token[196] = writeN(196, 1, Buffer2.prototype.writeUInt8);
      token[197] = writeN(197, 2, Buffer2.prototype.writeUInt16BE);
      token[198] = writeN(198, 4, Buffer2.prototype.writeUInt32BE);
      token[199] = writeN(199, 1, Buffer2.prototype.writeUInt8);
      token[200] = writeN(200, 2, Buffer2.prototype.writeUInt16BE);
      token[201] = writeN(201, 4, Buffer2.prototype.writeUInt32BE);
      token[202] = writeN(202, 4, Buffer2.prototype.writeFloatBE);
      token[203] = writeN(203, 8, Buffer2.prototype.writeDoubleBE);
      token[204] = writeN(204, 1, Buffer2.prototype.writeUInt8);
      token[205] = writeN(205, 2, Buffer2.prototype.writeUInt16BE);
      token[206] = writeN(206, 4, Buffer2.prototype.writeUInt32BE);
      token[207] = writeN(207, 8, writeUInt64BE);
      token[208] = writeN(208, 1, Buffer2.prototype.writeInt8);
      token[209] = writeN(209, 2, Buffer2.prototype.writeInt16BE);
      token[210] = writeN(210, 4, Buffer2.prototype.writeInt32BE);
      token[211] = writeN(211, 8, writeInt64BE);
      token[217] = writeN(217, 1, Buffer2.prototype.writeUInt8);
      token[218] = writeN(218, 2, Buffer2.prototype.writeUInt16BE);
      token[219] = writeN(219, 4, Buffer2.prototype.writeUInt32BE);
      token[220] = writeN(220, 2, Buffer2.prototype.writeUInt16BE);
      token[221] = writeN(221, 4, Buffer2.prototype.writeUInt32BE);
      token[222] = writeN(222, 2, Buffer2.prototype.writeUInt16BE);
      token[223] = writeN(223, 4, Buffer2.prototype.writeUInt32BE);
      return token;
    }
    function write1(type) {
      return function(encoder, value) {
        var offset = encoder.reserve(2);
        var buffer = encoder.buffer;
        buffer[offset++] = type;
        buffer[offset] = value;
      };
    }
    function write2(type) {
      return function(encoder, value) {
        var offset = encoder.reserve(3);
        var buffer = encoder.buffer;
        buffer[offset++] = type;
        buffer[offset++] = value >>> 8;
        buffer[offset] = value;
      };
    }
    function write4(type) {
      return function(encoder, value) {
        var offset = encoder.reserve(5);
        var buffer = encoder.buffer;
        buffer[offset++] = type;
        buffer[offset++] = value >>> 24;
        buffer[offset++] = value >>> 16;
        buffer[offset++] = value >>> 8;
        buffer[offset] = value;
      };
    }
    function writeN(type, len, method, noAssert) {
      return function(encoder, value) {
        var offset = encoder.reserve(len + 1);
        encoder.buffer[offset++] = type;
        method.call(encoder.buffer, value, offset, noAssert);
      };
    }
    function writeUInt64BE(value, offset) {
      new Uint64BE(this, offset, value);
    }
    function writeInt64BE(value, offset) {
      new Int64BE(this, offset, value);
    }
    function writeFloatBE(value, offset) {
      ieee754.write(this, value, offset, false, 23, 4);
    }
    function writeDoubleBE(value, offset) {
      ieee754.write(this, value, offset, false, 52, 8);
    }
  }
});

// node_modules/msgpack-lite/lib/write-type.js
var require_write_type = __commonJS({
  "node_modules/msgpack-lite/lib/write-type.js"(exports2) {
    var IS_ARRAY = require_isarray();
    var Int64Buffer = require_int64_buffer();
    var Uint64BE = Int64Buffer.Uint64BE;
    var Int64BE = Int64Buffer.Int64BE;
    var Bufferish = require_bufferish();
    var BufferProto = require_bufferish_proto();
    var WriteToken = require_write_token();
    var uint8 = require_write_uint8().uint8;
    var ExtBuffer = require_ext_buffer().ExtBuffer;
    var HAS_UINT8ARRAY = "undefined" !== typeof Uint8Array;
    var HAS_MAP = "undefined" !== typeof Map;
    var extmap = [];
    extmap[1] = 212;
    extmap[2] = 213;
    extmap[4] = 214;
    extmap[8] = 215;
    extmap[16] = 216;
    exports2.getWriteType = getWriteType;
    function getWriteType(options) {
      var token = WriteToken.getWriteToken(options);
      var useraw = options && options.useraw;
      var binarraybuffer = HAS_UINT8ARRAY && options && options.binarraybuffer;
      var isBuffer = binarraybuffer ? Bufferish.isArrayBuffer : Bufferish.isBuffer;
      var bin = binarraybuffer ? bin_arraybuffer : bin_buffer;
      var usemap = HAS_MAP && options && options.usemap;
      var map = usemap ? map_to_map : obj_to_map;
      var writeType = {
        "boolean": bool,
        "function": nil,
        "number": number,
        "object": useraw ? object_raw : object,
        "string": _string(useraw ? raw_head_size : str_head_size),
        "symbol": nil,
        "undefined": nil
      };
      return writeType;
      function bool(encoder, value) {
        var type = value ? 195 : 194;
        token[type](encoder, value);
      }
      function number(encoder, value) {
        var ivalue = value | 0;
        var type;
        if (value !== ivalue) {
          type = 203;
          token[type](encoder, value);
          return;
        } else if (-32 <= ivalue && ivalue <= 127) {
          type = ivalue & 255;
        } else if (0 <= ivalue) {
          type = ivalue <= 255 ? 204 : ivalue <= 65535 ? 205 : 206;
        } else {
          type = -128 <= ivalue ? 208 : -32768 <= ivalue ? 209 : 210;
        }
        token[type](encoder, ivalue);
      }
      function uint64(encoder, value) {
        var type = 207;
        token[type](encoder, value.toArray());
      }
      function int64(encoder, value) {
        var type = 211;
        token[type](encoder, value.toArray());
      }
      function str_head_size(length) {
        return length < 32 ? 1 : length <= 255 ? 2 : length <= 65535 ? 3 : 5;
      }
      function raw_head_size(length) {
        return length < 32 ? 1 : length <= 65535 ? 3 : 5;
      }
      function _string(head_size) {
        return string;
        function string(encoder, value) {
          var length = value.length;
          var maxsize = 5 + length * 3;
          encoder.offset = encoder.reserve(maxsize);
          var buffer = encoder.buffer;
          var expected = head_size(length);
          var start = encoder.offset + expected;
          length = BufferProto.write.call(buffer, value, start);
          var actual = head_size(length);
          if (expected !== actual) {
            var targetStart = start + actual - expected;
            var end = start + length;
            BufferProto.copy.call(buffer, buffer, targetStart, start, end);
          }
          var type = actual === 1 ? 160 + length : actual <= 3 ? 215 + actual : 219;
          token[type](encoder, length);
          encoder.offset += length;
        }
      }
      function object(encoder, value) {
        if (value === null)
          return nil(encoder, value);
        if (isBuffer(value))
          return bin(encoder, value);
        if (IS_ARRAY(value))
          return array(encoder, value);
        if (Uint64BE.isUint64BE(value))
          return uint64(encoder, value);
        if (Int64BE.isInt64BE(value))
          return int64(encoder, value);
        var packer = encoder.codec.getExtPacker(value);
        if (packer)
          value = packer(value);
        if (value instanceof ExtBuffer)
          return ext(encoder, value);
        map(encoder, value);
      }
      function object_raw(encoder, value) {
        if (isBuffer(value))
          return raw(encoder, value);
        object(encoder, value);
      }
      function nil(encoder, value) {
        var type = 192;
        token[type](encoder, value);
      }
      function array(encoder, value) {
        var length = value.length;
        var type = length < 16 ? 144 + length : length <= 65535 ? 220 : 221;
        token[type](encoder, length);
        var encode3 = encoder.codec.encode;
        for (var i = 0; i < length; i++) {
          encode3(encoder, value[i]);
        }
      }
      function bin_buffer(encoder, value) {
        var length = value.length;
        var type = length < 255 ? 196 : length <= 65535 ? 197 : 198;
        token[type](encoder, length);
        encoder.send(value);
      }
      function bin_arraybuffer(encoder, value) {
        bin_buffer(encoder, new Uint8Array(value));
      }
      function ext(encoder, value) {
        var buffer = value.buffer;
        var length = buffer.length;
        var type = extmap[length] || (length < 255 ? 199 : length <= 65535 ? 200 : 201);
        token[type](encoder, length);
        uint8[value.type](encoder);
        encoder.send(buffer);
      }
      function obj_to_map(encoder, value) {
        var keys = Object.keys(value);
        var length = keys.length;
        var type = length < 16 ? 128 + length : length <= 65535 ? 222 : 223;
        token[type](encoder, length);
        var encode3 = encoder.codec.encode;
        keys.forEach(function(key) {
          encode3(encoder, key);
          encode3(encoder, value[key]);
        });
      }
      function map_to_map(encoder, value) {
        if (!(value instanceof Map))
          return obj_to_map(encoder, value);
        var length = value.size;
        var type = length < 16 ? 128 + length : length <= 65535 ? 222 : 223;
        token[type](encoder, length);
        var encode3 = encoder.codec.encode;
        value.forEach(function(val, key, m) {
          encode3(encoder, key);
          encode3(encoder, val);
        });
      }
      function raw(encoder, value) {
        var length = value.length;
        var type = length < 32 ? 160 + length : length <= 65535 ? 218 : 219;
        token[type](encoder, length);
        encoder.send(value);
      }
    }
  }
});

// node_modules/msgpack-lite/lib/codec-base.js
var require_codec_base = __commonJS({
  "node_modules/msgpack-lite/lib/codec-base.js"(exports2) {
    var IS_ARRAY = require_isarray();
    exports2.createCodec = createCodec3;
    exports2.install = install;
    exports2.filter = filter;
    var Bufferish = require_bufferish();
    function Codec(options) {
      if (!(this instanceof Codec))
        return new Codec(options);
      this.options = options;
      this.init();
    }
    Codec.prototype.init = function() {
      var options = this.options;
      if (options && options.uint8array) {
        this.bufferish = Bufferish.Uint8Array;
      }
      return this;
    };
    function install(props) {
      for (var key in props) {
        Codec.prototype[key] = add(Codec.prototype[key], props[key]);
      }
    }
    function add(a2, b2) {
      return a2 && b2 ? ab : a2 || b2;
      function ab() {
        a2.apply(this, arguments);
        return b2.apply(this, arguments);
      }
    }
    function join2(filters) {
      filters = filters.slice();
      return function(value) {
        return filters.reduce(iterator, value);
      };
      function iterator(value, filter2) {
        return filter2(value);
      }
    }
    function filter(filter2) {
      return IS_ARRAY(filter2) ? join2(filter2) : filter2;
    }
    function createCodec3(options) {
      return new Codec(options);
    }
    exports2.preset = createCodec3({ preset: true });
  }
});

// node_modules/msgpack-lite/lib/write-core.js
var require_write_core = __commonJS({
  "node_modules/msgpack-lite/lib/write-core.js"(exports2) {
    var ExtBuffer = require_ext_buffer().ExtBuffer;
    var ExtPacker = require_ext_packer();
    var WriteType = require_write_type();
    var CodecBase = require_codec_base();
    CodecBase.install({
      addExtPacker,
      getExtPacker,
      init
    });
    exports2.preset = init.call(CodecBase.preset);
    function getEncoder(options) {
      var writeType = WriteType.getWriteType(options);
      return encode3;
      function encode3(encoder, value) {
        var func = writeType[typeof value];
        if (!func)
          throw new Error('Unsupported type "' + typeof value + '": ' + value);
        func(encoder, value);
      }
    }
    function init() {
      var options = this.options;
      this.encode = getEncoder(options);
      if (options && options.preset) {
        ExtPacker.setExtPackers(this);
      }
      return this;
    }
    function addExtPacker(etype, Class, packer) {
      packer = CodecBase.filter(packer);
      var name = Class.name;
      if (name && name !== "Object") {
        var packers = this.extPackers || (this.extPackers = {});
        packers[name] = extPacker;
      } else {
        var list = this.extEncoderList || (this.extEncoderList = []);
        list.unshift([Class, extPacker]);
      }
      function extPacker(value) {
        if (packer)
          value = packer(value);
        return new ExtBuffer(value, etype);
      }
    }
    function getExtPacker(value) {
      var packers = this.extPackers || (this.extPackers = {});
      var c2 = value.constructor;
      var e2 = c2 && c2.name && packers[c2.name];
      if (e2)
        return e2;
      var list = this.extEncoderList || (this.extEncoderList = []);
      var len = list.length;
      for (var i = 0; i < len; i++) {
        var pair = list[i];
        if (c2 === pair[0])
          return pair[1];
      }
    }
  }
});

// node_modules/msgpack-lite/lib/flex-buffer.js
var require_flex_buffer = __commonJS({
  "node_modules/msgpack-lite/lib/flex-buffer.js"(exports2) {
    exports2.FlexDecoder = FlexDecoder;
    exports2.FlexEncoder = FlexEncoder;
    var Bufferish = require_bufferish();
    var MIN_BUFFER_SIZE = 2048;
    var MAX_BUFFER_SIZE = 65536;
    var BUFFER_SHORTAGE = "BUFFER_SHORTAGE";
    function FlexDecoder() {
      if (!(this instanceof FlexDecoder))
        return new FlexDecoder();
    }
    function FlexEncoder() {
      if (!(this instanceof FlexEncoder))
        return new FlexEncoder();
    }
    FlexDecoder.mixin = mixinFactory(getDecoderMethods());
    FlexDecoder.mixin(FlexDecoder.prototype);
    FlexEncoder.mixin = mixinFactory(getEncoderMethods());
    FlexEncoder.mixin(FlexEncoder.prototype);
    function getDecoderMethods() {
      return {
        bufferish: Bufferish,
        write: write2,
        fetch,
        flush,
        push,
        pull,
        read,
        reserve,
        offset: 0
      };
      function write2(chunk) {
        var prev = this.offset ? Bufferish.prototype.slice.call(this.buffer, this.offset) : this.buffer;
        this.buffer = prev ? chunk ? this.bufferish.concat([prev, chunk]) : prev : chunk;
        this.offset = 0;
      }
      function flush() {
        while (this.offset < this.buffer.length) {
          var start = this.offset;
          var value;
          try {
            value = this.fetch();
          } catch (e2) {
            if (e2 && e2.message != BUFFER_SHORTAGE)
              throw e2;
            this.offset = start;
            break;
          }
          this.push(value);
        }
      }
      function reserve(length) {
        var start = this.offset;
        var end = start + length;
        if (end > this.buffer.length)
          throw new Error(BUFFER_SHORTAGE);
        this.offset = end;
        return start;
      }
    }
    function getEncoderMethods() {
      return {
        bufferish: Bufferish,
        write,
        fetch: fetch2,
        flush,
        push,
        pull: pull2,
        read,
        reserve,
        send,
        maxBufferSize: MAX_BUFFER_SIZE,
        minBufferSize: MIN_BUFFER_SIZE,
        offset: 0,
        start: 0
      };
      function fetch2() {
        var start = this.start;
        if (start < this.offset) {
          var end = this.start = this.offset;
          return Bufferish.prototype.slice.call(this.buffer, start, end);
        }
      }
      function flush() {
        while (this.start < this.offset) {
          var value = this.fetch();
          if (value)
            this.push(value);
        }
      }
      function pull2() {
        var buffers = this.buffers || (this.buffers = []);
        var chunk = buffers.length > 1 ? this.bufferish.concat(buffers) : buffers[0];
        buffers.length = 0;
        return chunk;
      }
      function reserve(length) {
        var req = length | 0;
        if (this.buffer) {
          var size = this.buffer.length;
          var start = this.offset | 0;
          var end = start + req;
          if (end < size) {
            this.offset = end;
            return start;
          }
          this.flush();
          length = Math.max(length, Math.min(size * 2, this.maxBufferSize));
        }
        length = Math.max(length, this.minBufferSize);
        this.buffer = this.bufferish.alloc(length);
        this.start = 0;
        this.offset = req;
        return 0;
      }
      function send(buffer) {
        var length = buffer.length;
        if (length > this.minBufferSize) {
          this.flush();
          this.push(buffer);
        } else {
          var offset = this.reserve(length);
          Bufferish.prototype.copy.call(buffer, this.buffer, offset);
        }
      }
    }
    function write() {
      throw new Error("method not implemented: write()");
    }
    function fetch() {
      throw new Error("method not implemented: fetch()");
    }
    function read() {
      var length = this.buffers && this.buffers.length;
      if (!length)
        return this.fetch();
      this.flush();
      return this.pull();
    }
    function push(chunk) {
      var buffers = this.buffers || (this.buffers = []);
      buffers.push(chunk);
    }
    function pull() {
      var buffers = this.buffers || (this.buffers = []);
      return buffers.shift();
    }
    function mixinFactory(source) {
      return mixin;
      function mixin(target) {
        for (var key in source) {
          target[key] = source[key];
        }
        return target;
      }
    }
  }
});

// node_modules/msgpack-lite/lib/encode-buffer.js
var require_encode_buffer = __commonJS({
  "node_modules/msgpack-lite/lib/encode-buffer.js"(exports2) {
    exports2.EncodeBuffer = EncodeBuffer;
    var preset = require_write_core().preset;
    var FlexEncoder = require_flex_buffer().FlexEncoder;
    FlexEncoder.mixin(EncodeBuffer.prototype);
    function EncodeBuffer(options) {
      if (!(this instanceof EncodeBuffer))
        return new EncodeBuffer(options);
      if (options) {
        this.options = options;
        if (options.codec) {
          var codec2 = this.codec = options.codec;
          if (codec2.bufferish)
            this.bufferish = codec2.bufferish;
        }
      }
    }
    EncodeBuffer.prototype.codec = preset;
    EncodeBuffer.prototype.write = function(input) {
      this.codec.encode(this, input);
    };
  }
});

// node_modules/msgpack-lite/lib/encode.js
var require_encode = __commonJS({
  "node_modules/msgpack-lite/lib/encode.js"(exports2) {
    exports2.encode = encode3;
    var EncodeBuffer = require_encode_buffer().EncodeBuffer;
    function encode3(input, options) {
      var encoder = new EncodeBuffer(options);
      encoder.write(input);
      return encoder.read();
    }
  }
});

// node_modules/msgpack-lite/lib/ext-unpacker.js
var require_ext_unpacker = __commonJS({
  "node_modules/msgpack-lite/lib/ext-unpacker.js"(exports2) {
    exports2.setExtUnpackers = setExtUnpackers;
    var Bufferish = require_bufferish();
    var Buffer2 = Bufferish.global;
    var _decode;
    var ERROR_COLUMNS = { name: 1, message: 1, stack: 1, columnNumber: 1, fileName: 1, lineNumber: 1 };
    function setExtUnpackers(codec2) {
      codec2.addExtUnpacker(14, [decode2, unpackError(Error)]);
      codec2.addExtUnpacker(1, [decode2, unpackError(EvalError)]);
      codec2.addExtUnpacker(2, [decode2, unpackError(RangeError)]);
      codec2.addExtUnpacker(3, [decode2, unpackError(ReferenceError)]);
      codec2.addExtUnpacker(4, [decode2, unpackError(SyntaxError)]);
      codec2.addExtUnpacker(5, [decode2, unpackError(TypeError)]);
      codec2.addExtUnpacker(6, [decode2, unpackError(URIError)]);
      codec2.addExtUnpacker(10, [decode2, unpackRegExp]);
      codec2.addExtUnpacker(11, [decode2, unpackClass(Boolean)]);
      codec2.addExtUnpacker(12, [decode2, unpackClass(String)]);
      codec2.addExtUnpacker(13, [decode2, unpackClass(Date)]);
      codec2.addExtUnpacker(15, [decode2, unpackClass(Number)]);
      if ("undefined" !== typeof Uint8Array) {
        codec2.addExtUnpacker(17, unpackClass(Int8Array));
        codec2.addExtUnpacker(18, unpackClass(Uint8Array));
        codec2.addExtUnpacker(19, [unpackArrayBuffer, unpackClass(Int16Array)]);
        codec2.addExtUnpacker(20, [unpackArrayBuffer, unpackClass(Uint16Array)]);
        codec2.addExtUnpacker(21, [unpackArrayBuffer, unpackClass(Int32Array)]);
        codec2.addExtUnpacker(22, [unpackArrayBuffer, unpackClass(Uint32Array)]);
        codec2.addExtUnpacker(23, [unpackArrayBuffer, unpackClass(Float32Array)]);
        if ("undefined" !== typeof Float64Array) {
          codec2.addExtUnpacker(24, [unpackArrayBuffer, unpackClass(Float64Array)]);
        }
        if ("undefined" !== typeof Uint8ClampedArray) {
          codec2.addExtUnpacker(25, unpackClass(Uint8ClampedArray));
        }
        codec2.addExtUnpacker(26, unpackArrayBuffer);
        codec2.addExtUnpacker(29, [unpackArrayBuffer, unpackClass(DataView)]);
      }
      if (Bufferish.hasBuffer) {
        codec2.addExtUnpacker(27, unpackClass(Buffer2));
      }
    }
    function decode2(input) {
      if (!_decode)
        _decode = require_decode().decode;
      return _decode(input);
    }
    function unpackRegExp(value) {
      return RegExp.apply(null, value);
    }
    function unpackError(Class) {
      return function(value) {
        var out = new Class();
        for (var key in ERROR_COLUMNS) {
          out[key] = value[key];
        }
        return out;
      };
    }
    function unpackClass(Class) {
      return function(value) {
        return new Class(value);
      };
    }
    function unpackArrayBuffer(value) {
      return new Uint8Array(value).buffer;
    }
  }
});

// node_modules/msgpack-lite/lib/read-format.js
var require_read_format = __commonJS({
  "node_modules/msgpack-lite/lib/read-format.js"(exports2) {
    var ieee754 = require_ieee754();
    var Int64Buffer = require_int64_buffer();
    var Uint64BE = Int64Buffer.Uint64BE;
    var Int64BE = Int64Buffer.Int64BE;
    exports2.getReadFormat = getReadFormat;
    exports2.readUint8 = uint8;
    var Bufferish = require_bufferish();
    var BufferProto = require_bufferish_proto();
    var HAS_MAP = "undefined" !== typeof Map;
    var NO_ASSERT = true;
    function getReadFormat(options) {
      var binarraybuffer = Bufferish.hasArrayBuffer && options && options.binarraybuffer;
      var int64 = options && options.int64;
      var usemap = HAS_MAP && options && options.usemap;
      var readFormat = {
        map: usemap ? map_to_map : map_to_obj,
        array,
        str,
        bin: binarraybuffer ? bin_arraybuffer : bin_buffer,
        ext,
        uint8,
        uint16,
        uint32,
        uint64: read(8, int64 ? readUInt64BE_int64 : readUInt64BE),
        int8,
        int16,
        int32,
        int64: read(8, int64 ? readInt64BE_int64 : readInt64BE),
        float32: read(4, readFloatBE),
        float64: read(8, readDoubleBE)
      };
      return readFormat;
    }
    function map_to_obj(decoder, len) {
      var value = {};
      var i;
      var k = new Array(len);
      var v = new Array(len);
      var decode2 = decoder.codec.decode;
      for (i = 0; i < len; i++) {
        k[i] = decode2(decoder);
        v[i] = decode2(decoder);
      }
      for (i = 0; i < len; i++) {
        value[k[i]] = v[i];
      }
      return value;
    }
    function map_to_map(decoder, len) {
      var value = /* @__PURE__ */ new Map();
      var i;
      var k = new Array(len);
      var v = new Array(len);
      var decode2 = decoder.codec.decode;
      for (i = 0; i < len; i++) {
        k[i] = decode2(decoder);
        v[i] = decode2(decoder);
      }
      for (i = 0; i < len; i++) {
        value.set(k[i], v[i]);
      }
      return value;
    }
    function array(decoder, len) {
      var value = new Array(len);
      var decode2 = decoder.codec.decode;
      for (var i = 0; i < len; i++) {
        value[i] = decode2(decoder);
      }
      return value;
    }
    function str(decoder, len) {
      var start = decoder.reserve(len);
      var end = start + len;
      return BufferProto.toString.call(decoder.buffer, "utf-8", start, end);
    }
    function bin_buffer(decoder, len) {
      var start = decoder.reserve(len);
      var end = start + len;
      var buf = BufferProto.slice.call(decoder.buffer, start, end);
      return Bufferish.from(buf);
    }
    function bin_arraybuffer(decoder, len) {
      var start = decoder.reserve(len);
      var end = start + len;
      var buf = BufferProto.slice.call(decoder.buffer, start, end);
      return Bufferish.Uint8Array.from(buf).buffer;
    }
    function ext(decoder, len) {
      var start = decoder.reserve(len + 1);
      var type = decoder.buffer[start++];
      var end = start + len;
      var unpack = decoder.codec.getExtUnpacker(type);
      if (!unpack)
        throw new Error("Invalid ext type: " + (type ? "0x" + type.toString(16) : type));
      var buf = BufferProto.slice.call(decoder.buffer, start, end);
      return unpack(buf);
    }
    function uint8(decoder) {
      var start = decoder.reserve(1);
      return decoder.buffer[start];
    }
    function int8(decoder) {
      var start = decoder.reserve(1);
      var value = decoder.buffer[start];
      return value & 128 ? value - 256 : value;
    }
    function uint16(decoder) {
      var start = decoder.reserve(2);
      var buffer = decoder.buffer;
      return buffer[start++] << 8 | buffer[start];
    }
    function int16(decoder) {
      var start = decoder.reserve(2);
      var buffer = decoder.buffer;
      var value = buffer[start++] << 8 | buffer[start];
      return value & 32768 ? value - 65536 : value;
    }
    function uint32(decoder) {
      var start = decoder.reserve(4);
      var buffer = decoder.buffer;
      return buffer[start++] * 16777216 + (buffer[start++] << 16) + (buffer[start++] << 8) + buffer[start];
    }
    function int32(decoder) {
      var start = decoder.reserve(4);
      var buffer = decoder.buffer;
      return buffer[start++] << 24 | buffer[start++] << 16 | buffer[start++] << 8 | buffer[start];
    }
    function read(len, method) {
      return function(decoder) {
        var start = decoder.reserve(len);
        return method.call(decoder.buffer, start, NO_ASSERT);
      };
    }
    function readUInt64BE(start) {
      return new Uint64BE(this, start).toNumber();
    }
    function readInt64BE(start) {
      return new Int64BE(this, start).toNumber();
    }
    function readUInt64BE_int64(start) {
      return new Uint64BE(this, start);
    }
    function readInt64BE_int64(start) {
      return new Int64BE(this, start);
    }
    function readFloatBE(start) {
      return ieee754.read(this, start, false, 23, 4);
    }
    function readDoubleBE(start) {
      return ieee754.read(this, start, false, 52, 8);
    }
  }
});

// node_modules/msgpack-lite/lib/read-token.js
var require_read_token = __commonJS({
  "node_modules/msgpack-lite/lib/read-token.js"(exports2) {
    var ReadFormat = require_read_format();
    exports2.getReadToken = getReadToken;
    function getReadToken(options) {
      var format = ReadFormat.getReadFormat(options);
      if (options && options.useraw) {
        return init_useraw(format);
      } else {
        return init_token(format);
      }
    }
    function init_token(format) {
      var i;
      var token = new Array(256);
      for (i = 0; i <= 127; i++) {
        token[i] = constant(i);
      }
      for (i = 128; i <= 143; i++) {
        token[i] = fix(i - 128, format.map);
      }
      for (i = 144; i <= 159; i++) {
        token[i] = fix(i - 144, format.array);
      }
      for (i = 160; i <= 191; i++) {
        token[i] = fix(i - 160, format.str);
      }
      token[192] = constant(null);
      token[193] = null;
      token[194] = constant(false);
      token[195] = constant(true);
      token[196] = flex(format.uint8, format.bin);
      token[197] = flex(format.uint16, format.bin);
      token[198] = flex(format.uint32, format.bin);
      token[199] = flex(format.uint8, format.ext);
      token[200] = flex(format.uint16, format.ext);
      token[201] = flex(format.uint32, format.ext);
      token[202] = format.float32;
      token[203] = format.float64;
      token[204] = format.uint8;
      token[205] = format.uint16;
      token[206] = format.uint32;
      token[207] = format.uint64;
      token[208] = format.int8;
      token[209] = format.int16;
      token[210] = format.int32;
      token[211] = format.int64;
      token[212] = fix(1, format.ext);
      token[213] = fix(2, format.ext);
      token[214] = fix(4, format.ext);
      token[215] = fix(8, format.ext);
      token[216] = fix(16, format.ext);
      token[217] = flex(format.uint8, format.str);
      token[218] = flex(format.uint16, format.str);
      token[219] = flex(format.uint32, format.str);
      token[220] = flex(format.uint16, format.array);
      token[221] = flex(format.uint32, format.array);
      token[222] = flex(format.uint16, format.map);
      token[223] = flex(format.uint32, format.map);
      for (i = 224; i <= 255; i++) {
        token[i] = constant(i - 256);
      }
      return token;
    }
    function init_useraw(format) {
      var i;
      var token = init_token(format).slice();
      token[217] = token[196];
      token[218] = token[197];
      token[219] = token[198];
      for (i = 160; i <= 191; i++) {
        token[i] = fix(i - 160, format.bin);
      }
      return token;
    }
    function constant(value) {
      return function() {
        return value;
      };
    }
    function flex(lenFunc, decodeFunc) {
      return function(decoder) {
        var len = lenFunc(decoder);
        return decodeFunc(decoder, len);
      };
    }
    function fix(len, method) {
      return function(decoder) {
        return method(decoder, len);
      };
    }
  }
});

// node_modules/msgpack-lite/lib/read-core.js
var require_read_core = __commonJS({
  "node_modules/msgpack-lite/lib/read-core.js"(exports2) {
    var ExtBuffer = require_ext_buffer().ExtBuffer;
    var ExtUnpacker = require_ext_unpacker();
    var readUint8 = require_read_format().readUint8;
    var ReadToken = require_read_token();
    var CodecBase = require_codec_base();
    CodecBase.install({
      addExtUnpacker,
      getExtUnpacker,
      init
    });
    exports2.preset = init.call(CodecBase.preset);
    function getDecoder(options) {
      var readToken = ReadToken.getReadToken(options);
      return decode2;
      function decode2(decoder) {
        var type = readUint8(decoder);
        var func = readToken[type];
        if (!func)
          throw new Error("Invalid type: " + (type ? "0x" + type.toString(16) : type));
        return func(decoder);
      }
    }
    function init() {
      var options = this.options;
      this.decode = getDecoder(options);
      if (options && options.preset) {
        ExtUnpacker.setExtUnpackers(this);
      }
      return this;
    }
    function addExtUnpacker(etype, unpacker) {
      var unpackers = this.extUnpackers || (this.extUnpackers = []);
      unpackers[etype] = CodecBase.filter(unpacker);
    }
    function getExtUnpacker(type) {
      var unpackers = this.extUnpackers || (this.extUnpackers = []);
      return unpackers[type] || extUnpacker;
      function extUnpacker(buffer) {
        return new ExtBuffer(buffer, type);
      }
    }
  }
});

// node_modules/msgpack-lite/lib/decode-buffer.js
var require_decode_buffer = __commonJS({
  "node_modules/msgpack-lite/lib/decode-buffer.js"(exports2) {
    exports2.DecodeBuffer = DecodeBuffer;
    var preset = require_read_core().preset;
    var FlexDecoder = require_flex_buffer().FlexDecoder;
    FlexDecoder.mixin(DecodeBuffer.prototype);
    function DecodeBuffer(options) {
      if (!(this instanceof DecodeBuffer))
        return new DecodeBuffer(options);
      if (options) {
        this.options = options;
        if (options.codec) {
          var codec2 = this.codec = options.codec;
          if (codec2.bufferish)
            this.bufferish = codec2.bufferish;
        }
      }
    }
    DecodeBuffer.prototype.codec = preset;
    DecodeBuffer.prototype.fetch = function() {
      return this.codec.decode(this);
    };
  }
});

// node_modules/msgpack-lite/lib/decode.js
var require_decode = __commonJS({
  "node_modules/msgpack-lite/lib/decode.js"(exports2) {
    exports2.decode = decode2;
    var DecodeBuffer = require_decode_buffer().DecodeBuffer;
    function decode2(input, options) {
      var decoder = new DecodeBuffer(options);
      decoder.write(input);
      return decoder.read();
    }
  }
});

// node_modules/event-lite/event-lite.js
var require_event_lite = __commonJS({
  "node_modules/event-lite/event-lite.js"(exports2, module2) {
    function EventLite() {
      if (!(this instanceof EventLite))
        return new EventLite();
    }
    (function(EventLite2) {
      if ("undefined" !== typeof module2)
        module2.exports = EventLite2;
      var LISTENERS = "listeners";
      var methods = {
        on,
        once,
        off,
        emit
      };
      mixin(EventLite2.prototype);
      EventLite2.mixin = mixin;
      function mixin(target) {
        for (var key in methods) {
          target[key] = methods[key];
        }
        return target;
      }
      function on(type, func) {
        getListeners(this, type).push(func);
        return this;
      }
      function once(type, func) {
        var that = this;
        wrap.originalListener = func;
        getListeners(that, type).push(wrap);
        return that;
        function wrap() {
          off.call(that, type, wrap);
          func.apply(this, arguments);
        }
      }
      function off(type, func) {
        var that = this;
        var listners;
        if (!arguments.length) {
          delete that[LISTENERS];
        } else if (!func) {
          listners = that[LISTENERS];
          if (listners) {
            delete listners[type];
            if (!Object.keys(listners).length)
              return off.call(that);
          }
        } else {
          listners = getListeners(that, type, true);
          if (listners) {
            listners = listners.filter(ne);
            if (!listners.length)
              return off.call(that, type);
            that[LISTENERS][type] = listners;
          }
        }
        return that;
        function ne(test) {
          return test !== func && test.originalListener !== func;
        }
      }
      function emit(type, value) {
        var that = this;
        var listeners = getListeners(that, type, true);
        if (!listeners)
          return false;
        var arglen = arguments.length;
        if (arglen === 1) {
          listeners.forEach(zeroarg);
        } else if (arglen === 2) {
          listeners.forEach(onearg);
        } else {
          var args = Array.prototype.slice.call(arguments, 1);
          listeners.forEach(moreargs);
        }
        return !!listeners.length;
        function zeroarg(func) {
          func.call(that);
        }
        function onearg(func) {
          func.call(that, value);
        }
        function moreargs(func) {
          func.apply(that, args);
        }
      }
      function getListeners(that, type, readonly) {
        if (readonly && !that[LISTENERS])
          return;
        var listeners = that[LISTENERS] || (that[LISTENERS] = {});
        return listeners[type] || (listeners[type] = []);
      }
    })(EventLite);
  }
});

// node_modules/msgpack-lite/lib/encoder.js
var require_encoder = __commonJS({
  "node_modules/msgpack-lite/lib/encoder.js"(exports2) {
    exports2.Encoder = Encoder;
    var EventLite = require_event_lite();
    var EncodeBuffer = require_encode_buffer().EncodeBuffer;
    function Encoder(options) {
      if (!(this instanceof Encoder))
        return new Encoder(options);
      EncodeBuffer.call(this, options);
    }
    Encoder.prototype = new EncodeBuffer();
    EventLite.mixin(Encoder.prototype);
    Encoder.prototype.encode = function(chunk) {
      this.write(chunk);
      this.emit("data", this.read());
    };
    Encoder.prototype.end = function(chunk) {
      if (arguments.length)
        this.encode(chunk);
      this.flush();
      this.emit("end");
    };
  }
});

// node_modules/msgpack-lite/lib/decoder.js
var require_decoder = __commonJS({
  "node_modules/msgpack-lite/lib/decoder.js"(exports2) {
    exports2.Decoder = Decoder;
    var EventLite = require_event_lite();
    var DecodeBuffer = require_decode_buffer().DecodeBuffer;
    function Decoder(options) {
      if (!(this instanceof Decoder))
        return new Decoder(options);
      DecodeBuffer.call(this, options);
    }
    Decoder.prototype = new DecodeBuffer();
    EventLite.mixin(Decoder.prototype);
    Decoder.prototype.decode = function(chunk) {
      if (arguments.length)
        this.write(chunk);
      this.flush();
    };
    Decoder.prototype.push = function(chunk) {
      this.emit("data", chunk);
    };
    Decoder.prototype.end = function(chunk) {
      this.decode(chunk);
      this.emit("end");
    };
  }
});

// node_modules/msgpack-lite/lib/encode-stream.js
var require_encode_stream = __commonJS({
  "node_modules/msgpack-lite/lib/encode-stream.js"(exports2) {
    exports2.createEncodeStream = EncodeStream;
    var util = require("util");
    var Transform = require("stream").Transform;
    var EncodeBuffer = require_encode_buffer().EncodeBuffer;
    util.inherits(EncodeStream, Transform);
    var DEFAULT_OPTIONS = { objectMode: true };
    function EncodeStream(options) {
      if (!(this instanceof EncodeStream))
        return new EncodeStream(options);
      if (options) {
        options.objectMode = true;
      } else {
        options = DEFAULT_OPTIONS;
      }
      Transform.call(this, options);
      var stream = this;
      var encoder = this.encoder = new EncodeBuffer(options);
      encoder.push = function(chunk) {
        stream.push(chunk);
      };
    }
    EncodeStream.prototype._transform = function(chunk, encoding, callback) {
      this.encoder.write(chunk);
      if (callback)
        callback();
    };
    EncodeStream.prototype._flush = function(callback) {
      this.encoder.flush();
      if (callback)
        callback();
    };
  }
});

// node_modules/msgpack-lite/lib/decode-stream.js
var require_decode_stream = __commonJS({
  "node_modules/msgpack-lite/lib/decode-stream.js"(exports2) {
    exports2.createDecodeStream = DecodeStream;
    var util = require("util");
    var Transform = require("stream").Transform;
    var DecodeBuffer = require_decode_buffer().DecodeBuffer;
    util.inherits(DecodeStream, Transform);
    var DEFAULT_OPTIONS = { objectMode: true };
    function DecodeStream(options) {
      if (!(this instanceof DecodeStream))
        return new DecodeStream(options);
      if (options) {
        options.objectMode = true;
      } else {
        options = DEFAULT_OPTIONS;
      }
      Transform.call(this, options);
      var stream = this;
      var decoder = this.decoder = new DecodeBuffer(options);
      decoder.push = function(chunk) {
        stream.push(chunk);
      };
    }
    DecodeStream.prototype._transform = function(chunk, encoding, callback) {
      this.decoder.write(chunk);
      this.decoder.flush();
      if (callback)
        callback();
    };
  }
});

// node_modules/msgpack-lite/lib/ext.js
var require_ext = __commonJS({
  "node_modules/msgpack-lite/lib/ext.js"(exports2) {
    require_read_core();
    require_write_core();
    exports2.createCodec = require_codec_base().createCodec;
  }
});

// node_modules/msgpack-lite/lib/codec.js
var require_codec = __commonJS({
  "node_modules/msgpack-lite/lib/codec.js"(exports2) {
    require_read_core();
    require_write_core();
    exports2.codec = {
      preset: require_codec_base().preset
    };
  }
});

// node_modules/msgpack-lite/index.js
var require_msgpack_lite = __commonJS({
  "node_modules/msgpack-lite/index.js"(exports2) {
    exports2.encode = require_encode().encode;
    exports2.decode = require_decode().decode;
    exports2.Encoder = require_encoder().Encoder;
    exports2.Decoder = require_decoder().Decoder;
    exports2.createEncodeStream = require_encode_stream().createEncodeStream;
    exports2.createDecodeStream = require_decode_stream().createDecodeStream;
    exports2.createCodec = require_ext().createCodec;
    exports2.codec = require_codec().codec;
  }
});

// node_modules/google-protobuf/google-protobuf.js
var require_google_protobuf = __commonJS({
  "node_modules/google-protobuf/google-protobuf.js"(exports, module) {
    var $jscomp = $jscomp || {};
    $jscomp.scope = {};
    $jscomp.findInternal = function(a2, b2, c2) {
      a2 instanceof String && (a2 = String(a2));
      for (var d2 = a2.length, e2 = 0; e2 < d2; e2++) {
        var f2 = a2[e2];
        if (b2.call(c2, f2, e2, a2))
          return { i: e2, v: f2 };
      }
      return { i: -1, v: void 0 };
    };
    $jscomp.ASSUME_ES5 = false;
    $jscomp.ASSUME_NO_NATIVE_MAP = false;
    $jscomp.ASSUME_NO_NATIVE_SET = false;
    $jscomp.SIMPLE_FROUND_POLYFILL = false;
    $jscomp.defineProperty = $jscomp.ASSUME_ES5 || "function" == typeof Object.defineProperties ? Object.defineProperty : function(a2, b2, c2) {
      a2 != Array.prototype && a2 != Object.prototype && (a2[b2] = c2.value);
    };
    $jscomp.getGlobal = function(a2) {
      return "undefined" != typeof window && window === a2 ? a2 : "undefined" != typeof global && null != global ? global : a2;
    };
    $jscomp.global = $jscomp.getGlobal(exports);
    $jscomp.polyfill = function(a2, b2, c2, d2) {
      if (b2) {
        c2 = $jscomp.global;
        a2 = a2.split(".");
        for (d2 = 0; d2 < a2.length - 1; d2++) {
          var e2 = a2[d2];
          e2 in c2 || (c2[e2] = {});
          c2 = c2[e2];
        }
        a2 = a2[a2.length - 1];
        d2 = c2[a2];
        b2 = b2(d2);
        b2 != d2 && null != b2 && $jscomp.defineProperty(c2, a2, { configurable: true, writable: true, value: b2 });
      }
    };
    $jscomp.polyfill("Array.prototype.findIndex", function(a2) {
      return a2 ? a2 : function(a3, c2) {
        return $jscomp.findInternal(this, a3, c2).i;
      };
    }, "es6", "es3");
    $jscomp.checkStringArgs = function(a2, b2, c2) {
      if (null == a2)
        throw new TypeError("The 'this' value for String.prototype." + c2 + " must not be null or undefined");
      if (b2 instanceof RegExp)
        throw new TypeError("First argument to String.prototype." + c2 + " must not be a regular expression");
      return a2 + "";
    };
    $jscomp.polyfill("String.prototype.endsWith", function(a2) {
      return a2 ? a2 : function(a3, c2) {
        var b2 = $jscomp.checkStringArgs(this, a3, "endsWith");
        a3 += "";
        void 0 === c2 && (c2 = b2.length);
        c2 = Math.max(0, Math.min(c2 | 0, b2.length));
        for (var e2 = a3.length; 0 < e2 && 0 < c2; )
          if (b2[--c2] != a3[--e2])
            return false;
        return 0 >= e2;
      };
    }, "es6", "es3");
    $jscomp.polyfill("Array.prototype.find", function(a2) {
      return a2 ? a2 : function(a3, c2) {
        return $jscomp.findInternal(this, a3, c2).v;
      };
    }, "es6", "es3");
    $jscomp.polyfill("String.prototype.startsWith", function(a2) {
      return a2 ? a2 : function(a3, c2) {
        var b2 = $jscomp.checkStringArgs(this, a3, "startsWith");
        a3 += "";
        var e2 = b2.length, f2 = a3.length;
        c2 = Math.max(0, Math.min(c2 | 0, b2.length));
        for (var g = 0; g < f2 && c2 < e2; )
          if (b2[c2++] != a3[g++])
            return false;
        return g >= f2;
      };
    }, "es6", "es3");
    $jscomp.polyfill("String.prototype.repeat", function(a2) {
      return a2 ? a2 : function(a3) {
        var b2 = $jscomp.checkStringArgs(this, null, "repeat");
        if (0 > a3 || 1342177279 < a3)
          throw new RangeError("Invalid count value");
        a3 |= 0;
        for (var d2 = ""; a3; )
          if (a3 & 1 && (d2 += b2), a3 >>>= 1)
            b2 += b2;
        return d2;
      };
    }, "es6", "es3");
    var COMPILED = true;
    var goog = goog || {};
    goog.global = exports || self;
    goog.exportPath_ = function(a2, b2, c2) {
      a2 = a2.split(".");
      c2 = c2 || goog.global;
      a2[0] in c2 || "undefined" == typeof c2.execScript || c2.execScript("var " + a2[0]);
      for (var d2; a2.length && (d2 = a2.shift()); )
        a2.length || void 0 === b2 ? c2 = c2[d2] && c2[d2] !== Object.prototype[d2] ? c2[d2] : c2[d2] = {} : c2[d2] = b2;
    };
    goog.define = function(a2, b2) {
      if (!COMPILED) {
        var c2 = goog.global.CLOSURE_UNCOMPILED_DEFINES, d2 = goog.global.CLOSURE_DEFINES;
        c2 && void 0 === c2.nodeType && Object.prototype.hasOwnProperty.call(c2, a2) ? b2 = c2[a2] : d2 && void 0 === d2.nodeType && Object.prototype.hasOwnProperty.call(d2, a2) && (b2 = d2[a2]);
      }
      return b2;
    };
    goog.FEATURESET_YEAR = 2012;
    goog.DEBUG = true;
    goog.LOCALE = "en";
    goog.TRUSTED_SITE = true;
    goog.STRICT_MODE_COMPATIBLE = false;
    goog.DISALLOW_TEST_ONLY_CODE = COMPILED && !goog.DEBUG;
    goog.ENABLE_CHROME_APP_SAFE_SCRIPT_LOADING = false;
    goog.provide = function(a2) {
      if (goog.isInModuleLoader_())
        throw Error("goog.provide cannot be used within a module.");
      if (!COMPILED && goog.isProvided_(a2))
        throw Error('Namespace "' + a2 + '" already declared.');
      goog.constructNamespace_(a2);
    };
    goog.constructNamespace_ = function(a2, b2) {
      if (!COMPILED) {
        delete goog.implicitNamespaces_[a2];
        for (var c2 = a2; (c2 = c2.substring(0, c2.lastIndexOf("."))) && !goog.getObjectByName(c2); )
          goog.implicitNamespaces_[c2] = true;
      }
      goog.exportPath_(a2, b2);
    };
    goog.getScriptNonce = function(a2) {
      if (a2 && a2 != goog.global)
        return goog.getScriptNonce_(a2.document);
      null === goog.cspNonce_ && (goog.cspNonce_ = goog.getScriptNonce_(goog.global.document));
      return goog.cspNonce_;
    };
    goog.NONCE_PATTERN_ = /^[\w+/_-]+[=]{0,2}$/;
    goog.cspNonce_ = null;
    goog.getScriptNonce_ = function(a2) {
      return (a2 = a2.querySelector && a2.querySelector("script[nonce]")) && (a2 = a2.nonce || a2.getAttribute("nonce")) && goog.NONCE_PATTERN_.test(a2) ? a2 : "";
    };
    goog.VALID_MODULE_RE_ = /^[a-zA-Z_$][a-zA-Z0-9._$]*$/;
    goog.module = function(a2) {
      if ("string" !== typeof a2 || !a2 || -1 == a2.search(goog.VALID_MODULE_RE_))
        throw Error("Invalid module identifier");
      if (!goog.isInGoogModuleLoader_())
        throw Error("Module " + a2 + " has been loaded incorrectly. Note, modules cannot be loaded as normal scripts. They require some kind of pre-processing step. You're likely trying to load a module via a script tag or as a part of a concatenated bundle without rewriting the module. For more info see: https://github.com/google/closure-library/wiki/goog.module:-an-ES6-module-like-alternative-to-goog.provide.");
      if (goog.moduleLoaderState_.moduleName)
        throw Error("goog.module may only be called once per module.");
      goog.moduleLoaderState_.moduleName = a2;
      if (!COMPILED) {
        if (goog.isProvided_(a2))
          throw Error('Namespace "' + a2 + '" already declared.');
        delete goog.implicitNamespaces_[a2];
      }
    };
    goog.module.get = function(a2) {
      return goog.module.getInternal_(a2);
    };
    goog.module.getInternal_ = function(a2) {
      if (!COMPILED) {
        if (a2 in goog.loadedModules_)
          return goog.loadedModules_[a2].exports;
        if (!goog.implicitNamespaces_[a2])
          return a2 = goog.getObjectByName(a2), null != a2 ? a2 : null;
      }
      return null;
    };
    goog.ModuleType = { ES6: "es6", GOOG: "goog" };
    goog.moduleLoaderState_ = null;
    goog.isInModuleLoader_ = function() {
      return goog.isInGoogModuleLoader_() || goog.isInEs6ModuleLoader_();
    };
    goog.isInGoogModuleLoader_ = function() {
      return !!goog.moduleLoaderState_ && goog.moduleLoaderState_.type == goog.ModuleType.GOOG;
    };
    goog.isInEs6ModuleLoader_ = function() {
      if (goog.moduleLoaderState_ && goog.moduleLoaderState_.type == goog.ModuleType.ES6)
        return true;
      var a2 = goog.global.$jscomp;
      return a2 ? "function" != typeof a2.getCurrentModulePath ? false : !!a2.getCurrentModulePath() : false;
    };
    goog.module.declareLegacyNamespace = function() {
      if (!COMPILED && !goog.isInGoogModuleLoader_())
        throw Error("goog.module.declareLegacyNamespace must be called from within a goog.module");
      if (!COMPILED && !goog.moduleLoaderState_.moduleName)
        throw Error("goog.module must be called prior to goog.module.declareLegacyNamespace.");
      goog.moduleLoaderState_.declareLegacyNamespace = true;
    };
    goog.declareModuleId = function(a2) {
      if (!COMPILED) {
        if (!goog.isInEs6ModuleLoader_())
          throw Error("goog.declareModuleId may only be called from within an ES6 module");
        if (goog.moduleLoaderState_ && goog.moduleLoaderState_.moduleName)
          throw Error("goog.declareModuleId may only be called once per module.");
        if (a2 in goog.loadedModules_)
          throw Error('Module with namespace "' + a2 + '" already exists.');
      }
      if (goog.moduleLoaderState_)
        goog.moduleLoaderState_.moduleName = a2;
      else {
        var b2 = goog.global.$jscomp;
        if (!b2 || "function" != typeof b2.getCurrentModulePath)
          throw Error('Module with namespace "' + a2 + '" has been loaded incorrectly.');
        b2 = b2.require(b2.getCurrentModulePath());
        goog.loadedModules_[a2] = { exports: b2, type: goog.ModuleType.ES6, moduleId: a2 };
      }
    };
    goog.setTestOnly = function(a2) {
      if (goog.DISALLOW_TEST_ONLY_CODE)
        throw a2 = a2 || "", Error("Importing test-only code into non-debug environment" + (a2 ? ": " + a2 : "."));
    };
    goog.forwardDeclare = function(a2) {
    };
    COMPILED || (goog.isProvided_ = function(a2) {
      return a2 in goog.loadedModules_ || !goog.implicitNamespaces_[a2] && null != goog.getObjectByName(a2);
    }, goog.implicitNamespaces_ = { "goog.module": true });
    goog.getObjectByName = function(a2, b2) {
      a2 = a2.split(".");
      b2 = b2 || goog.global;
      for (var c2 = 0; c2 < a2.length; c2++)
        if (b2 = b2[a2[c2]], null == b2)
          return null;
      return b2;
    };
    goog.globalize = function(a2, b2) {
      b2 = b2 || goog.global;
      for (var c2 in a2)
        b2[c2] = a2[c2];
    };
    goog.addDependency = function(a2, b2, c2, d2) {
      !COMPILED && goog.DEPENDENCIES_ENABLED && goog.debugLoader_.addDependency(a2, b2, c2, d2);
    };
    goog.ENABLE_DEBUG_LOADER = true;
    goog.logToConsole_ = function(a2) {
      goog.global.console && goog.global.console.error(a2);
    };
    goog.require = function(a2) {
      if (!COMPILED) {
        goog.ENABLE_DEBUG_LOADER && goog.debugLoader_.requested(a2);
        if (goog.isProvided_(a2)) {
          if (goog.isInModuleLoader_())
            return goog.module.getInternal_(a2);
        } else if (goog.ENABLE_DEBUG_LOADER) {
          var b2 = goog.moduleLoaderState_;
          goog.moduleLoaderState_ = null;
          try {
            goog.debugLoader_.load_(a2);
          } finally {
            goog.moduleLoaderState_ = b2;
          }
        }
        return null;
      }
    };
    goog.requireType = function(a2) {
      return {};
    };
    goog.basePath = "";
    goog.nullFunction = function() {
    };
    goog.abstractMethod = function() {
      throw Error("unimplemented abstract method");
    };
    goog.addSingletonGetter = function(a2) {
      a2.instance_ = void 0;
      a2.getInstance = function() {
        if (a2.instance_)
          return a2.instance_;
        goog.DEBUG && (goog.instantiatedSingletons_[goog.instantiatedSingletons_.length] = a2);
        return a2.instance_ = new a2();
      };
    };
    goog.instantiatedSingletons_ = [];
    goog.LOAD_MODULE_USING_EVAL = true;
    goog.SEAL_MODULE_EXPORTS = goog.DEBUG;
    goog.loadedModules_ = {};
    goog.DEPENDENCIES_ENABLED = !COMPILED && goog.ENABLE_DEBUG_LOADER;
    goog.TRANSPILE = "detect";
    goog.ASSUME_ES_MODULES_TRANSPILED = false;
    goog.TRANSPILE_TO_LANGUAGE = "";
    goog.TRANSPILER = "transpile.js";
    goog.hasBadLetScoping = null;
    goog.useSafari10Workaround = function() {
      if (null == goog.hasBadLetScoping) {
        try {
          var a = !eval('"use strict";let x = 1; function f() { return typeof x; };f() == "number";');
        } catch (b2) {
          a = false;
        }
        goog.hasBadLetScoping = a;
      }
      return goog.hasBadLetScoping;
    };
    goog.workaroundSafari10EvalBug = function(a2) {
      return "(function(){" + a2 + "\n;})();\n";
    };
    goog.loadModule = function(a2) {
      var b2 = goog.moduleLoaderState_;
      try {
        goog.moduleLoaderState_ = { moduleName: "", declareLegacyNamespace: false, type: goog.ModuleType.GOOG };
        if (goog.isFunction(a2))
          var c2 = a2.call(void 0, {});
        else if ("string" === typeof a2)
          goog.useSafari10Workaround() && (a2 = goog.workaroundSafari10EvalBug(a2)), c2 = goog.loadModuleFromSource_.call(void 0, a2);
        else
          throw Error("Invalid module definition");
        var d2 = goog.moduleLoaderState_.moduleName;
        if ("string" === typeof d2 && d2)
          goog.moduleLoaderState_.declareLegacyNamespace ? goog.constructNamespace_(
            d2,
            c2
          ) : goog.SEAL_MODULE_EXPORTS && Object.seal && "object" == typeof c2 && null != c2 && Object.seal(c2), goog.loadedModules_[d2] = { exports: c2, type: goog.ModuleType.GOOG, moduleId: goog.moduleLoaderState_.moduleName };
        else
          throw Error('Invalid module name "' + d2 + '"');
      } finally {
        goog.moduleLoaderState_ = b2;
      }
    };
    goog.loadModuleFromSource_ = function(a) {
      eval(a);
      return {};
    };
    goog.normalizePath_ = function(a2) {
      a2 = a2.split("/");
      for (var b2 = 0; b2 < a2.length; )
        "." == a2[b2] ? a2.splice(b2, 1) : b2 && ".." == a2[b2] && a2[b2 - 1] && ".." != a2[b2 - 1] ? a2.splice(--b2, 2) : b2++;
      return a2.join("/");
    };
    goog.loadFileSync_ = function(a2) {
      if (goog.global.CLOSURE_LOAD_FILE_SYNC)
        return goog.global.CLOSURE_LOAD_FILE_SYNC(a2);
      try {
        var b2 = new goog.global.XMLHttpRequest();
        b2.open("get", a2, false);
        b2.send();
        return 0 == b2.status || 200 == b2.status ? b2.responseText : null;
      } catch (c2) {
        return null;
      }
    };
    goog.transpile_ = function(a2, b2, c2) {
      var d2 = goog.global.$jscomp;
      d2 || (goog.global.$jscomp = d2 = {});
      var e2 = d2.transpile;
      if (!e2) {
        var f2 = goog.basePath + goog.TRANSPILER, g = goog.loadFileSync_(f2);
        if (g) {
          (function() {
            (0, eval)(g + "\n//# sourceURL=" + f2);
          }).call(goog.global);
          if (goog.global.$gwtExport && goog.global.$gwtExport.$jscomp && !goog.global.$gwtExport.$jscomp.transpile)
            throw Error('The transpiler did not properly export the "transpile" method. $gwtExport: ' + JSON.stringify(goog.global.$gwtExport));
          goog.global.$jscomp.transpile = goog.global.$gwtExport.$jscomp.transpile;
          d2 = goog.global.$jscomp;
          e2 = d2.transpile;
        }
      }
      e2 || (e2 = d2.transpile = function(a3, b3) {
        goog.logToConsole_(b3 + " requires transpilation but no transpiler was found.");
        return a3;
      });
      return e2(a2, b2, c2);
    };
    goog.typeOf = function(a2) {
      var b2 = typeof a2;
      if ("object" == b2)
        if (a2) {
          if (a2 instanceof Array)
            return "array";
          if (a2 instanceof Object)
            return b2;
          var c2 = Object.prototype.toString.call(a2);
          if ("[object Window]" == c2)
            return "object";
          if ("[object Array]" == c2 || "number" == typeof a2.length && "undefined" != typeof a2.splice && "undefined" != typeof a2.propertyIsEnumerable && !a2.propertyIsEnumerable("splice"))
            return "array";
          if ("[object Function]" == c2 || "undefined" != typeof a2.call && "undefined" != typeof a2.propertyIsEnumerable && !a2.propertyIsEnumerable("call"))
            return "function";
        } else
          return "null";
      else if ("function" == b2 && "undefined" == typeof a2.call)
        return "object";
      return b2;
    };
    goog.isArray = function(a2) {
      return "array" == goog.typeOf(a2);
    };
    goog.isArrayLike = function(a2) {
      var b2 = goog.typeOf(a2);
      return "array" == b2 || "object" == b2 && "number" == typeof a2.length;
    };
    goog.isDateLike = function(a2) {
      return goog.isObject(a2) && "function" == typeof a2.getFullYear;
    };
    goog.isFunction = function(a2) {
      return "function" == goog.typeOf(a2);
    };
    goog.isObject = function(a2) {
      var b2 = typeof a2;
      return "object" == b2 && null != a2 || "function" == b2;
    };
    goog.getUid = function(a2) {
      return Object.prototype.hasOwnProperty.call(a2, goog.UID_PROPERTY_) && a2[goog.UID_PROPERTY_] || (a2[goog.UID_PROPERTY_] = ++goog.uidCounter_);
    };
    goog.hasUid = function(a2) {
      return !!a2[goog.UID_PROPERTY_];
    };
    goog.removeUid = function(a2) {
      null !== a2 && "removeAttribute" in a2 && a2.removeAttribute(goog.UID_PROPERTY_);
      try {
        delete a2[goog.UID_PROPERTY_];
      } catch (b2) {
      }
    };
    goog.UID_PROPERTY_ = "closure_uid_" + (1e9 * Math.random() >>> 0);
    goog.uidCounter_ = 0;
    goog.getHashCode = goog.getUid;
    goog.removeHashCode = goog.removeUid;
    goog.cloneObject = function(a2) {
      var b2 = goog.typeOf(a2);
      if ("object" == b2 || "array" == b2) {
        if ("function" === typeof a2.clone)
          return a2.clone();
        b2 = "array" == b2 ? [] : {};
        for (var c2 in a2)
          b2[c2] = goog.cloneObject(a2[c2]);
        return b2;
      }
      return a2;
    };
    goog.bindNative_ = function(a2, b2, c2) {
      return a2.call.apply(a2.bind, arguments);
    };
    goog.bindJs_ = function(a2, b2, c2) {
      if (!a2)
        throw Error();
      if (2 < arguments.length) {
        var d2 = Array.prototype.slice.call(arguments, 2);
        return function() {
          var c3 = Array.prototype.slice.call(arguments);
          Array.prototype.unshift.apply(c3, d2);
          return a2.apply(b2, c3);
        };
      }
      return function() {
        return a2.apply(b2, arguments);
      };
    };
    goog.bind = function(a2, b2, c2) {
      Function.prototype.bind && -1 != Function.prototype.bind.toString().indexOf("native code") ? goog.bind = goog.bindNative_ : goog.bind = goog.bindJs_;
      return goog.bind.apply(null, arguments);
    };
    goog.partial = function(a2, b2) {
      var c2 = Array.prototype.slice.call(arguments, 1);
      return function() {
        var b3 = c2.slice();
        b3.push.apply(b3, arguments);
        return a2.apply(this, b3);
      };
    };
    goog.mixin = function(a2, b2) {
      for (var c2 in b2)
        a2[c2] = b2[c2];
    };
    goog.now = goog.TRUSTED_SITE && Date.now || function() {
      return +new Date();
    };
    goog.globalEval = function(a2) {
      if (goog.global.execScript)
        goog.global.execScript(a2, "JavaScript");
      else if (goog.global.eval) {
        if (null == goog.evalWorksForGlobals_) {
          try {
            goog.global.eval("var _evalTest_ = 1;");
          } catch (d2) {
          }
          if ("undefined" != typeof goog.global._evalTest_) {
            try {
              delete goog.global._evalTest_;
            } catch (d2) {
            }
            goog.evalWorksForGlobals_ = true;
          } else
            goog.evalWorksForGlobals_ = false;
        }
        if (goog.evalWorksForGlobals_)
          goog.global.eval(a2);
        else {
          var b2 = goog.global.document, c2 = b2.createElement("script");
          c2.type = "text/javascript";
          c2.defer = false;
          c2.appendChild(b2.createTextNode(a2));
          b2.head.appendChild(c2);
          b2.head.removeChild(c2);
        }
      } else
        throw Error("goog.globalEval not available");
    };
    goog.evalWorksForGlobals_ = null;
    goog.getCssName = function(a2, b2) {
      if ("." == String(a2).charAt(0))
        throw Error('className passed in goog.getCssName must not start with ".". You passed: ' + a2);
      var c2 = function(a3) {
        return goog.cssNameMapping_[a3] || a3;
      }, d2 = function(a3) {
        a3 = a3.split("-");
        for (var b3 = [], d3 = 0; d3 < a3.length; d3++)
          b3.push(c2(a3[d3]));
        return b3.join("-");
      };
      d2 = goog.cssNameMapping_ ? "BY_WHOLE" == goog.cssNameMappingStyle_ ? c2 : d2 : function(a3) {
        return a3;
      };
      a2 = b2 ? a2 + "-" + d2(b2) : d2(a2);
      return goog.global.CLOSURE_CSS_NAME_MAP_FN ? goog.global.CLOSURE_CSS_NAME_MAP_FN(a2) : a2;
    };
    goog.setCssNameMapping = function(a2, b2) {
      goog.cssNameMapping_ = a2;
      goog.cssNameMappingStyle_ = b2;
    };
    !COMPILED && goog.global.CLOSURE_CSS_NAME_MAPPING && (goog.cssNameMapping_ = goog.global.CLOSURE_CSS_NAME_MAPPING);
    goog.getMsg = function(a2, b2, c2) {
      c2 && c2.html && (a2 = a2.replace(/</g, "&lt;"));
      b2 && (a2 = a2.replace(/\{\$([^}]+)}/g, function(a3, c3) {
        return null != b2 && c3 in b2 ? b2[c3] : a3;
      }));
      return a2;
    };
    goog.getMsgWithFallback = function(a2, b2) {
      return a2;
    };
    goog.exportSymbol = function(a2, b2, c2) {
      goog.exportPath_(a2, b2, c2);
    };
    goog.exportProperty = function(a2, b2, c2) {
      a2[b2] = c2;
    };
    goog.inherits = function(a2, b2) {
      function c2() {
      }
      c2.prototype = b2.prototype;
      a2.superClass_ = b2.prototype;
      a2.prototype = new c2();
      a2.prototype.constructor = a2;
      a2.base = function(a3, c3, f2) {
        for (var d2 = Array(arguments.length - 2), e2 = 2; e2 < arguments.length; e2++)
          d2[e2 - 2] = arguments[e2];
        return b2.prototype[c3].apply(a3, d2);
      };
    };
    goog.scope = function(a2) {
      if (goog.isInModuleLoader_())
        throw Error("goog.scope is not supported within a module.");
      a2.call(goog.global);
    };
    COMPILED || (goog.global.COMPILED = COMPILED);
    goog.defineClass = function(a2, b2) {
      var c2 = b2.constructor, d2 = b2.statics;
      c2 && c2 != Object.prototype.constructor || (c2 = function() {
        throw Error("cannot instantiate an interface (no constructor defined).");
      });
      c2 = goog.defineClass.createSealingConstructor_(c2, a2);
      a2 && goog.inherits(c2, a2);
      delete b2.constructor;
      delete b2.statics;
      goog.defineClass.applyProperties_(c2.prototype, b2);
      null != d2 && (d2 instanceof Function ? d2(c2) : goog.defineClass.applyProperties_(c2, d2));
      return c2;
    };
    goog.defineClass.SEAL_CLASS_INSTANCES = goog.DEBUG;
    goog.defineClass.createSealingConstructor_ = function(a2, b2) {
      if (!goog.defineClass.SEAL_CLASS_INSTANCES)
        return a2;
      var c2 = !goog.defineClass.isUnsealable_(b2), d2 = function() {
        var b3 = a2.apply(this, arguments) || this;
        b3[goog.UID_PROPERTY_] = b3[goog.UID_PROPERTY_];
        this.constructor === d2 && c2 && Object.seal instanceof Function && Object.seal(b3);
        return b3;
      };
      return d2;
    };
    goog.defineClass.isUnsealable_ = function(a2) {
      return a2 && a2.prototype && a2.prototype[goog.UNSEALABLE_CONSTRUCTOR_PROPERTY_];
    };
    goog.defineClass.OBJECT_PROTOTYPE_FIELDS_ = "constructor hasOwnProperty isPrototypeOf propertyIsEnumerable toLocaleString toString valueOf".split(" ");
    goog.defineClass.applyProperties_ = function(a2, b2) {
      for (var c2 in b2)
        Object.prototype.hasOwnProperty.call(b2, c2) && (a2[c2] = b2[c2]);
      for (var d2 = 0; d2 < goog.defineClass.OBJECT_PROTOTYPE_FIELDS_.length; d2++)
        c2 = goog.defineClass.OBJECT_PROTOTYPE_FIELDS_[d2], Object.prototype.hasOwnProperty.call(b2, c2) && (a2[c2] = b2[c2]);
    };
    goog.tagUnsealableClass = function(a2) {
      !COMPILED && goog.defineClass.SEAL_CLASS_INSTANCES && (a2.prototype[goog.UNSEALABLE_CONSTRUCTOR_PROPERTY_] = true);
    };
    goog.UNSEALABLE_CONSTRUCTOR_PROPERTY_ = "goog_defineClass_legacy_unsealable";
    !COMPILED && goog.DEPENDENCIES_ENABLED && (goog.inHtmlDocument_ = function() {
      var a2 = goog.global.document;
      return null != a2 && "write" in a2;
    }, goog.isDocumentLoading_ = function() {
      var a2 = goog.global.document;
      return a2.attachEvent ? "complete" != a2.readyState : "loading" == a2.readyState;
    }, goog.findBasePath_ = function() {
      if (void 0 != goog.global.CLOSURE_BASE_PATH && "string" === typeof goog.global.CLOSURE_BASE_PATH)
        goog.basePath = goog.global.CLOSURE_BASE_PATH;
      else if (goog.inHtmlDocument_()) {
        var a2 = goog.global.document, b2 = a2.currentScript;
        a2 = b2 ? [b2] : a2.getElementsByTagName("SCRIPT");
        for (b2 = a2.length - 1; 0 <= b2; --b2) {
          var c2 = a2[b2].src, d2 = c2.lastIndexOf("?");
          d2 = -1 == d2 ? c2.length : d2;
          if ("base.js" == c2.substr(d2 - 7, 7)) {
            goog.basePath = c2.substr(0, d2 - 7);
            break;
          }
        }
      }
    }, goog.findBasePath_(), goog.Transpiler = function() {
      this.requiresTranspilation_ = null;
      this.transpilationTarget_ = goog.TRANSPILE_TO_LANGUAGE;
    }, goog.Transpiler.prototype.createRequiresTranspilation_ = function() {
      function a(a2, b2) {
        e ? d[a2] = true : b2() ? (c = a2, d[a2] = false) : e = d[a2] = true;
      }
      function b(a) {
        try {
          return !!eval(a);
        } catch (h) {
          return false;
        }
      }
      var c = "es3", d = { es3: false }, e = false, f = goog.global.navigator && goog.global.navigator.userAgent ? goog.global.navigator.userAgent : "";
      a("es5", function() {
        return b("[1,].length==1");
      });
      a("es6", function() {
        return f.match(/Edge\/(\d+)(\.\d)*/i) ? false : b('(()=>{"use strict";class X{constructor(){if(new.target!=String)throw 1;this.x=42}}let q=Reflect.construct(X,[],String);if(q.x!=42||!(q instanceof String))throw 1;for(const a of[2,3]){if(a==2)continue;function f(z={a}){let a=0;return z.a}{function f(){return 0;}}return f()==3}})()');
      });
      a("es7", function() {
        return b("2 ** 2 == 4");
      });
      a("es8", function() {
        return b("async () => 1, true");
      });
      a("es9", function() {
        return b("({...rest} = {}), true");
      });
      a("es_next", function() {
        return false;
      });
      return { target: c, map: d };
    }, goog.Transpiler.prototype.needsTranspile = function(a2, b2) {
      if ("always" == goog.TRANSPILE)
        return true;
      if ("never" == goog.TRANSPILE)
        return false;
      if (!this.requiresTranspilation_) {
        var c2 = this.createRequiresTranspilation_();
        this.requiresTranspilation_ = c2.map;
        this.transpilationTarget_ = this.transpilationTarget_ || c2.target;
      }
      if (a2 in this.requiresTranspilation_)
        return this.requiresTranspilation_[a2] ? true : !goog.inHtmlDocument_() || "es6" != b2 || "noModule" in goog.global.document.createElement("script") ? false : true;
      throw Error("Unknown language mode: " + a2);
    }, goog.Transpiler.prototype.transpile = function(a2, b2) {
      return goog.transpile_(a2, b2, this.transpilationTarget_);
    }, goog.transpiler_ = new goog.Transpiler(), goog.protectScriptTag_ = function(a2) {
      return a2.replace(/<\/(SCRIPT)/ig, "\\x3c/$1");
    }, goog.DebugLoader_ = function() {
      this.dependencies_ = {};
      this.idToPath_ = {};
      this.written_ = {};
      this.loadingDeps_ = [];
      this.depsToLoad_ = [];
      this.paused_ = false;
      this.factory_ = new goog.DependencyFactory(goog.transpiler_);
      this.deferredCallbacks_ = {};
      this.deferredQueue_ = [];
    }, goog.DebugLoader_.prototype.bootstrap = function(a2, b2) {
      function c2() {
        d2 && (goog.global.setTimeout(d2, 0), d2 = null);
      }
      var d2 = b2;
      if (a2.length) {
        b2 = [];
        for (var e2 = 0; e2 < a2.length; e2++) {
          var f2 = this.getPathFromDeps_(a2[e2]);
          if (!f2)
            throw Error("Unregonized namespace: " + a2[e2]);
          b2.push(this.dependencies_[f2]);
        }
        f2 = goog.require;
        var g = 0;
        for (e2 = 0; e2 < a2.length; e2++)
          f2(a2[e2]), b2[e2].onLoad(function() {
            ++g == a2.length && c2();
          });
      } else
        c2();
    }, goog.DebugLoader_.prototype.loadClosureDeps = function() {
      this.depsToLoad_.push(this.factory_.createDependency(goog.normalizePath_(goog.basePath + "deps.js"), "deps.js", [], [], {}, false));
      this.loadDeps_();
    }, goog.DebugLoader_.prototype.requested = function(a2, b2) {
      (a2 = this.getPathFromDeps_(a2)) && (b2 || this.areDepsLoaded_(this.dependencies_[a2].requires)) && (b2 = this.deferredCallbacks_[a2]) && (delete this.deferredCallbacks_[a2], b2());
    }, goog.DebugLoader_.prototype.setDependencyFactory = function(a2) {
      this.factory_ = a2;
    }, goog.DebugLoader_.prototype.load_ = function(a2) {
      if (this.getPathFromDeps_(a2)) {
        var b2 = this, c2 = [], d2 = function(a3) {
          var e2 = b2.getPathFromDeps_(a3);
          if (!e2)
            throw Error("Bad dependency path or symbol: " + a3);
          if (!b2.written_[e2]) {
            b2.written_[e2] = true;
            a3 = b2.dependencies_[e2];
            for (e2 = 0; e2 < a3.requires.length; e2++)
              goog.isProvided_(a3.requires[e2]) || d2(a3.requires[e2]);
            c2.push(a3);
          }
        };
        d2(a2);
        a2 = !!this.depsToLoad_.length;
        this.depsToLoad_ = this.depsToLoad_.concat(c2);
        this.paused_ || a2 || this.loadDeps_();
      } else
        throw a2 = "goog.require could not find: " + a2, goog.logToConsole_(a2), Error(a2);
    }, goog.DebugLoader_.prototype.loadDeps_ = function() {
      for (var a2 = this, b2 = this.paused_; this.depsToLoad_.length && !b2; )
        (function() {
          var c2 = false, d2 = a2.depsToLoad_.shift(), e2 = false;
          a2.loading_(d2);
          var f2 = { pause: function() {
            if (c2)
              throw Error("Cannot call pause after the call to load.");
            b2 = true;
          }, resume: function() {
            c2 ? a2.resume_() : b2 = false;
          }, loaded: function() {
            if (e2)
              throw Error("Double call to loaded.");
            e2 = true;
            a2.loaded_(d2);
          }, pending: function() {
            for (var b3 = [], c3 = 0; c3 < a2.loadingDeps_.length; c3++)
              b3.push(a2.loadingDeps_[c3]);
            return b3;
          }, setModuleState: function(a3) {
            goog.moduleLoaderState_ = { type: a3, moduleName: "", declareLegacyNamespace: false };
          }, registerEs6ModuleExports: function(a3, b3, c3) {
            c3 && (goog.loadedModules_[c3] = { exports: b3, type: goog.ModuleType.ES6, moduleId: c3 || "" });
          }, registerGoogModuleExports: function(a3, b3) {
            goog.loadedModules_[a3] = { exports: b3, type: goog.ModuleType.GOOG, moduleId: a3 };
          }, clearModuleState: function() {
            goog.moduleLoaderState_ = null;
          }, defer: function(b3) {
            if (c2)
              throw Error("Cannot register with defer after the call to load.");
            a2.defer_(
              d2,
              b3
            );
          }, areDepsLoaded: function() {
            return a2.areDepsLoaded_(d2.requires);
          } };
          try {
            d2.load(f2);
          } finally {
            c2 = true;
          }
        })();
      b2 && this.pause_();
    }, goog.DebugLoader_.prototype.pause_ = function() {
      this.paused_ = true;
    }, goog.DebugLoader_.prototype.resume_ = function() {
      this.paused_ && (this.paused_ = false, this.loadDeps_());
    }, goog.DebugLoader_.prototype.loading_ = function(a2) {
      this.loadingDeps_.push(a2);
    }, goog.DebugLoader_.prototype.loaded_ = function(a2) {
      for (var b2 = 0; b2 < this.loadingDeps_.length; b2++)
        if (this.loadingDeps_[b2] == a2) {
          this.loadingDeps_.splice(b2, 1);
          break;
        }
      for (b2 = 0; b2 < this.deferredQueue_.length; b2++)
        if (this.deferredQueue_[b2] == a2.path) {
          this.deferredQueue_.splice(b2, 1);
          break;
        }
      if (this.loadingDeps_.length == this.deferredQueue_.length && !this.depsToLoad_.length)
        for (; this.deferredQueue_.length; )
          this.requested(this.deferredQueue_.shift(), true);
      a2.loaded();
    }, goog.DebugLoader_.prototype.areDepsLoaded_ = function(a2) {
      for (var b2 = 0; b2 < a2.length; b2++) {
        var c2 = this.getPathFromDeps_(a2[b2]);
        if (!c2 || !(c2 in this.deferredCallbacks_ || goog.isProvided_(a2[b2])))
          return false;
      }
      return true;
    }, goog.DebugLoader_.prototype.getPathFromDeps_ = function(a2) {
      return a2 in this.idToPath_ ? this.idToPath_[a2] : a2 in this.dependencies_ ? a2 : null;
    }, goog.DebugLoader_.prototype.defer_ = function(a2, b2) {
      this.deferredCallbacks_[a2.path] = b2;
      this.deferredQueue_.push(a2.path);
    }, goog.LoadController = function() {
    }, goog.LoadController.prototype.pause = function() {
    }, goog.LoadController.prototype.resume = function() {
    }, goog.LoadController.prototype.loaded = function() {
    }, goog.LoadController.prototype.pending = function() {
    }, goog.LoadController.prototype.registerEs6ModuleExports = function(a2, b2, c2) {
    }, goog.LoadController.prototype.setModuleState = function(a2) {
    }, goog.LoadController.prototype.clearModuleState = function() {
    }, goog.LoadController.prototype.defer = function(a2) {
    }, goog.LoadController.prototype.areDepsLoaded = function() {
    }, goog.Dependency = function(a2, b2, c2, d2, e2) {
      this.path = a2;
      this.relativePath = b2;
      this.provides = c2;
      this.requires = d2;
      this.loadFlags = e2;
      this.loaded_ = false;
      this.loadCallbacks_ = [];
    }, goog.Dependency.prototype.getPathName = function() {
      var a2 = this.path, b2 = a2.indexOf("://");
      0 <= b2 && (a2 = a2.substring(b2 + 3), b2 = a2.indexOf("/"), 0 <= b2 && (a2 = a2.substring(b2 + 1)));
      return a2;
    }, goog.Dependency.prototype.onLoad = function(a2) {
      this.loaded_ ? a2() : this.loadCallbacks_.push(a2);
    }, goog.Dependency.prototype.loaded = function() {
      this.loaded_ = true;
      var a2 = this.loadCallbacks_;
      this.loadCallbacks_ = [];
      for (var b2 = 0; b2 < a2.length; b2++)
        a2[b2]();
    }, goog.Dependency.defer_ = false, goog.Dependency.callbackMap_ = {}, goog.Dependency.registerCallback_ = function(a2) {
      var b2 = Math.random().toString(32);
      goog.Dependency.callbackMap_[b2] = a2;
      return b2;
    }, goog.Dependency.unregisterCallback_ = function(a2) {
      delete goog.Dependency.callbackMap_[a2];
    }, goog.Dependency.callback_ = function(a2, b2) {
      if (a2 in goog.Dependency.callbackMap_) {
        for (var c2 = goog.Dependency.callbackMap_[a2], d2 = [], e2 = 1; e2 < arguments.length; e2++)
          d2.push(arguments[e2]);
        c2.apply(void 0, d2);
      } else
        throw Error("Callback key " + a2 + " does not exist (was base.js loaded more than once?).");
    }, goog.Dependency.prototype.load = function(a2) {
      if (goog.global.CLOSURE_IMPORT_SCRIPT)
        goog.global.CLOSURE_IMPORT_SCRIPT(this.path) ? a2.loaded() : a2.pause();
      else if (goog.inHtmlDocument_()) {
        var b2 = goog.global.document;
        if ("complete" == b2.readyState && !goog.ENABLE_CHROME_APP_SAFE_SCRIPT_LOADING) {
          if (/\bdeps.js$/.test(this.path)) {
            a2.loaded();
            return;
          }
          throw Error('Cannot write "' + this.path + '" after document load');
        }
        if (!goog.ENABLE_CHROME_APP_SAFE_SCRIPT_LOADING && goog.isDocumentLoading_()) {
          var c2 = goog.Dependency.registerCallback_(function(b3) {
            goog.DebugLoader_.IS_OLD_IE_ && "complete" != b3.readyState || (goog.Dependency.unregisterCallback_(c2), a2.loaded());
          }), d2 = !goog.DebugLoader_.IS_OLD_IE_ && goog.getScriptNonce() ? ' nonce="' + goog.getScriptNonce() + '"' : "";
          d2 = '<script src="' + this.path + '" ' + (goog.DebugLoader_.IS_OLD_IE_ ? "onreadystatechange" : "onload") + `="goog.Dependency.callback_('` + c2 + `', this)" type="text/javascript" ` + (goog.Dependency.defer_ ? "defer" : "") + d2 + "></script>";
          b2.write(goog.TRUSTED_TYPES_POLICY_ ? goog.TRUSTED_TYPES_POLICY_.createHTML(d2) : d2);
        } else {
          var e2 = b2.createElement("script");
          e2.defer = goog.Dependency.defer_;
          e2.async = false;
          e2.type = "text/javascript";
          (d2 = goog.getScriptNonce()) && e2.setAttribute("nonce", d2);
          goog.DebugLoader_.IS_OLD_IE_ ? (a2.pause(), e2.onreadystatechange = function() {
            if ("loaded" == e2.readyState || "complete" == e2.readyState)
              a2.loaded(), a2.resume();
          }) : e2.onload = function() {
            e2.onload = null;
            a2.loaded();
          };
          e2.src = goog.TRUSTED_TYPES_POLICY_ ? goog.TRUSTED_TYPES_POLICY_.createScriptURL(this.path) : this.path;
          b2.head.appendChild(e2);
        }
      } else
        goog.logToConsole_("Cannot use default debug loader outside of HTML documents."), "deps.js" == this.relativePath ? (goog.logToConsole_("Consider setting CLOSURE_IMPORT_SCRIPT before loading base.js, or setting CLOSURE_NO_DEPS to true."), a2.loaded()) : a2.pause();
    }, goog.Es6ModuleDependency = function(a2, b2, c2, d2, e2) {
      goog.Dependency.call(this, a2, b2, c2, d2, e2);
    }, goog.inherits(goog.Es6ModuleDependency, goog.Dependency), goog.Es6ModuleDependency.prototype.load = function(a2) {
      function b2(a3, b3) {
        a3 = b3 ? '<script type="module" crossorigin>' + b3 + "</script>" : '<script type="module" crossorigin src="' + a3 + '"></script>';
        d2.write(goog.TRUSTED_TYPES_POLICY_ ? goog.TRUSTED_TYPES_POLICY_.createHTML(a3) : a3);
      }
      function c2(a3, b3) {
        var c3 = d2.createElement("script");
        c3.defer = true;
        c3.async = false;
        c3.type = "module";
        c3.setAttribute("crossorigin", true);
        var e3 = goog.getScriptNonce();
        e3 && c3.setAttribute("nonce", e3);
        b3 ? c3.textContent = goog.TRUSTED_TYPES_POLICY_ ? goog.TRUSTED_TYPES_POLICY_.createScript(b3) : b3 : c3.src = goog.TRUSTED_TYPES_POLICY_ ? goog.TRUSTED_TYPES_POLICY_.createScriptURL(a3) : a3;
        d2.head.appendChild(c3);
      }
      if (goog.global.CLOSURE_IMPORT_SCRIPT)
        goog.global.CLOSURE_IMPORT_SCRIPT(this.path) ? a2.loaded() : a2.pause();
      else if (goog.inHtmlDocument_()) {
        var d2 = goog.global.document, e2 = this;
        if (goog.isDocumentLoading_()) {
          var f2 = b2;
          goog.Dependency.defer_ = true;
        } else
          f2 = c2;
        var g = goog.Dependency.registerCallback_(function() {
          goog.Dependency.unregisterCallback_(g);
          a2.setModuleState(goog.ModuleType.ES6);
        });
        f2(void 0, 'goog.Dependency.callback_("' + g + '")');
        f2(this.path, void 0);
        var h = goog.Dependency.registerCallback_(function(b3) {
          goog.Dependency.unregisterCallback_(h);
          a2.registerEs6ModuleExports(e2.path, b3, goog.moduleLoaderState_.moduleName);
        });
        f2(void 0, 'import * as m from "' + this.path + '"; goog.Dependency.callback_("' + h + '", m)');
        var k = goog.Dependency.registerCallback_(function() {
          goog.Dependency.unregisterCallback_(k);
          a2.clearModuleState();
          a2.loaded();
        });
        f2(void 0, 'goog.Dependency.callback_("' + k + '")');
      } else
        goog.logToConsole_("Cannot use default debug loader outside of HTML documents."), a2.pause();
    }, goog.TransformedDependency = function(a2, b2, c2, d2, e2) {
      goog.Dependency.call(this, a2, b2, c2, d2, e2);
      this.contents_ = null;
      this.lazyFetch_ = !goog.inHtmlDocument_() || !("noModule" in goog.global.document.createElement("script"));
    }, goog.inherits(goog.TransformedDependency, goog.Dependency), goog.TransformedDependency.prototype.load = function(a2) {
      function b2() {
        e2.contents_ = goog.loadFileSync_(e2.path);
        e2.contents_ && (e2.contents_ = e2.transform(e2.contents_), e2.contents_ && (e2.contents_ += "\n//# sourceURL=" + e2.path));
      }
      function c2() {
        e2.lazyFetch_ && b2();
        if (e2.contents_) {
          f2 && a2.setModuleState(goog.ModuleType.ES6);
          try {
            var c3 = e2.contents_;
            e2.contents_ = null;
            goog.globalEval(c3);
            if (f2)
              var d3 = goog.moduleLoaderState_.moduleName;
          } finally {
            f2 && a2.clearModuleState();
          }
          f2 && goog.global.$jscomp.require.ensure([e2.getPathName()], function() {
            a2.registerEs6ModuleExports(
              e2.path,
              goog.global.$jscomp.require(e2.getPathName()),
              d3
            );
          });
          a2.loaded();
        }
      }
      function d2() {
        var a3 = goog.global.document, b3 = goog.Dependency.registerCallback_(function() {
          goog.Dependency.unregisterCallback_(b3);
          c2();
        }), d3 = '<script type="text/javascript">' + goog.protectScriptTag_('goog.Dependency.callback_("' + b3 + '");') + "</script>";
        a3.write(goog.TRUSTED_TYPES_POLICY_ ? goog.TRUSTED_TYPES_POLICY_.createHTML(d3) : d3);
      }
      var e2 = this;
      if (goog.global.CLOSURE_IMPORT_SCRIPT)
        b2(), this.contents_ && goog.global.CLOSURE_IMPORT_SCRIPT("", this.contents_) ? (this.contents_ = null, a2.loaded()) : a2.pause();
      else {
        var f2 = this.loadFlags.module == goog.ModuleType.ES6;
        this.lazyFetch_ || b2();
        var g = 1 < a2.pending().length, h = g && goog.DebugLoader_.IS_OLD_IE_;
        g = goog.Dependency.defer_ && (g || goog.isDocumentLoading_());
        if (h || g)
          a2.defer(function() {
            c2();
          });
        else {
          var k = goog.global.document;
          h = goog.inHtmlDocument_() && "ActiveXObject" in goog.global;
          if (f2 && goog.inHtmlDocument_() && goog.isDocumentLoading_() && !h) {
            goog.Dependency.defer_ = true;
            a2.pause();
            var l = k.onreadystatechange;
            k.onreadystatechange = function() {
              "interactive" == k.readyState && (k.onreadystatechange = l, c2(), a2.resume());
              goog.isFunction(l) && l.apply(void 0, arguments);
            };
          } else
            !goog.DebugLoader_.IS_OLD_IE_ && goog.inHtmlDocument_() && goog.isDocumentLoading_() ? d2() : c2();
        }
      }
    }, goog.TransformedDependency.prototype.transform = function(a2) {
    }, goog.TranspiledDependency = function(a2, b2, c2, d2, e2, f2) {
      goog.TransformedDependency.call(this, a2, b2, c2, d2, e2);
      this.transpiler = f2;
    }, goog.inherits(goog.TranspiledDependency, goog.TransformedDependency), goog.TranspiledDependency.prototype.transform = function(a2) {
      return this.transpiler.transpile(a2, this.getPathName());
    }, goog.PreTranspiledEs6ModuleDependency = function(a2, b2, c2, d2, e2) {
      goog.TransformedDependency.call(this, a2, b2, c2, d2, e2);
    }, goog.inherits(goog.PreTranspiledEs6ModuleDependency, goog.TransformedDependency), goog.PreTranspiledEs6ModuleDependency.prototype.transform = function(a2) {
      return a2;
    }, goog.GoogModuleDependency = function(a2, b2, c2, d2, e2, f2, g) {
      goog.TransformedDependency.call(this, a2, b2, c2, d2, e2);
      this.needsTranspile_ = f2;
      this.transpiler_ = g;
    }, goog.inherits(goog.GoogModuleDependency, goog.TransformedDependency), goog.GoogModuleDependency.prototype.transform = function(a2) {
      this.needsTranspile_ && (a2 = this.transpiler_.transpile(a2, this.getPathName()));
      return goog.LOAD_MODULE_USING_EVAL && void 0 !== goog.global.JSON ? "goog.loadModule(" + goog.global.JSON.stringify(a2 + "\n//# sourceURL=" + this.path + "\n") + ");" : 'goog.loadModule(function(exports) {"use strict";' + a2 + "\n;return exports});\n//# sourceURL=" + this.path + "\n";
    }, goog.DebugLoader_.IS_OLD_IE_ = !(goog.global.atob || !goog.global.document || !goog.global.document.all), goog.DebugLoader_.prototype.addDependency = function(a2, b2, c2, d2) {
      b2 = b2 || [];
      a2 = a2.replace(/\\/g, "/");
      var e2 = goog.normalizePath_(goog.basePath + a2);
      d2 && "boolean" !== typeof d2 || (d2 = d2 ? { module: goog.ModuleType.GOOG } : {});
      c2 = this.factory_.createDependency(e2, a2, b2, c2, d2, goog.transpiler_.needsTranspile(d2.lang || "es3", d2.module));
      this.dependencies_[e2] = c2;
      for (c2 = 0; c2 < b2.length; c2++)
        this.idToPath_[b2[c2]] = e2;
      this.idToPath_[a2] = e2;
    }, goog.DependencyFactory = function(a2) {
      this.transpiler = a2;
    }, goog.DependencyFactory.prototype.createDependency = function(a2, b2, c2, d2, e2, f2) {
      return e2.module == goog.ModuleType.GOOG ? new goog.GoogModuleDependency(
        a2,
        b2,
        c2,
        d2,
        e2,
        f2,
        this.transpiler
      ) : f2 ? new goog.TranspiledDependency(a2, b2, c2, d2, e2, this.transpiler) : e2.module == goog.ModuleType.ES6 ? "never" == goog.TRANSPILE && goog.ASSUME_ES_MODULES_TRANSPILED ? new goog.PreTranspiledEs6ModuleDependency(a2, b2, c2, d2, e2) : new goog.Es6ModuleDependency(a2, b2, c2, d2, e2) : new goog.Dependency(a2, b2, c2, d2, e2);
    }, goog.debugLoader_ = new goog.DebugLoader_(), goog.loadClosureDeps = function() {
      goog.debugLoader_.loadClosureDeps();
    }, goog.setDependencyFactory = function(a2) {
      goog.debugLoader_.setDependencyFactory(a2);
    }, goog.global.CLOSURE_NO_DEPS || goog.debugLoader_.loadClosureDeps(), goog.bootstrap = function(a2, b2) {
      goog.debugLoader_.bootstrap(a2, b2);
    });
    goog.TRUSTED_TYPES_POLICY_NAME = "";
    goog.identity_ = function(a2) {
      return a2;
    };
    goog.createTrustedTypesPolicy = function(a2) {
      var b2 = null, c2 = goog.global.trustedTypes || goog.global.TrustedTypes;
      if (!c2 || !c2.createPolicy)
        return b2;
      try {
        b2 = c2.createPolicy(a2, { createHTML: goog.identity_, createScript: goog.identity_, createScriptURL: goog.identity_, createURL: goog.identity_ });
      } catch (d2) {
        goog.logToConsole_(d2.message);
      }
      return b2;
    };
    goog.TRUSTED_TYPES_POLICY_ = goog.TRUSTED_TYPES_POLICY_NAME ? goog.createTrustedTypesPolicy(goog.TRUSTED_TYPES_POLICY_NAME + "#base") : null;
    goog.object = {};
    goog.object.is = function(a2, b2) {
      return a2 === b2 ? 0 !== a2 || 1 / a2 === 1 / b2 : a2 !== a2 && b2 !== b2;
    };
    goog.object.forEach = function(a2, b2, c2) {
      for (var d2 in a2)
        b2.call(c2, a2[d2], d2, a2);
    };
    goog.object.filter = function(a2, b2, c2) {
      var d2 = {}, e2;
      for (e2 in a2)
        b2.call(c2, a2[e2], e2, a2) && (d2[e2] = a2[e2]);
      return d2;
    };
    goog.object.map = function(a2, b2, c2) {
      var d2 = {}, e2;
      for (e2 in a2)
        d2[e2] = b2.call(c2, a2[e2], e2, a2);
      return d2;
    };
    goog.object.some = function(a2, b2, c2) {
      for (var d2 in a2)
        if (b2.call(c2, a2[d2], d2, a2))
          return true;
      return false;
    };
    goog.object.every = function(a2, b2, c2) {
      for (var d2 in a2)
        if (!b2.call(c2, a2[d2], d2, a2))
          return false;
      return true;
    };
    goog.object.getCount = function(a2) {
      var b2 = 0, c2;
      for (c2 in a2)
        b2++;
      return b2;
    };
    goog.object.getAnyKey = function(a2) {
      for (var b2 in a2)
        return b2;
    };
    goog.object.getAnyValue = function(a2) {
      for (var b2 in a2)
        return a2[b2];
    };
    goog.object.contains = function(a2, b2) {
      return goog.object.containsValue(a2, b2);
    };
    goog.object.getValues = function(a2) {
      var b2 = [], c2 = 0, d2;
      for (d2 in a2)
        b2[c2++] = a2[d2];
      return b2;
    };
    goog.object.getKeys = function(a2) {
      var b2 = [], c2 = 0, d2;
      for (d2 in a2)
        b2[c2++] = d2;
      return b2;
    };
    goog.object.getValueByKeys = function(a2, b2) {
      var c2 = goog.isArrayLike(b2), d2 = c2 ? b2 : arguments;
      for (c2 = c2 ? 0 : 1; c2 < d2.length; c2++) {
        if (null == a2)
          return;
        a2 = a2[d2[c2]];
      }
      return a2;
    };
    goog.object.containsKey = function(a2, b2) {
      return null !== a2 && b2 in a2;
    };
    goog.object.containsValue = function(a2, b2) {
      for (var c2 in a2)
        if (a2[c2] == b2)
          return true;
      return false;
    };
    goog.object.findKey = function(a2, b2, c2) {
      for (var d2 in a2)
        if (b2.call(c2, a2[d2], d2, a2))
          return d2;
    };
    goog.object.findValue = function(a2, b2, c2) {
      return (b2 = goog.object.findKey(a2, b2, c2)) && a2[b2];
    };
    goog.object.isEmpty = function(a2) {
      for (var b2 in a2)
        return false;
      return true;
    };
    goog.object.clear = function(a2) {
      for (var b2 in a2)
        delete a2[b2];
    };
    goog.object.remove = function(a2, b2) {
      var c2;
      (c2 = b2 in a2) && delete a2[b2];
      return c2;
    };
    goog.object.add = function(a2, b2, c2) {
      if (null !== a2 && b2 in a2)
        throw Error('The object already contains the key "' + b2 + '"');
      goog.object.set(a2, b2, c2);
    };
    goog.object.get = function(a2, b2, c2) {
      return null !== a2 && b2 in a2 ? a2[b2] : c2;
    };
    goog.object.set = function(a2, b2, c2) {
      a2[b2] = c2;
    };
    goog.object.setIfUndefined = function(a2, b2, c2) {
      return b2 in a2 ? a2[b2] : a2[b2] = c2;
    };
    goog.object.setWithReturnValueIfNotSet = function(a2, b2, c2) {
      if (b2 in a2)
        return a2[b2];
      c2 = c2();
      return a2[b2] = c2;
    };
    goog.object.equals = function(a2, b2) {
      for (var c2 in a2)
        if (!(c2 in b2) || a2[c2] !== b2[c2])
          return false;
      for (var d2 in b2)
        if (!(d2 in a2))
          return false;
      return true;
    };
    goog.object.clone = function(a2) {
      var b2 = {}, c2;
      for (c2 in a2)
        b2[c2] = a2[c2];
      return b2;
    };
    goog.object.unsafeClone = function(a2) {
      var b2 = goog.typeOf(a2);
      if ("object" == b2 || "array" == b2) {
        if (goog.isFunction(a2.clone))
          return a2.clone();
        b2 = "array" == b2 ? [] : {};
        for (var c2 in a2)
          b2[c2] = goog.object.unsafeClone(a2[c2]);
        return b2;
      }
      return a2;
    };
    goog.object.transpose = function(a2) {
      var b2 = {}, c2;
      for (c2 in a2)
        b2[a2[c2]] = c2;
      return b2;
    };
    goog.object.PROTOTYPE_FIELDS_ = "constructor hasOwnProperty isPrototypeOf propertyIsEnumerable toLocaleString toString valueOf".split(" ");
    goog.object.extend = function(a2, b2) {
      for (var c2, d2, e2 = 1; e2 < arguments.length; e2++) {
        d2 = arguments[e2];
        for (c2 in d2)
          a2[c2] = d2[c2];
        for (var f2 = 0; f2 < goog.object.PROTOTYPE_FIELDS_.length; f2++)
          c2 = goog.object.PROTOTYPE_FIELDS_[f2], Object.prototype.hasOwnProperty.call(d2, c2) && (a2[c2] = d2[c2]);
      }
    };
    goog.object.create = function(a2) {
      var b2 = arguments.length;
      if (1 == b2 && Array.isArray(arguments[0]))
        return goog.object.create.apply(null, arguments[0]);
      if (b2 % 2)
        throw Error("Uneven number of arguments");
      for (var c2 = {}, d2 = 0; d2 < b2; d2 += 2)
        c2[arguments[d2]] = arguments[d2 + 1];
      return c2;
    };
    goog.object.createSet = function(a2) {
      var b2 = arguments.length;
      if (1 == b2 && Array.isArray(arguments[0]))
        return goog.object.createSet.apply(null, arguments[0]);
      for (var c2 = {}, d2 = 0; d2 < b2; d2++)
        c2[arguments[d2]] = true;
      return c2;
    };
    goog.object.createImmutableView = function(a2) {
      var b2 = a2;
      Object.isFrozen && !Object.isFrozen(a2) && (b2 = Object.create(a2), Object.freeze(b2));
      return b2;
    };
    goog.object.isImmutableView = function(a2) {
      return !!Object.isFrozen && Object.isFrozen(a2);
    };
    goog.object.getAllPropertyNames = function(a2, b2, c2) {
      if (!a2)
        return [];
      if (!Object.getOwnPropertyNames || !Object.getPrototypeOf)
        return goog.object.getKeys(a2);
      for (var d2 = {}; a2 && (a2 !== Object.prototype || b2) && (a2 !== Function.prototype || c2); ) {
        for (var e2 = Object.getOwnPropertyNames(a2), f2 = 0; f2 < e2.length; f2++)
          d2[e2[f2]] = true;
        a2 = Object.getPrototypeOf(a2);
      }
      return goog.object.getKeys(d2);
    };
    goog.object.getSuperClass = function(a2) {
      return (a2 = Object.getPrototypeOf(a2.prototype)) && a2.constructor;
    };
    var jspb = { asserts: {} };
    jspb.asserts.doAssertFailure = function(a2, b2, c2, d2) {
      var e2 = "Assertion failed";
      if (c2) {
        e2 += ": " + c2;
        var f2 = d2;
      } else
        a2 && (e2 += ": " + a2, f2 = b2);
      throw Error("" + e2, f2 || []);
    };
    jspb.asserts.assert = function(a2, b2, c2) {
      for (var d2 = [], e2 = 2; e2 < arguments.length; ++e2)
        d2[e2 - 2] = arguments[e2];
      a2 || jspb.asserts.doAssertFailure("", null, b2, d2);
      return a2;
    };
    jspb.asserts.assertString = function(a2, b2, c2) {
      for (var d2 = [], e2 = 2; e2 < arguments.length; ++e2)
        d2[e2 - 2] = arguments[e2];
      "string" !== typeof a2 && jspb.asserts.doAssertFailure("Expected string but got %s: %s.", [goog.typeOf(a2), a2], b2, d2);
      return a2;
    };
    jspb.asserts.assertArray = function(a2, b2, c2) {
      for (var d2 = [], e2 = 2; e2 < arguments.length; ++e2)
        d2[e2 - 2] = arguments[e2];
      Array.isArray(a2) || jspb.asserts.doAssertFailure("Expected array but got %s: %s.", [goog.typeOf(a2), a2], b2, d2);
      return a2;
    };
    jspb.asserts.fail = function(a2, b2) {
      for (var c2 = [], d2 = 1; d2 < arguments.length; ++d2)
        c2[d2 - 1] = arguments[d2];
      throw Error("Failure" + (a2 ? ": " + a2 : ""), c2);
    };
    jspb.asserts.assertInstanceof = function(a2, b2, c2, d2) {
      for (var e2 = [], f2 = 3; f2 < arguments.length; ++f2)
        e2[f2 - 3] = arguments[f2];
      a2 instanceof b2 || jspb.asserts.doAssertFailure("Expected instanceof %s but got %s.", [jspb.asserts.getType(b2), jspb.asserts.getType(a2)], c2, e2);
      return a2;
    };
    jspb.asserts.getType = function(a2) {
      return a2 instanceof Function ? a2.displayName || a2.name || "unknown type name" : a2 instanceof Object ? a2.constructor.displayName || a2.constructor.name || Object.prototype.toString.call(a2) : null === a2 ? "null" : typeof a2;
    };
    jspb.BinaryConstants = {};
    jspb.ConstBinaryMessage = function() {
    };
    jspb.BinaryMessage = function() {
    };
    jspb.BinaryConstants.FieldType = { INVALID: -1, DOUBLE: 1, FLOAT: 2, INT64: 3, UINT64: 4, INT32: 5, FIXED64: 6, FIXED32: 7, BOOL: 8, STRING: 9, GROUP: 10, MESSAGE: 11, BYTES: 12, UINT32: 13, ENUM: 14, SFIXED32: 15, SFIXED64: 16, SINT32: 17, SINT64: 18, FHASH64: 30, VHASH64: 31 };
    jspb.BinaryConstants.WireType = { INVALID: -1, VARINT: 0, FIXED64: 1, DELIMITED: 2, START_GROUP: 3, END_GROUP: 4, FIXED32: 5 };
    jspb.BinaryConstants.FieldTypeToWireType = function(a2) {
      var b2 = jspb.BinaryConstants.FieldType, c2 = jspb.BinaryConstants.WireType;
      switch (a2) {
        case b2.INT32:
        case b2.INT64:
        case b2.UINT32:
        case b2.UINT64:
        case b2.SINT32:
        case b2.SINT64:
        case b2.BOOL:
        case b2.ENUM:
        case b2.VHASH64:
          return c2.VARINT;
        case b2.DOUBLE:
        case b2.FIXED64:
        case b2.SFIXED64:
        case b2.FHASH64:
          return c2.FIXED64;
        case b2.STRING:
        case b2.MESSAGE:
        case b2.BYTES:
          return c2.DELIMITED;
        case b2.FLOAT:
        case b2.FIXED32:
        case b2.SFIXED32:
          return c2.FIXED32;
        default:
          return c2.INVALID;
      }
    };
    jspb.BinaryConstants.INVALID_FIELD_NUMBER = -1;
    jspb.BinaryConstants.FLOAT32_EPS = 1401298464324817e-60;
    jspb.BinaryConstants.FLOAT32_MIN = 11754943508222875e-54;
    jspb.BinaryConstants.FLOAT32_MAX = 34028234663852886e22;
    jspb.BinaryConstants.FLOAT64_EPS = 5e-324;
    jspb.BinaryConstants.FLOAT64_MIN = 22250738585072014e-324;
    jspb.BinaryConstants.FLOAT64_MAX = 17976931348623157e292;
    jspb.BinaryConstants.TWO_TO_20 = 1048576;
    jspb.BinaryConstants.TWO_TO_23 = 8388608;
    jspb.BinaryConstants.TWO_TO_31 = 2147483648;
    jspb.BinaryConstants.TWO_TO_32 = 4294967296;
    jspb.BinaryConstants.TWO_TO_52 = 4503599627370496;
    jspb.BinaryConstants.TWO_TO_63 = 9223372036854776e3;
    jspb.BinaryConstants.TWO_TO_64 = 18446744073709552e3;
    jspb.BinaryConstants.ZERO_HASH = "\0\0\0\0\0\0\0\0";
    goog.debug = {};
    goog.debug.Error = function(a2) {
      if (Error.captureStackTrace)
        Error.captureStackTrace(this, goog.debug.Error);
      else {
        var b2 = Error().stack;
        b2 && (this.stack = b2);
      }
      a2 && (this.message = String(a2));
      this.reportErrorToServer = true;
    };
    goog.inherits(goog.debug.Error, Error);
    goog.debug.Error.prototype.name = "CustomError";
    goog.dom = {};
    goog.dom.NodeType = { ELEMENT: 1, ATTRIBUTE: 2, TEXT: 3, CDATA_SECTION: 4, ENTITY_REFERENCE: 5, ENTITY: 6, PROCESSING_INSTRUCTION: 7, COMMENT: 8, DOCUMENT: 9, DOCUMENT_TYPE: 10, DOCUMENT_FRAGMENT: 11, NOTATION: 12 };
    goog.asserts = {};
    goog.asserts.ENABLE_ASSERTS = goog.DEBUG;
    goog.asserts.AssertionError = function(a2, b2) {
      goog.debug.Error.call(this, goog.asserts.subs_(a2, b2));
      this.messagePattern = a2;
    };
    goog.inherits(goog.asserts.AssertionError, goog.debug.Error);
    goog.asserts.AssertionError.prototype.name = "AssertionError";
    goog.asserts.DEFAULT_ERROR_HANDLER = function(a2) {
      throw a2;
    };
    goog.asserts.errorHandler_ = goog.asserts.DEFAULT_ERROR_HANDLER;
    goog.asserts.subs_ = function(a2, b2) {
      a2 = a2.split("%s");
      for (var c2 = "", d2 = a2.length - 1, e2 = 0; e2 < d2; e2++)
        c2 += a2[e2] + (e2 < b2.length ? b2[e2] : "%s");
      return c2 + a2[d2];
    };
    goog.asserts.doAssertFailure_ = function(a2, b2, c2, d2) {
      var e2 = "Assertion failed";
      if (c2) {
        e2 += ": " + c2;
        var f2 = d2;
      } else
        a2 && (e2 += ": " + a2, f2 = b2);
      a2 = new goog.asserts.AssertionError("" + e2, f2 || []);
      goog.asserts.errorHandler_(a2);
    };
    goog.asserts.setErrorHandler = function(a2) {
      goog.asserts.ENABLE_ASSERTS && (goog.asserts.errorHandler_ = a2);
    };
    goog.asserts.assert = function(a2, b2, c2) {
      goog.asserts.ENABLE_ASSERTS && !a2 && goog.asserts.doAssertFailure_("", null, b2, Array.prototype.slice.call(arguments, 2));
      return a2;
    };
    goog.asserts.assertExists = function(a2, b2, c2) {
      goog.asserts.ENABLE_ASSERTS && null == a2 && goog.asserts.doAssertFailure_("Expected to exist: %s.", [a2], b2, Array.prototype.slice.call(arguments, 2));
      return a2;
    };
    goog.asserts.fail = function(a2, b2) {
      goog.asserts.ENABLE_ASSERTS && goog.asserts.errorHandler_(new goog.asserts.AssertionError("Failure" + (a2 ? ": " + a2 : ""), Array.prototype.slice.call(arguments, 1)));
    };
    goog.asserts.assertNumber = function(a2, b2, c2) {
      goog.asserts.ENABLE_ASSERTS && "number" !== typeof a2 && goog.asserts.doAssertFailure_("Expected number but got %s: %s.", [goog.typeOf(a2), a2], b2, Array.prototype.slice.call(arguments, 2));
      return a2;
    };
    goog.asserts.assertString = function(a2, b2, c2) {
      goog.asserts.ENABLE_ASSERTS && "string" !== typeof a2 && goog.asserts.doAssertFailure_("Expected string but got %s: %s.", [goog.typeOf(a2), a2], b2, Array.prototype.slice.call(arguments, 2));
      return a2;
    };
    goog.asserts.assertFunction = function(a2, b2, c2) {
      goog.asserts.ENABLE_ASSERTS && !goog.isFunction(a2) && goog.asserts.doAssertFailure_("Expected function but got %s: %s.", [goog.typeOf(a2), a2], b2, Array.prototype.slice.call(arguments, 2));
      return a2;
    };
    goog.asserts.assertObject = function(a2, b2, c2) {
      goog.asserts.ENABLE_ASSERTS && !goog.isObject(a2) && goog.asserts.doAssertFailure_("Expected object but got %s: %s.", [goog.typeOf(a2), a2], b2, Array.prototype.slice.call(arguments, 2));
      return a2;
    };
    goog.asserts.assertArray = function(a2, b2, c2) {
      goog.asserts.ENABLE_ASSERTS && !Array.isArray(a2) && goog.asserts.doAssertFailure_("Expected array but got %s: %s.", [goog.typeOf(a2), a2], b2, Array.prototype.slice.call(arguments, 2));
      return a2;
    };
    goog.asserts.assertBoolean = function(a2, b2, c2) {
      goog.asserts.ENABLE_ASSERTS && "boolean" !== typeof a2 && goog.asserts.doAssertFailure_("Expected boolean but got %s: %s.", [goog.typeOf(a2), a2], b2, Array.prototype.slice.call(arguments, 2));
      return a2;
    };
    goog.asserts.assertElement = function(a2, b2, c2) {
      !goog.asserts.ENABLE_ASSERTS || goog.isObject(a2) && a2.nodeType == goog.dom.NodeType.ELEMENT || goog.asserts.doAssertFailure_("Expected Element but got %s: %s.", [goog.typeOf(a2), a2], b2, Array.prototype.slice.call(arguments, 2));
      return a2;
    };
    goog.asserts.assertInstanceof = function(a2, b2, c2, d2) {
      !goog.asserts.ENABLE_ASSERTS || a2 instanceof b2 || goog.asserts.doAssertFailure_("Expected instanceof %s but got %s.", [goog.asserts.getType_(b2), goog.asserts.getType_(a2)], c2, Array.prototype.slice.call(arguments, 3));
      return a2;
    };
    goog.asserts.assertFinite = function(a2, b2, c2) {
      !goog.asserts.ENABLE_ASSERTS || "number" == typeof a2 && isFinite(a2) || goog.asserts.doAssertFailure_("Expected %s to be a finite number but it is not.", [a2], b2, Array.prototype.slice.call(arguments, 2));
      return a2;
    };
    goog.asserts.assertObjectPrototypeIsIntact = function() {
      for (var a2 in Object.prototype)
        goog.asserts.fail(a2 + " should not be enumerable in Object.prototype.");
    };
    goog.asserts.getType_ = function(a2) {
      return a2 instanceof Function ? a2.displayName || a2.name || "unknown type name" : a2 instanceof Object ? a2.constructor.displayName || a2.constructor.name || Object.prototype.toString.call(a2) : null === a2 ? "null" : typeof a2;
    };
    goog.array = {};
    goog.NATIVE_ARRAY_PROTOTYPES = goog.TRUSTED_SITE;
    goog.array.ASSUME_NATIVE_FUNCTIONS = 2012 < goog.FEATURESET_YEAR;
    goog.array.peek = function(a2) {
      return a2[a2.length - 1];
    };
    goog.array.last = goog.array.peek;
    goog.array.indexOf = goog.NATIVE_ARRAY_PROTOTYPES && (goog.array.ASSUME_NATIVE_FUNCTIONS || Array.prototype.indexOf) ? function(a2, b2, c2) {
      goog.asserts.assert(null != a2.length);
      return Array.prototype.indexOf.call(a2, b2, c2);
    } : function(a2, b2, c2) {
      c2 = null == c2 ? 0 : 0 > c2 ? Math.max(0, a2.length + c2) : c2;
      if ("string" === typeof a2)
        return "string" !== typeof b2 || 1 != b2.length ? -1 : a2.indexOf(b2, c2);
      for (; c2 < a2.length; c2++)
        if (c2 in a2 && a2[c2] === b2)
          return c2;
      return -1;
    };
    goog.array.lastIndexOf = goog.NATIVE_ARRAY_PROTOTYPES && (goog.array.ASSUME_NATIVE_FUNCTIONS || Array.prototype.lastIndexOf) ? function(a2, b2, c2) {
      goog.asserts.assert(null != a2.length);
      return Array.prototype.lastIndexOf.call(a2, b2, null == c2 ? a2.length - 1 : c2);
    } : function(a2, b2, c2) {
      c2 = null == c2 ? a2.length - 1 : c2;
      0 > c2 && (c2 = Math.max(0, a2.length + c2));
      if ("string" === typeof a2)
        return "string" !== typeof b2 || 1 != b2.length ? -1 : a2.lastIndexOf(b2, c2);
      for (; 0 <= c2; c2--)
        if (c2 in a2 && a2[c2] === b2)
          return c2;
      return -1;
    };
    goog.array.forEach = goog.NATIVE_ARRAY_PROTOTYPES && (goog.array.ASSUME_NATIVE_FUNCTIONS || Array.prototype.forEach) ? function(a2, b2, c2) {
      goog.asserts.assert(null != a2.length);
      Array.prototype.forEach.call(a2, b2, c2);
    } : function(a2, b2, c2) {
      for (var d2 = a2.length, e2 = "string" === typeof a2 ? a2.split("") : a2, f2 = 0; f2 < d2; f2++)
        f2 in e2 && b2.call(c2, e2[f2], f2, a2);
    };
    goog.array.forEachRight = function(a2, b2, c2) {
      var d2 = a2.length, e2 = "string" === typeof a2 ? a2.split("") : a2;
      for (--d2; 0 <= d2; --d2)
        d2 in e2 && b2.call(c2, e2[d2], d2, a2);
    };
    goog.array.filter = goog.NATIVE_ARRAY_PROTOTYPES && (goog.array.ASSUME_NATIVE_FUNCTIONS || Array.prototype.filter) ? function(a2, b2, c2) {
      goog.asserts.assert(null != a2.length);
      return Array.prototype.filter.call(a2, b2, c2);
    } : function(a2, b2, c2) {
      for (var d2 = a2.length, e2 = [], f2 = 0, g = "string" === typeof a2 ? a2.split("") : a2, h = 0; h < d2; h++)
        if (h in g) {
          var k = g[h];
          b2.call(c2, k, h, a2) && (e2[f2++] = k);
        }
      return e2;
    };
    goog.array.map = goog.NATIVE_ARRAY_PROTOTYPES && (goog.array.ASSUME_NATIVE_FUNCTIONS || Array.prototype.map) ? function(a2, b2, c2) {
      goog.asserts.assert(null != a2.length);
      return Array.prototype.map.call(a2, b2, c2);
    } : function(a2, b2, c2) {
      for (var d2 = a2.length, e2 = Array(d2), f2 = "string" === typeof a2 ? a2.split("") : a2, g = 0; g < d2; g++)
        g in f2 && (e2[g] = b2.call(c2, f2[g], g, a2));
      return e2;
    };
    goog.array.reduce = goog.NATIVE_ARRAY_PROTOTYPES && (goog.array.ASSUME_NATIVE_FUNCTIONS || Array.prototype.reduce) ? function(a2, b2, c2, d2) {
      goog.asserts.assert(null != a2.length);
      d2 && (b2 = goog.bind(b2, d2));
      return Array.prototype.reduce.call(a2, b2, c2);
    } : function(a2, b2, c2, d2) {
      var e2 = c2;
      goog.array.forEach(a2, function(c3, g) {
        e2 = b2.call(d2, e2, c3, g, a2);
      });
      return e2;
    };
    goog.array.reduceRight = goog.NATIVE_ARRAY_PROTOTYPES && (goog.array.ASSUME_NATIVE_FUNCTIONS || Array.prototype.reduceRight) ? function(a2, b2, c2, d2) {
      goog.asserts.assert(null != a2.length);
      goog.asserts.assert(null != b2);
      d2 && (b2 = goog.bind(b2, d2));
      return Array.prototype.reduceRight.call(a2, b2, c2);
    } : function(a2, b2, c2, d2) {
      var e2 = c2;
      goog.array.forEachRight(a2, function(c3, g) {
        e2 = b2.call(d2, e2, c3, g, a2);
      });
      return e2;
    };
    goog.array.some = goog.NATIVE_ARRAY_PROTOTYPES && (goog.array.ASSUME_NATIVE_FUNCTIONS || Array.prototype.some) ? function(a2, b2, c2) {
      goog.asserts.assert(null != a2.length);
      return Array.prototype.some.call(a2, b2, c2);
    } : function(a2, b2, c2) {
      for (var d2 = a2.length, e2 = "string" === typeof a2 ? a2.split("") : a2, f2 = 0; f2 < d2; f2++)
        if (f2 in e2 && b2.call(c2, e2[f2], f2, a2))
          return true;
      return false;
    };
    goog.array.every = goog.NATIVE_ARRAY_PROTOTYPES && (goog.array.ASSUME_NATIVE_FUNCTIONS || Array.prototype.every) ? function(a2, b2, c2) {
      goog.asserts.assert(null != a2.length);
      return Array.prototype.every.call(a2, b2, c2);
    } : function(a2, b2, c2) {
      for (var d2 = a2.length, e2 = "string" === typeof a2 ? a2.split("") : a2, f2 = 0; f2 < d2; f2++)
        if (f2 in e2 && !b2.call(c2, e2[f2], f2, a2))
          return false;
      return true;
    };
    goog.array.count = function(a2, b2, c2) {
      var d2 = 0;
      goog.array.forEach(a2, function(a3, f2, g) {
        b2.call(c2, a3, f2, g) && ++d2;
      }, c2);
      return d2;
    };
    goog.array.find = function(a2, b2, c2) {
      b2 = goog.array.findIndex(a2, b2, c2);
      return 0 > b2 ? null : "string" === typeof a2 ? a2.charAt(b2) : a2[b2];
    };
    goog.array.findIndex = function(a2, b2, c2) {
      for (var d2 = a2.length, e2 = "string" === typeof a2 ? a2.split("") : a2, f2 = 0; f2 < d2; f2++)
        if (f2 in e2 && b2.call(c2, e2[f2], f2, a2))
          return f2;
      return -1;
    };
    goog.array.findRight = function(a2, b2, c2) {
      b2 = goog.array.findIndexRight(a2, b2, c2);
      return 0 > b2 ? null : "string" === typeof a2 ? a2.charAt(b2) : a2[b2];
    };
    goog.array.findIndexRight = function(a2, b2, c2) {
      var d2 = a2.length, e2 = "string" === typeof a2 ? a2.split("") : a2;
      for (--d2; 0 <= d2; d2--)
        if (d2 in e2 && b2.call(c2, e2[d2], d2, a2))
          return d2;
      return -1;
    };
    goog.array.contains = function(a2, b2) {
      return 0 <= goog.array.indexOf(a2, b2);
    };
    goog.array.isEmpty = function(a2) {
      return 0 == a2.length;
    };
    goog.array.clear = function(a2) {
      if (!Array.isArray(a2))
        for (var b2 = a2.length - 1; 0 <= b2; b2--)
          delete a2[b2];
      a2.length = 0;
    };
    goog.array.insert = function(a2, b2) {
      goog.array.contains(a2, b2) || a2.push(b2);
    };
    goog.array.insertAt = function(a2, b2, c2) {
      goog.array.splice(a2, c2, 0, b2);
    };
    goog.array.insertArrayAt = function(a2, b2, c2) {
      goog.partial(goog.array.splice, a2, c2, 0).apply(null, b2);
    };
    goog.array.insertBefore = function(a2, b2, c2) {
      var d2;
      2 == arguments.length || 0 > (d2 = goog.array.indexOf(a2, c2)) ? a2.push(b2) : goog.array.insertAt(a2, b2, d2);
    };
    goog.array.remove = function(a2, b2) {
      b2 = goog.array.indexOf(a2, b2);
      var c2;
      (c2 = 0 <= b2) && goog.array.removeAt(a2, b2);
      return c2;
    };
    goog.array.removeLast = function(a2, b2) {
      b2 = goog.array.lastIndexOf(a2, b2);
      return 0 <= b2 ? (goog.array.removeAt(a2, b2), true) : false;
    };
    goog.array.removeAt = function(a2, b2) {
      goog.asserts.assert(null != a2.length);
      return 1 == Array.prototype.splice.call(a2, b2, 1).length;
    };
    goog.array.removeIf = function(a2, b2, c2) {
      b2 = goog.array.findIndex(a2, b2, c2);
      return 0 <= b2 ? (goog.array.removeAt(a2, b2), true) : false;
    };
    goog.array.removeAllIf = function(a2, b2, c2) {
      var d2 = 0;
      goog.array.forEachRight(a2, function(e2, f2) {
        b2.call(c2, e2, f2, a2) && goog.array.removeAt(a2, f2) && d2++;
      });
      return d2;
    };
    goog.array.concat = function(a2) {
      return Array.prototype.concat.apply([], arguments);
    };
    goog.array.join = function(a2) {
      return Array.prototype.concat.apply([], arguments);
    };
    goog.array.toArray = function(a2) {
      var b2 = a2.length;
      if (0 < b2) {
        for (var c2 = Array(b2), d2 = 0; d2 < b2; d2++)
          c2[d2] = a2[d2];
        return c2;
      }
      return [];
    };
    goog.array.clone = goog.array.toArray;
    goog.array.extend = function(a2, b2) {
      for (var c2 = 1; c2 < arguments.length; c2++) {
        var d2 = arguments[c2];
        if (goog.isArrayLike(d2)) {
          var e2 = a2.length || 0, f2 = d2.length || 0;
          a2.length = e2 + f2;
          for (var g = 0; g < f2; g++)
            a2[e2 + g] = d2[g];
        } else
          a2.push(d2);
      }
    };
    goog.array.splice = function(a2, b2, c2, d2) {
      goog.asserts.assert(null != a2.length);
      return Array.prototype.splice.apply(a2, goog.array.slice(arguments, 1));
    };
    goog.array.slice = function(a2, b2, c2) {
      goog.asserts.assert(null != a2.length);
      return 2 >= arguments.length ? Array.prototype.slice.call(a2, b2) : Array.prototype.slice.call(a2, b2, c2);
    };
    goog.array.removeDuplicates = function(a2, b2, c2) {
      b2 = b2 || a2;
      var d2 = function(a3) {
        return goog.isObject(a3) ? "o" + goog.getUid(a3) : (typeof a3).charAt(0) + a3;
      };
      c2 = c2 || d2;
      d2 = {};
      for (var e2 = 0, f2 = 0; f2 < a2.length; ) {
        var g = a2[f2++], h = c2(g);
        Object.prototype.hasOwnProperty.call(d2, h) || (d2[h] = true, b2[e2++] = g);
      }
      b2.length = e2;
    };
    goog.array.binarySearch = function(a2, b2, c2) {
      return goog.array.binarySearch_(a2, c2 || goog.array.defaultCompare, false, b2);
    };
    goog.array.binarySelect = function(a2, b2, c2) {
      return goog.array.binarySearch_(a2, b2, true, void 0, c2);
    };
    goog.array.binarySearch_ = function(a2, b2, c2, d2, e2) {
      for (var f2 = 0, g = a2.length, h; f2 < g; ) {
        var k = f2 + (g - f2 >>> 1);
        var l = c2 ? b2.call(e2, a2[k], k, a2) : b2(d2, a2[k]);
        0 < l ? f2 = k + 1 : (g = k, h = !l);
      }
      return h ? f2 : -f2 - 1;
    };
    goog.array.sort = function(a2, b2) {
      a2.sort(b2 || goog.array.defaultCompare);
    };
    goog.array.stableSort = function(a2, b2) {
      for (var c2 = Array(a2.length), d2 = 0; d2 < a2.length; d2++)
        c2[d2] = { index: d2, value: a2[d2] };
      var e2 = b2 || goog.array.defaultCompare;
      goog.array.sort(c2, function(a3, b3) {
        return e2(a3.value, b3.value) || a3.index - b3.index;
      });
      for (d2 = 0; d2 < a2.length; d2++)
        a2[d2] = c2[d2].value;
    };
    goog.array.sortByKey = function(a2, b2, c2) {
      var d2 = c2 || goog.array.defaultCompare;
      goog.array.sort(a2, function(a3, c3) {
        return d2(b2(a3), b2(c3));
      });
    };
    goog.array.sortObjectsByKey = function(a2, b2, c2) {
      goog.array.sortByKey(a2, function(a3) {
        return a3[b2];
      }, c2);
    };
    goog.array.isSorted = function(a2, b2, c2) {
      b2 = b2 || goog.array.defaultCompare;
      for (var d2 = 1; d2 < a2.length; d2++) {
        var e2 = b2(a2[d2 - 1], a2[d2]);
        if (0 < e2 || 0 == e2 && c2)
          return false;
      }
      return true;
    };
    goog.array.equals = function(a2, b2, c2) {
      if (!goog.isArrayLike(a2) || !goog.isArrayLike(b2) || a2.length != b2.length)
        return false;
      var d2 = a2.length;
      c2 = c2 || goog.array.defaultCompareEquality;
      for (var e2 = 0; e2 < d2; e2++)
        if (!c2(a2[e2], b2[e2]))
          return false;
      return true;
    };
    goog.array.compare3 = function(a2, b2, c2) {
      c2 = c2 || goog.array.defaultCompare;
      for (var d2 = Math.min(a2.length, b2.length), e2 = 0; e2 < d2; e2++) {
        var f2 = c2(a2[e2], b2[e2]);
        if (0 != f2)
          return f2;
      }
      return goog.array.defaultCompare(a2.length, b2.length);
    };
    goog.array.defaultCompare = function(a2, b2) {
      return a2 > b2 ? 1 : a2 < b2 ? -1 : 0;
    };
    goog.array.inverseDefaultCompare = function(a2, b2) {
      return -goog.array.defaultCompare(a2, b2);
    };
    goog.array.defaultCompareEquality = function(a2, b2) {
      return a2 === b2;
    };
    goog.array.binaryInsert = function(a2, b2, c2) {
      c2 = goog.array.binarySearch(a2, b2, c2);
      return 0 > c2 ? (goog.array.insertAt(a2, b2, -(c2 + 1)), true) : false;
    };
    goog.array.binaryRemove = function(a2, b2, c2) {
      b2 = goog.array.binarySearch(a2, b2, c2);
      return 0 <= b2 ? goog.array.removeAt(a2, b2) : false;
    };
    goog.array.bucket = function(a2, b2, c2) {
      for (var d2 = {}, e2 = 0; e2 < a2.length; e2++) {
        var f2 = a2[e2], g = b2.call(c2, f2, e2, a2);
        void 0 !== g && (d2[g] || (d2[g] = [])).push(f2);
      }
      return d2;
    };
    goog.array.toObject = function(a2, b2, c2) {
      var d2 = {};
      goog.array.forEach(a2, function(e2, f2) {
        d2[b2.call(c2, e2, f2, a2)] = e2;
      });
      return d2;
    };
    goog.array.range = function(a2, b2, c2) {
      var d2 = [], e2 = 0, f2 = a2;
      c2 = c2 || 1;
      void 0 !== b2 && (e2 = a2, f2 = b2);
      if (0 > c2 * (f2 - e2))
        return [];
      if (0 < c2)
        for (a2 = e2; a2 < f2; a2 += c2)
          d2.push(a2);
      else
        for (a2 = e2; a2 > f2; a2 += c2)
          d2.push(a2);
      return d2;
    };
    goog.array.repeat = function(a2, b2) {
      for (var c2 = [], d2 = 0; d2 < b2; d2++)
        c2[d2] = a2;
      return c2;
    };
    goog.array.flatten = function(a2) {
      for (var b2 = [], c2 = 0; c2 < arguments.length; c2++) {
        var d2 = arguments[c2];
        if (Array.isArray(d2))
          for (var e2 = 0; e2 < d2.length; e2 += 8192) {
            var f2 = goog.array.slice(d2, e2, e2 + 8192);
            f2 = goog.array.flatten.apply(null, f2);
            for (var g = 0; g < f2.length; g++)
              b2.push(f2[g]);
          }
        else
          b2.push(d2);
      }
      return b2;
    };
    goog.array.rotate = function(a2, b2) {
      goog.asserts.assert(null != a2.length);
      a2.length && (b2 %= a2.length, 0 < b2 ? Array.prototype.unshift.apply(a2, a2.splice(-b2, b2)) : 0 > b2 && Array.prototype.push.apply(a2, a2.splice(0, -b2)));
      return a2;
    };
    goog.array.moveItem = function(a2, b2, c2) {
      goog.asserts.assert(0 <= b2 && b2 < a2.length);
      goog.asserts.assert(0 <= c2 && c2 < a2.length);
      b2 = Array.prototype.splice.call(a2, b2, 1);
      Array.prototype.splice.call(a2, c2, 0, b2[0]);
    };
    goog.array.zip = function(a2) {
      if (!arguments.length)
        return [];
      for (var b2 = [], c2 = arguments[0].length, d2 = 1; d2 < arguments.length; d2++)
        arguments[d2].length < c2 && (c2 = arguments[d2].length);
      for (d2 = 0; d2 < c2; d2++) {
        for (var e2 = [], f2 = 0; f2 < arguments.length; f2++)
          e2.push(arguments[f2][d2]);
        b2.push(e2);
      }
      return b2;
    };
    goog.array.shuffle = function(a2, b2) {
      b2 = b2 || Math.random;
      for (var c2 = a2.length - 1; 0 < c2; c2--) {
        var d2 = Math.floor(b2() * (c2 + 1)), e2 = a2[c2];
        a2[c2] = a2[d2];
        a2[d2] = e2;
      }
    };
    goog.array.copyByIndex = function(a2, b2) {
      var c2 = [];
      goog.array.forEach(b2, function(b3) {
        c2.push(a2[b3]);
      });
      return c2;
    };
    goog.array.concatMap = function(a2, b2, c2) {
      return goog.array.concat.apply([], goog.array.map(a2, b2, c2));
    };
    goog.crypt = {};
    goog.crypt.stringToByteArray = function(a2) {
      for (var b2 = [], c2 = 0, d2 = 0; d2 < a2.length; d2++) {
        var e2 = a2.charCodeAt(d2);
        255 < e2 && (b2[c2++] = e2 & 255, e2 >>= 8);
        b2[c2++] = e2;
      }
      return b2;
    };
    goog.crypt.byteArrayToString = function(a2) {
      if (8192 >= a2.length)
        return String.fromCharCode.apply(null, a2);
      for (var b2 = "", c2 = 0; c2 < a2.length; c2 += 8192) {
        var d2 = goog.array.slice(a2, c2, c2 + 8192);
        b2 += String.fromCharCode.apply(null, d2);
      }
      return b2;
    };
    goog.crypt.byteArrayToHex = function(a2, b2) {
      return goog.array.map(a2, function(a3) {
        a3 = a3.toString(16);
        return 1 < a3.length ? a3 : "0" + a3;
      }).join(b2 || "");
    };
    goog.crypt.hexToByteArray = function(a2) {
      goog.asserts.assert(0 == a2.length % 2, "Key string length must be multiple of 2");
      for (var b2 = [], c2 = 0; c2 < a2.length; c2 += 2)
        b2.push(parseInt(a2.substring(c2, c2 + 2), 16));
      return b2;
    };
    goog.crypt.stringToUtf8ByteArray = function(a2) {
      for (var b2 = [], c2 = 0, d2 = 0; d2 < a2.length; d2++) {
        var e2 = a2.charCodeAt(d2);
        128 > e2 ? b2[c2++] = e2 : (2048 > e2 ? b2[c2++] = e2 >> 6 | 192 : (55296 == (e2 & 64512) && d2 + 1 < a2.length && 56320 == (a2.charCodeAt(d2 + 1) & 64512) ? (e2 = 65536 + ((e2 & 1023) << 10) + (a2.charCodeAt(++d2) & 1023), b2[c2++] = e2 >> 18 | 240, b2[c2++] = e2 >> 12 & 63 | 128) : b2[c2++] = e2 >> 12 | 224, b2[c2++] = e2 >> 6 & 63 | 128), b2[c2++] = e2 & 63 | 128);
      }
      return b2;
    };
    goog.crypt.utf8ByteArrayToString = function(a2) {
      for (var b2 = [], c2 = 0, d2 = 0; c2 < a2.length; ) {
        var e2 = a2[c2++];
        if (128 > e2)
          b2[d2++] = String.fromCharCode(e2);
        else if (191 < e2 && 224 > e2) {
          var f2 = a2[c2++];
          b2[d2++] = String.fromCharCode((e2 & 31) << 6 | f2 & 63);
        } else if (239 < e2 && 365 > e2) {
          f2 = a2[c2++];
          var g = a2[c2++], h = a2[c2++];
          e2 = ((e2 & 7) << 18 | (f2 & 63) << 12 | (g & 63) << 6 | h & 63) - 65536;
          b2[d2++] = String.fromCharCode(55296 + (e2 >> 10));
          b2[d2++] = String.fromCharCode(56320 + (e2 & 1023));
        } else
          f2 = a2[c2++], g = a2[c2++], b2[d2++] = String.fromCharCode((e2 & 15) << 12 | (f2 & 63) << 6 | g & 63);
      }
      return b2.join("");
    };
    goog.crypt.xorByteArray = function(a2, b2) {
      goog.asserts.assert(a2.length == b2.length, "XOR array lengths must match");
      for (var c2 = [], d2 = 0; d2 < a2.length; d2++)
        c2.push(a2[d2] ^ b2[d2]);
      return c2;
    };
    goog.dom.asserts = {};
    goog.dom.asserts.assertIsLocation = function(a2) {
      if (goog.asserts.ENABLE_ASSERTS) {
        var b2 = goog.dom.asserts.getWindow_(a2);
        b2 && (!a2 || !(a2 instanceof b2.Location) && a2 instanceof b2.Element) && goog.asserts.fail("Argument is not a Location (or a non-Element mock); got: %s", goog.dom.asserts.debugStringForType_(a2));
      }
      return a2;
    };
    goog.dom.asserts.assertIsElementType_ = function(a2, b2) {
      if (goog.asserts.ENABLE_ASSERTS) {
        var c2 = goog.dom.asserts.getWindow_(a2);
        c2 && "undefined" != typeof c2[b2] && (a2 && (a2 instanceof c2[b2] || !(a2 instanceof c2.Location || a2 instanceof c2.Element)) || goog.asserts.fail("Argument is not a %s (or a non-Element, non-Location mock); got: %s", b2, goog.dom.asserts.debugStringForType_(a2)));
      }
      return a2;
    };
    goog.dom.asserts.assertIsHTMLAnchorElement = function(a2) {
      return goog.dom.asserts.assertIsElementType_(a2, "HTMLAnchorElement");
    };
    goog.dom.asserts.assertIsHTMLButtonElement = function(a2) {
      return goog.dom.asserts.assertIsElementType_(a2, "HTMLButtonElement");
    };
    goog.dom.asserts.assertIsHTMLLinkElement = function(a2) {
      return goog.dom.asserts.assertIsElementType_(a2, "HTMLLinkElement");
    };
    goog.dom.asserts.assertIsHTMLImageElement = function(a2) {
      return goog.dom.asserts.assertIsElementType_(a2, "HTMLImageElement");
    };
    goog.dom.asserts.assertIsHTMLAudioElement = function(a2) {
      return goog.dom.asserts.assertIsElementType_(a2, "HTMLAudioElement");
    };
    goog.dom.asserts.assertIsHTMLVideoElement = function(a2) {
      return goog.dom.asserts.assertIsElementType_(a2, "HTMLVideoElement");
    };
    goog.dom.asserts.assertIsHTMLInputElement = function(a2) {
      return goog.dom.asserts.assertIsElementType_(a2, "HTMLInputElement");
    };
    goog.dom.asserts.assertIsHTMLTextAreaElement = function(a2) {
      return goog.dom.asserts.assertIsElementType_(a2, "HTMLTextAreaElement");
    };
    goog.dom.asserts.assertIsHTMLCanvasElement = function(a2) {
      return goog.dom.asserts.assertIsElementType_(a2, "HTMLCanvasElement");
    };
    goog.dom.asserts.assertIsHTMLEmbedElement = function(a2) {
      return goog.dom.asserts.assertIsElementType_(a2, "HTMLEmbedElement");
    };
    goog.dom.asserts.assertIsHTMLFormElement = function(a2) {
      return goog.dom.asserts.assertIsElementType_(a2, "HTMLFormElement");
    };
    goog.dom.asserts.assertIsHTMLFrameElement = function(a2) {
      return goog.dom.asserts.assertIsElementType_(a2, "HTMLFrameElement");
    };
    goog.dom.asserts.assertIsHTMLIFrameElement = function(a2) {
      return goog.dom.asserts.assertIsElementType_(a2, "HTMLIFrameElement");
    };
    goog.dom.asserts.assertIsHTMLObjectElement = function(a2) {
      return goog.dom.asserts.assertIsElementType_(a2, "HTMLObjectElement");
    };
    goog.dom.asserts.assertIsHTMLScriptElement = function(a2) {
      return goog.dom.asserts.assertIsElementType_(a2, "HTMLScriptElement");
    };
    goog.dom.asserts.debugStringForType_ = function(a2) {
      if (goog.isObject(a2))
        try {
          return a2.constructor.displayName || a2.constructor.name || Object.prototype.toString.call(a2);
        } catch (b2) {
          return "<object could not be stringified>";
        }
      else
        return void 0 === a2 ? "undefined" : null === a2 ? "null" : typeof a2;
    };
    goog.dom.asserts.getWindow_ = function(a2) {
      try {
        var b2 = a2 && a2.ownerDocument, c2 = b2 && (b2.defaultView || b2.parentWindow);
        c2 = c2 || goog.global;
        if (c2.Element && c2.Location)
          return c2;
      } catch (d2) {
      }
      return null;
    };
    goog.functions = {};
    goog.functions.constant = function(a2) {
      return function() {
        return a2;
      };
    };
    goog.functions.FALSE = function() {
      return false;
    };
    goog.functions.TRUE = function() {
      return true;
    };
    goog.functions.NULL = function() {
      return null;
    };
    goog.functions.identity = function(a2, b2) {
      return a2;
    };
    goog.functions.error = function(a2) {
      return function() {
        throw Error(a2);
      };
    };
    goog.functions.fail = function(a2) {
      return function() {
        throw a2;
      };
    };
    goog.functions.lock = function(a2, b2) {
      b2 = b2 || 0;
      return function() {
        return a2.apply(this, Array.prototype.slice.call(arguments, 0, b2));
      };
    };
    goog.functions.nth = function(a2) {
      return function() {
        return arguments[a2];
      };
    };
    goog.functions.partialRight = function(a2, b2) {
      var c2 = Array.prototype.slice.call(arguments, 1);
      return function() {
        var b3 = Array.prototype.slice.call(arguments);
        b3.push.apply(b3, c2);
        return a2.apply(this, b3);
      };
    };
    goog.functions.withReturnValue = function(a2, b2) {
      return goog.functions.sequence(a2, goog.functions.constant(b2));
    };
    goog.functions.equalTo = function(a2, b2) {
      return function(c2) {
        return b2 ? a2 == c2 : a2 === c2;
      };
    };
    goog.functions.compose = function(a2, b2) {
      var c2 = arguments, d2 = c2.length;
      return function() {
        var a3;
        d2 && (a3 = c2[d2 - 1].apply(this, arguments));
        for (var b3 = d2 - 2; 0 <= b3; b3--)
          a3 = c2[b3].call(this, a3);
        return a3;
      };
    };
    goog.functions.sequence = function(a2) {
      var b2 = arguments, c2 = b2.length;
      return function() {
        for (var a3, e2 = 0; e2 < c2; e2++)
          a3 = b2[e2].apply(this, arguments);
        return a3;
      };
    };
    goog.functions.and = function(a2) {
      var b2 = arguments, c2 = b2.length;
      return function() {
        for (var a3 = 0; a3 < c2; a3++)
          if (!b2[a3].apply(this, arguments))
            return false;
        return true;
      };
    };
    goog.functions.or = function(a2) {
      var b2 = arguments, c2 = b2.length;
      return function() {
        for (var a3 = 0; a3 < c2; a3++)
          if (b2[a3].apply(this, arguments))
            return true;
        return false;
      };
    };
    goog.functions.not = function(a2) {
      return function() {
        return !a2.apply(this, arguments);
      };
    };
    goog.functions.create = function(a2, b2) {
      var c2 = function() {
      };
      c2.prototype = a2.prototype;
      c2 = new c2();
      a2.apply(c2, Array.prototype.slice.call(arguments, 1));
      return c2;
    };
    goog.functions.CACHE_RETURN_VALUE = true;
    goog.functions.cacheReturnValue = function(a2) {
      var b2 = false, c2;
      return function() {
        if (!goog.functions.CACHE_RETURN_VALUE)
          return a2();
        b2 || (c2 = a2(), b2 = true);
        return c2;
      };
    };
    goog.functions.once = function(a2) {
      var b2 = a2;
      return function() {
        if (b2) {
          var a3 = b2;
          b2 = null;
          a3();
        }
      };
    };
    goog.functions.debounce = function(a2, b2, c2) {
      var d2 = 0;
      return function(e2) {
        goog.global.clearTimeout(d2);
        var f2 = arguments;
        d2 = goog.global.setTimeout(function() {
          a2.apply(c2, f2);
        }, b2);
      };
    };
    goog.functions.throttle = function(a2, b2, c2) {
      var d2 = 0, e2 = false, f2 = [], g = function() {
        d2 = 0;
        e2 && (e2 = false, h());
      }, h = function() {
        d2 = goog.global.setTimeout(g, b2);
        a2.apply(c2, f2);
      };
      return function(a3) {
        f2 = arguments;
        d2 ? e2 = true : h();
      };
    };
    goog.functions.rateLimit = function(a2, b2, c2) {
      var d2 = 0, e2 = function() {
        d2 = 0;
      };
      return function(f2) {
        d2 || (d2 = goog.global.setTimeout(e2, b2), a2.apply(c2, arguments));
      };
    };
    goog.dom.HtmlElement = function() {
    };
    goog.dom.TagName = function(a2) {
      this.tagName_ = a2;
    };
    goog.dom.TagName.prototype.toString = function() {
      return this.tagName_;
    };
    goog.dom.TagName.A = new goog.dom.TagName("A");
    goog.dom.TagName.ABBR = new goog.dom.TagName("ABBR");
    goog.dom.TagName.ACRONYM = new goog.dom.TagName("ACRONYM");
    goog.dom.TagName.ADDRESS = new goog.dom.TagName("ADDRESS");
    goog.dom.TagName.APPLET = new goog.dom.TagName("APPLET");
    goog.dom.TagName.AREA = new goog.dom.TagName("AREA");
    goog.dom.TagName.ARTICLE = new goog.dom.TagName("ARTICLE");
    goog.dom.TagName.ASIDE = new goog.dom.TagName("ASIDE");
    goog.dom.TagName.AUDIO = new goog.dom.TagName("AUDIO");
    goog.dom.TagName.B = new goog.dom.TagName("B");
    goog.dom.TagName.BASE = new goog.dom.TagName("BASE");
    goog.dom.TagName.BASEFONT = new goog.dom.TagName("BASEFONT");
    goog.dom.TagName.BDI = new goog.dom.TagName("BDI");
    goog.dom.TagName.BDO = new goog.dom.TagName("BDO");
    goog.dom.TagName.BIG = new goog.dom.TagName("BIG");
    goog.dom.TagName.BLOCKQUOTE = new goog.dom.TagName("BLOCKQUOTE");
    goog.dom.TagName.BODY = new goog.dom.TagName("BODY");
    goog.dom.TagName.BR = new goog.dom.TagName("BR");
    goog.dom.TagName.BUTTON = new goog.dom.TagName("BUTTON");
    goog.dom.TagName.CANVAS = new goog.dom.TagName("CANVAS");
    goog.dom.TagName.CAPTION = new goog.dom.TagName("CAPTION");
    goog.dom.TagName.CENTER = new goog.dom.TagName("CENTER");
    goog.dom.TagName.CITE = new goog.dom.TagName("CITE");
    goog.dom.TagName.CODE = new goog.dom.TagName("CODE");
    goog.dom.TagName.COL = new goog.dom.TagName("COL");
    goog.dom.TagName.COLGROUP = new goog.dom.TagName("COLGROUP");
    goog.dom.TagName.COMMAND = new goog.dom.TagName("COMMAND");
    goog.dom.TagName.DATA = new goog.dom.TagName("DATA");
    goog.dom.TagName.DATALIST = new goog.dom.TagName("DATALIST");
    goog.dom.TagName.DD = new goog.dom.TagName("DD");
    goog.dom.TagName.DEL = new goog.dom.TagName("DEL");
    goog.dom.TagName.DETAILS = new goog.dom.TagName("DETAILS");
    goog.dom.TagName.DFN = new goog.dom.TagName("DFN");
    goog.dom.TagName.DIALOG = new goog.dom.TagName("DIALOG");
    goog.dom.TagName.DIR = new goog.dom.TagName("DIR");
    goog.dom.TagName.DIV = new goog.dom.TagName("DIV");
    goog.dom.TagName.DL = new goog.dom.TagName("DL");
    goog.dom.TagName.DT = new goog.dom.TagName("DT");
    goog.dom.TagName.EM = new goog.dom.TagName("EM");
    goog.dom.TagName.EMBED = new goog.dom.TagName("EMBED");
    goog.dom.TagName.FIELDSET = new goog.dom.TagName("FIELDSET");
    goog.dom.TagName.FIGCAPTION = new goog.dom.TagName("FIGCAPTION");
    goog.dom.TagName.FIGURE = new goog.dom.TagName("FIGURE");
    goog.dom.TagName.FONT = new goog.dom.TagName("FONT");
    goog.dom.TagName.FOOTER = new goog.dom.TagName("FOOTER");
    goog.dom.TagName.FORM = new goog.dom.TagName("FORM");
    goog.dom.TagName.FRAME = new goog.dom.TagName("FRAME");
    goog.dom.TagName.FRAMESET = new goog.dom.TagName("FRAMESET");
    goog.dom.TagName.H1 = new goog.dom.TagName("H1");
    goog.dom.TagName.H2 = new goog.dom.TagName("H2");
    goog.dom.TagName.H3 = new goog.dom.TagName("H3");
    goog.dom.TagName.H4 = new goog.dom.TagName("H4");
    goog.dom.TagName.H5 = new goog.dom.TagName("H5");
    goog.dom.TagName.H6 = new goog.dom.TagName("H6");
    goog.dom.TagName.HEAD = new goog.dom.TagName("HEAD");
    goog.dom.TagName.HEADER = new goog.dom.TagName("HEADER");
    goog.dom.TagName.HGROUP = new goog.dom.TagName("HGROUP");
    goog.dom.TagName.HR = new goog.dom.TagName("HR");
    goog.dom.TagName.HTML = new goog.dom.TagName("HTML");
    goog.dom.TagName.I = new goog.dom.TagName("I");
    goog.dom.TagName.IFRAME = new goog.dom.TagName("IFRAME");
    goog.dom.TagName.IMG = new goog.dom.TagName("IMG");
    goog.dom.TagName.INPUT = new goog.dom.TagName("INPUT");
    goog.dom.TagName.INS = new goog.dom.TagName("INS");
    goog.dom.TagName.ISINDEX = new goog.dom.TagName("ISINDEX");
    goog.dom.TagName.KBD = new goog.dom.TagName("KBD");
    goog.dom.TagName.KEYGEN = new goog.dom.TagName("KEYGEN");
    goog.dom.TagName.LABEL = new goog.dom.TagName("LABEL");
    goog.dom.TagName.LEGEND = new goog.dom.TagName("LEGEND");
    goog.dom.TagName.LI = new goog.dom.TagName("LI");
    goog.dom.TagName.LINK = new goog.dom.TagName("LINK");
    goog.dom.TagName.MAIN = new goog.dom.TagName("MAIN");
    goog.dom.TagName.MAP = new goog.dom.TagName("MAP");
    goog.dom.TagName.MARK = new goog.dom.TagName("MARK");
    goog.dom.TagName.MATH = new goog.dom.TagName("MATH");
    goog.dom.TagName.MENU = new goog.dom.TagName("MENU");
    goog.dom.TagName.MENUITEM = new goog.dom.TagName("MENUITEM");
    goog.dom.TagName.META = new goog.dom.TagName("META");
    goog.dom.TagName.METER = new goog.dom.TagName("METER");
    goog.dom.TagName.NAV = new goog.dom.TagName("NAV");
    goog.dom.TagName.NOFRAMES = new goog.dom.TagName("NOFRAMES");
    goog.dom.TagName.NOSCRIPT = new goog.dom.TagName("NOSCRIPT");
    goog.dom.TagName.OBJECT = new goog.dom.TagName("OBJECT");
    goog.dom.TagName.OL = new goog.dom.TagName("OL");
    goog.dom.TagName.OPTGROUP = new goog.dom.TagName("OPTGROUP");
    goog.dom.TagName.OPTION = new goog.dom.TagName("OPTION");
    goog.dom.TagName.OUTPUT = new goog.dom.TagName("OUTPUT");
    goog.dom.TagName.P = new goog.dom.TagName("P");
    goog.dom.TagName.PARAM = new goog.dom.TagName("PARAM");
    goog.dom.TagName.PICTURE = new goog.dom.TagName("PICTURE");
    goog.dom.TagName.PRE = new goog.dom.TagName("PRE");
    goog.dom.TagName.PROGRESS = new goog.dom.TagName("PROGRESS");
    goog.dom.TagName.Q = new goog.dom.TagName("Q");
    goog.dom.TagName.RP = new goog.dom.TagName("RP");
    goog.dom.TagName.RT = new goog.dom.TagName("RT");
    goog.dom.TagName.RTC = new goog.dom.TagName("RTC");
    goog.dom.TagName.RUBY = new goog.dom.TagName("RUBY");
    goog.dom.TagName.S = new goog.dom.TagName("S");
    goog.dom.TagName.SAMP = new goog.dom.TagName("SAMP");
    goog.dom.TagName.SCRIPT = new goog.dom.TagName("SCRIPT");
    goog.dom.TagName.SECTION = new goog.dom.TagName("SECTION");
    goog.dom.TagName.SELECT = new goog.dom.TagName("SELECT");
    goog.dom.TagName.SMALL = new goog.dom.TagName("SMALL");
    goog.dom.TagName.SOURCE = new goog.dom.TagName("SOURCE");
    goog.dom.TagName.SPAN = new goog.dom.TagName("SPAN");
    goog.dom.TagName.STRIKE = new goog.dom.TagName("STRIKE");
    goog.dom.TagName.STRONG = new goog.dom.TagName("STRONG");
    goog.dom.TagName.STYLE = new goog.dom.TagName("STYLE");
    goog.dom.TagName.SUB = new goog.dom.TagName("SUB");
    goog.dom.TagName.SUMMARY = new goog.dom.TagName("SUMMARY");
    goog.dom.TagName.SUP = new goog.dom.TagName("SUP");
    goog.dom.TagName.SVG = new goog.dom.TagName("SVG");
    goog.dom.TagName.TABLE = new goog.dom.TagName("TABLE");
    goog.dom.TagName.TBODY = new goog.dom.TagName("TBODY");
    goog.dom.TagName.TD = new goog.dom.TagName("TD");
    goog.dom.TagName.TEMPLATE = new goog.dom.TagName("TEMPLATE");
    goog.dom.TagName.TEXTAREA = new goog.dom.TagName("TEXTAREA");
    goog.dom.TagName.TFOOT = new goog.dom.TagName("TFOOT");
    goog.dom.TagName.TH = new goog.dom.TagName("TH");
    goog.dom.TagName.THEAD = new goog.dom.TagName("THEAD");
    goog.dom.TagName.TIME = new goog.dom.TagName("TIME");
    goog.dom.TagName.TITLE = new goog.dom.TagName("TITLE");
    goog.dom.TagName.TR = new goog.dom.TagName("TR");
    goog.dom.TagName.TRACK = new goog.dom.TagName("TRACK");
    goog.dom.TagName.TT = new goog.dom.TagName("TT");
    goog.dom.TagName.U = new goog.dom.TagName("U");
    goog.dom.TagName.UL = new goog.dom.TagName("UL");
    goog.dom.TagName.VAR = new goog.dom.TagName("VAR");
    goog.dom.TagName.VIDEO = new goog.dom.TagName("VIDEO");
    goog.dom.TagName.WBR = new goog.dom.TagName("WBR");
    goog.dom.tags = {};
    goog.dom.tags.VOID_TAGS_ = { area: true, base: true, br: true, col: true, command: true, embed: true, hr: true, img: true, input: true, keygen: true, link: true, meta: true, param: true, source: true, track: true, wbr: true };
    goog.dom.tags.isVoidTag = function(a2) {
      return true === goog.dom.tags.VOID_TAGS_[a2];
    };
    goog.html = {};
    goog.html.trustedtypes = {};
    goog.html.trustedtypes.PRIVATE_DO_NOT_ACCESS_OR_ELSE_POLICY = goog.TRUSTED_TYPES_POLICY_NAME ? goog.createTrustedTypesPolicy(goog.TRUSTED_TYPES_POLICY_NAME + "#html") : null;
    goog.string = {};
    goog.string.TypedString = function() {
    };
    goog.string.Const = function(a2, b2) {
      this.stringConstValueWithSecurityContract__googStringSecurityPrivate_ = a2 === goog.string.Const.GOOG_STRING_CONSTRUCTOR_TOKEN_PRIVATE_ && b2 || "";
      this.STRING_CONST_TYPE_MARKER__GOOG_STRING_SECURITY_PRIVATE_ = goog.string.Const.TYPE_MARKER_;
    };
    goog.string.Const.prototype.implementsGoogStringTypedString = true;
    goog.string.Const.prototype.getTypedStringValue = function() {
      return this.stringConstValueWithSecurityContract__googStringSecurityPrivate_;
    };
    goog.DEBUG && (goog.string.Const.prototype.toString = function() {
      return "Const{" + this.stringConstValueWithSecurityContract__googStringSecurityPrivate_ + "}";
    });
    goog.string.Const.unwrap = function(a2) {
      if (a2 instanceof goog.string.Const && a2.constructor === goog.string.Const && a2.STRING_CONST_TYPE_MARKER__GOOG_STRING_SECURITY_PRIVATE_ === goog.string.Const.TYPE_MARKER_)
        return a2.stringConstValueWithSecurityContract__googStringSecurityPrivate_;
      goog.asserts.fail("expected object of type Const, got '" + a2 + "'");
      return "type_error:Const";
    };
    goog.string.Const.from = function(a2) {
      return new goog.string.Const(goog.string.Const.GOOG_STRING_CONSTRUCTOR_TOKEN_PRIVATE_, a2);
    };
    goog.string.Const.TYPE_MARKER_ = {};
    goog.string.Const.GOOG_STRING_CONSTRUCTOR_TOKEN_PRIVATE_ = {};
    goog.string.Const.EMPTY = goog.string.Const.from("");
    goog.html.SafeScript = function() {
      this.privateDoNotAccessOrElseSafeScriptWrappedValue_ = "";
      this.SAFE_SCRIPT_TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_ = goog.html.SafeScript.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_;
    };
    goog.html.SafeScript.prototype.implementsGoogStringTypedString = true;
    goog.html.SafeScript.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_ = {};
    goog.html.SafeScript.fromConstant = function(a2) {
      a2 = goog.string.Const.unwrap(a2);
      return 0 === a2.length ? goog.html.SafeScript.EMPTY : goog.html.SafeScript.createSafeScriptSecurityPrivateDoNotAccessOrElse(a2);
    };
    goog.html.SafeScript.fromConstantAndArgs = function(a2, b2) {
      for (var c2 = [], d2 = 1; d2 < arguments.length; d2++)
        c2.push(goog.html.SafeScript.stringify_(arguments[d2]));
      return goog.html.SafeScript.createSafeScriptSecurityPrivateDoNotAccessOrElse("(" + goog.string.Const.unwrap(a2) + ")(" + c2.join(", ") + ");");
    };
    goog.html.SafeScript.fromJson = function(a2) {
      return goog.html.SafeScript.createSafeScriptSecurityPrivateDoNotAccessOrElse(goog.html.SafeScript.stringify_(a2));
    };
    goog.html.SafeScript.prototype.getTypedStringValue = function() {
      return this.privateDoNotAccessOrElseSafeScriptWrappedValue_.toString();
    };
    goog.DEBUG && (goog.html.SafeScript.prototype.toString = function() {
      return "SafeScript{" + this.privateDoNotAccessOrElseSafeScriptWrappedValue_ + "}";
    });
    goog.html.SafeScript.unwrap = function(a2) {
      return goog.html.SafeScript.unwrapTrustedScript(a2).toString();
    };
    goog.html.SafeScript.unwrapTrustedScript = function(a2) {
      if (a2 instanceof goog.html.SafeScript && a2.constructor === goog.html.SafeScript && a2.SAFE_SCRIPT_TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_ === goog.html.SafeScript.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_)
        return a2.privateDoNotAccessOrElseSafeScriptWrappedValue_;
      goog.asserts.fail("expected object of type SafeScript, got '" + a2 + "' of type " + goog.typeOf(a2));
      return "type_error:SafeScript";
    };
    goog.html.SafeScript.stringify_ = function(a2) {
      return JSON.stringify(a2).replace(/</g, "\\x3c");
    };
    goog.html.SafeScript.createSafeScriptSecurityPrivateDoNotAccessOrElse = function(a2) {
      return new goog.html.SafeScript().initSecurityPrivateDoNotAccessOrElse_(a2);
    };
    goog.html.SafeScript.prototype.initSecurityPrivateDoNotAccessOrElse_ = function(a2) {
      this.privateDoNotAccessOrElseSafeScriptWrappedValue_ = goog.html.trustedtypes.PRIVATE_DO_NOT_ACCESS_OR_ELSE_POLICY ? goog.html.trustedtypes.PRIVATE_DO_NOT_ACCESS_OR_ELSE_POLICY.createScript(a2) : a2;
      return this;
    };
    goog.html.SafeScript.EMPTY = goog.html.SafeScript.createSafeScriptSecurityPrivateDoNotAccessOrElse("");
    goog.fs = {};
    goog.fs.url = {};
    goog.fs.url.createObjectUrl = function(a2) {
      return goog.fs.url.getUrlObject_().createObjectURL(a2);
    };
    goog.fs.url.revokeObjectUrl = function(a2) {
      goog.fs.url.getUrlObject_().revokeObjectURL(a2);
    };
    goog.fs.url.UrlObject_ = function() {
    };
    goog.fs.url.UrlObject_.prototype.createObjectURL = function(a2) {
    };
    goog.fs.url.UrlObject_.prototype.revokeObjectURL = function(a2) {
    };
    goog.fs.url.getUrlObject_ = function() {
      var a2 = goog.fs.url.findUrlObject_();
      if (null != a2)
        return a2;
      throw Error("This browser doesn't seem to support blob URLs");
    };
    goog.fs.url.findUrlObject_ = function() {
      return void 0 !== goog.global.URL && void 0 !== goog.global.URL.createObjectURL ? goog.global.URL : void 0 !== goog.global.webkitURL && void 0 !== goog.global.webkitURL.createObjectURL ? goog.global.webkitURL : void 0 !== goog.global.createObjectURL ? goog.global : null;
    };
    goog.fs.url.browserSupportsObjectUrls = function() {
      return null != goog.fs.url.findUrlObject_();
    };
    goog.fs.blob = {};
    goog.fs.blob.getBlob = function(a2) {
      var b2 = goog.global.BlobBuilder || goog.global.WebKitBlobBuilder;
      if (void 0 !== b2) {
        b2 = new b2();
        for (var c2 = 0; c2 < arguments.length; c2++)
          b2.append(arguments[c2]);
        return b2.getBlob();
      }
      return goog.fs.blob.getBlobWithProperties(goog.array.toArray(arguments));
    };
    goog.fs.blob.getBlobWithProperties = function(a2, b2, c2) {
      var d2 = goog.global.BlobBuilder || goog.global.WebKitBlobBuilder;
      if (void 0 !== d2) {
        d2 = new d2();
        for (var e2 = 0; e2 < a2.length; e2++)
          d2.append(a2[e2], c2);
        return d2.getBlob(b2);
      }
      if (void 0 !== goog.global.Blob)
        return d2 = {}, b2 && (d2.type = b2), c2 && (d2.endings = c2), new Blob(a2, d2);
      throw Error("This browser doesn't seem to support creating Blobs");
    };
    goog.i18n = {};
    goog.i18n.bidi = {};
    goog.i18n.bidi.FORCE_RTL = false;
    goog.i18n.bidi.IS_RTL = goog.i18n.bidi.FORCE_RTL || ("ar" == goog.LOCALE.substring(0, 2).toLowerCase() || "fa" == goog.LOCALE.substring(0, 2).toLowerCase() || "he" == goog.LOCALE.substring(0, 2).toLowerCase() || "iw" == goog.LOCALE.substring(0, 2).toLowerCase() || "ps" == goog.LOCALE.substring(0, 2).toLowerCase() || "sd" == goog.LOCALE.substring(0, 2).toLowerCase() || "ug" == goog.LOCALE.substring(0, 2).toLowerCase() || "ur" == goog.LOCALE.substring(0, 2).toLowerCase() || "yi" == goog.LOCALE.substring(0, 2).toLowerCase()) && (2 == goog.LOCALE.length || "-" == goog.LOCALE.substring(2, 3) || "_" == goog.LOCALE.substring(2, 3)) || 3 <= goog.LOCALE.length && "ckb" == goog.LOCALE.substring(0, 3).toLowerCase() && (3 == goog.LOCALE.length || "-" == goog.LOCALE.substring(3, 4) || "_" == goog.LOCALE.substring(3, 4)) || 7 <= goog.LOCALE.length && ("-" == goog.LOCALE.substring(2, 3) || "_" == goog.LOCALE.substring(2, 3)) && ("adlm" == goog.LOCALE.substring(3, 7).toLowerCase() || "arab" == goog.LOCALE.substring(3, 7).toLowerCase() || "hebr" == goog.LOCALE.substring(3, 7).toLowerCase() || "nkoo" == goog.LOCALE.substring(
      3,
      7
    ).toLowerCase() || "rohg" == goog.LOCALE.substring(3, 7).toLowerCase() || "thaa" == goog.LOCALE.substring(3, 7).toLowerCase()) || 8 <= goog.LOCALE.length && ("-" == goog.LOCALE.substring(3, 4) || "_" == goog.LOCALE.substring(3, 4)) && ("adlm" == goog.LOCALE.substring(4, 8).toLowerCase() || "arab" == goog.LOCALE.substring(4, 8).toLowerCase() || "hebr" == goog.LOCALE.substring(4, 8).toLowerCase() || "nkoo" == goog.LOCALE.substring(4, 8).toLowerCase() || "rohg" == goog.LOCALE.substring(4, 8).toLowerCase() || "thaa" == goog.LOCALE.substring(4, 8).toLowerCase());
    goog.i18n.bidi.Format = { LRE: "\u202A", RLE: "\u202B", PDF: "\u202C", LRM: "\u200E", RLM: "\u200F" };
    goog.i18n.bidi.Dir = { LTR: 1, RTL: -1, NEUTRAL: 0 };
    goog.i18n.bidi.RIGHT = "right";
    goog.i18n.bidi.LEFT = "left";
    goog.i18n.bidi.I18N_RIGHT = goog.i18n.bidi.IS_RTL ? goog.i18n.bidi.LEFT : goog.i18n.bidi.RIGHT;
    goog.i18n.bidi.I18N_LEFT = goog.i18n.bidi.IS_RTL ? goog.i18n.bidi.RIGHT : goog.i18n.bidi.LEFT;
    goog.i18n.bidi.toDir = function(a2, b2) {
      return "number" == typeof a2 ? 0 < a2 ? goog.i18n.bidi.Dir.LTR : 0 > a2 ? goog.i18n.bidi.Dir.RTL : b2 ? null : goog.i18n.bidi.Dir.NEUTRAL : null == a2 ? null : a2 ? goog.i18n.bidi.Dir.RTL : goog.i18n.bidi.Dir.LTR;
    };
    goog.i18n.bidi.ltrChars_ = "A-Za-z\xC0-\xD6\xD8-\xF6\xF8-\u02B8\u0300-\u0590\u0900-\u1FFF\u200E\u2C00-\uD801\uD804-\uD839\uD83C-\uDBFF\uF900-\uFB1C\uFE00-\uFE6F\uFEFD-\uFFFF";
    goog.i18n.bidi.rtlChars_ = "\u0591-\u06EF\u06FA-\u08FF\u200F\uD802-\uD803\uD83A-\uD83B\uFB1D-\uFDFF\uFE70-\uFEFC";
    goog.i18n.bidi.htmlSkipReg_ = /<[^>]*>|&[^;]+;/g;
    goog.i18n.bidi.stripHtmlIfNeeded_ = function(a2, b2) {
      return b2 ? a2.replace(goog.i18n.bidi.htmlSkipReg_, "") : a2;
    };
    goog.i18n.bidi.rtlCharReg_ = new RegExp("[" + goog.i18n.bidi.rtlChars_ + "]");
    goog.i18n.bidi.ltrCharReg_ = new RegExp("[" + goog.i18n.bidi.ltrChars_ + "]");
    goog.i18n.bidi.hasAnyRtl = function(a2, b2) {
      return goog.i18n.bidi.rtlCharReg_.test(goog.i18n.bidi.stripHtmlIfNeeded_(a2, b2));
    };
    goog.i18n.bidi.hasRtlChar = goog.i18n.bidi.hasAnyRtl;
    goog.i18n.bidi.hasAnyLtr = function(a2, b2) {
      return goog.i18n.bidi.ltrCharReg_.test(goog.i18n.bidi.stripHtmlIfNeeded_(a2, b2));
    };
    goog.i18n.bidi.ltrRe_ = new RegExp("^[" + goog.i18n.bidi.ltrChars_ + "]");
    goog.i18n.bidi.rtlRe_ = new RegExp("^[" + goog.i18n.bidi.rtlChars_ + "]");
    goog.i18n.bidi.isRtlChar = function(a2) {
      return goog.i18n.bidi.rtlRe_.test(a2);
    };
    goog.i18n.bidi.isLtrChar = function(a2) {
      return goog.i18n.bidi.ltrRe_.test(a2);
    };
    goog.i18n.bidi.isNeutralChar = function(a2) {
      return !goog.i18n.bidi.isLtrChar(a2) && !goog.i18n.bidi.isRtlChar(a2);
    };
    goog.i18n.bidi.ltrDirCheckRe_ = new RegExp("^[^" + goog.i18n.bidi.rtlChars_ + "]*[" + goog.i18n.bidi.ltrChars_ + "]");
    goog.i18n.bidi.rtlDirCheckRe_ = new RegExp("^[^" + goog.i18n.bidi.ltrChars_ + "]*[" + goog.i18n.bidi.rtlChars_ + "]");
    goog.i18n.bidi.startsWithRtl = function(a2, b2) {
      return goog.i18n.bidi.rtlDirCheckRe_.test(goog.i18n.bidi.stripHtmlIfNeeded_(a2, b2));
    };
    goog.i18n.bidi.isRtlText = goog.i18n.bidi.startsWithRtl;
    goog.i18n.bidi.startsWithLtr = function(a2, b2) {
      return goog.i18n.bidi.ltrDirCheckRe_.test(goog.i18n.bidi.stripHtmlIfNeeded_(a2, b2));
    };
    goog.i18n.bidi.isLtrText = goog.i18n.bidi.startsWithLtr;
    goog.i18n.bidi.isRequiredLtrRe_ = /^http:\/\/.*/;
    goog.i18n.bidi.isNeutralText = function(a2, b2) {
      a2 = goog.i18n.bidi.stripHtmlIfNeeded_(a2, b2);
      return goog.i18n.bidi.isRequiredLtrRe_.test(a2) || !goog.i18n.bidi.hasAnyLtr(a2) && !goog.i18n.bidi.hasAnyRtl(a2);
    };
    goog.i18n.bidi.ltrExitDirCheckRe_ = new RegExp("[" + goog.i18n.bidi.ltrChars_ + "][^" + goog.i18n.bidi.rtlChars_ + "]*$");
    goog.i18n.bidi.rtlExitDirCheckRe_ = new RegExp("[" + goog.i18n.bidi.rtlChars_ + "][^" + goog.i18n.bidi.ltrChars_ + "]*$");
    goog.i18n.bidi.endsWithLtr = function(a2, b2) {
      return goog.i18n.bidi.ltrExitDirCheckRe_.test(goog.i18n.bidi.stripHtmlIfNeeded_(a2, b2));
    };
    goog.i18n.bidi.isLtrExitText = goog.i18n.bidi.endsWithLtr;
    goog.i18n.bidi.endsWithRtl = function(a2, b2) {
      return goog.i18n.bidi.rtlExitDirCheckRe_.test(goog.i18n.bidi.stripHtmlIfNeeded_(a2, b2));
    };
    goog.i18n.bidi.isRtlExitText = goog.i18n.bidi.endsWithRtl;
    goog.i18n.bidi.rtlLocalesRe_ = /^(ar|ckb|dv|he|iw|fa|nqo|ps|sd|ug|ur|yi|.*[-_](Adlm|Arab|Hebr|Nkoo|Rohg|Thaa))(?!.*[-_](Latn|Cyrl)($|-|_))($|-|_)/i;
    goog.i18n.bidi.isRtlLanguage = function(a2) {
      return goog.i18n.bidi.rtlLocalesRe_.test(a2);
    };
    goog.i18n.bidi.bracketGuardTextRe_ = /(\(.*?\)+)|(\[.*?\]+)|(\{.*?\}+)|(<.*?>+)/g;
    goog.i18n.bidi.guardBracketInText = function(a2, b2) {
      b2 = (void 0 === b2 ? goog.i18n.bidi.hasAnyRtl(a2) : b2) ? goog.i18n.bidi.Format.RLM : goog.i18n.bidi.Format.LRM;
      return a2.replace(goog.i18n.bidi.bracketGuardTextRe_, b2 + "$&" + b2);
    };
    goog.i18n.bidi.enforceRtlInHtml = function(a2) {
      return "<" == a2.charAt(0) ? a2.replace(/<\w+/, "$& dir=rtl") : "\n<span dir=rtl>" + a2 + "</span>";
    };
    goog.i18n.bidi.enforceRtlInText = function(a2) {
      return goog.i18n.bidi.Format.RLE + a2 + goog.i18n.bidi.Format.PDF;
    };
    goog.i18n.bidi.enforceLtrInHtml = function(a2) {
      return "<" == a2.charAt(0) ? a2.replace(/<\w+/, "$& dir=ltr") : "\n<span dir=ltr>" + a2 + "</span>";
    };
    goog.i18n.bidi.enforceLtrInText = function(a2) {
      return goog.i18n.bidi.Format.LRE + a2 + goog.i18n.bidi.Format.PDF;
    };
    goog.i18n.bidi.dimensionsRe_ = /:\s*([.\d][.\w]*)\s+([.\d][.\w]*)\s+([.\d][.\w]*)\s+([.\d][.\w]*)/g;
    goog.i18n.bidi.leftRe_ = /left/gi;
    goog.i18n.bidi.rightRe_ = /right/gi;
    goog.i18n.bidi.tempRe_ = /%%%%/g;
    goog.i18n.bidi.mirrorCSS = function(a2) {
      return a2.replace(goog.i18n.bidi.dimensionsRe_, ":$1 $4 $3 $2").replace(goog.i18n.bidi.leftRe_, "%%%%").replace(goog.i18n.bidi.rightRe_, goog.i18n.bidi.LEFT).replace(goog.i18n.bidi.tempRe_, goog.i18n.bidi.RIGHT);
    };
    goog.i18n.bidi.doubleQuoteSubstituteRe_ = /([\u0591-\u05f2])"/g;
    goog.i18n.bidi.singleQuoteSubstituteRe_ = /([\u0591-\u05f2])'/g;
    goog.i18n.bidi.normalizeHebrewQuote = function(a2) {
      return a2.replace(goog.i18n.bidi.doubleQuoteSubstituteRe_, "$1\u05F4").replace(goog.i18n.bidi.singleQuoteSubstituteRe_, "$1\u05F3");
    };
    goog.i18n.bidi.wordSeparatorRe_ = /\s+/;
    goog.i18n.bidi.hasNumeralsRe_ = /[\d\u06f0-\u06f9]/;
    goog.i18n.bidi.rtlDetectionThreshold_ = 0.4;
    goog.i18n.bidi.estimateDirection = function(a2, b2) {
      var c2 = 0, d2 = 0, e2 = false;
      a2 = goog.i18n.bidi.stripHtmlIfNeeded_(a2, b2).split(goog.i18n.bidi.wordSeparatorRe_);
      for (b2 = 0; b2 < a2.length; b2++) {
        var f2 = a2[b2];
        goog.i18n.bidi.startsWithRtl(f2) ? (c2++, d2++) : goog.i18n.bidi.isRequiredLtrRe_.test(f2) ? e2 = true : goog.i18n.bidi.hasAnyLtr(f2) ? d2++ : goog.i18n.bidi.hasNumeralsRe_.test(f2) && (e2 = true);
      }
      return 0 == d2 ? e2 ? goog.i18n.bidi.Dir.LTR : goog.i18n.bidi.Dir.NEUTRAL : c2 / d2 > goog.i18n.bidi.rtlDetectionThreshold_ ? goog.i18n.bidi.Dir.RTL : goog.i18n.bidi.Dir.LTR;
    };
    goog.i18n.bidi.detectRtlDirectionality = function(a2, b2) {
      return goog.i18n.bidi.estimateDirection(a2, b2) == goog.i18n.bidi.Dir.RTL;
    };
    goog.i18n.bidi.setElementDirAndAlign = function(a2, b2) {
      a2 && (b2 = goog.i18n.bidi.toDir(b2)) && (a2.style.textAlign = b2 == goog.i18n.bidi.Dir.RTL ? goog.i18n.bidi.RIGHT : goog.i18n.bidi.LEFT, a2.dir = b2 == goog.i18n.bidi.Dir.RTL ? "rtl" : "ltr");
    };
    goog.i18n.bidi.setElementDirByTextDirectionality = function(a2, b2) {
      switch (goog.i18n.bidi.estimateDirection(b2)) {
        case goog.i18n.bidi.Dir.LTR:
          a2.dir = "ltr";
          break;
        case goog.i18n.bidi.Dir.RTL:
          a2.dir = "rtl";
          break;
        default:
          a2.removeAttribute("dir");
      }
    };
    goog.i18n.bidi.DirectionalString = function() {
    };
    goog.html.TrustedResourceUrl = function(a2, b2) {
      this.privateDoNotAccessOrElseTrustedResourceUrlWrappedValue_ = a2 === goog.html.TrustedResourceUrl.CONSTRUCTOR_TOKEN_PRIVATE_ && b2 || "";
      this.TRUSTED_RESOURCE_URL_TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_ = goog.html.TrustedResourceUrl.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_;
    };
    goog.html.TrustedResourceUrl.prototype.implementsGoogStringTypedString = true;
    goog.html.TrustedResourceUrl.prototype.getTypedStringValue = function() {
      return this.privateDoNotAccessOrElseTrustedResourceUrlWrappedValue_.toString();
    };
    goog.html.TrustedResourceUrl.prototype.implementsGoogI18nBidiDirectionalString = true;
    goog.html.TrustedResourceUrl.prototype.getDirection = function() {
      return goog.i18n.bidi.Dir.LTR;
    };
    goog.html.TrustedResourceUrl.prototype.cloneWithParams = function(a2, b2) {
      var c2 = goog.html.TrustedResourceUrl.unwrap(this);
      c2 = goog.html.TrustedResourceUrl.URL_PARAM_PARSER_.exec(c2);
      var d2 = c2[3] || "";
      return goog.html.TrustedResourceUrl.createTrustedResourceUrlSecurityPrivateDoNotAccessOrElse(c2[1] + goog.html.TrustedResourceUrl.stringifyParams_("?", c2[2] || "", a2) + goog.html.TrustedResourceUrl.stringifyParams_("#", d2, b2));
    };
    goog.DEBUG && (goog.html.TrustedResourceUrl.prototype.toString = function() {
      return "TrustedResourceUrl{" + this.privateDoNotAccessOrElseTrustedResourceUrlWrappedValue_ + "}";
    });
    goog.html.TrustedResourceUrl.unwrap = function(a2) {
      return goog.html.TrustedResourceUrl.unwrapTrustedScriptURL(a2).toString();
    };
    goog.html.TrustedResourceUrl.unwrapTrustedScriptURL = function(a2) {
      if (a2 instanceof goog.html.TrustedResourceUrl && a2.constructor === goog.html.TrustedResourceUrl && a2.TRUSTED_RESOURCE_URL_TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_ === goog.html.TrustedResourceUrl.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_)
        return a2.privateDoNotAccessOrElseTrustedResourceUrlWrappedValue_;
      goog.asserts.fail("expected object of type TrustedResourceUrl, got '" + a2 + "' of type " + goog.typeOf(a2));
      return "type_error:TrustedResourceUrl";
    };
    goog.html.TrustedResourceUrl.format = function(a2, b2) {
      var c2 = goog.string.Const.unwrap(a2);
      if (!goog.html.TrustedResourceUrl.BASE_URL_.test(c2))
        throw Error("Invalid TrustedResourceUrl format: " + c2);
      a2 = c2.replace(goog.html.TrustedResourceUrl.FORMAT_MARKER_, function(a3, e2) {
        if (!Object.prototype.hasOwnProperty.call(b2, e2))
          throw Error('Found marker, "' + e2 + '", in format string, "' + c2 + '", but no valid label mapping found in args: ' + JSON.stringify(b2));
        a3 = b2[e2];
        return a3 instanceof goog.string.Const ? goog.string.Const.unwrap(a3) : encodeURIComponent(String(a3));
      });
      return goog.html.TrustedResourceUrl.createTrustedResourceUrlSecurityPrivateDoNotAccessOrElse(a2);
    };
    goog.html.TrustedResourceUrl.FORMAT_MARKER_ = /%{(\w+)}/g;
    goog.html.TrustedResourceUrl.BASE_URL_ = /^((https:)?\/\/[0-9a-z.:[\]-]+\/|\/[^/\\]|[^:/\\%]+\/|[^:/\\%]*[?#]|about:blank#)/i;
    goog.html.TrustedResourceUrl.URL_PARAM_PARSER_ = /^([^?#]*)(\?[^#]*)?(#[\s\S]*)?/;
    goog.html.TrustedResourceUrl.formatWithParams = function(a2, b2, c2, d2) {
      return goog.html.TrustedResourceUrl.format(a2, b2).cloneWithParams(c2, d2);
    };
    goog.html.TrustedResourceUrl.fromConstant = function(a2) {
      return goog.html.TrustedResourceUrl.createTrustedResourceUrlSecurityPrivateDoNotAccessOrElse(goog.string.Const.unwrap(a2));
    };
    goog.html.TrustedResourceUrl.fromConstants = function(a2) {
      for (var b2 = "", c2 = 0; c2 < a2.length; c2++)
        b2 += goog.string.Const.unwrap(a2[c2]);
      return goog.html.TrustedResourceUrl.createTrustedResourceUrlSecurityPrivateDoNotAccessOrElse(b2);
    };
    goog.html.TrustedResourceUrl.fromSafeScript = function(a2) {
      a2 = goog.fs.blob.getBlobWithProperties([goog.html.SafeScript.unwrap(a2)], "text/javascript");
      a2 = goog.fs.url.createObjectUrl(a2);
      return goog.html.TrustedResourceUrl.createTrustedResourceUrlSecurityPrivateDoNotAccessOrElse(a2);
    };
    goog.html.TrustedResourceUrl.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_ = {};
    goog.html.TrustedResourceUrl.createTrustedResourceUrlSecurityPrivateDoNotAccessOrElse = function(a2) {
      a2 = goog.html.trustedtypes.PRIVATE_DO_NOT_ACCESS_OR_ELSE_POLICY ? goog.html.trustedtypes.PRIVATE_DO_NOT_ACCESS_OR_ELSE_POLICY.createScriptURL(a2) : a2;
      return new goog.html.TrustedResourceUrl(goog.html.TrustedResourceUrl.CONSTRUCTOR_TOKEN_PRIVATE_, a2);
    };
    goog.html.TrustedResourceUrl.stringifyParams_ = function(a2, b2, c2) {
      if (null == c2)
        return b2;
      if ("string" === typeof c2)
        return c2 ? a2 + encodeURIComponent(c2) : "";
      for (var d2 in c2) {
        var e2 = c2[d2];
        e2 = Array.isArray(e2) ? e2 : [e2];
        for (var f2 = 0; f2 < e2.length; f2++) {
          var g = e2[f2];
          null != g && (b2 || (b2 = a2), b2 += (b2.length > a2.length ? "&" : "") + encodeURIComponent(d2) + "=" + encodeURIComponent(String(g)));
        }
      }
      return b2;
    };
    goog.html.TrustedResourceUrl.CONSTRUCTOR_TOKEN_PRIVATE_ = {};
    goog.string.internal = {};
    goog.string.internal.startsWith = function(a2, b2) {
      return 0 == a2.lastIndexOf(b2, 0);
    };
    goog.string.internal.endsWith = function(a2, b2) {
      var c2 = a2.length - b2.length;
      return 0 <= c2 && a2.indexOf(b2, c2) == c2;
    };
    goog.string.internal.caseInsensitiveStartsWith = function(a2, b2) {
      return 0 == goog.string.internal.caseInsensitiveCompare(b2, a2.substr(0, b2.length));
    };
    goog.string.internal.caseInsensitiveEndsWith = function(a2, b2) {
      return 0 == goog.string.internal.caseInsensitiveCompare(b2, a2.substr(a2.length - b2.length, b2.length));
    };
    goog.string.internal.caseInsensitiveEquals = function(a2, b2) {
      return a2.toLowerCase() == b2.toLowerCase();
    };
    goog.string.internal.isEmptyOrWhitespace = function(a2) {
      return /^[\s\xa0]*$/.test(a2);
    };
    goog.string.internal.trim = goog.TRUSTED_SITE && String.prototype.trim ? function(a2) {
      return a2.trim();
    } : function(a2) {
      return /^[\s\xa0]*([\s\S]*?)[\s\xa0]*$/.exec(a2)[1];
    };
    goog.string.internal.caseInsensitiveCompare = function(a2, b2) {
      a2 = String(a2).toLowerCase();
      b2 = String(b2).toLowerCase();
      return a2 < b2 ? -1 : a2 == b2 ? 0 : 1;
    };
    goog.string.internal.newLineToBr = function(a2, b2) {
      return a2.replace(/(\r\n|\r|\n)/g, b2 ? "<br />" : "<br>");
    };
    goog.string.internal.htmlEscape = function(a2, b2) {
      if (b2)
        a2 = a2.replace(goog.string.internal.AMP_RE_, "&amp;").replace(goog.string.internal.LT_RE_, "&lt;").replace(goog.string.internal.GT_RE_, "&gt;").replace(goog.string.internal.QUOT_RE_, "&quot;").replace(goog.string.internal.SINGLE_QUOTE_RE_, "&#39;").replace(goog.string.internal.NULL_RE_, "&#0;");
      else {
        if (!goog.string.internal.ALL_RE_.test(a2))
          return a2;
        -1 != a2.indexOf("&") && (a2 = a2.replace(goog.string.internal.AMP_RE_, "&amp;"));
        -1 != a2.indexOf("<") && (a2 = a2.replace(
          goog.string.internal.LT_RE_,
          "&lt;"
        ));
        -1 != a2.indexOf(">") && (a2 = a2.replace(goog.string.internal.GT_RE_, "&gt;"));
        -1 != a2.indexOf('"') && (a2 = a2.replace(goog.string.internal.QUOT_RE_, "&quot;"));
        -1 != a2.indexOf("'") && (a2 = a2.replace(goog.string.internal.SINGLE_QUOTE_RE_, "&#39;"));
        -1 != a2.indexOf("\0") && (a2 = a2.replace(goog.string.internal.NULL_RE_, "&#0;"));
      }
      return a2;
    };
    goog.string.internal.AMP_RE_ = /&/g;
    goog.string.internal.LT_RE_ = /</g;
    goog.string.internal.GT_RE_ = />/g;
    goog.string.internal.QUOT_RE_ = /"/g;
    goog.string.internal.SINGLE_QUOTE_RE_ = /'/g;
    goog.string.internal.NULL_RE_ = /\x00/g;
    goog.string.internal.ALL_RE_ = /[\x00&<>"']/;
    goog.string.internal.whitespaceEscape = function(a2, b2) {
      return goog.string.internal.newLineToBr(a2.replace(/  /g, " &#160;"), b2);
    };
    goog.string.internal.contains = function(a2, b2) {
      return -1 != a2.indexOf(b2);
    };
    goog.string.internal.caseInsensitiveContains = function(a2, b2) {
      return goog.string.internal.contains(a2.toLowerCase(), b2.toLowerCase());
    };
    goog.string.internal.compareVersions = function(a2, b2) {
      var c2 = 0;
      a2 = goog.string.internal.trim(String(a2)).split(".");
      b2 = goog.string.internal.trim(String(b2)).split(".");
      for (var d2 = Math.max(a2.length, b2.length), e2 = 0; 0 == c2 && e2 < d2; e2++) {
        var f2 = a2[e2] || "", g = b2[e2] || "";
        do {
          f2 = /(\d*)(\D*)(.*)/.exec(f2) || ["", "", "", ""];
          g = /(\d*)(\D*)(.*)/.exec(g) || ["", "", "", ""];
          if (0 == f2[0].length && 0 == g[0].length)
            break;
          c2 = 0 == f2[1].length ? 0 : parseInt(f2[1], 10);
          var h = 0 == g[1].length ? 0 : parseInt(g[1], 10);
          c2 = goog.string.internal.compareElements_(c2, h) || goog.string.internal.compareElements_(0 == f2[2].length, 0 == g[2].length) || goog.string.internal.compareElements_(f2[2], g[2]);
          f2 = f2[3];
          g = g[3];
        } while (0 == c2);
      }
      return c2;
    };
    goog.string.internal.compareElements_ = function(a2, b2) {
      return a2 < b2 ? -1 : a2 > b2 ? 1 : 0;
    };
    goog.html.SafeUrl = function(a2, b2) {
      this.privateDoNotAccessOrElseSafeUrlWrappedValue_ = a2 === goog.html.SafeUrl.CONSTRUCTOR_TOKEN_PRIVATE_ && b2 || "";
      this.SAFE_URL_TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_ = goog.html.SafeUrl.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_;
    };
    goog.html.SafeUrl.INNOCUOUS_STRING = "about:invalid#zClosurez";
    goog.html.SafeUrl.prototype.implementsGoogStringTypedString = true;
    goog.html.SafeUrl.prototype.getTypedStringValue = function() {
      return this.privateDoNotAccessOrElseSafeUrlWrappedValue_.toString();
    };
    goog.html.SafeUrl.prototype.implementsGoogI18nBidiDirectionalString = true;
    goog.html.SafeUrl.prototype.getDirection = function() {
      return goog.i18n.bidi.Dir.LTR;
    };
    goog.DEBUG && (goog.html.SafeUrl.prototype.toString = function() {
      return "SafeUrl{" + this.privateDoNotAccessOrElseSafeUrlWrappedValue_ + "}";
    });
    goog.html.SafeUrl.unwrap = function(a2) {
      if (a2 instanceof goog.html.SafeUrl && a2.constructor === goog.html.SafeUrl && a2.SAFE_URL_TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_ === goog.html.SafeUrl.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_)
        return a2.privateDoNotAccessOrElseSafeUrlWrappedValue_;
      goog.asserts.fail("expected object of type SafeUrl, got '" + a2 + "' of type " + goog.typeOf(a2));
      return "type_error:SafeUrl";
    };
    goog.html.SafeUrl.fromConstant = function(a2) {
      return goog.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse(goog.string.Const.unwrap(a2));
    };
    goog.html.SAFE_MIME_TYPE_PATTERN_ = /^(?:audio\/(?:3gpp2|3gpp|aac|L16|midi|mp3|mp4|mpeg|oga|ogg|opus|x-m4a|x-matroska|x-wav|wav|webm)|image\/(?:bmp|gif|jpeg|jpg|png|tiff|webp|x-icon)|text\/csv|video\/(?:mpeg|mp4|ogg|webm|quicktime|x-matroska))(?:;\w+=(?:\w+|"[\w;,= ]+"))*$/i;
    goog.html.SafeUrl.isSafeMimeType = function(a2) {
      return goog.html.SAFE_MIME_TYPE_PATTERN_.test(a2);
    };
    goog.html.SafeUrl.fromBlob = function(a2) {
      a2 = goog.html.SafeUrl.isSafeMimeType(a2.type) ? goog.fs.url.createObjectUrl(a2) : goog.html.SafeUrl.INNOCUOUS_STRING;
      return goog.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse(a2);
    };
    goog.html.SafeUrl.fromMediaSource = function(a2) {
      goog.asserts.assert("MediaSource" in goog.global, "No support for MediaSource");
      a2 = a2 instanceof MediaSource ? goog.fs.url.createObjectUrl(a2) : goog.html.SafeUrl.INNOCUOUS_STRING;
      return goog.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse(a2);
    };
    goog.html.DATA_URL_PATTERN_ = /^data:(.*);base64,[a-z0-9+\/]+=*$/i;
    goog.html.SafeUrl.fromDataUrl = function(a2) {
      a2 = a2.replace(/(%0A|%0D)/g, "");
      var b2 = a2.match(goog.html.DATA_URL_PATTERN_);
      b2 = b2 && goog.html.SafeUrl.isSafeMimeType(b2[1]);
      return goog.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse(b2 ? a2 : goog.html.SafeUrl.INNOCUOUS_STRING);
    };
    goog.html.SafeUrl.fromTelUrl = function(a2) {
      goog.string.internal.caseInsensitiveStartsWith(a2, "tel:") || (a2 = goog.html.SafeUrl.INNOCUOUS_STRING);
      return goog.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse(a2);
    };
    goog.html.SIP_URL_PATTERN_ = /^sip[s]?:[+a-z0-9_.!$%&'*\/=^`{|}~-]+@([a-z0-9-]+\.)+[a-z0-9]{2,63}$/i;
    goog.html.SafeUrl.fromSipUrl = function(a2) {
      goog.html.SIP_URL_PATTERN_.test(decodeURIComponent(a2)) || (a2 = goog.html.SafeUrl.INNOCUOUS_STRING);
      return goog.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse(a2);
    };
    goog.html.SafeUrl.fromFacebookMessengerUrl = function(a2) {
      goog.string.internal.caseInsensitiveStartsWith(a2, "fb-messenger://share") || (a2 = goog.html.SafeUrl.INNOCUOUS_STRING);
      return goog.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse(a2);
    };
    goog.html.SafeUrl.fromWhatsAppUrl = function(a2) {
      goog.string.internal.caseInsensitiveStartsWith(a2, "whatsapp://send") || (a2 = goog.html.SafeUrl.INNOCUOUS_STRING);
      return goog.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse(a2);
    };
    goog.html.SafeUrl.fromSmsUrl = function(a2) {
      goog.string.internal.caseInsensitiveStartsWith(a2, "sms:") && goog.html.SafeUrl.isSmsUrlBodyValid_(a2) || (a2 = goog.html.SafeUrl.INNOCUOUS_STRING);
      return goog.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse(a2);
    };
    goog.html.SafeUrl.isSmsUrlBodyValid_ = function(a2) {
      var b2 = a2.indexOf("#");
      0 < b2 && (a2 = a2.substring(0, b2));
      b2 = a2.match(/[?&]body=/gi);
      if (!b2)
        return true;
      if (1 < b2.length)
        return false;
      a2 = a2.match(/[?&]body=([^&]*)/)[1];
      if (!a2)
        return true;
      try {
        decodeURIComponent(a2);
      } catch (c2) {
        return false;
      }
      return /^(?:[a-z0-9\-_.~]|%[0-9a-f]{2})+$/i.test(a2);
    };
    goog.html.SafeUrl.fromSshUrl = function(a2) {
      goog.string.internal.caseInsensitiveStartsWith(a2, "ssh://") || (a2 = goog.html.SafeUrl.INNOCUOUS_STRING);
      return goog.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse(a2);
    };
    goog.html.SafeUrl.sanitizeChromeExtensionUrl = function(a2, b2) {
      return goog.html.SafeUrl.sanitizeExtensionUrl_(/^chrome-extension:\/\/([^\/]+)\//, a2, b2);
    };
    goog.html.SafeUrl.sanitizeFirefoxExtensionUrl = function(a2, b2) {
      return goog.html.SafeUrl.sanitizeExtensionUrl_(/^moz-extension:\/\/([^\/]+)\//, a2, b2);
    };
    goog.html.SafeUrl.sanitizeEdgeExtensionUrl = function(a2, b2) {
      return goog.html.SafeUrl.sanitizeExtensionUrl_(/^ms-browser-extension:\/\/([^\/]+)\//, a2, b2);
    };
    goog.html.SafeUrl.sanitizeExtensionUrl_ = function(a2, b2, c2) {
      (a2 = a2.exec(b2)) ? (a2 = a2[1], -1 == (c2 instanceof goog.string.Const ? [goog.string.Const.unwrap(c2)] : c2.map(function(a3) {
        return goog.string.Const.unwrap(a3);
      })).indexOf(a2) && (b2 = goog.html.SafeUrl.INNOCUOUS_STRING)) : b2 = goog.html.SafeUrl.INNOCUOUS_STRING;
      return goog.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse(b2);
    };
    goog.html.SafeUrl.fromTrustedResourceUrl = function(a2) {
      return goog.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse(goog.html.TrustedResourceUrl.unwrap(a2));
    };
    goog.html.SAFE_URL_PATTERN_ = /^(?:(?:https?|mailto|ftp):|[^:/?#]*(?:[/?#]|$))/i;
    goog.html.SafeUrl.SAFE_URL_PATTERN = goog.html.SAFE_URL_PATTERN_;
    goog.html.SafeUrl.sanitize = function(a2) {
      if (a2 instanceof goog.html.SafeUrl)
        return a2;
      a2 = "object" == typeof a2 && a2.implementsGoogStringTypedString ? a2.getTypedStringValue() : String(a2);
      goog.html.SAFE_URL_PATTERN_.test(a2) || (a2 = goog.html.SafeUrl.INNOCUOUS_STRING);
      return goog.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse(a2);
    };
    goog.html.SafeUrl.sanitizeAssertUnchanged = function(a2, b2) {
      if (a2 instanceof goog.html.SafeUrl)
        return a2;
      a2 = "object" == typeof a2 && a2.implementsGoogStringTypedString ? a2.getTypedStringValue() : String(a2);
      if (b2 && /^data:/i.test(a2) && (b2 = goog.html.SafeUrl.fromDataUrl(a2), b2.getTypedStringValue() == a2))
        return b2;
      goog.asserts.assert(goog.html.SAFE_URL_PATTERN_.test(a2), "%s does not match the safe URL pattern", a2) || (a2 = goog.html.SafeUrl.INNOCUOUS_STRING);
      return goog.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse(a2);
    };
    goog.html.SafeUrl.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_ = {};
    goog.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse = function(a2) {
      return new goog.html.SafeUrl(goog.html.SafeUrl.CONSTRUCTOR_TOKEN_PRIVATE_, a2);
    };
    goog.html.SafeUrl.ABOUT_BLANK = goog.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse("about:blank");
    goog.html.SafeUrl.CONSTRUCTOR_TOKEN_PRIVATE_ = {};
    goog.html.SafeStyle = function() {
      this.privateDoNotAccessOrElseSafeStyleWrappedValue_ = "";
      this.SAFE_STYLE_TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_ = goog.html.SafeStyle.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_;
    };
    goog.html.SafeStyle.prototype.implementsGoogStringTypedString = true;
    goog.html.SafeStyle.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_ = {};
    goog.html.SafeStyle.fromConstant = function(a2) {
      a2 = goog.string.Const.unwrap(a2);
      if (0 === a2.length)
        return goog.html.SafeStyle.EMPTY;
      goog.asserts.assert(goog.string.internal.endsWith(a2, ";"), "Last character of style string is not ';': " + a2);
      goog.asserts.assert(goog.string.internal.contains(a2, ":"), `Style string must contain at least one ':', to specify a "name: value" pair: ` + a2);
      return goog.html.SafeStyle.createSafeStyleSecurityPrivateDoNotAccessOrElse(a2);
    };
    goog.html.SafeStyle.prototype.getTypedStringValue = function() {
      return this.privateDoNotAccessOrElseSafeStyleWrappedValue_;
    };
    goog.DEBUG && (goog.html.SafeStyle.prototype.toString = function() {
      return "SafeStyle{" + this.privateDoNotAccessOrElseSafeStyleWrappedValue_ + "}";
    });
    goog.html.SafeStyle.unwrap = function(a2) {
      if (a2 instanceof goog.html.SafeStyle && a2.constructor === goog.html.SafeStyle && a2.SAFE_STYLE_TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_ === goog.html.SafeStyle.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_)
        return a2.privateDoNotAccessOrElseSafeStyleWrappedValue_;
      goog.asserts.fail("expected object of type SafeStyle, got '" + a2 + "' of type " + goog.typeOf(a2));
      return "type_error:SafeStyle";
    };
    goog.html.SafeStyle.createSafeStyleSecurityPrivateDoNotAccessOrElse = function(a2) {
      return new goog.html.SafeStyle().initSecurityPrivateDoNotAccessOrElse_(a2);
    };
    goog.html.SafeStyle.prototype.initSecurityPrivateDoNotAccessOrElse_ = function(a2) {
      this.privateDoNotAccessOrElseSafeStyleWrappedValue_ = a2;
      return this;
    };
    goog.html.SafeStyle.EMPTY = goog.html.SafeStyle.createSafeStyleSecurityPrivateDoNotAccessOrElse("");
    goog.html.SafeStyle.INNOCUOUS_STRING = "zClosurez";
    goog.html.SafeStyle.create = function(a2) {
      var b2 = "", c2;
      for (c2 in a2) {
        if (!/^[-_a-zA-Z0-9]+$/.test(c2))
          throw Error("Name allows only [-_a-zA-Z0-9], got: " + c2);
        var d2 = a2[c2];
        null != d2 && (d2 = Array.isArray(d2) ? goog.array.map(d2, goog.html.SafeStyle.sanitizePropertyValue_).join(" ") : goog.html.SafeStyle.sanitizePropertyValue_(d2), b2 += c2 + ":" + d2 + ";");
      }
      return b2 ? goog.html.SafeStyle.createSafeStyleSecurityPrivateDoNotAccessOrElse(b2) : goog.html.SafeStyle.EMPTY;
    };
    goog.html.SafeStyle.sanitizePropertyValue_ = function(a2) {
      if (a2 instanceof goog.html.SafeUrl)
        return 'url("' + goog.html.SafeUrl.unwrap(a2).replace(/</g, "%3c").replace(/[\\"]/g, "\\$&") + '")';
      a2 = a2 instanceof goog.string.Const ? goog.string.Const.unwrap(a2) : goog.html.SafeStyle.sanitizePropertyValueString_(String(a2));
      if (/[{;}]/.test(a2))
        throw new goog.asserts.AssertionError("Value does not allow [{;}], got: %s.", [a2]);
      return a2;
    };
    goog.html.SafeStyle.sanitizePropertyValueString_ = function(a2) {
      var b2 = a2.replace(goog.html.SafeStyle.FUNCTIONS_RE_, "$1").replace(goog.html.SafeStyle.FUNCTIONS_RE_, "$1").replace(goog.html.SafeStyle.URL_RE_, "url");
      if (goog.html.SafeStyle.VALUE_RE_.test(b2)) {
        if (goog.html.SafeStyle.COMMENT_RE_.test(a2))
          return goog.asserts.fail("String value disallows comments, got: " + a2), goog.html.SafeStyle.INNOCUOUS_STRING;
        if (!goog.html.SafeStyle.hasBalancedQuotes_(a2))
          return goog.asserts.fail("String value requires balanced quotes, got: " + a2), goog.html.SafeStyle.INNOCUOUS_STRING;
        if (!goog.html.SafeStyle.hasBalancedSquareBrackets_(a2))
          return goog.asserts.fail("String value requires balanced square brackets and one identifier per pair of brackets, got: " + a2), goog.html.SafeStyle.INNOCUOUS_STRING;
      } else
        return goog.asserts.fail("String value allows only " + goog.html.SafeStyle.VALUE_ALLOWED_CHARS_ + " and simple functions, got: " + a2), goog.html.SafeStyle.INNOCUOUS_STRING;
      return goog.html.SafeStyle.sanitizeUrl_(a2);
    };
    goog.html.SafeStyle.hasBalancedQuotes_ = function(a2) {
      for (var b2 = true, c2 = true, d2 = 0; d2 < a2.length; d2++) {
        var e2 = a2.charAt(d2);
        "'" == e2 && c2 ? b2 = !b2 : '"' == e2 && b2 && (c2 = !c2);
      }
      return b2 && c2;
    };
    goog.html.SafeStyle.hasBalancedSquareBrackets_ = function(a2) {
      for (var b2 = true, c2 = /^[-_a-zA-Z0-9]$/, d2 = 0; d2 < a2.length; d2++) {
        var e2 = a2.charAt(d2);
        if ("]" == e2) {
          if (b2)
            return false;
          b2 = true;
        } else if ("[" == e2) {
          if (!b2)
            return false;
          b2 = false;
        } else if (!b2 && !c2.test(e2))
          return false;
      }
      return b2;
    };
    goog.html.SafeStyle.VALUE_ALLOWED_CHARS_ = `[-,."'%_!# a-zA-Z0-9\\[\\]]`;
    goog.html.SafeStyle.VALUE_RE_ = new RegExp("^" + goog.html.SafeStyle.VALUE_ALLOWED_CHARS_ + "+$");
    goog.html.SafeStyle.URL_RE_ = /\b(url\([ \t\n]*)('[ -&(-\[\]-~]*'|"[ !#-\[\]-~]*"|[!#-&*-\[\]-~]*)([ \t\n]*\))/g;
    goog.html.SafeStyle.ALLOWED_FUNCTIONS_ = "calc cubic-bezier fit-content hsl hsla linear-gradient matrix minmax repeat rgb rgba (rotate|scale|translate)(X|Y|Z|3d)?".split(" ");
    goog.html.SafeStyle.FUNCTIONS_RE_ = new RegExp("\\b(" + goog.html.SafeStyle.ALLOWED_FUNCTIONS_.join("|") + ")\\([-+*/0-9a-z.%\\[\\], ]+\\)", "g");
    goog.html.SafeStyle.COMMENT_RE_ = /\/\*/;
    goog.html.SafeStyle.sanitizeUrl_ = function(a2) {
      return a2.replace(goog.html.SafeStyle.URL_RE_, function(a3, c2, d2, e2) {
        var b2 = "";
        d2 = d2.replace(/^(['"])(.*)\1$/, function(a4, c3, d3) {
          b2 = c3;
          return d3;
        });
        a3 = goog.html.SafeUrl.sanitize(d2).getTypedStringValue();
        return c2 + b2 + a3 + b2 + e2;
      });
    };
    goog.html.SafeStyle.concat = function(a2) {
      var b2 = "", c2 = function(a3) {
        Array.isArray(a3) ? goog.array.forEach(a3, c2) : b2 += goog.html.SafeStyle.unwrap(a3);
      };
      goog.array.forEach(arguments, c2);
      return b2 ? goog.html.SafeStyle.createSafeStyleSecurityPrivateDoNotAccessOrElse(b2) : goog.html.SafeStyle.EMPTY;
    };
    goog.html.SafeStyleSheet = function() {
      this.privateDoNotAccessOrElseSafeStyleSheetWrappedValue_ = "";
      this.SAFE_STYLE_SHEET_TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_ = goog.html.SafeStyleSheet.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_;
    };
    goog.html.SafeStyleSheet.prototype.implementsGoogStringTypedString = true;
    goog.html.SafeStyleSheet.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_ = {};
    goog.html.SafeStyleSheet.createRule = function(a2, b2) {
      if (goog.string.internal.contains(a2, "<"))
        throw Error("Selector does not allow '<', got: " + a2);
      var c2 = a2.replace(/('|")((?!\1)[^\r\n\f\\]|\\[\s\S])*\1/g, "");
      if (!/^[-_a-zA-Z0-9#.:* ,>+~[\]()=^$|]+$/.test(c2))
        throw Error("Selector allows only [-_a-zA-Z0-9#.:* ,>+~[\\]()=^$|] and strings, got: " + a2);
      if (!goog.html.SafeStyleSheet.hasBalancedBrackets_(c2))
        throw Error("() and [] in selector must be balanced, got: " + a2);
      b2 instanceof goog.html.SafeStyle || (b2 = goog.html.SafeStyle.create(b2));
      a2 = a2 + "{" + goog.html.SafeStyle.unwrap(b2).replace(/</g, "\\3C ") + "}";
      return goog.html.SafeStyleSheet.createSafeStyleSheetSecurityPrivateDoNotAccessOrElse(a2);
    };
    goog.html.SafeStyleSheet.hasBalancedBrackets_ = function(a2) {
      for (var b2 = { "(": ")", "[": "]" }, c2 = [], d2 = 0; d2 < a2.length; d2++) {
        var e2 = a2[d2];
        if (b2[e2])
          c2.push(b2[e2]);
        else if (goog.object.contains(b2, e2) && c2.pop() != e2)
          return false;
      }
      return 0 == c2.length;
    };
    goog.html.SafeStyleSheet.concat = function(a2) {
      var b2 = "", c2 = function(a3) {
        Array.isArray(a3) ? goog.array.forEach(a3, c2) : b2 += goog.html.SafeStyleSheet.unwrap(a3);
      };
      goog.array.forEach(arguments, c2);
      return goog.html.SafeStyleSheet.createSafeStyleSheetSecurityPrivateDoNotAccessOrElse(b2);
    };
    goog.html.SafeStyleSheet.fromConstant = function(a2) {
      a2 = goog.string.Const.unwrap(a2);
      if (0 === a2.length)
        return goog.html.SafeStyleSheet.EMPTY;
      goog.asserts.assert(!goog.string.internal.contains(a2, "<"), "Forbidden '<' character in style sheet string: " + a2);
      return goog.html.SafeStyleSheet.createSafeStyleSheetSecurityPrivateDoNotAccessOrElse(a2);
    };
    goog.html.SafeStyleSheet.prototype.getTypedStringValue = function() {
      return this.privateDoNotAccessOrElseSafeStyleSheetWrappedValue_;
    };
    goog.DEBUG && (goog.html.SafeStyleSheet.prototype.toString = function() {
      return "SafeStyleSheet{" + this.privateDoNotAccessOrElseSafeStyleSheetWrappedValue_ + "}";
    });
    goog.html.SafeStyleSheet.unwrap = function(a2) {
      if (a2 instanceof goog.html.SafeStyleSheet && a2.constructor === goog.html.SafeStyleSheet && a2.SAFE_STYLE_SHEET_TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_ === goog.html.SafeStyleSheet.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_)
        return a2.privateDoNotAccessOrElseSafeStyleSheetWrappedValue_;
      goog.asserts.fail("expected object of type SafeStyleSheet, got '" + a2 + "' of type " + goog.typeOf(a2));
      return "type_error:SafeStyleSheet";
    };
    goog.html.SafeStyleSheet.createSafeStyleSheetSecurityPrivateDoNotAccessOrElse = function(a2) {
      return new goog.html.SafeStyleSheet().initSecurityPrivateDoNotAccessOrElse_(a2);
    };
    goog.html.SafeStyleSheet.prototype.initSecurityPrivateDoNotAccessOrElse_ = function(a2) {
      this.privateDoNotAccessOrElseSafeStyleSheetWrappedValue_ = a2;
      return this;
    };
    goog.html.SafeStyleSheet.EMPTY = goog.html.SafeStyleSheet.createSafeStyleSheetSecurityPrivateDoNotAccessOrElse("");
    goog.labs = {};
    goog.labs.userAgent = {};
    goog.labs.userAgent.util = {};
    goog.labs.userAgent.util.getNativeUserAgentString_ = function() {
      var a2 = goog.labs.userAgent.util.getNavigator_();
      return a2 && (a2 = a2.userAgent) ? a2 : "";
    };
    goog.labs.userAgent.util.getNavigator_ = function() {
      return goog.global.navigator;
    };
    goog.labs.userAgent.util.userAgent_ = goog.labs.userAgent.util.getNativeUserAgentString_();
    goog.labs.userAgent.util.setUserAgent = function(a2) {
      goog.labs.userAgent.util.userAgent_ = a2 || goog.labs.userAgent.util.getNativeUserAgentString_();
    };
    goog.labs.userAgent.util.getUserAgent = function() {
      return goog.labs.userAgent.util.userAgent_;
    };
    goog.labs.userAgent.util.matchUserAgent = function(a2) {
      var b2 = goog.labs.userAgent.util.getUserAgent();
      return goog.string.internal.contains(b2, a2);
    };
    goog.labs.userAgent.util.matchUserAgentIgnoreCase = function(a2) {
      var b2 = goog.labs.userAgent.util.getUserAgent();
      return goog.string.internal.caseInsensitiveContains(b2, a2);
    };
    goog.labs.userAgent.util.extractVersionTuples = function(a2) {
      for (var b2 = /(\w[\w ]+)\/([^\s]+)\s*(?:\((.*?)\))?/g, c2 = [], d2; d2 = b2.exec(a2); )
        c2.push([d2[1], d2[2], d2[3] || void 0]);
      return c2;
    };
    goog.labs.userAgent.browser = {};
    goog.labs.userAgent.browser.matchOpera_ = function() {
      return goog.labs.userAgent.util.matchUserAgent("Opera");
    };
    goog.labs.userAgent.browser.matchIE_ = function() {
      return goog.labs.userAgent.util.matchUserAgent("Trident") || goog.labs.userAgent.util.matchUserAgent("MSIE");
    };
    goog.labs.userAgent.browser.matchEdgeHtml_ = function() {
      return goog.labs.userAgent.util.matchUserAgent("Edge");
    };
    goog.labs.userAgent.browser.matchEdgeChromium_ = function() {
      return goog.labs.userAgent.util.matchUserAgent("Edg/");
    };
    goog.labs.userAgent.browser.matchOperaChromium_ = function() {
      return goog.labs.userAgent.util.matchUserAgent("OPR");
    };
    goog.labs.userAgent.browser.matchFirefox_ = function() {
      return goog.labs.userAgent.util.matchUserAgent("Firefox") || goog.labs.userAgent.util.matchUserAgent("FxiOS");
    };
    goog.labs.userAgent.browser.matchSafari_ = function() {
      return goog.labs.userAgent.util.matchUserAgent("Safari") && !(goog.labs.userAgent.browser.matchChrome_() || goog.labs.userAgent.browser.matchCoast_() || goog.labs.userAgent.browser.matchOpera_() || goog.labs.userAgent.browser.matchEdgeHtml_() || goog.labs.userAgent.browser.matchEdgeChromium_() || goog.labs.userAgent.browser.matchOperaChromium_() || goog.labs.userAgent.browser.matchFirefox_() || goog.labs.userAgent.browser.isSilk() || goog.labs.userAgent.util.matchUserAgent("Android"));
    };
    goog.labs.userAgent.browser.matchCoast_ = function() {
      return goog.labs.userAgent.util.matchUserAgent("Coast");
    };
    goog.labs.userAgent.browser.matchIosWebview_ = function() {
      return (goog.labs.userAgent.util.matchUserAgent("iPad") || goog.labs.userAgent.util.matchUserAgent("iPhone")) && !goog.labs.userAgent.browser.matchSafari_() && !goog.labs.userAgent.browser.matchChrome_() && !goog.labs.userAgent.browser.matchCoast_() && !goog.labs.userAgent.browser.matchFirefox_() && goog.labs.userAgent.util.matchUserAgent("AppleWebKit");
    };
    goog.labs.userAgent.browser.matchChrome_ = function() {
      return (goog.labs.userAgent.util.matchUserAgent("Chrome") || goog.labs.userAgent.util.matchUserAgent("CriOS")) && !goog.labs.userAgent.browser.matchEdgeHtml_();
    };
    goog.labs.userAgent.browser.matchAndroidBrowser_ = function() {
      return goog.labs.userAgent.util.matchUserAgent("Android") && !(goog.labs.userAgent.browser.isChrome() || goog.labs.userAgent.browser.isFirefox() || goog.labs.userAgent.browser.isOpera() || goog.labs.userAgent.browser.isSilk());
    };
    goog.labs.userAgent.browser.isOpera = goog.labs.userAgent.browser.matchOpera_;
    goog.labs.userAgent.browser.isIE = goog.labs.userAgent.browser.matchIE_;
    goog.labs.userAgent.browser.isEdge = goog.labs.userAgent.browser.matchEdgeHtml_;
    goog.labs.userAgent.browser.isEdgeChromium = goog.labs.userAgent.browser.matchEdgeChromium_;
    goog.labs.userAgent.browser.isOperaChromium = goog.labs.userAgent.browser.matchOperaChromium_;
    goog.labs.userAgent.browser.isFirefox = goog.labs.userAgent.browser.matchFirefox_;
    goog.labs.userAgent.browser.isSafari = goog.labs.userAgent.browser.matchSafari_;
    goog.labs.userAgent.browser.isCoast = goog.labs.userAgent.browser.matchCoast_;
    goog.labs.userAgent.browser.isIosWebview = goog.labs.userAgent.browser.matchIosWebview_;
    goog.labs.userAgent.browser.isChrome = goog.labs.userAgent.browser.matchChrome_;
    goog.labs.userAgent.browser.isAndroidBrowser = goog.labs.userAgent.browser.matchAndroidBrowser_;
    goog.labs.userAgent.browser.isSilk = function() {
      return goog.labs.userAgent.util.matchUserAgent("Silk");
    };
    goog.labs.userAgent.browser.getVersion = function() {
      function a2(a3) {
        a3 = goog.array.find(a3, d2);
        return c2[a3] || "";
      }
      var b2 = goog.labs.userAgent.util.getUserAgent();
      if (goog.labs.userAgent.browser.isIE())
        return goog.labs.userAgent.browser.getIEVersion_(b2);
      b2 = goog.labs.userAgent.util.extractVersionTuples(b2);
      var c2 = {};
      goog.array.forEach(b2, function(a3) {
        c2[a3[0]] = a3[1];
      });
      var d2 = goog.partial(goog.object.containsKey, c2);
      return goog.labs.userAgent.browser.isOpera() ? a2(["Version", "Opera"]) : goog.labs.userAgent.browser.isEdge() ? a2(["Edge"]) : goog.labs.userAgent.browser.isEdgeChromium() ? a2(["Edg"]) : goog.labs.userAgent.browser.isChrome() ? a2(["Chrome", "CriOS", "HeadlessChrome"]) : (b2 = b2[2]) && b2[1] || "";
    };
    goog.labs.userAgent.browser.isVersionOrHigher = function(a2) {
      return 0 <= goog.string.internal.compareVersions(goog.labs.userAgent.browser.getVersion(), a2);
    };
    goog.labs.userAgent.browser.getIEVersion_ = function(a2) {
      var b2 = /rv: *([\d\.]*)/.exec(a2);
      if (b2 && b2[1])
        return b2[1];
      b2 = "";
      var c2 = /MSIE +([\d\.]+)/.exec(a2);
      if (c2 && c2[1])
        if (a2 = /Trident\/(\d.\d)/.exec(a2), "7.0" == c2[1])
          if (a2 && a2[1])
            switch (a2[1]) {
              case "4.0":
                b2 = "8.0";
                break;
              case "5.0":
                b2 = "9.0";
                break;
              case "6.0":
                b2 = "10.0";
                break;
              case "7.0":
                b2 = "11.0";
            }
          else
            b2 = "7.0";
        else
          b2 = c2[1];
      return b2;
    };
    goog.html.SafeHtml = function() {
      this.privateDoNotAccessOrElseSafeHtmlWrappedValue_ = "";
      this.SAFE_HTML_TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_ = goog.html.SafeHtml.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_;
      this.dir_ = null;
    };
    goog.html.SafeHtml.ENABLE_ERROR_MESSAGES = goog.DEBUG;
    goog.html.SafeHtml.SUPPORT_STYLE_ATTRIBUTE = true;
    goog.html.SafeHtml.prototype.implementsGoogI18nBidiDirectionalString = true;
    goog.html.SafeHtml.prototype.getDirection = function() {
      return this.dir_;
    };
    goog.html.SafeHtml.prototype.implementsGoogStringTypedString = true;
    goog.html.SafeHtml.prototype.getTypedStringValue = function() {
      return this.privateDoNotAccessOrElseSafeHtmlWrappedValue_.toString();
    };
    goog.DEBUG && (goog.html.SafeHtml.prototype.toString = function() {
      return "SafeHtml{" + this.privateDoNotAccessOrElseSafeHtmlWrappedValue_ + "}";
    });
    goog.html.SafeHtml.unwrap = function(a2) {
      return goog.html.SafeHtml.unwrapTrustedHTML(a2).toString();
    };
    goog.html.SafeHtml.unwrapTrustedHTML = function(a2) {
      if (a2 instanceof goog.html.SafeHtml && a2.constructor === goog.html.SafeHtml && a2.SAFE_HTML_TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_ === goog.html.SafeHtml.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_)
        return a2.privateDoNotAccessOrElseSafeHtmlWrappedValue_;
      goog.asserts.fail("expected object of type SafeHtml, got '" + a2 + "' of type " + goog.typeOf(a2));
      return "type_error:SafeHtml";
    };
    goog.html.SafeHtml.htmlEscape = function(a2) {
      if (a2 instanceof goog.html.SafeHtml)
        return a2;
      var b2 = "object" == typeof a2, c2 = null;
      b2 && a2.implementsGoogI18nBidiDirectionalString && (c2 = a2.getDirection());
      a2 = b2 && a2.implementsGoogStringTypedString ? a2.getTypedStringValue() : String(a2);
      return goog.html.SafeHtml.createSafeHtmlSecurityPrivateDoNotAccessOrElse(goog.string.internal.htmlEscape(a2), c2);
    };
    goog.html.SafeHtml.htmlEscapePreservingNewlines = function(a2) {
      if (a2 instanceof goog.html.SafeHtml)
        return a2;
      a2 = goog.html.SafeHtml.htmlEscape(a2);
      return goog.html.SafeHtml.createSafeHtmlSecurityPrivateDoNotAccessOrElse(goog.string.internal.newLineToBr(goog.html.SafeHtml.unwrap(a2)), a2.getDirection());
    };
    goog.html.SafeHtml.htmlEscapePreservingNewlinesAndSpaces = function(a2) {
      if (a2 instanceof goog.html.SafeHtml)
        return a2;
      a2 = goog.html.SafeHtml.htmlEscape(a2);
      return goog.html.SafeHtml.createSafeHtmlSecurityPrivateDoNotAccessOrElse(goog.string.internal.whitespaceEscape(goog.html.SafeHtml.unwrap(a2)), a2.getDirection());
    };
    goog.html.SafeHtml.from = goog.html.SafeHtml.htmlEscape;
    goog.html.SafeHtml.comment = function(a2) {
      return goog.html.SafeHtml.createSafeHtmlSecurityPrivateDoNotAccessOrElse("<!--" + goog.string.internal.htmlEscape(a2) + "-->", null);
    };
    goog.html.SafeHtml.VALID_NAMES_IN_TAG_ = /^[a-zA-Z0-9-]+$/;
    goog.html.SafeHtml.URL_ATTRIBUTES_ = { action: true, cite: true, data: true, formaction: true, href: true, manifest: true, poster: true, src: true };
    goog.html.SafeHtml.NOT_ALLOWED_TAG_NAMES_ = { APPLET: true, BASE: true, EMBED: true, IFRAME: true, LINK: true, MATH: true, META: true, OBJECT: true, SCRIPT: true, STYLE: true, SVG: true, TEMPLATE: true };
    goog.html.SafeHtml.create = function(a2, b2, c2) {
      goog.html.SafeHtml.verifyTagName(String(a2));
      return goog.html.SafeHtml.createSafeHtmlTagSecurityPrivateDoNotAccessOrElse(String(a2), b2, c2);
    };
    goog.html.SafeHtml.verifyTagName = function(a2) {
      if (!goog.html.SafeHtml.VALID_NAMES_IN_TAG_.test(a2))
        throw Error(goog.html.SafeHtml.ENABLE_ERROR_MESSAGES ? "Invalid tag name <" + a2 + ">." : "");
      if (a2.toUpperCase() in goog.html.SafeHtml.NOT_ALLOWED_TAG_NAMES_)
        throw Error(goog.html.SafeHtml.ENABLE_ERROR_MESSAGES ? "Tag name <" + a2 + "> is not allowed for SafeHtml." : "");
    };
    goog.html.SafeHtml.createIframe = function(a2, b2, c2, d2) {
      a2 && goog.html.TrustedResourceUrl.unwrap(a2);
      var e2 = {};
      e2.src = a2 || null;
      e2.srcdoc = b2 && goog.html.SafeHtml.unwrap(b2);
      a2 = goog.html.SafeHtml.combineAttributes(e2, { sandbox: "" }, c2);
      return goog.html.SafeHtml.createSafeHtmlTagSecurityPrivateDoNotAccessOrElse("iframe", a2, d2);
    };
    goog.html.SafeHtml.createSandboxIframe = function(a2, b2, c2, d2) {
      if (!goog.html.SafeHtml.canUseSandboxIframe())
        throw Error(goog.html.SafeHtml.ENABLE_ERROR_MESSAGES ? "The browser does not support sandboxed iframes." : "");
      var e2 = {};
      e2.src = a2 ? goog.html.SafeUrl.unwrap(goog.html.SafeUrl.sanitize(a2)) : null;
      e2.srcdoc = b2 || null;
      e2.sandbox = "";
      a2 = goog.html.SafeHtml.combineAttributes(e2, {}, c2);
      return goog.html.SafeHtml.createSafeHtmlTagSecurityPrivateDoNotAccessOrElse("iframe", a2, d2);
    };
    goog.html.SafeHtml.canUseSandboxIframe = function() {
      return goog.global.HTMLIFrameElement && "sandbox" in goog.global.HTMLIFrameElement.prototype;
    };
    goog.html.SafeHtml.createScriptSrc = function(a2, b2) {
      goog.html.TrustedResourceUrl.unwrap(a2);
      a2 = goog.html.SafeHtml.combineAttributes({ src: a2 }, {}, b2);
      return goog.html.SafeHtml.createSafeHtmlTagSecurityPrivateDoNotAccessOrElse("script", a2);
    };
    goog.html.SafeHtml.createScript = function(a2, b2) {
      for (var c2 in b2) {
        var d2 = c2.toLowerCase();
        if ("language" == d2 || "src" == d2 || "text" == d2 || "type" == d2)
          throw Error(goog.html.SafeHtml.ENABLE_ERROR_MESSAGES ? 'Cannot set "' + d2 + '" attribute' : "");
      }
      c2 = "";
      a2 = goog.array.concat(a2);
      for (d2 = 0; d2 < a2.length; d2++)
        c2 += goog.html.SafeScript.unwrap(a2[d2]);
      a2 = goog.html.SafeHtml.createSafeHtmlSecurityPrivateDoNotAccessOrElse(c2, goog.i18n.bidi.Dir.NEUTRAL);
      return goog.html.SafeHtml.createSafeHtmlTagSecurityPrivateDoNotAccessOrElse("script", b2, a2);
    };
    goog.html.SafeHtml.createStyle = function(a2, b2) {
      b2 = goog.html.SafeHtml.combineAttributes({ type: "text/css" }, {}, b2);
      var c2 = "";
      a2 = goog.array.concat(a2);
      for (var d2 = 0; d2 < a2.length; d2++)
        c2 += goog.html.SafeStyleSheet.unwrap(a2[d2]);
      a2 = goog.html.SafeHtml.createSafeHtmlSecurityPrivateDoNotAccessOrElse(c2, goog.i18n.bidi.Dir.NEUTRAL);
      return goog.html.SafeHtml.createSafeHtmlTagSecurityPrivateDoNotAccessOrElse("style", b2, a2);
    };
    goog.html.SafeHtml.createMetaRefresh = function(a2, b2) {
      a2 = goog.html.SafeUrl.unwrap(goog.html.SafeUrl.sanitize(a2));
      (goog.labs.userAgent.browser.isIE() || goog.labs.userAgent.browser.isEdge()) && goog.string.internal.contains(a2, ";") && (a2 = "'" + a2.replace(/'/g, "%27") + "'");
      return goog.html.SafeHtml.createSafeHtmlTagSecurityPrivateDoNotAccessOrElse("meta", { "http-equiv": "refresh", content: (b2 || 0) + "; url=" + a2 });
    };
    goog.html.SafeHtml.getAttrNameAndValue_ = function(a2, b2, c2) {
      if (c2 instanceof goog.string.Const)
        c2 = goog.string.Const.unwrap(c2);
      else if ("style" == b2.toLowerCase())
        if (goog.html.SafeHtml.SUPPORT_STYLE_ATTRIBUTE)
          c2 = goog.html.SafeHtml.getStyleValue_(c2);
        else
          throw Error(goog.html.SafeHtml.ENABLE_ERROR_MESSAGES ? 'Attribute "style" not supported.' : "");
      else {
        if (/^on/i.test(b2))
          throw Error(goog.html.SafeHtml.ENABLE_ERROR_MESSAGES ? 'Attribute "' + b2 + '" requires goog.string.Const value, "' + c2 + '" given.' : "");
        if (b2.toLowerCase() in goog.html.SafeHtml.URL_ATTRIBUTES_)
          if (c2 instanceof goog.html.TrustedResourceUrl)
            c2 = goog.html.TrustedResourceUrl.unwrap(c2);
          else if (c2 instanceof goog.html.SafeUrl)
            c2 = goog.html.SafeUrl.unwrap(c2);
          else if ("string" === typeof c2)
            c2 = goog.html.SafeUrl.sanitize(c2).getTypedStringValue();
          else
            throw Error(goog.html.SafeHtml.ENABLE_ERROR_MESSAGES ? 'Attribute "' + b2 + '" on tag "' + a2 + '" requires goog.html.SafeUrl, goog.string.Const, or string, value "' + c2 + '" given.' : "");
      }
      c2.implementsGoogStringTypedString && (c2 = c2.getTypedStringValue());
      goog.asserts.assert("string" === typeof c2 || "number" === typeof c2, "String or number value expected, got " + typeof c2 + " with value: " + c2);
      return b2 + '="' + goog.string.internal.htmlEscape(String(c2)) + '"';
    };
    goog.html.SafeHtml.getStyleValue_ = function(a2) {
      if (!goog.isObject(a2))
        throw Error(goog.html.SafeHtml.ENABLE_ERROR_MESSAGES ? 'The "style" attribute requires goog.html.SafeStyle or map of style properties, ' + typeof a2 + " given: " + a2 : "");
      a2 instanceof goog.html.SafeStyle || (a2 = goog.html.SafeStyle.create(a2));
      return goog.html.SafeStyle.unwrap(a2);
    };
    goog.html.SafeHtml.createWithDir = function(a2, b2, c2, d2) {
      b2 = goog.html.SafeHtml.create(b2, c2, d2);
      b2.dir_ = a2;
      return b2;
    };
    goog.html.SafeHtml.join = function(a2, b2) {
      a2 = goog.html.SafeHtml.htmlEscape(a2);
      var c2 = a2.getDirection(), d2 = [], e2 = function(a3) {
        Array.isArray(a3) ? goog.array.forEach(a3, e2) : (a3 = goog.html.SafeHtml.htmlEscape(a3), d2.push(goog.html.SafeHtml.unwrap(a3)), a3 = a3.getDirection(), c2 == goog.i18n.bidi.Dir.NEUTRAL ? c2 = a3 : a3 != goog.i18n.bidi.Dir.NEUTRAL && c2 != a3 && (c2 = null));
      };
      goog.array.forEach(b2, e2);
      return goog.html.SafeHtml.createSafeHtmlSecurityPrivateDoNotAccessOrElse(d2.join(goog.html.SafeHtml.unwrap(a2)), c2);
    };
    goog.html.SafeHtml.concat = function(a2) {
      return goog.html.SafeHtml.join(goog.html.SafeHtml.EMPTY, Array.prototype.slice.call(arguments));
    };
    goog.html.SafeHtml.concatWithDir = function(a2, b2) {
      var c2 = goog.html.SafeHtml.concat(goog.array.slice(arguments, 1));
      c2.dir_ = a2;
      return c2;
    };
    goog.html.SafeHtml.TYPE_MARKER_GOOG_HTML_SECURITY_PRIVATE_ = {};
    goog.html.SafeHtml.createSafeHtmlSecurityPrivateDoNotAccessOrElse = function(a2, b2) {
      return new goog.html.SafeHtml().initSecurityPrivateDoNotAccessOrElse_(a2, b2);
    };
    goog.html.SafeHtml.prototype.initSecurityPrivateDoNotAccessOrElse_ = function(a2, b2) {
      this.privateDoNotAccessOrElseSafeHtmlWrappedValue_ = goog.html.trustedtypes.PRIVATE_DO_NOT_ACCESS_OR_ELSE_POLICY ? goog.html.trustedtypes.PRIVATE_DO_NOT_ACCESS_OR_ELSE_POLICY.createHTML(a2) : a2;
      this.dir_ = b2;
      return this;
    };
    goog.html.SafeHtml.createSafeHtmlTagSecurityPrivateDoNotAccessOrElse = function(a2, b2, c2) {
      var d2 = null;
      var e2 = "<" + a2 + goog.html.SafeHtml.stringifyAttributes(a2, b2);
      null == c2 ? c2 = [] : Array.isArray(c2) || (c2 = [c2]);
      goog.dom.tags.isVoidTag(a2.toLowerCase()) ? (goog.asserts.assert(!c2.length, "Void tag <" + a2 + "> does not allow content."), e2 += ">") : (d2 = goog.html.SafeHtml.concat(c2), e2 += ">" + goog.html.SafeHtml.unwrap(d2) + "</" + a2 + ">", d2 = d2.getDirection());
      (a2 = b2 && b2.dir) && (d2 = /^(ltr|rtl|auto)$/i.test(a2) ? goog.i18n.bidi.Dir.NEUTRAL : null);
      return goog.html.SafeHtml.createSafeHtmlSecurityPrivateDoNotAccessOrElse(
        e2,
        d2
      );
    };
    goog.html.SafeHtml.stringifyAttributes = function(a2, b2) {
      var c2 = "";
      if (b2)
        for (var d2 in b2) {
          if (!goog.html.SafeHtml.VALID_NAMES_IN_TAG_.test(d2))
            throw Error(goog.html.SafeHtml.ENABLE_ERROR_MESSAGES ? 'Invalid attribute name "' + d2 + '".' : "");
          var e2 = b2[d2];
          null != e2 && (c2 += " " + goog.html.SafeHtml.getAttrNameAndValue_(a2, d2, e2));
        }
      return c2;
    };
    goog.html.SafeHtml.combineAttributes = function(a2, b2, c2) {
      var d2 = {}, e2;
      for (e2 in a2)
        goog.asserts.assert(e2.toLowerCase() == e2, "Must be lower case"), d2[e2] = a2[e2];
      for (e2 in b2)
        goog.asserts.assert(e2.toLowerCase() == e2, "Must be lower case"), d2[e2] = b2[e2];
      if (c2)
        for (e2 in c2) {
          var f2 = e2.toLowerCase();
          if (f2 in a2)
            throw Error(goog.html.SafeHtml.ENABLE_ERROR_MESSAGES ? 'Cannot override "' + f2 + '" attribute, got "' + e2 + '" with value "' + c2[e2] + '"' : "");
          f2 in b2 && delete d2[f2];
          d2[e2] = c2[e2];
        }
      return d2;
    };
    goog.html.SafeHtml.DOCTYPE_HTML = goog.html.SafeHtml.createSafeHtmlSecurityPrivateDoNotAccessOrElse("<!DOCTYPE html>", goog.i18n.bidi.Dir.NEUTRAL);
    goog.html.SafeHtml.EMPTY = goog.html.SafeHtml.createSafeHtmlSecurityPrivateDoNotAccessOrElse("", goog.i18n.bidi.Dir.NEUTRAL);
    goog.html.SafeHtml.BR = goog.html.SafeHtml.createSafeHtmlSecurityPrivateDoNotAccessOrElse("<br>", goog.i18n.bidi.Dir.NEUTRAL);
    goog.html.uncheckedconversions = {};
    goog.html.uncheckedconversions.safeHtmlFromStringKnownToSatisfyTypeContract = function(a2, b2, c2) {
      goog.asserts.assertString(goog.string.Const.unwrap(a2), "must provide justification");
      goog.asserts.assert(!goog.string.internal.isEmptyOrWhitespace(goog.string.Const.unwrap(a2)), "must provide non-empty justification");
      return goog.html.SafeHtml.createSafeHtmlSecurityPrivateDoNotAccessOrElse(b2, c2 || null);
    };
    goog.html.uncheckedconversions.safeScriptFromStringKnownToSatisfyTypeContract = function(a2, b2) {
      goog.asserts.assertString(goog.string.Const.unwrap(a2), "must provide justification");
      goog.asserts.assert(!goog.string.internal.isEmptyOrWhitespace(goog.string.Const.unwrap(a2)), "must provide non-empty justification");
      return goog.html.SafeScript.createSafeScriptSecurityPrivateDoNotAccessOrElse(b2);
    };
    goog.html.uncheckedconversions.safeStyleFromStringKnownToSatisfyTypeContract = function(a2, b2) {
      goog.asserts.assertString(goog.string.Const.unwrap(a2), "must provide justification");
      goog.asserts.assert(!goog.string.internal.isEmptyOrWhitespace(goog.string.Const.unwrap(a2)), "must provide non-empty justification");
      return goog.html.SafeStyle.createSafeStyleSecurityPrivateDoNotAccessOrElse(b2);
    };
    goog.html.uncheckedconversions.safeStyleSheetFromStringKnownToSatisfyTypeContract = function(a2, b2) {
      goog.asserts.assertString(goog.string.Const.unwrap(a2), "must provide justification");
      goog.asserts.assert(!goog.string.internal.isEmptyOrWhitespace(goog.string.Const.unwrap(a2)), "must provide non-empty justification");
      return goog.html.SafeStyleSheet.createSafeStyleSheetSecurityPrivateDoNotAccessOrElse(b2);
    };
    goog.html.uncheckedconversions.safeUrlFromStringKnownToSatisfyTypeContract = function(a2, b2) {
      goog.asserts.assertString(goog.string.Const.unwrap(a2), "must provide justification");
      goog.asserts.assert(!goog.string.internal.isEmptyOrWhitespace(goog.string.Const.unwrap(a2)), "must provide non-empty justification");
      return goog.html.SafeUrl.createSafeUrlSecurityPrivateDoNotAccessOrElse(b2);
    };
    goog.html.uncheckedconversions.trustedResourceUrlFromStringKnownToSatisfyTypeContract = function(a2, b2) {
      goog.asserts.assertString(goog.string.Const.unwrap(a2), "must provide justification");
      goog.asserts.assert(!goog.string.internal.isEmptyOrWhitespace(goog.string.Const.unwrap(a2)), "must provide non-empty justification");
      return goog.html.TrustedResourceUrl.createTrustedResourceUrlSecurityPrivateDoNotAccessOrElse(b2);
    };
    goog.dom.safe = {};
    goog.dom.safe.InsertAdjacentHtmlPosition = { AFTERBEGIN: "afterbegin", AFTEREND: "afterend", BEFOREBEGIN: "beforebegin", BEFOREEND: "beforeend" };
    goog.dom.safe.insertAdjacentHtml = function(a2, b2, c2) {
      a2.insertAdjacentHTML(b2, goog.html.SafeHtml.unwrapTrustedHTML(c2));
    };
    goog.dom.safe.SET_INNER_HTML_DISALLOWED_TAGS_ = { MATH: true, SCRIPT: true, STYLE: true, SVG: true, TEMPLATE: true };
    goog.dom.safe.isInnerHtmlCleanupRecursive_ = goog.functions.cacheReturnValue(function() {
      if (goog.DEBUG && "undefined" === typeof document)
        return false;
      var a2 = document.createElement("div"), b2 = document.createElement("div");
      b2.appendChild(document.createElement("div"));
      a2.appendChild(b2);
      if (goog.DEBUG && !a2.firstChild)
        return false;
      b2 = a2.firstChild.firstChild;
      a2.innerHTML = goog.html.SafeHtml.unwrapTrustedHTML(goog.html.SafeHtml.EMPTY);
      return !b2.parentElement;
    });
    goog.dom.safe.unsafeSetInnerHtmlDoNotUseOrElse = function(a2, b2) {
      if (goog.dom.safe.isInnerHtmlCleanupRecursive_())
        for (; a2.lastChild; )
          a2.removeChild(a2.lastChild);
      a2.innerHTML = goog.html.SafeHtml.unwrapTrustedHTML(b2);
    };
    goog.dom.safe.setInnerHtml = function(a2, b2) {
      if (goog.asserts.ENABLE_ASSERTS) {
        var c2 = a2.tagName.toUpperCase();
        if (goog.dom.safe.SET_INNER_HTML_DISALLOWED_TAGS_[c2])
          throw Error("goog.dom.safe.setInnerHtml cannot be used to set content of " + a2.tagName + ".");
      }
      goog.dom.safe.unsafeSetInnerHtmlDoNotUseOrElse(a2, b2);
    };
    goog.dom.safe.setOuterHtml = function(a2, b2) {
      a2.outerHTML = goog.html.SafeHtml.unwrapTrustedHTML(b2);
    };
    goog.dom.safe.setFormElementAction = function(a2, b2) {
      b2 = b2 instanceof goog.html.SafeUrl ? b2 : goog.html.SafeUrl.sanitizeAssertUnchanged(b2);
      goog.dom.asserts.assertIsHTMLFormElement(a2).action = goog.html.SafeUrl.unwrap(b2);
    };
    goog.dom.safe.setButtonFormAction = function(a2, b2) {
      b2 = b2 instanceof goog.html.SafeUrl ? b2 : goog.html.SafeUrl.sanitizeAssertUnchanged(b2);
      goog.dom.asserts.assertIsHTMLButtonElement(a2).formAction = goog.html.SafeUrl.unwrap(b2);
    };
    goog.dom.safe.setInputFormAction = function(a2, b2) {
      b2 = b2 instanceof goog.html.SafeUrl ? b2 : goog.html.SafeUrl.sanitizeAssertUnchanged(b2);
      goog.dom.asserts.assertIsHTMLInputElement(a2).formAction = goog.html.SafeUrl.unwrap(b2);
    };
    goog.dom.safe.setStyle = function(a2, b2) {
      a2.style.cssText = goog.html.SafeStyle.unwrap(b2);
    };
    goog.dom.safe.documentWrite = function(a2, b2) {
      a2.write(goog.html.SafeHtml.unwrapTrustedHTML(b2));
    };
    goog.dom.safe.setAnchorHref = function(a2, b2) {
      goog.dom.asserts.assertIsHTMLAnchorElement(a2);
      b2 = b2 instanceof goog.html.SafeUrl ? b2 : goog.html.SafeUrl.sanitizeAssertUnchanged(b2);
      a2.href = goog.html.SafeUrl.unwrap(b2);
    };
    goog.dom.safe.setImageSrc = function(a2, b2) {
      goog.dom.asserts.assertIsHTMLImageElement(a2);
      if (!(b2 instanceof goog.html.SafeUrl)) {
        var c2 = /^data:image\//i.test(b2);
        b2 = goog.html.SafeUrl.sanitizeAssertUnchanged(b2, c2);
      }
      a2.src = goog.html.SafeUrl.unwrap(b2);
    };
    goog.dom.safe.setAudioSrc = function(a2, b2) {
      goog.dom.asserts.assertIsHTMLAudioElement(a2);
      if (!(b2 instanceof goog.html.SafeUrl)) {
        var c2 = /^data:audio\//i.test(b2);
        b2 = goog.html.SafeUrl.sanitizeAssertUnchanged(b2, c2);
      }
      a2.src = goog.html.SafeUrl.unwrap(b2);
    };
    goog.dom.safe.setVideoSrc = function(a2, b2) {
      goog.dom.asserts.assertIsHTMLVideoElement(a2);
      if (!(b2 instanceof goog.html.SafeUrl)) {
        var c2 = /^data:video\//i.test(b2);
        b2 = goog.html.SafeUrl.sanitizeAssertUnchanged(b2, c2);
      }
      a2.src = goog.html.SafeUrl.unwrap(b2);
    };
    goog.dom.safe.setEmbedSrc = function(a2, b2) {
      goog.dom.asserts.assertIsHTMLEmbedElement(a2);
      a2.src = goog.html.TrustedResourceUrl.unwrapTrustedScriptURL(b2);
    };
    goog.dom.safe.setFrameSrc = function(a2, b2) {
      goog.dom.asserts.assertIsHTMLFrameElement(a2);
      a2.src = goog.html.TrustedResourceUrl.unwrap(b2);
    };
    goog.dom.safe.setIframeSrc = function(a2, b2) {
      goog.dom.asserts.assertIsHTMLIFrameElement(a2);
      a2.src = goog.html.TrustedResourceUrl.unwrap(b2);
    };
    goog.dom.safe.setIframeSrcdoc = function(a2, b2) {
      goog.dom.asserts.assertIsHTMLIFrameElement(a2);
      a2.srcdoc = goog.html.SafeHtml.unwrapTrustedHTML(b2);
    };
    goog.dom.safe.setLinkHrefAndRel = function(a2, b2, c2) {
      goog.dom.asserts.assertIsHTMLLinkElement(a2);
      a2.rel = c2;
      goog.string.internal.caseInsensitiveContains(c2, "stylesheet") ? (goog.asserts.assert(b2 instanceof goog.html.TrustedResourceUrl, 'URL must be TrustedResourceUrl because "rel" contains "stylesheet"'), a2.href = goog.html.TrustedResourceUrl.unwrap(b2)) : a2.href = b2 instanceof goog.html.TrustedResourceUrl ? goog.html.TrustedResourceUrl.unwrap(b2) : b2 instanceof goog.html.SafeUrl ? goog.html.SafeUrl.unwrap(b2) : goog.html.SafeUrl.unwrap(goog.html.SafeUrl.sanitizeAssertUnchanged(b2));
    };
    goog.dom.safe.setObjectData = function(a2, b2) {
      goog.dom.asserts.assertIsHTMLObjectElement(a2);
      a2.data = goog.html.TrustedResourceUrl.unwrapTrustedScriptURL(b2);
    };
    goog.dom.safe.setScriptSrc = function(a2, b2) {
      goog.dom.asserts.assertIsHTMLScriptElement(a2);
      a2.src = goog.html.TrustedResourceUrl.unwrapTrustedScriptURL(b2);
      (b2 = goog.getScriptNonce()) && a2.setAttribute("nonce", b2);
    };
    goog.dom.safe.setScriptContent = function(a2, b2) {
      goog.dom.asserts.assertIsHTMLScriptElement(a2);
      a2.text = goog.html.SafeScript.unwrapTrustedScript(b2);
      (b2 = goog.getScriptNonce()) && a2.setAttribute("nonce", b2);
    };
    goog.dom.safe.setLocationHref = function(a2, b2) {
      goog.dom.asserts.assertIsLocation(a2);
      b2 = b2 instanceof goog.html.SafeUrl ? b2 : goog.html.SafeUrl.sanitizeAssertUnchanged(b2);
      a2.href = goog.html.SafeUrl.unwrap(b2);
    };
    goog.dom.safe.assignLocation = function(a2, b2) {
      goog.dom.asserts.assertIsLocation(a2);
      b2 = b2 instanceof goog.html.SafeUrl ? b2 : goog.html.SafeUrl.sanitizeAssertUnchanged(b2);
      a2.assign(goog.html.SafeUrl.unwrap(b2));
    };
    goog.dom.safe.replaceLocation = function(a2, b2) {
      b2 = b2 instanceof goog.html.SafeUrl ? b2 : goog.html.SafeUrl.sanitizeAssertUnchanged(b2);
      a2.replace(goog.html.SafeUrl.unwrap(b2));
    };
    goog.dom.safe.openInWindow = function(a2, b2, c2, d2, e2) {
      a2 = a2 instanceof goog.html.SafeUrl ? a2 : goog.html.SafeUrl.sanitizeAssertUnchanged(a2);
      b2 = b2 || goog.global;
      c2 = c2 instanceof goog.string.Const ? goog.string.Const.unwrap(c2) : c2 || "";
      return b2.open(goog.html.SafeUrl.unwrap(a2), c2, d2, e2);
    };
    goog.dom.safe.parseFromStringHtml = function(a2, b2) {
      return goog.dom.safe.parseFromString(a2, b2, "text/html");
    };
    goog.dom.safe.parseFromString = function(a2, b2, c2) {
      return a2.parseFromString(goog.html.SafeHtml.unwrapTrustedHTML(b2), c2);
    };
    goog.dom.safe.createImageFromBlob = function(a2) {
      if (!/^image\/.*/g.test(a2.type))
        throw Error("goog.dom.safe.createImageFromBlob only accepts MIME type image/.*.");
      var b2 = goog.global.URL.createObjectURL(a2);
      a2 = new goog.global.Image();
      a2.onload = function() {
        goog.global.URL.revokeObjectURL(b2);
      };
      goog.dom.safe.setImageSrc(a2, goog.html.uncheckedconversions.safeUrlFromStringKnownToSatisfyTypeContract(goog.string.Const.from("Image blob URL."), b2));
      return a2;
    };
    goog.string.DETECT_DOUBLE_ESCAPING = false;
    goog.string.FORCE_NON_DOM_HTML_UNESCAPING = false;
    goog.string.Unicode = { NBSP: "\xA0" };
    goog.string.startsWith = goog.string.internal.startsWith;
    goog.string.endsWith = goog.string.internal.endsWith;
    goog.string.caseInsensitiveStartsWith = goog.string.internal.caseInsensitiveStartsWith;
    goog.string.caseInsensitiveEndsWith = goog.string.internal.caseInsensitiveEndsWith;
    goog.string.caseInsensitiveEquals = goog.string.internal.caseInsensitiveEquals;
    goog.string.subs = function(a2, b2) {
      for (var c2 = a2.split("%s"), d2 = "", e2 = Array.prototype.slice.call(arguments, 1); e2.length && 1 < c2.length; )
        d2 += c2.shift() + e2.shift();
      return d2 + c2.join("%s");
    };
    goog.string.collapseWhitespace = function(a2) {
      return a2.replace(/[\s\xa0]+/g, " ").replace(/^\s+|\s+$/g, "");
    };
    goog.string.isEmptyOrWhitespace = goog.string.internal.isEmptyOrWhitespace;
    goog.string.isEmptyString = function(a2) {
      return 0 == a2.length;
    };
    goog.string.isEmpty = goog.string.isEmptyOrWhitespace;
    goog.string.isEmptyOrWhitespaceSafe = function(a2) {
      return goog.string.isEmptyOrWhitespace(goog.string.makeSafe(a2));
    };
    goog.string.isEmptySafe = goog.string.isEmptyOrWhitespaceSafe;
    goog.string.isBreakingWhitespace = function(a2) {
      return !/[^\t\n\r ]/.test(a2);
    };
    goog.string.isAlpha = function(a2) {
      return !/[^a-zA-Z]/.test(a2);
    };
    goog.string.isNumeric = function(a2) {
      return !/[^0-9]/.test(a2);
    };
    goog.string.isAlphaNumeric = function(a2) {
      return !/[^a-zA-Z0-9]/.test(a2);
    };
    goog.string.isSpace = function(a2) {
      return " " == a2;
    };
    goog.string.isUnicodeChar = function(a2) {
      return 1 == a2.length && " " <= a2 && "~" >= a2 || "\x80" <= a2 && "\uFFFD" >= a2;
    };
    goog.string.stripNewlines = function(a2) {
      return a2.replace(/(\r\n|\r|\n)+/g, " ");
    };
    goog.string.canonicalizeNewlines = function(a2) {
      return a2.replace(/(\r\n|\r|\n)/g, "\n");
    };
    goog.string.normalizeWhitespace = function(a2) {
      return a2.replace(/\xa0|\s/g, " ");
    };
    goog.string.normalizeSpaces = function(a2) {
      return a2.replace(/\xa0|[ \t]+/g, " ");
    };
    goog.string.collapseBreakingSpaces = function(a2) {
      return a2.replace(/[\t\r\n ]+/g, " ").replace(/^[\t\r\n ]+|[\t\r\n ]+$/g, "");
    };
    goog.string.trim = goog.string.internal.trim;
    goog.string.trimLeft = function(a2) {
      return a2.replace(/^[\s\xa0]+/, "");
    };
    goog.string.trimRight = function(a2) {
      return a2.replace(/[\s\xa0]+$/, "");
    };
    goog.string.caseInsensitiveCompare = goog.string.internal.caseInsensitiveCompare;
    goog.string.numberAwareCompare_ = function(a2, b2, c2) {
      if (a2 == b2)
        return 0;
      if (!a2)
        return -1;
      if (!b2)
        return 1;
      for (var d2 = a2.toLowerCase().match(c2), e2 = b2.toLowerCase().match(c2), f2 = Math.min(d2.length, e2.length), g = 0; g < f2; g++) {
        c2 = d2[g];
        var h = e2[g];
        if (c2 != h)
          return a2 = parseInt(c2, 10), !isNaN(a2) && (b2 = parseInt(h, 10), !isNaN(b2) && a2 - b2) ? a2 - b2 : c2 < h ? -1 : 1;
      }
      return d2.length != e2.length ? d2.length - e2.length : a2 < b2 ? -1 : 1;
    };
    goog.string.intAwareCompare = function(a2, b2) {
      return goog.string.numberAwareCompare_(a2, b2, /\d+|\D+/g);
    };
    goog.string.floatAwareCompare = function(a2, b2) {
      return goog.string.numberAwareCompare_(a2, b2, /\d+|\.\d+|\D+/g);
    };
    goog.string.numerateCompare = goog.string.floatAwareCompare;
    goog.string.urlEncode = function(a2) {
      return encodeURIComponent(String(a2));
    };
    goog.string.urlDecode = function(a2) {
      return decodeURIComponent(a2.replace(/\+/g, " "));
    };
    goog.string.newLineToBr = goog.string.internal.newLineToBr;
    goog.string.htmlEscape = function(a2, b2) {
      a2 = goog.string.internal.htmlEscape(a2, b2);
      goog.string.DETECT_DOUBLE_ESCAPING && (a2 = a2.replace(goog.string.E_RE_, "&#101;"));
      return a2;
    };
    goog.string.E_RE_ = /e/g;
    goog.string.unescapeEntities = function(a2) {
      return goog.string.contains(a2, "&") ? !goog.string.FORCE_NON_DOM_HTML_UNESCAPING && "document" in goog.global ? goog.string.unescapeEntitiesUsingDom_(a2) : goog.string.unescapePureXmlEntities_(a2) : a2;
    };
    goog.string.unescapeEntitiesWithDocument = function(a2, b2) {
      return goog.string.contains(a2, "&") ? goog.string.unescapeEntitiesUsingDom_(a2, b2) : a2;
    };
    goog.string.unescapeEntitiesUsingDom_ = function(a2, b2) {
      var c2 = { "&amp;": "&", "&lt;": "<", "&gt;": ">", "&quot;": '"' };
      var d2 = b2 ? b2.createElement("div") : goog.global.document.createElement("div");
      return a2.replace(goog.string.HTML_ENTITY_PATTERN_, function(a3, b3) {
        var e2 = c2[a3];
        if (e2)
          return e2;
        "#" == b3.charAt(0) && (b3 = Number("0" + b3.substr(1)), isNaN(b3) || (e2 = String.fromCharCode(b3)));
        e2 || (goog.dom.safe.setInnerHtml(d2, goog.html.uncheckedconversions.safeHtmlFromStringKnownToSatisfyTypeContract(
          goog.string.Const.from("Single HTML entity."),
          a3 + " "
        )), e2 = d2.firstChild.nodeValue.slice(0, -1));
        return c2[a3] = e2;
      });
    };
    goog.string.unescapePureXmlEntities_ = function(a2) {
      return a2.replace(/&([^;]+);/g, function(a3, c2) {
        switch (c2) {
          case "amp":
            return "&";
          case "lt":
            return "<";
          case "gt":
            return ">";
          case "quot":
            return '"';
          default:
            return "#" != c2.charAt(0) || (c2 = Number("0" + c2.substr(1)), isNaN(c2)) ? a3 : String.fromCharCode(c2);
        }
      });
    };
    goog.string.HTML_ENTITY_PATTERN_ = /&([^;\s<&]+);?/g;
    goog.string.whitespaceEscape = function(a2, b2) {
      return goog.string.newLineToBr(a2.replace(/  /g, " &#160;"), b2);
    };
    goog.string.preserveSpaces = function(a2) {
      return a2.replace(/(^|[\n ]) /g, "$1" + goog.string.Unicode.NBSP);
    };
    goog.string.stripQuotes = function(a2, b2) {
      for (var c2 = b2.length, d2 = 0; d2 < c2; d2++) {
        var e2 = 1 == c2 ? b2 : b2.charAt(d2);
        if (a2.charAt(0) == e2 && a2.charAt(a2.length - 1) == e2)
          return a2.substring(1, a2.length - 1);
      }
      return a2;
    };
    goog.string.truncate = function(a2, b2, c2) {
      c2 && (a2 = goog.string.unescapeEntities(a2));
      a2.length > b2 && (a2 = a2.substring(0, b2 - 3) + "...");
      c2 && (a2 = goog.string.htmlEscape(a2));
      return a2;
    };
    goog.string.truncateMiddle = function(a2, b2, c2, d2) {
      c2 && (a2 = goog.string.unescapeEntities(a2));
      if (d2 && a2.length > b2) {
        d2 > b2 && (d2 = b2);
        var e2 = a2.length - d2;
        a2 = a2.substring(0, b2 - d2) + "..." + a2.substring(e2);
      } else
        a2.length > b2 && (d2 = Math.floor(b2 / 2), e2 = a2.length - d2, a2 = a2.substring(0, d2 + b2 % 2) + "..." + a2.substring(e2));
      c2 && (a2 = goog.string.htmlEscape(a2));
      return a2;
    };
    goog.string.specialEscapeChars_ = { "\0": "\\0", "\b": "\\b", "\f": "\\f", "\n": "\\n", "\r": "\\r", "	": "\\t", "\v": "\\x0B", '"': '\\"', "\\": "\\\\", "<": "\\u003C" };
    goog.string.jsEscapeCache_ = { "'": "\\'" };
    goog.string.quote = function(a2) {
      a2 = String(a2);
      for (var b2 = ['"'], c2 = 0; c2 < a2.length; c2++) {
        var d2 = a2.charAt(c2), e2 = d2.charCodeAt(0);
        b2[c2 + 1] = goog.string.specialEscapeChars_[d2] || (31 < e2 && 127 > e2 ? d2 : goog.string.escapeChar(d2));
      }
      b2.push('"');
      return b2.join("");
    };
    goog.string.escapeString = function(a2) {
      for (var b2 = [], c2 = 0; c2 < a2.length; c2++)
        b2[c2] = goog.string.escapeChar(a2.charAt(c2));
      return b2.join("");
    };
    goog.string.escapeChar = function(a2) {
      if (a2 in goog.string.jsEscapeCache_)
        return goog.string.jsEscapeCache_[a2];
      if (a2 in goog.string.specialEscapeChars_)
        return goog.string.jsEscapeCache_[a2] = goog.string.specialEscapeChars_[a2];
      var b2 = a2.charCodeAt(0);
      if (31 < b2 && 127 > b2)
        var c2 = a2;
      else {
        if (256 > b2) {
          if (c2 = "\\x", 16 > b2 || 256 < b2)
            c2 += "0";
        } else
          c2 = "\\u", 4096 > b2 && (c2 += "0");
        c2 += b2.toString(16).toUpperCase();
      }
      return goog.string.jsEscapeCache_[a2] = c2;
    };
    goog.string.contains = goog.string.internal.contains;
    goog.string.caseInsensitiveContains = goog.string.internal.caseInsensitiveContains;
    goog.string.countOf = function(a2, b2) {
      return a2 && b2 ? a2.split(b2).length - 1 : 0;
    };
    goog.string.removeAt = function(a2, b2, c2) {
      var d2 = a2;
      0 <= b2 && b2 < a2.length && 0 < c2 && (d2 = a2.substr(0, b2) + a2.substr(b2 + c2, a2.length - b2 - c2));
      return d2;
    };
    goog.string.remove = function(a2, b2) {
      return a2.replace(b2, "");
    };
    goog.string.removeAll = function(a2, b2) {
      b2 = new RegExp(goog.string.regExpEscape(b2), "g");
      return a2.replace(b2, "");
    };
    goog.string.replaceAll = function(a2, b2, c2) {
      b2 = new RegExp(goog.string.regExpEscape(b2), "g");
      return a2.replace(b2, c2.replace(/\$/g, "$$$$"));
    };
    goog.string.regExpEscape = function(a2) {
      return String(a2).replace(/([-()\[\]{}+?*.$\^|,:#<!\\])/g, "\\$1").replace(/\x08/g, "\\x08");
    };
    goog.string.repeat = String.prototype.repeat ? function(a2, b2) {
      return a2.repeat(b2);
    } : function(a2, b2) {
      return Array(b2 + 1).join(a2);
    };
    goog.string.padNumber = function(a2, b2, c2) {
      a2 = void 0 !== c2 ? a2.toFixed(c2) : String(a2);
      c2 = a2.indexOf(".");
      -1 == c2 && (c2 = a2.length);
      return goog.string.repeat("0", Math.max(0, b2 - c2)) + a2;
    };
    goog.string.makeSafe = function(a2) {
      return null == a2 ? "" : String(a2);
    };
    goog.string.buildString = function(a2) {
      return Array.prototype.join.call(arguments, "");
    };
    goog.string.getRandomString = function() {
      return Math.floor(2147483648 * Math.random()).toString(36) + Math.abs(Math.floor(2147483648 * Math.random()) ^ goog.now()).toString(36);
    };
    goog.string.compareVersions = goog.string.internal.compareVersions;
    goog.string.hashCode = function(a2) {
      for (var b2 = 0, c2 = 0; c2 < a2.length; ++c2)
        b2 = 31 * b2 + a2.charCodeAt(c2) >>> 0;
      return b2;
    };
    goog.string.uniqueStringCounter_ = 2147483648 * Math.random() | 0;
    goog.string.createUniqueString = function() {
      return "goog_" + goog.string.uniqueStringCounter_++;
    };
    goog.string.toNumber = function(a2) {
      var b2 = Number(a2);
      return 0 == b2 && goog.string.isEmptyOrWhitespace(a2) ? NaN : b2;
    };
    goog.string.isLowerCamelCase = function(a2) {
      return /^[a-z]+([A-Z][a-z]*)*$/.test(a2);
    };
    goog.string.isUpperCamelCase = function(a2) {
      return /^([A-Z][a-z]*)+$/.test(a2);
    };
    goog.string.toCamelCase = function(a2) {
      return String(a2).replace(/\-([a-z])/g, function(a3, c2) {
        return c2.toUpperCase();
      });
    };
    goog.string.toSelectorCase = function(a2) {
      return String(a2).replace(/([A-Z])/g, "-$1").toLowerCase();
    };
    goog.string.toTitleCase = function(a2, b2) {
      b2 = "string" === typeof b2 ? goog.string.regExpEscape(b2) : "\\s";
      return a2.replace(new RegExp("(^" + (b2 ? "|[" + b2 + "]+" : "") + ")([a-z])", "g"), function(a3, b3, e2) {
        return b3 + e2.toUpperCase();
      });
    };
    goog.string.capitalize = function(a2) {
      return String(a2.charAt(0)).toUpperCase() + String(a2.substr(1)).toLowerCase();
    };
    goog.string.parseInt = function(a2) {
      isFinite(a2) && (a2 = String(a2));
      return "string" === typeof a2 ? /^\s*-?0x/i.test(a2) ? parseInt(a2, 16) : parseInt(a2, 10) : NaN;
    };
    goog.string.splitLimit = function(a2, b2, c2) {
      a2 = a2.split(b2);
      for (var d2 = []; 0 < c2 && a2.length; )
        d2.push(a2.shift()), c2--;
      a2.length && d2.push(a2.join(b2));
      return d2;
    };
    goog.string.lastComponent = function(a2, b2) {
      if (b2)
        "string" == typeof b2 && (b2 = [b2]);
      else
        return a2;
      for (var c2 = -1, d2 = 0; d2 < b2.length; d2++)
        if ("" != b2[d2]) {
          var e2 = a2.lastIndexOf(b2[d2]);
          e2 > c2 && (c2 = e2);
        }
      return -1 == c2 ? a2 : a2.slice(c2 + 1);
    };
    goog.string.editDistance = function(a2, b2) {
      var c2 = [], d2 = [];
      if (a2 == b2)
        return 0;
      if (!a2.length || !b2.length)
        return Math.max(a2.length, b2.length);
      for (var e2 = 0; e2 < b2.length + 1; e2++)
        c2[e2] = e2;
      for (e2 = 0; e2 < a2.length; e2++) {
        d2[0] = e2 + 1;
        for (var f2 = 0; f2 < b2.length; f2++)
          d2[f2 + 1] = Math.min(d2[f2] + 1, c2[f2 + 1] + 1, c2[f2] + Number(a2[e2] != b2[f2]));
        for (f2 = 0; f2 < c2.length; f2++)
          c2[f2] = d2[f2];
      }
      return d2[b2.length];
    };
    goog.labs.userAgent.engine = {};
    goog.labs.userAgent.engine.isPresto = function() {
      return goog.labs.userAgent.util.matchUserAgent("Presto");
    };
    goog.labs.userAgent.engine.isTrident = function() {
      return goog.labs.userAgent.util.matchUserAgent("Trident") || goog.labs.userAgent.util.matchUserAgent("MSIE");
    };
    goog.labs.userAgent.engine.isEdge = function() {
      return goog.labs.userAgent.util.matchUserAgent("Edge");
    };
    goog.labs.userAgent.engine.isWebKit = function() {
      return goog.labs.userAgent.util.matchUserAgentIgnoreCase("WebKit") && !goog.labs.userAgent.engine.isEdge();
    };
    goog.labs.userAgent.engine.isGecko = function() {
      return goog.labs.userAgent.util.matchUserAgent("Gecko") && !goog.labs.userAgent.engine.isWebKit() && !goog.labs.userAgent.engine.isTrident() && !goog.labs.userAgent.engine.isEdge();
    };
    goog.labs.userAgent.engine.getVersion = function() {
      var a2 = goog.labs.userAgent.util.getUserAgent();
      if (a2) {
        a2 = goog.labs.userAgent.util.extractVersionTuples(a2);
        var b2 = goog.labs.userAgent.engine.getEngineTuple_(a2);
        if (b2)
          return "Gecko" == b2[0] ? goog.labs.userAgent.engine.getVersionForKey_(a2, "Firefox") : b2[1];
        a2 = a2[0];
        var c2;
        if (a2 && (c2 = a2[2]) && (c2 = /Trident\/([^\s;]+)/.exec(c2)))
          return c2[1];
      }
      return "";
    };
    goog.labs.userAgent.engine.getEngineTuple_ = function(a2) {
      if (!goog.labs.userAgent.engine.isEdge())
        return a2[1];
      for (var b2 = 0; b2 < a2.length; b2++) {
        var c2 = a2[b2];
        if ("Edge" == c2[0])
          return c2;
      }
    };
    goog.labs.userAgent.engine.isVersionOrHigher = function(a2) {
      return 0 <= goog.string.compareVersions(goog.labs.userAgent.engine.getVersion(), a2);
    };
    goog.labs.userAgent.engine.getVersionForKey_ = function(a2, b2) {
      return (a2 = goog.array.find(a2, function(a3) {
        return b2 == a3[0];
      })) && a2[1] || "";
    };
    goog.labs.userAgent.platform = {};
    goog.labs.userAgent.platform.isAndroid = function() {
      return goog.labs.userAgent.util.matchUserAgent("Android");
    };
    goog.labs.userAgent.platform.isIpod = function() {
      return goog.labs.userAgent.util.matchUserAgent("iPod");
    };
    goog.labs.userAgent.platform.isIphone = function() {
      return goog.labs.userAgent.util.matchUserAgent("iPhone") && !goog.labs.userAgent.util.matchUserAgent("iPod") && !goog.labs.userAgent.util.matchUserAgent("iPad");
    };
    goog.labs.userAgent.platform.isIpad = function() {
      return goog.labs.userAgent.util.matchUserAgent("iPad");
    };
    goog.labs.userAgent.platform.isIos = function() {
      return goog.labs.userAgent.platform.isIphone() || goog.labs.userAgent.platform.isIpad() || goog.labs.userAgent.platform.isIpod();
    };
    goog.labs.userAgent.platform.isMacintosh = function() {
      return goog.labs.userAgent.util.matchUserAgent("Macintosh");
    };
    goog.labs.userAgent.platform.isLinux = function() {
      return goog.labs.userAgent.util.matchUserAgent("Linux");
    };
    goog.labs.userAgent.platform.isWindows = function() {
      return goog.labs.userAgent.util.matchUserAgent("Windows");
    };
    goog.labs.userAgent.platform.isChromeOS = function() {
      return goog.labs.userAgent.util.matchUserAgent("CrOS");
    };
    goog.labs.userAgent.platform.isChromecast = function() {
      return goog.labs.userAgent.util.matchUserAgent("CrKey");
    };
    goog.labs.userAgent.platform.isKaiOS = function() {
      return goog.labs.userAgent.util.matchUserAgentIgnoreCase("KaiOS");
    };
    goog.labs.userAgent.platform.getVersion = function() {
      var a2 = goog.labs.userAgent.util.getUserAgent(), b2 = "";
      goog.labs.userAgent.platform.isWindows() ? (b2 = /Windows (?:NT|Phone) ([0-9.]+)/, b2 = (a2 = b2.exec(a2)) ? a2[1] : "0.0") : goog.labs.userAgent.platform.isIos() ? (b2 = /(?:iPhone|iPod|iPad|CPU)\s+OS\s+(\S+)/, b2 = (a2 = b2.exec(a2)) && a2[1].replace(/_/g, ".")) : goog.labs.userAgent.platform.isMacintosh() ? (b2 = /Mac OS X ([0-9_.]+)/, b2 = (a2 = b2.exec(a2)) ? a2[1].replace(/_/g, ".") : "10") : goog.labs.userAgent.platform.isKaiOS() ? (b2 = /(?:KaiOS)\/(\S+)/i, b2 = (a2 = b2.exec(a2)) && a2[1]) : goog.labs.userAgent.platform.isAndroid() ? (b2 = /Android\s+([^\);]+)(\)|;)/, b2 = (a2 = b2.exec(a2)) && a2[1]) : goog.labs.userAgent.platform.isChromeOS() && (b2 = /(?:CrOS\s+(?:i686|x86_64)\s+([0-9.]+))/, b2 = (a2 = b2.exec(a2)) && a2[1]);
      return b2 || "";
    };
    goog.labs.userAgent.platform.isVersionOrHigher = function(a2) {
      return 0 <= goog.string.compareVersions(goog.labs.userAgent.platform.getVersion(), a2);
    };
    goog.reflect = {};
    goog.reflect.object = function(a2, b2) {
      return b2;
    };
    goog.reflect.objectProperty = function(a2, b2) {
      return a2;
    };
    goog.reflect.sinkValue = function(a2) {
      goog.reflect.sinkValue[" "](a2);
      return a2;
    };
    goog.reflect.sinkValue[" "] = goog.nullFunction;
    goog.reflect.canAccessProperty = function(a2, b2) {
      try {
        return goog.reflect.sinkValue(a2[b2]), true;
      } catch (c2) {
      }
      return false;
    };
    goog.reflect.cache = function(a2, b2, c2, d2) {
      d2 = d2 ? d2(b2) : b2;
      return Object.prototype.hasOwnProperty.call(a2, d2) ? a2[d2] : a2[d2] = c2(b2);
    };
    goog.userAgent = {};
    goog.userAgent.ASSUME_IE = false;
    goog.userAgent.ASSUME_EDGE = false;
    goog.userAgent.ASSUME_GECKO = false;
    goog.userAgent.ASSUME_WEBKIT = false;
    goog.userAgent.ASSUME_MOBILE_WEBKIT = false;
    goog.userAgent.ASSUME_OPERA = false;
    goog.userAgent.ASSUME_ANY_VERSION = false;
    goog.userAgent.BROWSER_KNOWN_ = goog.userAgent.ASSUME_IE || goog.userAgent.ASSUME_EDGE || goog.userAgent.ASSUME_GECKO || goog.userAgent.ASSUME_MOBILE_WEBKIT || goog.userAgent.ASSUME_WEBKIT || goog.userAgent.ASSUME_OPERA;
    goog.userAgent.getUserAgentString = function() {
      return goog.labs.userAgent.util.getUserAgent();
    };
    goog.userAgent.getNavigatorTyped = function() {
      return goog.global.navigator || null;
    };
    goog.userAgent.getNavigator = function() {
      return goog.userAgent.getNavigatorTyped();
    };
    goog.userAgent.OPERA = goog.userAgent.BROWSER_KNOWN_ ? goog.userAgent.ASSUME_OPERA : goog.labs.userAgent.browser.isOpera();
    goog.userAgent.IE = goog.userAgent.BROWSER_KNOWN_ ? goog.userAgent.ASSUME_IE : goog.labs.userAgent.browser.isIE();
    goog.userAgent.EDGE = goog.userAgent.BROWSER_KNOWN_ ? goog.userAgent.ASSUME_EDGE : goog.labs.userAgent.engine.isEdge();
    goog.userAgent.EDGE_OR_IE = goog.userAgent.EDGE || goog.userAgent.IE;
    goog.userAgent.GECKO = goog.userAgent.BROWSER_KNOWN_ ? goog.userAgent.ASSUME_GECKO : goog.labs.userAgent.engine.isGecko();
    goog.userAgent.WEBKIT = goog.userAgent.BROWSER_KNOWN_ ? goog.userAgent.ASSUME_WEBKIT || goog.userAgent.ASSUME_MOBILE_WEBKIT : goog.labs.userAgent.engine.isWebKit();
    goog.userAgent.isMobile_ = function() {
      return goog.userAgent.WEBKIT && goog.labs.userAgent.util.matchUserAgent("Mobile");
    };
    goog.userAgent.MOBILE = goog.userAgent.ASSUME_MOBILE_WEBKIT || goog.userAgent.isMobile_();
    goog.userAgent.SAFARI = goog.userAgent.WEBKIT;
    goog.userAgent.determinePlatform_ = function() {
      var a2 = goog.userAgent.getNavigatorTyped();
      return a2 && a2.platform || "";
    };
    goog.userAgent.PLATFORM = goog.userAgent.determinePlatform_();
    goog.userAgent.ASSUME_MAC = false;
    goog.userAgent.ASSUME_WINDOWS = false;
    goog.userAgent.ASSUME_LINUX = false;
    goog.userAgent.ASSUME_X11 = false;
    goog.userAgent.ASSUME_ANDROID = false;
    goog.userAgent.ASSUME_IPHONE = false;
    goog.userAgent.ASSUME_IPAD = false;
    goog.userAgent.ASSUME_IPOD = false;
    goog.userAgent.ASSUME_KAIOS = false;
    goog.userAgent.PLATFORM_KNOWN_ = goog.userAgent.ASSUME_MAC || goog.userAgent.ASSUME_WINDOWS || goog.userAgent.ASSUME_LINUX || goog.userAgent.ASSUME_X11 || goog.userAgent.ASSUME_ANDROID || goog.userAgent.ASSUME_IPHONE || goog.userAgent.ASSUME_IPAD || goog.userAgent.ASSUME_IPOD;
    goog.userAgent.MAC = goog.userAgent.PLATFORM_KNOWN_ ? goog.userAgent.ASSUME_MAC : goog.labs.userAgent.platform.isMacintosh();
    goog.userAgent.WINDOWS = goog.userAgent.PLATFORM_KNOWN_ ? goog.userAgent.ASSUME_WINDOWS : goog.labs.userAgent.platform.isWindows();
    goog.userAgent.isLegacyLinux_ = function() {
      return goog.labs.userAgent.platform.isLinux() || goog.labs.userAgent.platform.isChromeOS();
    };
    goog.userAgent.LINUX = goog.userAgent.PLATFORM_KNOWN_ ? goog.userAgent.ASSUME_LINUX : goog.userAgent.isLegacyLinux_();
    goog.userAgent.isX11_ = function() {
      var a2 = goog.userAgent.getNavigatorTyped();
      return !!a2 && goog.string.contains(a2.appVersion || "", "X11");
    };
    goog.userAgent.X11 = goog.userAgent.PLATFORM_KNOWN_ ? goog.userAgent.ASSUME_X11 : goog.userAgent.isX11_();
    goog.userAgent.ANDROID = goog.userAgent.PLATFORM_KNOWN_ ? goog.userAgent.ASSUME_ANDROID : goog.labs.userAgent.platform.isAndroid();
    goog.userAgent.IPHONE = goog.userAgent.PLATFORM_KNOWN_ ? goog.userAgent.ASSUME_IPHONE : goog.labs.userAgent.platform.isIphone();
    goog.userAgent.IPAD = goog.userAgent.PLATFORM_KNOWN_ ? goog.userAgent.ASSUME_IPAD : goog.labs.userAgent.platform.isIpad();
    goog.userAgent.IPOD = goog.userAgent.PLATFORM_KNOWN_ ? goog.userAgent.ASSUME_IPOD : goog.labs.userAgent.platform.isIpod();
    goog.userAgent.IOS = goog.userAgent.PLATFORM_KNOWN_ ? goog.userAgent.ASSUME_IPHONE || goog.userAgent.ASSUME_IPAD || goog.userAgent.ASSUME_IPOD : goog.labs.userAgent.platform.isIos();
    goog.userAgent.KAIOS = goog.userAgent.PLATFORM_KNOWN_ ? goog.userAgent.ASSUME_KAIOS : goog.labs.userAgent.platform.isKaiOS();
    goog.userAgent.determineVersion_ = function() {
      var a2 = "", b2 = goog.userAgent.getVersionRegexResult_();
      b2 && (a2 = b2 ? b2[1] : "");
      return goog.userAgent.IE && (b2 = goog.userAgent.getDocumentMode_(), null != b2 && b2 > parseFloat(a2)) ? String(b2) : a2;
    };
    goog.userAgent.getVersionRegexResult_ = function() {
      var a2 = goog.userAgent.getUserAgentString();
      if (goog.userAgent.GECKO)
        return /rv:([^\);]+)(\)|;)/.exec(a2);
      if (goog.userAgent.EDGE)
        return /Edge\/([\d\.]+)/.exec(a2);
      if (goog.userAgent.IE)
        return /\b(?:MSIE|rv)[: ]([^\);]+)(\)|;)/.exec(a2);
      if (goog.userAgent.WEBKIT)
        return /WebKit\/(\S+)/.exec(a2);
      if (goog.userAgent.OPERA)
        return /(?:Version)[ \/]?(\S+)/.exec(a2);
    };
    goog.userAgent.getDocumentMode_ = function() {
      var a2 = goog.global.document;
      return a2 ? a2.documentMode : void 0;
    };
    goog.userAgent.VERSION = goog.userAgent.determineVersion_();
    goog.userAgent.compare = function(a2, b2) {
      return goog.string.compareVersions(a2, b2);
    };
    goog.userAgent.isVersionOrHigherCache_ = {};
    goog.userAgent.isVersionOrHigher = function(a2) {
      return goog.userAgent.ASSUME_ANY_VERSION || goog.reflect.cache(goog.userAgent.isVersionOrHigherCache_, a2, function() {
        return 0 <= goog.string.compareVersions(goog.userAgent.VERSION, a2);
      });
    };
    goog.userAgent.isVersion = goog.userAgent.isVersionOrHigher;
    goog.userAgent.isDocumentModeOrHigher = function(a2) {
      return Number(goog.userAgent.DOCUMENT_MODE) >= a2;
    };
    goog.userAgent.isDocumentMode = goog.userAgent.isDocumentModeOrHigher;
    goog.userAgent.DOCUMENT_MODE = function() {
      if (goog.global.document && goog.userAgent.IE) {
        var a2 = goog.userAgent.getDocumentMode_();
        return a2 ? a2 : parseInt(goog.userAgent.VERSION, 10) || void 0;
      }
    }();
    goog.userAgent.product = {};
    goog.userAgent.product.ASSUME_FIREFOX = false;
    goog.userAgent.product.ASSUME_IPHONE = false;
    goog.userAgent.product.ASSUME_IPAD = false;
    goog.userAgent.product.ASSUME_ANDROID = false;
    goog.userAgent.product.ASSUME_CHROME = false;
    goog.userAgent.product.ASSUME_SAFARI = false;
    goog.userAgent.product.PRODUCT_KNOWN_ = goog.userAgent.ASSUME_IE || goog.userAgent.ASSUME_EDGE || goog.userAgent.ASSUME_OPERA || goog.userAgent.product.ASSUME_FIREFOX || goog.userAgent.product.ASSUME_IPHONE || goog.userAgent.product.ASSUME_IPAD || goog.userAgent.product.ASSUME_ANDROID || goog.userAgent.product.ASSUME_CHROME || goog.userAgent.product.ASSUME_SAFARI;
    goog.userAgent.product.OPERA = goog.userAgent.OPERA;
    goog.userAgent.product.IE = goog.userAgent.IE;
    goog.userAgent.product.EDGE = goog.userAgent.EDGE;
    goog.userAgent.product.FIREFOX = goog.userAgent.product.PRODUCT_KNOWN_ ? goog.userAgent.product.ASSUME_FIREFOX : goog.labs.userAgent.browser.isFirefox();
    goog.userAgent.product.isIphoneOrIpod_ = function() {
      return goog.labs.userAgent.platform.isIphone() || goog.labs.userAgent.platform.isIpod();
    };
    goog.userAgent.product.IPHONE = goog.userAgent.product.PRODUCT_KNOWN_ ? goog.userAgent.product.ASSUME_IPHONE : goog.userAgent.product.isIphoneOrIpod_();
    goog.userAgent.product.IPAD = goog.userAgent.product.PRODUCT_KNOWN_ ? goog.userAgent.product.ASSUME_IPAD : goog.labs.userAgent.platform.isIpad();
    goog.userAgent.product.ANDROID = goog.userAgent.product.PRODUCT_KNOWN_ ? goog.userAgent.product.ASSUME_ANDROID : goog.labs.userAgent.browser.isAndroidBrowser();
    goog.userAgent.product.CHROME = goog.userAgent.product.PRODUCT_KNOWN_ ? goog.userAgent.product.ASSUME_CHROME : goog.labs.userAgent.browser.isChrome();
    goog.userAgent.product.isSafariDesktop_ = function() {
      return goog.labs.userAgent.browser.isSafari() && !goog.labs.userAgent.platform.isIos();
    };
    goog.userAgent.product.SAFARI = goog.userAgent.product.PRODUCT_KNOWN_ ? goog.userAgent.product.ASSUME_SAFARI : goog.userAgent.product.isSafariDesktop_();
    goog.crypt.base64 = {};
    goog.crypt.base64.DEFAULT_ALPHABET_COMMON_ = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
    goog.crypt.base64.ENCODED_VALS = goog.crypt.base64.DEFAULT_ALPHABET_COMMON_ + "+/=";
    goog.crypt.base64.ENCODED_VALS_WEBSAFE = goog.crypt.base64.DEFAULT_ALPHABET_COMMON_ + "-_.";
    goog.crypt.base64.Alphabet = { DEFAULT: 0, NO_PADDING: 1, WEBSAFE: 2, WEBSAFE_DOT_PADDING: 3, WEBSAFE_NO_PADDING: 4 };
    goog.crypt.base64.paddingChars_ = "=.";
    goog.crypt.base64.isPadding_ = function(a2) {
      return goog.string.contains(goog.crypt.base64.paddingChars_, a2);
    };
    goog.crypt.base64.byteToCharMaps_ = {};
    goog.crypt.base64.charToByteMap_ = null;
    goog.crypt.base64.ASSUME_NATIVE_SUPPORT_ = goog.userAgent.GECKO || goog.userAgent.WEBKIT && !goog.userAgent.product.SAFARI || goog.userAgent.OPERA;
    goog.crypt.base64.HAS_NATIVE_ENCODE_ = goog.crypt.base64.ASSUME_NATIVE_SUPPORT_ || "function" == typeof goog.global.btoa;
    goog.crypt.base64.HAS_NATIVE_DECODE_ = goog.crypt.base64.ASSUME_NATIVE_SUPPORT_ || !goog.userAgent.product.SAFARI && !goog.userAgent.IE && "function" == typeof goog.global.atob;
    goog.crypt.base64.encodeByteArray = function(a2, b2) {
      goog.asserts.assert(goog.isArrayLike(a2), "encodeByteArray takes an array as a parameter");
      void 0 === b2 && (b2 = goog.crypt.base64.Alphabet.DEFAULT);
      goog.crypt.base64.init_();
      b2 = goog.crypt.base64.byteToCharMaps_[b2];
      for (var c2 = [], d2 = 0; d2 < a2.length; d2 += 3) {
        var e2 = a2[d2], f2 = d2 + 1 < a2.length, g = f2 ? a2[d2 + 1] : 0, h = d2 + 2 < a2.length, k = h ? a2[d2 + 2] : 0, l = e2 >> 2;
        e2 = (e2 & 3) << 4 | g >> 4;
        g = (g & 15) << 2 | k >> 6;
        k &= 63;
        h || (k = 64, f2 || (g = 64));
        c2.push(b2[l], b2[e2], b2[g] || "", b2[k] || "");
      }
      return c2.join("");
    };
    goog.crypt.base64.encodeString = function(a2, b2) {
      return goog.crypt.base64.HAS_NATIVE_ENCODE_ && !b2 ? goog.global.btoa(a2) : goog.crypt.base64.encodeByteArray(goog.crypt.stringToByteArray(a2), b2);
    };
    goog.crypt.base64.decodeString = function(a2, b2) {
      if (goog.crypt.base64.HAS_NATIVE_DECODE_ && !b2)
        return goog.global.atob(a2);
      var c2 = "";
      goog.crypt.base64.decodeStringInternal_(a2, function(a3) {
        c2 += String.fromCharCode(a3);
      });
      return c2;
    };
    goog.crypt.base64.decodeStringToByteArray = function(a2, b2) {
      var c2 = [];
      goog.crypt.base64.decodeStringInternal_(a2, function(a3) {
        c2.push(a3);
      });
      return c2;
    };
    goog.crypt.base64.decodeStringToUint8Array = function(a2) {
      goog.asserts.assert(!goog.userAgent.IE || goog.userAgent.isVersionOrHigher("10"), "Browser does not support typed arrays");
      var b2 = a2.length, c2 = 3 * b2 / 4;
      c2 % 3 ? c2 = Math.floor(c2) : goog.crypt.base64.isPadding_(a2[b2 - 1]) && (c2 = goog.crypt.base64.isPadding_(a2[b2 - 2]) ? c2 - 2 : c2 - 1);
      var d2 = new Uint8Array(c2), e2 = 0;
      goog.crypt.base64.decodeStringInternal_(a2, function(a3) {
        d2[e2++] = a3;
      });
      return d2.subarray(0, e2);
    };
    goog.crypt.base64.decodeStringInternal_ = function(a2, b2) {
      function c2(b3) {
        for (; d2 < a2.length; ) {
          var c3 = a2.charAt(d2++), e3 = goog.crypt.base64.charToByteMap_[c3];
          if (null != e3)
            return e3;
          if (!goog.string.isEmptyOrWhitespace(c3))
            throw Error("Unknown base64 encoding at char: " + c3);
        }
        return b3;
      }
      goog.crypt.base64.init_();
      for (var d2 = 0; ; ) {
        var e2 = c2(-1), f2 = c2(0), g = c2(64), h = c2(64);
        if (64 === h && -1 === e2)
          break;
        b2(e2 << 2 | f2 >> 4);
        64 != g && (b2(f2 << 4 & 240 | g >> 2), 64 != h && b2(g << 6 & 192 | h));
      }
    };
    goog.crypt.base64.init_ = function() {
      if (!goog.crypt.base64.charToByteMap_) {
        goog.crypt.base64.charToByteMap_ = {};
        for (var a2 = goog.crypt.base64.DEFAULT_ALPHABET_COMMON_.split(""), b2 = ["+/=", "+/", "-_=", "-_.", "-_"], c2 = 0; 5 > c2; c2++) {
          var d2 = a2.concat(b2[c2].split(""));
          goog.crypt.base64.byteToCharMaps_[c2] = d2;
          for (var e2 = 0; e2 < d2.length; e2++) {
            var f2 = d2[e2], g = goog.crypt.base64.charToByteMap_[f2];
            void 0 === g ? goog.crypt.base64.charToByteMap_[f2] = e2 : goog.asserts.assert(g === e2);
          }
        }
      }
    };
    jspb.utils = {};
    jspb.utils.split64Low = 0;
    jspb.utils.split64High = 0;
    jspb.utils.splitUint64 = function(a2) {
      var b2 = a2 >>> 0;
      a2 = Math.floor((a2 - b2) / jspb.BinaryConstants.TWO_TO_32) >>> 0;
      jspb.utils.split64Low = b2;
      jspb.utils.split64High = a2;
    };
    jspb.utils.splitInt64 = function(a2) {
      var b2 = 0 > a2;
      a2 = Math.abs(a2);
      var c2 = a2 >>> 0;
      a2 = Math.floor((a2 - c2) / jspb.BinaryConstants.TWO_TO_32);
      a2 >>>= 0;
      b2 && (a2 = ~a2 >>> 0, c2 = (~c2 >>> 0) + 1, 4294967295 < c2 && (c2 = 0, a2++, 4294967295 < a2 && (a2 = 0)));
      jspb.utils.split64Low = c2;
      jspb.utils.split64High = a2;
    };
    jspb.utils.splitZigzag64 = function(a2) {
      var b2 = 0 > a2;
      a2 = 2 * Math.abs(a2);
      jspb.utils.splitUint64(a2);
      a2 = jspb.utils.split64Low;
      var c2 = jspb.utils.split64High;
      b2 && (0 == a2 ? 0 == c2 ? c2 = a2 = 4294967295 : (c2--, a2 = 4294967295) : a2--);
      jspb.utils.split64Low = a2;
      jspb.utils.split64High = c2;
    };
    jspb.utils.splitFloat32 = function(a2) {
      var b2 = 0 > a2 ? 1 : 0;
      a2 = b2 ? -a2 : a2;
      if (0 === a2)
        0 < 1 / a2 ? (jspb.utils.split64High = 0, jspb.utils.split64Low = 0) : (jspb.utils.split64High = 0, jspb.utils.split64Low = 2147483648);
      else if (isNaN(a2))
        jspb.utils.split64High = 0, jspb.utils.split64Low = 2147483647;
      else if (a2 > jspb.BinaryConstants.FLOAT32_MAX)
        jspb.utils.split64High = 0, jspb.utils.split64Low = (b2 << 31 | 2139095040) >>> 0;
      else if (a2 < jspb.BinaryConstants.FLOAT32_MIN)
        a2 = Math.round(a2 / Math.pow(2, -149)), jspb.utils.split64High = 0, jspb.utils.split64Low = (b2 << 31 | a2) >>> 0;
      else {
        var c2 = Math.floor(Math.log(a2) / Math.LN2);
        a2 *= Math.pow(2, -c2);
        a2 = Math.round(a2 * jspb.BinaryConstants.TWO_TO_23);
        16777216 <= a2 && ++c2;
        jspb.utils.split64High = 0;
        jspb.utils.split64Low = (b2 << 31 | c2 + 127 << 23 | a2 & 8388607) >>> 0;
      }
    };
    jspb.utils.splitFloat64 = function(a2) {
      var b2 = 0 > a2 ? 1 : 0;
      a2 = b2 ? -a2 : a2;
      if (0 === a2)
        jspb.utils.split64High = 0 < 1 / a2 ? 0 : 2147483648, jspb.utils.split64Low = 0;
      else if (isNaN(a2))
        jspb.utils.split64High = 2147483647, jspb.utils.split64Low = 4294967295;
      else if (a2 > jspb.BinaryConstants.FLOAT64_MAX)
        jspb.utils.split64High = (b2 << 31 | 2146435072) >>> 0, jspb.utils.split64Low = 0;
      else if (a2 < jspb.BinaryConstants.FLOAT64_MIN) {
        var c2 = a2 / Math.pow(2, -1074);
        a2 = c2 / jspb.BinaryConstants.TWO_TO_32;
        jspb.utils.split64High = (b2 << 31 | a2) >>> 0;
        jspb.utils.split64Low = c2 >>> 0;
      } else {
        c2 = a2;
        var d2 = 0;
        if (2 <= c2)
          for (; 2 <= c2 && 1023 > d2; )
            d2++, c2 /= 2;
        else
          for (; 1 > c2 && -1022 < d2; )
            c2 *= 2, d2--;
        c2 = a2 * Math.pow(2, -d2);
        a2 = c2 * jspb.BinaryConstants.TWO_TO_20 & 1048575;
        c2 = c2 * jspb.BinaryConstants.TWO_TO_52 >>> 0;
        jspb.utils.split64High = (b2 << 31 | d2 + 1023 << 20 | a2) >>> 0;
        jspb.utils.split64Low = c2;
      }
    };
    jspb.utils.splitHash64 = function(a2) {
      var b2 = a2.charCodeAt(0), c2 = a2.charCodeAt(1), d2 = a2.charCodeAt(2), e2 = a2.charCodeAt(3), f2 = a2.charCodeAt(4), g = a2.charCodeAt(5), h = a2.charCodeAt(6);
      a2 = a2.charCodeAt(7);
      jspb.utils.split64Low = b2 + (c2 << 8) + (d2 << 16) + (e2 << 24) >>> 0;
      jspb.utils.split64High = f2 + (g << 8) + (h << 16) + (a2 << 24) >>> 0;
    };
    jspb.utils.joinUint64 = function(a2, b2) {
      return b2 * jspb.BinaryConstants.TWO_TO_32 + (a2 >>> 0);
    };
    jspb.utils.joinInt64 = function(a2, b2) {
      var c2 = b2 & 2147483648;
      c2 && (a2 = ~a2 + 1 >>> 0, b2 = ~b2 >>> 0, 0 == a2 && (b2 = b2 + 1 >>> 0));
      a2 = jspb.utils.joinUint64(a2, b2);
      return c2 ? -a2 : a2;
    };
    jspb.utils.toZigzag64 = function(a2, b2, c2) {
      var d2 = b2 >> 31;
      return c2(a2 << 1 ^ d2, (b2 << 1 | a2 >>> 31) ^ d2);
    };
    jspb.utils.joinZigzag64 = function(a2, b2) {
      return jspb.utils.fromZigzag64(a2, b2, jspb.utils.joinInt64);
    };
    jspb.utils.fromZigzag64 = function(a2, b2, c2) {
      var d2 = -(a2 & 1);
      return c2((a2 >>> 1 | b2 << 31) ^ d2, b2 >>> 1 ^ d2);
    };
    jspb.utils.joinFloat32 = function(a2, b2) {
      b2 = 2 * (a2 >> 31) + 1;
      var c2 = a2 >>> 23 & 255;
      a2 &= 8388607;
      return 255 == c2 ? a2 ? NaN : Infinity * b2 : 0 == c2 ? b2 * Math.pow(2, -149) * a2 : b2 * Math.pow(2, c2 - 150) * (a2 + Math.pow(2, 23));
    };
    jspb.utils.joinFloat64 = function(a2, b2) {
      var c2 = 2 * (b2 >> 31) + 1, d2 = b2 >>> 20 & 2047;
      a2 = jspb.BinaryConstants.TWO_TO_32 * (b2 & 1048575) + a2;
      return 2047 == d2 ? a2 ? NaN : Infinity * c2 : 0 == d2 ? c2 * Math.pow(2, -1074) * a2 : c2 * Math.pow(2, d2 - 1075) * (a2 + jspb.BinaryConstants.TWO_TO_52);
    };
    jspb.utils.joinHash64 = function(a2, b2) {
      return String.fromCharCode(a2 >>> 0 & 255, a2 >>> 8 & 255, a2 >>> 16 & 255, a2 >>> 24 & 255, b2 >>> 0 & 255, b2 >>> 8 & 255, b2 >>> 16 & 255, b2 >>> 24 & 255);
    };
    jspb.utils.DIGITS = "0123456789abcdef".split("");
    jspb.utils.ZERO_CHAR_CODE_ = 48;
    jspb.utils.A_CHAR_CODE_ = 97;
    jspb.utils.joinUnsignedDecimalString = function(a2, b2) {
      function c2(a3, b3) {
        a3 = a3 ? String(a3) : "";
        return b3 ? "0000000".slice(a3.length) + a3 : a3;
      }
      if (2097151 >= b2)
        return "" + jspb.utils.joinUint64(a2, b2);
      var d2 = (a2 >>> 24 | b2 << 8) >>> 0 & 16777215;
      b2 = b2 >> 16 & 65535;
      a2 = (a2 & 16777215) + 6777216 * d2 + 6710656 * b2;
      d2 += 8147497 * b2;
      b2 *= 2;
      1e7 <= a2 && (d2 += Math.floor(a2 / 1e7), a2 %= 1e7);
      1e7 <= d2 && (b2 += Math.floor(d2 / 1e7), d2 %= 1e7);
      return c2(b2, 0) + c2(d2, b2) + c2(a2, 1);
    };
    jspb.utils.joinSignedDecimalString = function(a2, b2) {
      var c2 = b2 & 2147483648;
      c2 && (a2 = ~a2 + 1 >>> 0, b2 = ~b2 + (0 == a2 ? 1 : 0) >>> 0);
      a2 = jspb.utils.joinUnsignedDecimalString(a2, b2);
      return c2 ? "-" + a2 : a2;
    };
    jspb.utils.hash64ToDecimalString = function(a2, b2) {
      jspb.utils.splitHash64(a2);
      a2 = jspb.utils.split64Low;
      var c2 = jspb.utils.split64High;
      return b2 ? jspb.utils.joinSignedDecimalString(a2, c2) : jspb.utils.joinUnsignedDecimalString(a2, c2);
    };
    jspb.utils.hash64ArrayToDecimalStrings = function(a2, b2) {
      for (var c2 = Array(a2.length), d2 = 0; d2 < a2.length; d2++)
        c2[d2] = jspb.utils.hash64ToDecimalString(a2[d2], b2);
      return c2;
    };
    jspb.utils.decimalStringToHash64 = function(a2) {
      function b2(a3, b3) {
        for (var c3 = 0; 8 > c3 && (1 !== a3 || 0 < b3); c3++)
          b3 = a3 * e2[c3] + b3, e2[c3] = b3 & 255, b3 >>>= 8;
      }
      function c2() {
        for (var a3 = 0; 8 > a3; a3++)
          e2[a3] = ~e2[a3] & 255;
      }
      jspb.asserts.assert(0 < a2.length);
      var d2 = false;
      "-" === a2[0] && (d2 = true, a2 = a2.slice(1));
      for (var e2 = [0, 0, 0, 0, 0, 0, 0, 0], f2 = 0; f2 < a2.length; f2++)
        b2(10, a2.charCodeAt(f2) - jspb.utils.ZERO_CHAR_CODE_);
      d2 && (c2(), b2(1, 1));
      return goog.crypt.byteArrayToString(e2);
    };
    jspb.utils.splitDecimalString = function(a2) {
      jspb.utils.splitHash64(jspb.utils.decimalStringToHash64(a2));
    };
    jspb.utils.toHexDigit_ = function(a2) {
      return String.fromCharCode(10 > a2 ? jspb.utils.ZERO_CHAR_CODE_ + a2 : jspb.utils.A_CHAR_CODE_ - 10 + a2);
    };
    jspb.utils.fromHexCharCode_ = function(a2) {
      return a2 >= jspb.utils.A_CHAR_CODE_ ? a2 - jspb.utils.A_CHAR_CODE_ + 10 : a2 - jspb.utils.ZERO_CHAR_CODE_;
    };
    jspb.utils.hash64ToHexString = function(a2) {
      var b2 = Array(18);
      b2[0] = "0";
      b2[1] = "x";
      for (var c2 = 0; 8 > c2; c2++) {
        var d2 = a2.charCodeAt(7 - c2);
        b2[2 * c2 + 2] = jspb.utils.toHexDigit_(d2 >> 4);
        b2[2 * c2 + 3] = jspb.utils.toHexDigit_(d2 & 15);
      }
      return b2.join("");
    };
    jspb.utils.hexStringToHash64 = function(a2) {
      a2 = a2.toLowerCase();
      jspb.asserts.assert(18 == a2.length);
      jspb.asserts.assert("0" == a2[0]);
      jspb.asserts.assert("x" == a2[1]);
      for (var b2 = "", c2 = 0; 8 > c2; c2++) {
        var d2 = jspb.utils.fromHexCharCode_(a2.charCodeAt(2 * c2 + 2)), e2 = jspb.utils.fromHexCharCode_(a2.charCodeAt(2 * c2 + 3));
        b2 = String.fromCharCode(16 * d2 + e2) + b2;
      }
      return b2;
    };
    jspb.utils.hash64ToNumber = function(a2, b2) {
      jspb.utils.splitHash64(a2);
      a2 = jspb.utils.split64Low;
      var c2 = jspb.utils.split64High;
      return b2 ? jspb.utils.joinInt64(a2, c2) : jspb.utils.joinUint64(a2, c2);
    };
    jspb.utils.numberToHash64 = function(a2) {
      jspb.utils.splitInt64(a2);
      return jspb.utils.joinHash64(jspb.utils.split64Low, jspb.utils.split64High);
    };
    jspb.utils.countVarints = function(a2, b2, c2) {
      for (var d2 = 0, e2 = b2; e2 < c2; e2++)
        d2 += a2[e2] >> 7;
      return c2 - b2 - d2;
    };
    jspb.utils.countVarintFields = function(a2, b2, c2, d2) {
      var e2 = 0;
      d2 = 8 * d2 + jspb.BinaryConstants.WireType.VARINT;
      if (128 > d2)
        for (; b2 < c2 && a2[b2++] == d2; )
          for (e2++; ; ) {
            var f2 = a2[b2++];
            if (0 == (f2 & 128))
              break;
          }
      else
        for (; b2 < c2; ) {
          for (f2 = d2; 128 < f2; ) {
            if (a2[b2] != (f2 & 127 | 128))
              return e2;
            b2++;
            f2 >>= 7;
          }
          if (a2[b2++] != f2)
            break;
          for (e2++; f2 = a2[b2++], 0 != (f2 & 128); )
            ;
        }
      return e2;
    };
    jspb.utils.countFixedFields_ = function(a2, b2, c2, d2, e2) {
      var f2 = 0;
      if (128 > d2)
        for (; b2 < c2 && a2[b2++] == d2; )
          f2++, b2 += e2;
      else
        for (; b2 < c2; ) {
          for (var g = d2; 128 < g; ) {
            if (a2[b2++] != (g & 127 | 128))
              return f2;
            g >>= 7;
          }
          if (a2[b2++] != g)
            break;
          f2++;
          b2 += e2;
        }
      return f2;
    };
    jspb.utils.countFixed32Fields = function(a2, b2, c2, d2) {
      return jspb.utils.countFixedFields_(a2, b2, c2, 8 * d2 + jspb.BinaryConstants.WireType.FIXED32, 4);
    };
    jspb.utils.countFixed64Fields = function(a2, b2, c2, d2) {
      return jspb.utils.countFixedFields_(a2, b2, c2, 8 * d2 + jspb.BinaryConstants.WireType.FIXED64, 8);
    };
    jspb.utils.countDelimitedFields = function(a2, b2, c2, d2) {
      var e2 = 0;
      for (d2 = 8 * d2 + jspb.BinaryConstants.WireType.DELIMITED; b2 < c2; ) {
        for (var f2 = d2; 128 < f2; ) {
          if (a2[b2++] != (f2 & 127 | 128))
            return e2;
          f2 >>= 7;
        }
        if (a2[b2++] != f2)
          break;
        e2++;
        for (var g = 0, h = 1; f2 = a2[b2++], g += (f2 & 127) * h, h *= 128, 0 != (f2 & 128); )
          ;
        b2 += g;
      }
      return e2;
    };
    jspb.utils.debugBytesToTextFormat = function(a2) {
      var b2 = '"';
      if (a2) {
        a2 = jspb.utils.byteSourceToUint8Array(a2);
        for (var c2 = 0; c2 < a2.length; c2++)
          b2 += "\\x", 16 > a2[c2] && (b2 += "0"), b2 += a2[c2].toString(16);
      }
      return b2 + '"';
    };
    jspb.utils.debugScalarToTextFormat = function(a2) {
      return "string" === typeof a2 ? goog.string.quote(a2) : a2.toString();
    };
    jspb.utils.stringToByteArray = function(a2) {
      for (var b2 = new Uint8Array(a2.length), c2 = 0; c2 < a2.length; c2++) {
        var d2 = a2.charCodeAt(c2);
        if (255 < d2)
          throw Error("Conversion error: string contains codepoint outside of byte range");
        b2[c2] = d2;
      }
      return b2;
    };
    jspb.utils.byteSourceToUint8Array = function(a2) {
      if (a2.constructor === Uint8Array)
        return a2;
      if (a2.constructor === ArrayBuffer || a2.constructor === Array)
        return new Uint8Array(a2);
      if (a2.constructor === String)
        return goog.crypt.base64.decodeStringToUint8Array(a2);
      if (a2 instanceof Uint8Array)
        return new Uint8Array(a2.buffer, a2.byteOffset, a2.byteLength);
      jspb.asserts.fail("Type not convertible to Uint8Array.");
      return new Uint8Array(0);
    };
    jspb.BinaryDecoder = function(a2, b2, c2) {
      this.bytes_ = null;
      this.cursor_ = this.end_ = this.start_ = 0;
      this.error_ = false;
      a2 && this.setBlock(a2, b2, c2);
    };
    jspb.BinaryDecoder.instanceCache_ = [];
    jspb.BinaryDecoder.alloc = function(a2, b2, c2) {
      if (jspb.BinaryDecoder.instanceCache_.length) {
        var d2 = jspb.BinaryDecoder.instanceCache_.pop();
        a2 && d2.setBlock(a2, b2, c2);
        return d2;
      }
      return new jspb.BinaryDecoder(a2, b2, c2);
    };
    jspb.BinaryDecoder.prototype.free = function() {
      this.clear();
      100 > jspb.BinaryDecoder.instanceCache_.length && jspb.BinaryDecoder.instanceCache_.push(this);
    };
    jspb.BinaryDecoder.prototype.clone = function() {
      return jspb.BinaryDecoder.alloc(this.bytes_, this.start_, this.end_ - this.start_);
    };
    jspb.BinaryDecoder.prototype.clear = function() {
      this.bytes_ = null;
      this.cursor_ = this.end_ = this.start_ = 0;
      this.error_ = false;
    };
    jspb.BinaryDecoder.prototype.getBuffer = function() {
      return this.bytes_;
    };
    jspb.BinaryDecoder.prototype.setBlock = function(a2, b2, c2) {
      this.bytes_ = jspb.utils.byteSourceToUint8Array(a2);
      this.start_ = void 0 !== b2 ? b2 : 0;
      this.end_ = void 0 !== c2 ? this.start_ + c2 : this.bytes_.length;
      this.cursor_ = this.start_;
    };
    jspb.BinaryDecoder.prototype.getEnd = function() {
      return this.end_;
    };
    jspb.BinaryDecoder.prototype.setEnd = function(a2) {
      this.end_ = a2;
    };
    jspb.BinaryDecoder.prototype.reset = function() {
      this.cursor_ = this.start_;
    };
    jspb.BinaryDecoder.prototype.getCursor = function() {
      return this.cursor_;
    };
    jspb.BinaryDecoder.prototype.setCursor = function(a2) {
      this.cursor_ = a2;
    };
    jspb.BinaryDecoder.prototype.advance = function(a2) {
      this.cursor_ += a2;
      jspb.asserts.assert(this.cursor_ <= this.end_);
    };
    jspb.BinaryDecoder.prototype.atEnd = function() {
      return this.cursor_ == this.end_;
    };
    jspb.BinaryDecoder.prototype.pastEnd = function() {
      return this.cursor_ > this.end_;
    };
    jspb.BinaryDecoder.prototype.getError = function() {
      return this.error_ || 0 > this.cursor_ || this.cursor_ > this.end_;
    };
    jspb.BinaryDecoder.prototype.readSplitVarint64 = function(a2) {
      for (var b2 = 128, c2 = 0, d2 = 0, e2 = 0; 4 > e2 && 128 <= b2; e2++)
        b2 = this.bytes_[this.cursor_++], c2 |= (b2 & 127) << 7 * e2;
      128 <= b2 && (b2 = this.bytes_[this.cursor_++], c2 |= (b2 & 127) << 28, d2 |= (b2 & 127) >> 4);
      if (128 <= b2)
        for (e2 = 0; 5 > e2 && 128 <= b2; e2++)
          b2 = this.bytes_[this.cursor_++], d2 |= (b2 & 127) << 7 * e2 + 3;
      if (128 > b2)
        return a2(c2 >>> 0, d2 >>> 0);
      jspb.asserts.fail("Failed to read varint, encoding is invalid.");
      this.error_ = true;
    };
    jspb.BinaryDecoder.prototype.readSplitZigzagVarint64 = function(a2) {
      return this.readSplitVarint64(function(b2, c2) {
        return jspb.utils.fromZigzag64(b2, c2, a2);
      });
    };
    jspb.BinaryDecoder.prototype.readSplitFixed64 = function(a2) {
      var b2 = this.bytes_, c2 = this.cursor_;
      this.cursor_ += 8;
      for (var d2 = 0, e2 = 0, f2 = c2 + 7; f2 >= c2; f2--)
        d2 = d2 << 8 | b2[f2], e2 = e2 << 8 | b2[f2 + 4];
      return a2(d2, e2);
    };
    jspb.BinaryDecoder.prototype.skipVarint = function() {
      for (; this.bytes_[this.cursor_] & 128; )
        this.cursor_++;
      this.cursor_++;
    };
    jspb.BinaryDecoder.prototype.unskipVarint = function(a2) {
      for (; 128 < a2; )
        this.cursor_--, a2 >>>= 7;
      this.cursor_--;
    };
    jspb.BinaryDecoder.prototype.readUnsignedVarint32 = function() {
      var a2 = this.bytes_;
      var b2 = a2[this.cursor_ + 0];
      var c2 = b2 & 127;
      if (128 > b2)
        return this.cursor_ += 1, jspb.asserts.assert(this.cursor_ <= this.end_), c2;
      b2 = a2[this.cursor_ + 1];
      c2 |= (b2 & 127) << 7;
      if (128 > b2)
        return this.cursor_ += 2, jspb.asserts.assert(this.cursor_ <= this.end_), c2;
      b2 = a2[this.cursor_ + 2];
      c2 |= (b2 & 127) << 14;
      if (128 > b2)
        return this.cursor_ += 3, jspb.asserts.assert(this.cursor_ <= this.end_), c2;
      b2 = a2[this.cursor_ + 3];
      c2 |= (b2 & 127) << 21;
      if (128 > b2)
        return this.cursor_ += 4, jspb.asserts.assert(this.cursor_ <= this.end_), c2;
      b2 = a2[this.cursor_ + 4];
      c2 |= (b2 & 15) << 28;
      if (128 > b2)
        return this.cursor_ += 5, jspb.asserts.assert(this.cursor_ <= this.end_), c2 >>> 0;
      this.cursor_ += 5;
      128 <= a2[this.cursor_++] && 128 <= a2[this.cursor_++] && 128 <= a2[this.cursor_++] && 128 <= a2[this.cursor_++] && 128 <= a2[this.cursor_++] && jspb.asserts.assert(false);
      jspb.asserts.assert(this.cursor_ <= this.end_);
      return c2;
    };
    jspb.BinaryDecoder.prototype.readSignedVarint32 = function() {
      return ~~this.readUnsignedVarint32();
    };
    jspb.BinaryDecoder.prototype.readUnsignedVarint32String = function() {
      return this.readUnsignedVarint32().toString();
    };
    jspb.BinaryDecoder.prototype.readSignedVarint32String = function() {
      return this.readSignedVarint32().toString();
    };
    jspb.BinaryDecoder.prototype.readZigzagVarint32 = function() {
      var a2 = this.readUnsignedVarint32();
      return a2 >>> 1 ^ -(a2 & 1);
    };
    jspb.BinaryDecoder.prototype.readUnsignedVarint64 = function() {
      return this.readSplitVarint64(jspb.utils.joinUint64);
    };
    jspb.BinaryDecoder.prototype.readUnsignedVarint64String = function() {
      return this.readSplitVarint64(jspb.utils.joinUnsignedDecimalString);
    };
    jspb.BinaryDecoder.prototype.readSignedVarint64 = function() {
      return this.readSplitVarint64(jspb.utils.joinInt64);
    };
    jspb.BinaryDecoder.prototype.readSignedVarint64String = function() {
      return this.readSplitVarint64(jspb.utils.joinSignedDecimalString);
    };
    jspb.BinaryDecoder.prototype.readZigzagVarint64 = function() {
      return this.readSplitVarint64(jspb.utils.joinZigzag64);
    };
    jspb.BinaryDecoder.prototype.readZigzagVarintHash64 = function() {
      return this.readSplitZigzagVarint64(jspb.utils.joinHash64);
    };
    jspb.BinaryDecoder.prototype.readZigzagVarint64String = function() {
      return this.readSplitZigzagVarint64(jspb.utils.joinSignedDecimalString);
    };
    jspb.BinaryDecoder.prototype.readUint8 = function() {
      var a2 = this.bytes_[this.cursor_ + 0];
      this.cursor_ += 1;
      jspb.asserts.assert(this.cursor_ <= this.end_);
      return a2;
    };
    jspb.BinaryDecoder.prototype.readUint16 = function() {
      var a2 = this.bytes_[this.cursor_ + 0], b2 = this.bytes_[this.cursor_ + 1];
      this.cursor_ += 2;
      jspb.asserts.assert(this.cursor_ <= this.end_);
      return a2 << 0 | b2 << 8;
    };
    jspb.BinaryDecoder.prototype.readUint32 = function() {
      var a2 = this.bytes_[this.cursor_ + 0], b2 = this.bytes_[this.cursor_ + 1], c2 = this.bytes_[this.cursor_ + 2], d2 = this.bytes_[this.cursor_ + 3];
      this.cursor_ += 4;
      jspb.asserts.assert(this.cursor_ <= this.end_);
      return (a2 << 0 | b2 << 8 | c2 << 16 | d2 << 24) >>> 0;
    };
    jspb.BinaryDecoder.prototype.readUint64 = function() {
      var a2 = this.readUint32(), b2 = this.readUint32();
      return jspb.utils.joinUint64(a2, b2);
    };
    jspb.BinaryDecoder.prototype.readUint64String = function() {
      var a2 = this.readUint32(), b2 = this.readUint32();
      return jspb.utils.joinUnsignedDecimalString(a2, b2);
    };
    jspb.BinaryDecoder.prototype.readInt8 = function() {
      var a2 = this.bytes_[this.cursor_ + 0];
      this.cursor_ += 1;
      jspb.asserts.assert(this.cursor_ <= this.end_);
      return a2 << 24 >> 24;
    };
    jspb.BinaryDecoder.prototype.readInt16 = function() {
      var a2 = this.bytes_[this.cursor_ + 0], b2 = this.bytes_[this.cursor_ + 1];
      this.cursor_ += 2;
      jspb.asserts.assert(this.cursor_ <= this.end_);
      return (a2 << 0 | b2 << 8) << 16 >> 16;
    };
    jspb.BinaryDecoder.prototype.readInt32 = function() {
      var a2 = this.bytes_[this.cursor_ + 0], b2 = this.bytes_[this.cursor_ + 1], c2 = this.bytes_[this.cursor_ + 2], d2 = this.bytes_[this.cursor_ + 3];
      this.cursor_ += 4;
      jspb.asserts.assert(this.cursor_ <= this.end_);
      return a2 << 0 | b2 << 8 | c2 << 16 | d2 << 24;
    };
    jspb.BinaryDecoder.prototype.readInt64 = function() {
      var a2 = this.readUint32(), b2 = this.readUint32();
      return jspb.utils.joinInt64(a2, b2);
    };
    jspb.BinaryDecoder.prototype.readInt64String = function() {
      var a2 = this.readUint32(), b2 = this.readUint32();
      return jspb.utils.joinSignedDecimalString(a2, b2);
    };
    jspb.BinaryDecoder.prototype.readFloat = function() {
      var a2 = this.readUint32();
      return jspb.utils.joinFloat32(a2, 0);
    };
    jspb.BinaryDecoder.prototype.readDouble = function() {
      var a2 = this.readUint32(), b2 = this.readUint32();
      return jspb.utils.joinFloat64(a2, b2);
    };
    jspb.BinaryDecoder.prototype.readBool = function() {
      return !!this.bytes_[this.cursor_++];
    };
    jspb.BinaryDecoder.prototype.readEnum = function() {
      return this.readSignedVarint32();
    };
    jspb.BinaryDecoder.prototype.readString = function(a2) {
      var b2 = this.bytes_, c2 = this.cursor_;
      a2 = c2 + a2;
      for (var d2 = [], e2 = ""; c2 < a2; ) {
        var f2 = b2[c2++];
        if (128 > f2)
          d2.push(f2);
        else if (192 > f2)
          continue;
        else if (224 > f2) {
          var g = b2[c2++];
          d2.push((f2 & 31) << 6 | g & 63);
        } else if (240 > f2) {
          g = b2[c2++];
          var h = b2[c2++];
          d2.push((f2 & 15) << 12 | (g & 63) << 6 | h & 63);
        } else if (248 > f2) {
          g = b2[c2++];
          h = b2[c2++];
          var k = b2[c2++];
          f2 = (f2 & 7) << 18 | (g & 63) << 12 | (h & 63) << 6 | k & 63;
          f2 -= 65536;
          d2.push((f2 >> 10 & 1023) + 55296, (f2 & 1023) + 56320);
        }
        8192 <= d2.length && (e2 += String.fromCharCode.apply(null, d2), d2.length = 0);
      }
      e2 += goog.crypt.byteArrayToString(d2);
      this.cursor_ = c2;
      return e2;
    };
    jspb.BinaryDecoder.prototype.readStringWithLength = function() {
      var a2 = this.readUnsignedVarint32();
      return this.readString(a2);
    };
    jspb.BinaryDecoder.prototype.readBytes = function(a2) {
      if (0 > a2 || this.cursor_ + a2 > this.bytes_.length)
        return this.error_ = true, jspb.asserts.fail("Invalid byte length!"), new Uint8Array(0);
      var b2 = this.bytes_.subarray(this.cursor_, this.cursor_ + a2);
      this.cursor_ += a2;
      jspb.asserts.assert(this.cursor_ <= this.end_);
      return b2;
    };
    jspb.BinaryDecoder.prototype.readVarintHash64 = function() {
      return this.readSplitVarint64(jspb.utils.joinHash64);
    };
    jspb.BinaryDecoder.prototype.readFixedHash64 = function() {
      var a2 = this.bytes_, b2 = this.cursor_, c2 = a2[b2 + 0], d2 = a2[b2 + 1], e2 = a2[b2 + 2], f2 = a2[b2 + 3], g = a2[b2 + 4], h = a2[b2 + 5], k = a2[b2 + 6];
      a2 = a2[b2 + 7];
      this.cursor_ += 8;
      return String.fromCharCode(c2, d2, e2, f2, g, h, k, a2);
    };
    jspb.BinaryReader = function(a2, b2, c2) {
      this.decoder_ = jspb.BinaryDecoder.alloc(a2, b2, c2);
      this.fieldCursor_ = this.decoder_.getCursor();
      this.nextField_ = jspb.BinaryConstants.INVALID_FIELD_NUMBER;
      this.nextWireType_ = jspb.BinaryConstants.WireType.INVALID;
      this.error_ = false;
      this.readCallbacks_ = null;
    };
    jspb.BinaryReader.instanceCache_ = [];
    jspb.BinaryReader.alloc = function(a2, b2, c2) {
      if (jspb.BinaryReader.instanceCache_.length) {
        var d2 = jspb.BinaryReader.instanceCache_.pop();
        a2 && d2.decoder_.setBlock(a2, b2, c2);
        return d2;
      }
      return new jspb.BinaryReader(a2, b2, c2);
    };
    jspb.BinaryReader.prototype.alloc = jspb.BinaryReader.alloc;
    jspb.BinaryReader.prototype.free = function() {
      this.decoder_.clear();
      this.nextField_ = jspb.BinaryConstants.INVALID_FIELD_NUMBER;
      this.nextWireType_ = jspb.BinaryConstants.WireType.INVALID;
      this.error_ = false;
      this.readCallbacks_ = null;
      100 > jspb.BinaryReader.instanceCache_.length && jspb.BinaryReader.instanceCache_.push(this);
    };
    jspb.BinaryReader.prototype.getFieldCursor = function() {
      return this.fieldCursor_;
    };
    jspb.BinaryReader.prototype.getCursor = function() {
      return this.decoder_.getCursor();
    };
    jspb.BinaryReader.prototype.getBuffer = function() {
      return this.decoder_.getBuffer();
    };
    jspb.BinaryReader.prototype.getFieldNumber = function() {
      return this.nextField_;
    };
    goog.exportProperty(jspb.BinaryReader.prototype, "getFieldNumber", jspb.BinaryReader.prototype.getFieldNumber);
    jspb.BinaryReader.prototype.getWireType = function() {
      return this.nextWireType_;
    };
    jspb.BinaryReader.prototype.isDelimited = function() {
      return this.nextWireType_ == jspb.BinaryConstants.WireType.DELIMITED;
    };
    goog.exportProperty(jspb.BinaryReader.prototype, "isDelimited", jspb.BinaryReader.prototype.isDelimited);
    jspb.BinaryReader.prototype.isEndGroup = function() {
      return this.nextWireType_ == jspb.BinaryConstants.WireType.END_GROUP;
    };
    goog.exportProperty(jspb.BinaryReader.prototype, "isEndGroup", jspb.BinaryReader.prototype.isEndGroup);
    jspb.BinaryReader.prototype.getError = function() {
      return this.error_ || this.decoder_.getError();
    };
    jspb.BinaryReader.prototype.setBlock = function(a2, b2, c2) {
      this.decoder_.setBlock(a2, b2, c2);
      this.nextField_ = jspb.BinaryConstants.INVALID_FIELD_NUMBER;
      this.nextWireType_ = jspb.BinaryConstants.WireType.INVALID;
    };
    jspb.BinaryReader.prototype.reset = function() {
      this.decoder_.reset();
      this.nextField_ = jspb.BinaryConstants.INVALID_FIELD_NUMBER;
      this.nextWireType_ = jspb.BinaryConstants.WireType.INVALID;
    };
    jspb.BinaryReader.prototype.advance = function(a2) {
      this.decoder_.advance(a2);
    };
    jspb.BinaryReader.prototype.nextField = function() {
      if (this.decoder_.atEnd())
        return false;
      if (this.getError())
        return jspb.asserts.fail("Decoder hit an error"), false;
      this.fieldCursor_ = this.decoder_.getCursor();
      var a2 = this.decoder_.readUnsignedVarint32(), b2 = a2 >>> 3;
      a2 &= 7;
      if (a2 != jspb.BinaryConstants.WireType.VARINT && a2 != jspb.BinaryConstants.WireType.FIXED32 && a2 != jspb.BinaryConstants.WireType.FIXED64 && a2 != jspb.BinaryConstants.WireType.DELIMITED && a2 != jspb.BinaryConstants.WireType.START_GROUP && a2 != jspb.BinaryConstants.WireType.END_GROUP)
        return jspb.asserts.fail(
          "Invalid wire type: %s (at position %s)",
          a2,
          this.fieldCursor_
        ), this.error_ = true, false;
      this.nextField_ = b2;
      this.nextWireType_ = a2;
      return true;
    };
    goog.exportProperty(jspb.BinaryReader.prototype, "nextField", jspb.BinaryReader.prototype.nextField);
    jspb.BinaryReader.prototype.unskipHeader = function() {
      this.decoder_.unskipVarint(this.nextField_ << 3 | this.nextWireType_);
    };
    jspb.BinaryReader.prototype.skipMatchingFields = function() {
      var a2 = this.nextField_;
      for (this.unskipHeader(); this.nextField() && this.getFieldNumber() == a2; )
        this.skipField();
      this.decoder_.atEnd() || this.unskipHeader();
    };
    jspb.BinaryReader.prototype.skipVarintField = function() {
      this.nextWireType_ != jspb.BinaryConstants.WireType.VARINT ? (jspb.asserts.fail("Invalid wire type for skipVarintField"), this.skipField()) : this.decoder_.skipVarint();
    };
    jspb.BinaryReader.prototype.skipDelimitedField = function() {
      if (this.nextWireType_ != jspb.BinaryConstants.WireType.DELIMITED)
        jspb.asserts.fail("Invalid wire type for skipDelimitedField"), this.skipField();
      else {
        var a2 = this.decoder_.readUnsignedVarint32();
        this.decoder_.advance(a2);
      }
    };
    jspb.BinaryReader.prototype.skipFixed32Field = function() {
      this.nextWireType_ != jspb.BinaryConstants.WireType.FIXED32 ? (jspb.asserts.fail("Invalid wire type for skipFixed32Field"), this.skipField()) : this.decoder_.advance(4);
    };
    jspb.BinaryReader.prototype.skipFixed64Field = function() {
      this.nextWireType_ != jspb.BinaryConstants.WireType.FIXED64 ? (jspb.asserts.fail("Invalid wire type for skipFixed64Field"), this.skipField()) : this.decoder_.advance(8);
    };
    jspb.BinaryReader.prototype.skipGroup = function() {
      var a2 = this.nextField_;
      do {
        if (!this.nextField()) {
          jspb.asserts.fail("Unmatched start-group tag: stream EOF");
          this.error_ = true;
          break;
        }
        if (this.nextWireType_ == jspb.BinaryConstants.WireType.END_GROUP) {
          this.nextField_ != a2 && (jspb.asserts.fail("Unmatched end-group tag"), this.error_ = true);
          break;
        }
        this.skipField();
      } while (1);
    };
    jspb.BinaryReader.prototype.skipField = function() {
      switch (this.nextWireType_) {
        case jspb.BinaryConstants.WireType.VARINT:
          this.skipVarintField();
          break;
        case jspb.BinaryConstants.WireType.FIXED64:
          this.skipFixed64Field();
          break;
        case jspb.BinaryConstants.WireType.DELIMITED:
          this.skipDelimitedField();
          break;
        case jspb.BinaryConstants.WireType.FIXED32:
          this.skipFixed32Field();
          break;
        case jspb.BinaryConstants.WireType.START_GROUP:
          this.skipGroup();
          break;
        default:
          jspb.asserts.fail("Invalid wire encoding for field.");
      }
    };
    jspb.BinaryReader.prototype.registerReadCallback = function(a2, b2) {
      null === this.readCallbacks_ && (this.readCallbacks_ = {});
      jspb.asserts.assert(!this.readCallbacks_[a2]);
      this.readCallbacks_[a2] = b2;
    };
    jspb.BinaryReader.prototype.runReadCallback = function(a2) {
      jspb.asserts.assert(null !== this.readCallbacks_);
      a2 = this.readCallbacks_[a2];
      jspb.asserts.assert(a2);
      return a2(this);
    };
    jspb.BinaryReader.prototype.readAny = function(a2) {
      this.nextWireType_ = jspb.BinaryConstants.FieldTypeToWireType(a2);
      var b2 = jspb.BinaryConstants.FieldType;
      switch (a2) {
        case b2.DOUBLE:
          return this.readDouble();
        case b2.FLOAT:
          return this.readFloat();
        case b2.INT64:
          return this.readInt64();
        case b2.UINT64:
          return this.readUint64();
        case b2.INT32:
          return this.readInt32();
        case b2.FIXED64:
          return this.readFixed64();
        case b2.FIXED32:
          return this.readFixed32();
        case b2.BOOL:
          return this.readBool();
        case b2.STRING:
          return this.readString();
        case b2.GROUP:
          jspb.asserts.fail("Group field type not supported in readAny()");
        case b2.MESSAGE:
          jspb.asserts.fail("Message field type not supported in readAny()");
        case b2.BYTES:
          return this.readBytes();
        case b2.UINT32:
          return this.readUint32();
        case b2.ENUM:
          return this.readEnum();
        case b2.SFIXED32:
          return this.readSfixed32();
        case b2.SFIXED64:
          return this.readSfixed64();
        case b2.SINT32:
          return this.readSint32();
        case b2.SINT64:
          return this.readSint64();
        case b2.FHASH64:
          return this.readFixedHash64();
        case b2.VHASH64:
          return this.readVarintHash64();
        default:
          jspb.asserts.fail("Invalid field type in readAny()");
      }
      return 0;
    };
    jspb.BinaryReader.prototype.readMessage = function(a2, b2) {
      jspb.asserts.assert(this.nextWireType_ == jspb.BinaryConstants.WireType.DELIMITED);
      var c2 = this.decoder_.getEnd(), d2 = this.decoder_.readUnsignedVarint32();
      d2 = this.decoder_.getCursor() + d2;
      this.decoder_.setEnd(d2);
      b2(a2, this);
      this.decoder_.setCursor(d2);
      this.decoder_.setEnd(c2);
    };
    goog.exportProperty(jspb.BinaryReader.prototype, "readMessage", jspb.BinaryReader.prototype.readMessage);
    jspb.BinaryReader.prototype.readGroup = function(a2, b2, c2) {
      jspb.asserts.assert(this.nextWireType_ == jspb.BinaryConstants.WireType.START_GROUP);
      jspb.asserts.assert(this.nextField_ == a2);
      c2(b2, this);
      this.error_ || this.nextWireType_ == jspb.BinaryConstants.WireType.END_GROUP || (jspb.asserts.fail("Group submessage did not end with an END_GROUP tag"), this.error_ = true);
    };
    goog.exportProperty(jspb.BinaryReader.prototype, "readGroup", jspb.BinaryReader.prototype.readGroup);
    jspb.BinaryReader.prototype.getFieldDecoder = function() {
      jspb.asserts.assert(this.nextWireType_ == jspb.BinaryConstants.WireType.DELIMITED);
      var a2 = this.decoder_.readUnsignedVarint32(), b2 = this.decoder_.getCursor(), c2 = b2 + a2;
      a2 = jspb.BinaryDecoder.alloc(this.decoder_.getBuffer(), b2, a2);
      this.decoder_.setCursor(c2);
      return a2;
    };
    jspb.BinaryReader.prototype.readInt32 = function() {
      jspb.asserts.assert(this.nextWireType_ == jspb.BinaryConstants.WireType.VARINT);
      return this.decoder_.readSignedVarint32();
    };
    goog.exportProperty(jspb.BinaryReader.prototype, "readInt32", jspb.BinaryReader.prototype.readInt32);
    jspb.BinaryReader.prototype.readInt32String = function() {
      jspb.asserts.assert(this.nextWireType_ == jspb.BinaryConstants.WireType.VARINT);
      return this.decoder_.readSignedVarint32String();
    };
    jspb.BinaryReader.prototype.readInt64 = function() {
      jspb.asserts.assert(this.nextWireType_ == jspb.BinaryConstants.WireType.VARINT);
      return this.decoder_.readSignedVarint64();
    };
    goog.exportProperty(jspb.BinaryReader.prototype, "readInt64", jspb.BinaryReader.prototype.readInt64);
    jspb.BinaryReader.prototype.readInt64String = function() {
      jspb.asserts.assert(this.nextWireType_ == jspb.BinaryConstants.WireType.VARINT);
      return this.decoder_.readSignedVarint64String();
    };
    jspb.BinaryReader.prototype.readUint32 = function() {
      jspb.asserts.assert(this.nextWireType_ == jspb.BinaryConstants.WireType.VARINT);
      return this.decoder_.readUnsignedVarint32();
    };
    goog.exportProperty(jspb.BinaryReader.prototype, "readUint32", jspb.BinaryReader.prototype.readUint32);
    jspb.BinaryReader.prototype.readUint32String = function() {
      jspb.asserts.assert(this.nextWireType_ == jspb.BinaryConstants.WireType.VARINT);
      return this.decoder_.readUnsignedVarint32String();
    };
    jspb.BinaryReader.prototype.readUint64 = function() {
      jspb.asserts.assert(this.nextWireType_ == jspb.BinaryConstants.WireType.VARINT);
      return this.decoder_.readUnsignedVarint64();
    };
    goog.exportProperty(jspb.BinaryReader.prototype, "readUint64", jspb.BinaryReader.prototype.readUint64);
    jspb.BinaryReader.prototype.readUint64String = function() {
      jspb.asserts.assert(this.nextWireType_ == jspb.BinaryConstants.WireType.VARINT);
      return this.decoder_.readUnsignedVarint64String();
    };
    jspb.BinaryReader.prototype.readSint32 = function() {
      jspb.asserts.assert(this.nextWireType_ == jspb.BinaryConstants.WireType.VARINT);
      return this.decoder_.readZigzagVarint32();
    };
    goog.exportProperty(jspb.BinaryReader.prototype, "readSint32", jspb.BinaryReader.prototype.readSint32);
    jspb.BinaryReader.prototype.readSint64 = function() {
      jspb.asserts.assert(this.nextWireType_ == jspb.BinaryConstants.WireType.VARINT);
      return this.decoder_.readZigzagVarint64();
    };
    goog.exportProperty(jspb.BinaryReader.prototype, "readSint64", jspb.BinaryReader.prototype.readSint64);
    jspb.BinaryReader.prototype.readSint64String = function() {
      jspb.asserts.assert(this.nextWireType_ == jspb.BinaryConstants.WireType.VARINT);
      return this.decoder_.readZigzagVarint64String();
    };
    jspb.BinaryReader.prototype.readFixed32 = function() {
      jspb.asserts.assert(this.nextWireType_ == jspb.BinaryConstants.WireType.FIXED32);
      return this.decoder_.readUint32();
    };
    goog.exportProperty(jspb.BinaryReader.prototype, "readFixed32", jspb.BinaryReader.prototype.readFixed32);
    jspb.BinaryReader.prototype.readFixed64 = function() {
      jspb.asserts.assert(this.nextWireType_ == jspb.BinaryConstants.WireType.FIXED64);
      return this.decoder_.readUint64();
    };
    goog.exportProperty(jspb.BinaryReader.prototype, "readFixed64", jspb.BinaryReader.prototype.readFixed64);
    jspb.BinaryReader.prototype.readFixed64String = function() {
      jspb.asserts.assert(this.nextWireType_ == jspb.BinaryConstants.WireType.FIXED64);
      return this.decoder_.readUint64String();
    };
    jspb.BinaryReader.prototype.readSfixed32 = function() {
      jspb.asserts.assert(this.nextWireType_ == jspb.BinaryConstants.WireType.FIXED32);
      return this.decoder_.readInt32();
    };
    goog.exportProperty(jspb.BinaryReader.prototype, "readSfixed32", jspb.BinaryReader.prototype.readSfixed32);
    jspb.BinaryReader.prototype.readSfixed32String = function() {
      jspb.asserts.assert(this.nextWireType_ == jspb.BinaryConstants.WireType.FIXED32);
      return this.decoder_.readInt32().toString();
    };
    jspb.BinaryReader.prototype.readSfixed64 = function() {
      jspb.asserts.assert(this.nextWireType_ == jspb.BinaryConstants.WireType.FIXED64);
      return this.decoder_.readInt64();
    };
    goog.exportProperty(jspb.BinaryReader.prototype, "readSfixed64", jspb.BinaryReader.prototype.readSfixed64);
    jspb.BinaryReader.prototype.readSfixed64String = function() {
      jspb.asserts.assert(this.nextWireType_ == jspb.BinaryConstants.WireType.FIXED64);
      return this.decoder_.readInt64String();
    };
    jspb.BinaryReader.prototype.readFloat = function() {
      jspb.asserts.assert(this.nextWireType_ == jspb.BinaryConstants.WireType.FIXED32);
      return this.decoder_.readFloat();
    };
    goog.exportProperty(jspb.BinaryReader.prototype, "readFloat", jspb.BinaryReader.prototype.readFloat);
    jspb.BinaryReader.prototype.readDouble = function() {
      jspb.asserts.assert(this.nextWireType_ == jspb.BinaryConstants.WireType.FIXED64);
      return this.decoder_.readDouble();
    };
    goog.exportProperty(jspb.BinaryReader.prototype, "readDouble", jspb.BinaryReader.prototype.readDouble);
    jspb.BinaryReader.prototype.readBool = function() {
      jspb.asserts.assert(this.nextWireType_ == jspb.BinaryConstants.WireType.VARINT);
      return !!this.decoder_.readUnsignedVarint32();
    };
    goog.exportProperty(jspb.BinaryReader.prototype, "readBool", jspb.BinaryReader.prototype.readBool);
    jspb.BinaryReader.prototype.readEnum = function() {
      jspb.asserts.assert(this.nextWireType_ == jspb.BinaryConstants.WireType.VARINT);
      return this.decoder_.readSignedVarint64();
    };
    goog.exportProperty(jspb.BinaryReader.prototype, "readEnum", jspb.BinaryReader.prototype.readEnum);
    jspb.BinaryReader.prototype.readString = function() {
      jspb.asserts.assert(this.nextWireType_ == jspb.BinaryConstants.WireType.DELIMITED);
      var a2 = this.decoder_.readUnsignedVarint32();
      return this.decoder_.readString(a2);
    };
    goog.exportProperty(jspb.BinaryReader.prototype, "readString", jspb.BinaryReader.prototype.readString);
    jspb.BinaryReader.prototype.readBytes = function() {
      jspb.asserts.assert(this.nextWireType_ == jspb.BinaryConstants.WireType.DELIMITED);
      var a2 = this.decoder_.readUnsignedVarint32();
      return this.decoder_.readBytes(a2);
    };
    goog.exportProperty(jspb.BinaryReader.prototype, "readBytes", jspb.BinaryReader.prototype.readBytes);
    jspb.BinaryReader.prototype.readVarintHash64 = function() {
      jspb.asserts.assert(this.nextWireType_ == jspb.BinaryConstants.WireType.VARINT);
      return this.decoder_.readVarintHash64();
    };
    jspb.BinaryReader.prototype.readSintHash64 = function() {
      jspb.asserts.assert(this.nextWireType_ == jspb.BinaryConstants.WireType.VARINT);
      return this.decoder_.readZigzagVarintHash64();
    };
    jspb.BinaryReader.prototype.readSplitVarint64 = function(a2) {
      jspb.asserts.assert(this.nextWireType_ == jspb.BinaryConstants.WireType.VARINT);
      return this.decoder_.readSplitVarint64(a2);
    };
    jspb.BinaryReader.prototype.readSplitZigzagVarint64 = function(a2) {
      jspb.asserts.assert(this.nextWireType_ == jspb.BinaryConstants.WireType.VARINT);
      return this.decoder_.readSplitVarint64(function(b2, c2) {
        return jspb.utils.fromZigzag64(b2, c2, a2);
      });
    };
    jspb.BinaryReader.prototype.readFixedHash64 = function() {
      jspb.asserts.assert(this.nextWireType_ == jspb.BinaryConstants.WireType.FIXED64);
      return this.decoder_.readFixedHash64();
    };
    jspb.BinaryReader.prototype.readSplitFixed64 = function(a2) {
      jspb.asserts.assert(this.nextWireType_ == jspb.BinaryConstants.WireType.FIXED64);
      return this.decoder_.readSplitFixed64(a2);
    };
    jspb.BinaryReader.prototype.readPackedField_ = function(a2) {
      jspb.asserts.assert(this.nextWireType_ == jspb.BinaryConstants.WireType.DELIMITED);
      var b2 = this.decoder_.readUnsignedVarint32();
      b2 = this.decoder_.getCursor() + b2;
      for (var c2 = []; this.decoder_.getCursor() < b2; )
        c2.push(a2.call(this.decoder_));
      return c2;
    };
    jspb.BinaryReader.prototype.readPackedInt32 = function() {
      return this.readPackedField_(this.decoder_.readSignedVarint32);
    };
    goog.exportProperty(jspb.BinaryReader.prototype, "readPackedInt32", jspb.BinaryReader.prototype.readPackedInt32);
    jspb.BinaryReader.prototype.readPackedInt32String = function() {
      return this.readPackedField_(this.decoder_.readSignedVarint32String);
    };
    jspb.BinaryReader.prototype.readPackedInt64 = function() {
      return this.readPackedField_(this.decoder_.readSignedVarint64);
    };
    goog.exportProperty(jspb.BinaryReader.prototype, "readPackedInt64", jspb.BinaryReader.prototype.readPackedInt64);
    jspb.BinaryReader.prototype.readPackedInt64String = function() {
      return this.readPackedField_(this.decoder_.readSignedVarint64String);
    };
    jspb.BinaryReader.prototype.readPackedUint32 = function() {
      return this.readPackedField_(this.decoder_.readUnsignedVarint32);
    };
    goog.exportProperty(jspb.BinaryReader.prototype, "readPackedUint32", jspb.BinaryReader.prototype.readPackedUint32);
    jspb.BinaryReader.prototype.readPackedUint32String = function() {
      return this.readPackedField_(this.decoder_.readUnsignedVarint32String);
    };
    jspb.BinaryReader.prototype.readPackedUint64 = function() {
      return this.readPackedField_(this.decoder_.readUnsignedVarint64);
    };
    goog.exportProperty(jspb.BinaryReader.prototype, "readPackedUint64", jspb.BinaryReader.prototype.readPackedUint64);
    jspb.BinaryReader.prototype.readPackedUint64String = function() {
      return this.readPackedField_(this.decoder_.readUnsignedVarint64String);
    };
    jspb.BinaryReader.prototype.readPackedSint32 = function() {
      return this.readPackedField_(this.decoder_.readZigzagVarint32);
    };
    goog.exportProperty(jspb.BinaryReader.prototype, "readPackedSint32", jspb.BinaryReader.prototype.readPackedSint32);
    jspb.BinaryReader.prototype.readPackedSint64 = function() {
      return this.readPackedField_(this.decoder_.readZigzagVarint64);
    };
    goog.exportProperty(jspb.BinaryReader.prototype, "readPackedSint64", jspb.BinaryReader.prototype.readPackedSint64);
    jspb.BinaryReader.prototype.readPackedSint64String = function() {
      return this.readPackedField_(this.decoder_.readZigzagVarint64String);
    };
    jspb.BinaryReader.prototype.readPackedFixed32 = function() {
      return this.readPackedField_(this.decoder_.readUint32);
    };
    goog.exportProperty(jspb.BinaryReader.prototype, "readPackedFixed32", jspb.BinaryReader.prototype.readPackedFixed32);
    jspb.BinaryReader.prototype.readPackedFixed64 = function() {
      return this.readPackedField_(this.decoder_.readUint64);
    };
    goog.exportProperty(jspb.BinaryReader.prototype, "readPackedFixed64", jspb.BinaryReader.prototype.readPackedFixed64);
    jspb.BinaryReader.prototype.readPackedFixed64String = function() {
      return this.readPackedField_(this.decoder_.readUint64String);
    };
    jspb.BinaryReader.prototype.readPackedSfixed32 = function() {
      return this.readPackedField_(this.decoder_.readInt32);
    };
    goog.exportProperty(jspb.BinaryReader.prototype, "readPackedSfixed32", jspb.BinaryReader.prototype.readPackedSfixed32);
    jspb.BinaryReader.prototype.readPackedSfixed64 = function() {
      return this.readPackedField_(this.decoder_.readInt64);
    };
    goog.exportProperty(jspb.BinaryReader.prototype, "readPackedSfixed64", jspb.BinaryReader.prototype.readPackedSfixed64);
    jspb.BinaryReader.prototype.readPackedSfixed64String = function() {
      return this.readPackedField_(this.decoder_.readInt64String);
    };
    jspb.BinaryReader.prototype.readPackedFloat = function() {
      return this.readPackedField_(this.decoder_.readFloat);
    };
    goog.exportProperty(jspb.BinaryReader.prototype, "readPackedFloat", jspb.BinaryReader.prototype.readPackedFloat);
    jspb.BinaryReader.prototype.readPackedDouble = function() {
      return this.readPackedField_(this.decoder_.readDouble);
    };
    goog.exportProperty(jspb.BinaryReader.prototype, "readPackedDouble", jspb.BinaryReader.prototype.readPackedDouble);
    jspb.BinaryReader.prototype.readPackedBool = function() {
      return this.readPackedField_(this.decoder_.readBool);
    };
    goog.exportProperty(jspb.BinaryReader.prototype, "readPackedBool", jspb.BinaryReader.prototype.readPackedBool);
    jspb.BinaryReader.prototype.readPackedEnum = function() {
      return this.readPackedField_(this.decoder_.readEnum);
    };
    goog.exportProperty(jspb.BinaryReader.prototype, "readPackedEnum", jspb.BinaryReader.prototype.readPackedEnum);
    jspb.BinaryReader.prototype.readPackedVarintHash64 = function() {
      return this.readPackedField_(this.decoder_.readVarintHash64);
    };
    jspb.BinaryReader.prototype.readPackedFixedHash64 = function() {
      return this.readPackedField_(this.decoder_.readFixedHash64);
    };
    jspb.BinaryEncoder = function() {
      this.buffer_ = [];
    };
    jspb.BinaryEncoder.prototype.length = function() {
      return this.buffer_.length;
    };
    jspb.BinaryEncoder.prototype.end = function() {
      var a2 = this.buffer_;
      this.buffer_ = [];
      return a2;
    };
    jspb.BinaryEncoder.prototype.writeSplitVarint64 = function(a2, b2) {
      jspb.asserts.assert(a2 == Math.floor(a2));
      jspb.asserts.assert(b2 == Math.floor(b2));
      jspb.asserts.assert(0 <= a2 && a2 < jspb.BinaryConstants.TWO_TO_32);
      for (jspb.asserts.assert(0 <= b2 && b2 < jspb.BinaryConstants.TWO_TO_32); 0 < b2 || 127 < a2; )
        this.buffer_.push(a2 & 127 | 128), a2 = (a2 >>> 7 | b2 << 25) >>> 0, b2 >>>= 7;
      this.buffer_.push(a2);
    };
    jspb.BinaryEncoder.prototype.writeSplitFixed64 = function(a2, b2) {
      jspb.asserts.assert(a2 == Math.floor(a2));
      jspb.asserts.assert(b2 == Math.floor(b2));
      jspb.asserts.assert(0 <= a2 && a2 < jspb.BinaryConstants.TWO_TO_32);
      jspb.asserts.assert(0 <= b2 && b2 < jspb.BinaryConstants.TWO_TO_32);
      this.writeUint32(a2);
      this.writeUint32(b2);
    };
    jspb.BinaryEncoder.prototype.writeUnsignedVarint32 = function(a2) {
      jspb.asserts.assert(a2 == Math.floor(a2));
      for (jspb.asserts.assert(0 <= a2 && a2 < jspb.BinaryConstants.TWO_TO_32); 127 < a2; )
        this.buffer_.push(a2 & 127 | 128), a2 >>>= 7;
      this.buffer_.push(a2);
    };
    jspb.BinaryEncoder.prototype.writeSignedVarint32 = function(a2) {
      jspb.asserts.assert(a2 == Math.floor(a2));
      jspb.asserts.assert(a2 >= -jspb.BinaryConstants.TWO_TO_31 && a2 < jspb.BinaryConstants.TWO_TO_31);
      if (0 <= a2)
        this.writeUnsignedVarint32(a2);
      else {
        for (var b2 = 0; 9 > b2; b2++)
          this.buffer_.push(a2 & 127 | 128), a2 >>= 7;
        this.buffer_.push(1);
      }
    };
    jspb.BinaryEncoder.prototype.writeUnsignedVarint64 = function(a2) {
      jspb.asserts.assert(a2 == Math.floor(a2));
      jspb.asserts.assert(0 <= a2 && a2 < jspb.BinaryConstants.TWO_TO_64);
      jspb.utils.splitInt64(a2);
      this.writeSplitVarint64(jspb.utils.split64Low, jspb.utils.split64High);
    };
    jspb.BinaryEncoder.prototype.writeSignedVarint64 = function(a2) {
      jspb.asserts.assert(a2 == Math.floor(a2));
      jspb.asserts.assert(a2 >= -jspb.BinaryConstants.TWO_TO_63 && a2 < jspb.BinaryConstants.TWO_TO_63);
      jspb.utils.splitInt64(a2);
      this.writeSplitVarint64(jspb.utils.split64Low, jspb.utils.split64High);
    };
    jspb.BinaryEncoder.prototype.writeZigzagVarint32 = function(a2) {
      jspb.asserts.assert(a2 == Math.floor(a2));
      jspb.asserts.assert(a2 >= -jspb.BinaryConstants.TWO_TO_31 && a2 < jspb.BinaryConstants.TWO_TO_31);
      this.writeUnsignedVarint32((a2 << 1 ^ a2 >> 31) >>> 0);
    };
    jspb.BinaryEncoder.prototype.writeZigzagVarint64 = function(a2) {
      jspb.asserts.assert(a2 == Math.floor(a2));
      jspb.asserts.assert(a2 >= -jspb.BinaryConstants.TWO_TO_63 && a2 < jspb.BinaryConstants.TWO_TO_63);
      jspb.utils.splitZigzag64(a2);
      this.writeSplitVarint64(jspb.utils.split64Low, jspb.utils.split64High);
    };
    jspb.BinaryEncoder.prototype.writeZigzagVarint64String = function(a2) {
      this.writeZigzagVarintHash64(jspb.utils.decimalStringToHash64(a2));
    };
    jspb.BinaryEncoder.prototype.writeZigzagVarintHash64 = function(a2) {
      var b2 = this;
      jspb.utils.splitHash64(a2);
      jspb.utils.toZigzag64(jspb.utils.split64Low, jspb.utils.split64High, function(a3, d2) {
        b2.writeSplitVarint64(a3 >>> 0, d2 >>> 0);
      });
    };
    jspb.BinaryEncoder.prototype.writeUint8 = function(a2) {
      jspb.asserts.assert(a2 == Math.floor(a2));
      jspb.asserts.assert(0 <= a2 && 256 > a2);
      this.buffer_.push(a2 >>> 0 & 255);
    };
    jspb.BinaryEncoder.prototype.writeUint16 = function(a2) {
      jspb.asserts.assert(a2 == Math.floor(a2));
      jspb.asserts.assert(0 <= a2 && 65536 > a2);
      this.buffer_.push(a2 >>> 0 & 255);
      this.buffer_.push(a2 >>> 8 & 255);
    };
    jspb.BinaryEncoder.prototype.writeUint32 = function(a2) {
      jspb.asserts.assert(a2 == Math.floor(a2));
      jspb.asserts.assert(0 <= a2 && a2 < jspb.BinaryConstants.TWO_TO_32);
      this.buffer_.push(a2 >>> 0 & 255);
      this.buffer_.push(a2 >>> 8 & 255);
      this.buffer_.push(a2 >>> 16 & 255);
      this.buffer_.push(a2 >>> 24 & 255);
    };
    jspb.BinaryEncoder.prototype.writeUint64 = function(a2) {
      jspb.asserts.assert(a2 == Math.floor(a2));
      jspb.asserts.assert(0 <= a2 && a2 < jspb.BinaryConstants.TWO_TO_64);
      jspb.utils.splitUint64(a2);
      this.writeUint32(jspb.utils.split64Low);
      this.writeUint32(jspb.utils.split64High);
    };
    jspb.BinaryEncoder.prototype.writeInt8 = function(a2) {
      jspb.asserts.assert(a2 == Math.floor(a2));
      jspb.asserts.assert(-128 <= a2 && 128 > a2);
      this.buffer_.push(a2 >>> 0 & 255);
    };
    jspb.BinaryEncoder.prototype.writeInt16 = function(a2) {
      jspb.asserts.assert(a2 == Math.floor(a2));
      jspb.asserts.assert(-32768 <= a2 && 32768 > a2);
      this.buffer_.push(a2 >>> 0 & 255);
      this.buffer_.push(a2 >>> 8 & 255);
    };
    jspb.BinaryEncoder.prototype.writeInt32 = function(a2) {
      jspb.asserts.assert(a2 == Math.floor(a2));
      jspb.asserts.assert(a2 >= -jspb.BinaryConstants.TWO_TO_31 && a2 < jspb.BinaryConstants.TWO_TO_31);
      this.buffer_.push(a2 >>> 0 & 255);
      this.buffer_.push(a2 >>> 8 & 255);
      this.buffer_.push(a2 >>> 16 & 255);
      this.buffer_.push(a2 >>> 24 & 255);
    };
    jspb.BinaryEncoder.prototype.writeInt64 = function(a2) {
      jspb.asserts.assert(a2 == Math.floor(a2));
      jspb.asserts.assert(a2 >= -jspb.BinaryConstants.TWO_TO_63 && a2 < jspb.BinaryConstants.TWO_TO_63);
      jspb.utils.splitInt64(a2);
      this.writeSplitFixed64(jspb.utils.split64Low, jspb.utils.split64High);
    };
    jspb.BinaryEncoder.prototype.writeInt64String = function(a2) {
      jspb.asserts.assert(a2 == Math.floor(a2));
      jspb.asserts.assert(+a2 >= -jspb.BinaryConstants.TWO_TO_63 && +a2 < jspb.BinaryConstants.TWO_TO_63);
      jspb.utils.splitHash64(jspb.utils.decimalStringToHash64(a2));
      this.writeSplitFixed64(jspb.utils.split64Low, jspb.utils.split64High);
    };
    jspb.BinaryEncoder.prototype.writeFloat = function(a2) {
      jspb.asserts.assert(Infinity === a2 || -Infinity === a2 || isNaN(a2) || a2 >= -jspb.BinaryConstants.FLOAT32_MAX && a2 <= jspb.BinaryConstants.FLOAT32_MAX);
      jspb.utils.splitFloat32(a2);
      this.writeUint32(jspb.utils.split64Low);
    };
    jspb.BinaryEncoder.prototype.writeDouble = function(a2) {
      jspb.asserts.assert(Infinity === a2 || -Infinity === a2 || isNaN(a2) || a2 >= -jspb.BinaryConstants.FLOAT64_MAX && a2 <= jspb.BinaryConstants.FLOAT64_MAX);
      jspb.utils.splitFloat64(a2);
      this.writeUint32(jspb.utils.split64Low);
      this.writeUint32(jspb.utils.split64High);
    };
    jspb.BinaryEncoder.prototype.writeBool = function(a2) {
      jspb.asserts.assert("boolean" === typeof a2 || "number" === typeof a2);
      this.buffer_.push(a2 ? 1 : 0);
    };
    jspb.BinaryEncoder.prototype.writeEnum = function(a2) {
      jspb.asserts.assert(a2 == Math.floor(a2));
      jspb.asserts.assert(a2 >= -jspb.BinaryConstants.TWO_TO_31 && a2 < jspb.BinaryConstants.TWO_TO_31);
      this.writeSignedVarint32(a2);
    };
    jspb.BinaryEncoder.prototype.writeBytes = function(a2) {
      this.buffer_.push.apply(this.buffer_, a2);
    };
    jspb.BinaryEncoder.prototype.writeVarintHash64 = function(a2) {
      jspb.utils.splitHash64(a2);
      this.writeSplitVarint64(jspb.utils.split64Low, jspb.utils.split64High);
    };
    jspb.BinaryEncoder.prototype.writeFixedHash64 = function(a2) {
      jspb.utils.splitHash64(a2);
      this.writeUint32(jspb.utils.split64Low);
      this.writeUint32(jspb.utils.split64High);
    };
    jspb.BinaryEncoder.prototype.writeString = function(a2) {
      var b2 = this.buffer_.length;
      jspb.asserts.assertString(a2);
      for (var c2 = 0; c2 < a2.length; c2++) {
        var d2 = a2.charCodeAt(c2);
        if (128 > d2)
          this.buffer_.push(d2);
        else if (2048 > d2)
          this.buffer_.push(d2 >> 6 | 192), this.buffer_.push(d2 & 63 | 128);
        else if (65536 > d2)
          if (55296 <= d2 && 56319 >= d2 && c2 + 1 < a2.length) {
            var e2 = a2.charCodeAt(c2 + 1);
            56320 <= e2 && 57343 >= e2 && (d2 = 1024 * (d2 - 55296) + e2 - 56320 + 65536, this.buffer_.push(d2 >> 18 | 240), this.buffer_.push(d2 >> 12 & 63 | 128), this.buffer_.push(d2 >> 6 & 63 | 128), this.buffer_.push(d2 & 63 | 128), c2++);
          } else
            this.buffer_.push(d2 >> 12 | 224), this.buffer_.push(d2 >> 6 & 63 | 128), this.buffer_.push(d2 & 63 | 128);
      }
      return this.buffer_.length - b2;
    };
    jspb.arith = {};
    jspb.arith.UInt64 = function(a2, b2) {
      this.lo = a2;
      this.hi = b2;
    };
    jspb.arith.UInt64.prototype.cmp = function(a2) {
      return this.hi < a2.hi || this.hi == a2.hi && this.lo < a2.lo ? -1 : this.hi == a2.hi && this.lo == a2.lo ? 0 : 1;
    };
    jspb.arith.UInt64.prototype.rightShift = function() {
      return new jspb.arith.UInt64((this.lo >>> 1 | (this.hi & 1) << 31) >>> 0, this.hi >>> 1 >>> 0);
    };
    jspb.arith.UInt64.prototype.leftShift = function() {
      return new jspb.arith.UInt64(this.lo << 1 >>> 0, (this.hi << 1 | this.lo >>> 31) >>> 0);
    };
    jspb.arith.UInt64.prototype.msb = function() {
      return !!(this.hi & 2147483648);
    };
    jspb.arith.UInt64.prototype.lsb = function() {
      return !!(this.lo & 1);
    };
    jspb.arith.UInt64.prototype.zero = function() {
      return 0 == this.lo && 0 == this.hi;
    };
    jspb.arith.UInt64.prototype.add = function(a2) {
      return new jspb.arith.UInt64((this.lo + a2.lo & 4294967295) >>> 0 >>> 0, ((this.hi + a2.hi & 4294967295) >>> 0) + (4294967296 <= this.lo + a2.lo ? 1 : 0) >>> 0);
    };
    jspb.arith.UInt64.prototype.sub = function(a2) {
      return new jspb.arith.UInt64((this.lo - a2.lo & 4294967295) >>> 0 >>> 0, ((this.hi - a2.hi & 4294967295) >>> 0) - (0 > this.lo - a2.lo ? 1 : 0) >>> 0);
    };
    jspb.arith.UInt64.mul32x32 = function(a2, b2) {
      var c2 = a2 & 65535;
      a2 >>>= 16;
      var d2 = b2 & 65535, e2 = b2 >>> 16;
      b2 = c2 * d2 + 65536 * (c2 * e2 & 65535) + 65536 * (a2 * d2 & 65535);
      for (c2 = a2 * e2 + (c2 * e2 >>> 16) + (a2 * d2 >>> 16); 4294967296 <= b2; )
        b2 -= 4294967296, c2 += 1;
      return new jspb.arith.UInt64(b2 >>> 0, c2 >>> 0);
    };
    jspb.arith.UInt64.prototype.mul = function(a2) {
      var b2 = jspb.arith.UInt64.mul32x32(this.lo, a2);
      a2 = jspb.arith.UInt64.mul32x32(this.hi, a2);
      a2.hi = a2.lo;
      a2.lo = 0;
      return b2.add(a2);
    };
    jspb.arith.UInt64.prototype.div = function(a2) {
      if (0 == a2)
        return [];
      var b2 = new jspb.arith.UInt64(0, 0), c2 = new jspb.arith.UInt64(this.lo, this.hi);
      a2 = new jspb.arith.UInt64(a2, 0);
      for (var d2 = new jspb.arith.UInt64(1, 0); !a2.msb(); )
        a2 = a2.leftShift(), d2 = d2.leftShift();
      for (; !d2.zero(); )
        0 >= a2.cmp(c2) && (b2 = b2.add(d2), c2 = c2.sub(a2)), a2 = a2.rightShift(), d2 = d2.rightShift();
      return [b2, c2];
    };
    jspb.arith.UInt64.prototype.toString = function() {
      for (var a2 = "", b2 = this; !b2.zero(); ) {
        b2 = b2.div(10);
        var c2 = b2[0];
        a2 = b2[1].lo + a2;
        b2 = c2;
      }
      "" == a2 && (a2 = "0");
      return a2;
    };
    jspb.arith.UInt64.fromString = function(a2) {
      for (var b2 = new jspb.arith.UInt64(0, 0), c2 = new jspb.arith.UInt64(0, 0), d2 = 0; d2 < a2.length; d2++) {
        if ("0" > a2[d2] || "9" < a2[d2])
          return null;
        var e2 = parseInt(a2[d2], 10);
        c2.lo = e2;
        b2 = b2.mul(10).add(c2);
      }
      return b2;
    };
    jspb.arith.UInt64.prototype.clone = function() {
      return new jspb.arith.UInt64(this.lo, this.hi);
    };
    jspb.arith.Int64 = function(a2, b2) {
      this.lo = a2;
      this.hi = b2;
    };
    jspb.arith.Int64.prototype.add = function(a2) {
      return new jspb.arith.Int64((this.lo + a2.lo & 4294967295) >>> 0 >>> 0, ((this.hi + a2.hi & 4294967295) >>> 0) + (4294967296 <= this.lo + a2.lo ? 1 : 0) >>> 0);
    };
    jspb.arith.Int64.prototype.sub = function(a2) {
      return new jspb.arith.Int64((this.lo - a2.lo & 4294967295) >>> 0 >>> 0, ((this.hi - a2.hi & 4294967295) >>> 0) - (0 > this.lo - a2.lo ? 1 : 0) >>> 0);
    };
    jspb.arith.Int64.prototype.clone = function() {
      return new jspb.arith.Int64(this.lo, this.hi);
    };
    jspb.arith.Int64.prototype.toString = function() {
      var a2 = 0 != (this.hi & 2147483648), b2 = new jspb.arith.UInt64(this.lo, this.hi);
      a2 && (b2 = new jspb.arith.UInt64(0, 0).sub(b2));
      return (a2 ? "-" : "") + b2.toString();
    };
    jspb.arith.Int64.fromString = function(a2) {
      var b2 = 0 < a2.length && "-" == a2[0];
      b2 && (a2 = a2.substring(1));
      a2 = jspb.arith.UInt64.fromString(a2);
      if (null === a2)
        return null;
      b2 && (a2 = new jspb.arith.UInt64(0, 0).sub(a2));
      return new jspb.arith.Int64(a2.lo, a2.hi);
    };
    jspb.BinaryWriter = function() {
      this.blocks_ = [];
      this.totalLength_ = 0;
      this.encoder_ = new jspb.BinaryEncoder();
      this.bookmarks_ = [];
    };
    jspb.BinaryWriter.prototype.appendUint8Array_ = function(a2) {
      var b2 = this.encoder_.end();
      this.blocks_.push(b2);
      this.blocks_.push(a2);
      this.totalLength_ += b2.length + a2.length;
    };
    jspb.BinaryWriter.prototype.beginDelimited_ = function(a2) {
      this.writeFieldHeader_(a2, jspb.BinaryConstants.WireType.DELIMITED);
      a2 = this.encoder_.end();
      this.blocks_.push(a2);
      this.totalLength_ += a2.length;
      a2.push(this.totalLength_);
      return a2;
    };
    jspb.BinaryWriter.prototype.endDelimited_ = function(a2) {
      var b2 = a2.pop();
      b2 = this.totalLength_ + this.encoder_.length() - b2;
      for (jspb.asserts.assert(0 <= b2); 127 < b2; )
        a2.push(b2 & 127 | 128), b2 >>>= 7, this.totalLength_++;
      a2.push(b2);
      this.totalLength_++;
    };
    jspb.BinaryWriter.prototype.writeSerializedMessage = function(a2, b2, c2) {
      this.appendUint8Array_(a2.subarray(b2, c2));
    };
    jspb.BinaryWriter.prototype.maybeWriteSerializedMessage = function(a2, b2, c2) {
      null != a2 && null != b2 && null != c2 && this.writeSerializedMessage(a2, b2, c2);
    };
    jspb.BinaryWriter.prototype.reset = function() {
      this.blocks_ = [];
      this.encoder_.end();
      this.totalLength_ = 0;
      this.bookmarks_ = [];
    };
    jspb.BinaryWriter.prototype.getResultBuffer = function() {
      jspb.asserts.assert(0 == this.bookmarks_.length);
      for (var a2 = new Uint8Array(this.totalLength_ + this.encoder_.length()), b2 = this.blocks_, c2 = b2.length, d2 = 0, e2 = 0; e2 < c2; e2++) {
        var f2 = b2[e2];
        a2.set(f2, d2);
        d2 += f2.length;
      }
      b2 = this.encoder_.end();
      a2.set(b2, d2);
      d2 += b2.length;
      jspb.asserts.assert(d2 == a2.length);
      this.blocks_ = [a2];
      return a2;
    };
    goog.exportProperty(jspb.BinaryWriter.prototype, "getResultBuffer", jspb.BinaryWriter.prototype.getResultBuffer);
    jspb.BinaryWriter.prototype.getResultBase64String = function(a2) {
      return goog.crypt.base64.encodeByteArray(this.getResultBuffer(), a2);
    };
    jspb.BinaryWriter.prototype.beginSubMessage = function(a2) {
      this.bookmarks_.push(this.beginDelimited_(a2));
    };
    jspb.BinaryWriter.prototype.endSubMessage = function() {
      jspb.asserts.assert(0 <= this.bookmarks_.length);
      this.endDelimited_(this.bookmarks_.pop());
    };
    jspb.BinaryWriter.prototype.writeFieldHeader_ = function(a2, b2) {
      jspb.asserts.assert(1 <= a2 && a2 == Math.floor(a2));
      this.encoder_.writeUnsignedVarint32(8 * a2 + b2);
    };
    jspb.BinaryWriter.prototype.writeAny = function(a2, b2, c2) {
      var d2 = jspb.BinaryConstants.FieldType;
      switch (a2) {
        case d2.DOUBLE:
          this.writeDouble(b2, c2);
          break;
        case d2.FLOAT:
          this.writeFloat(b2, c2);
          break;
        case d2.INT64:
          this.writeInt64(b2, c2);
          break;
        case d2.UINT64:
          this.writeUint64(b2, c2);
          break;
        case d2.INT32:
          this.writeInt32(b2, c2);
          break;
        case d2.FIXED64:
          this.writeFixed64(b2, c2);
          break;
        case d2.FIXED32:
          this.writeFixed32(b2, c2);
          break;
        case d2.BOOL:
          this.writeBool(b2, c2);
          break;
        case d2.STRING:
          this.writeString(b2, c2);
          break;
        case d2.GROUP:
          jspb.asserts.fail("Group field type not supported in writeAny()");
          break;
        case d2.MESSAGE:
          jspb.asserts.fail("Message field type not supported in writeAny()");
          break;
        case d2.BYTES:
          this.writeBytes(b2, c2);
          break;
        case d2.UINT32:
          this.writeUint32(b2, c2);
          break;
        case d2.ENUM:
          this.writeEnum(b2, c2);
          break;
        case d2.SFIXED32:
          this.writeSfixed32(b2, c2);
          break;
        case d2.SFIXED64:
          this.writeSfixed64(b2, c2);
          break;
        case d2.SINT32:
          this.writeSint32(b2, c2);
          break;
        case d2.SINT64:
          this.writeSint64(b2, c2);
          break;
        case d2.FHASH64:
          this.writeFixedHash64(b2, c2);
          break;
        case d2.VHASH64:
          this.writeVarintHash64(b2, c2);
          break;
        default:
          jspb.asserts.fail("Invalid field type in writeAny()");
      }
    };
    jspb.BinaryWriter.prototype.writeUnsignedVarint32_ = function(a2, b2) {
      null != b2 && (this.writeFieldHeader_(a2, jspb.BinaryConstants.WireType.VARINT), this.encoder_.writeUnsignedVarint32(b2));
    };
    jspb.BinaryWriter.prototype.writeSignedVarint32_ = function(a2, b2) {
      null != b2 && (this.writeFieldHeader_(a2, jspb.BinaryConstants.WireType.VARINT), this.encoder_.writeSignedVarint32(b2));
    };
    jspb.BinaryWriter.prototype.writeUnsignedVarint64_ = function(a2, b2) {
      null != b2 && (this.writeFieldHeader_(a2, jspb.BinaryConstants.WireType.VARINT), this.encoder_.writeUnsignedVarint64(b2));
    };
    jspb.BinaryWriter.prototype.writeSignedVarint64_ = function(a2, b2) {
      null != b2 && (this.writeFieldHeader_(a2, jspb.BinaryConstants.WireType.VARINT), this.encoder_.writeSignedVarint64(b2));
    };
    jspb.BinaryWriter.prototype.writeZigzagVarint32_ = function(a2, b2) {
      null != b2 && (this.writeFieldHeader_(a2, jspb.BinaryConstants.WireType.VARINT), this.encoder_.writeZigzagVarint32(b2));
    };
    jspb.BinaryWriter.prototype.writeZigzagVarint64_ = function(a2, b2) {
      null != b2 && (this.writeFieldHeader_(a2, jspb.BinaryConstants.WireType.VARINT), this.encoder_.writeZigzagVarint64(b2));
    };
    jspb.BinaryWriter.prototype.writeZigzagVarint64String_ = function(a2, b2) {
      null != b2 && (this.writeFieldHeader_(a2, jspb.BinaryConstants.WireType.VARINT), this.encoder_.writeZigzagVarint64String(b2));
    };
    jspb.BinaryWriter.prototype.writeZigzagVarintHash64_ = function(a2, b2) {
      null != b2 && (this.writeFieldHeader_(a2, jspb.BinaryConstants.WireType.VARINT), this.encoder_.writeZigzagVarintHash64(b2));
    };
    jspb.BinaryWriter.prototype.writeInt32 = function(a2, b2) {
      null != b2 && (jspb.asserts.assert(b2 >= -jspb.BinaryConstants.TWO_TO_31 && b2 < jspb.BinaryConstants.TWO_TO_31), this.writeSignedVarint32_(a2, b2));
    };
    goog.exportProperty(jspb.BinaryWriter.prototype, "writeInt32", jspb.BinaryWriter.prototype.writeInt32);
    jspb.BinaryWriter.prototype.writeInt32String = function(a2, b2) {
      null != b2 && (b2 = parseInt(b2, 10), jspb.asserts.assert(b2 >= -jspb.BinaryConstants.TWO_TO_31 && b2 < jspb.BinaryConstants.TWO_TO_31), this.writeSignedVarint32_(a2, b2));
    };
    jspb.BinaryWriter.prototype.writeInt64 = function(a2, b2) {
      null != b2 && (jspb.asserts.assert(b2 >= -jspb.BinaryConstants.TWO_TO_63 && b2 < jspb.BinaryConstants.TWO_TO_63), this.writeSignedVarint64_(a2, b2));
    };
    goog.exportProperty(jspb.BinaryWriter.prototype, "writeInt64", jspb.BinaryWriter.prototype.writeInt64);
    jspb.BinaryWriter.prototype.writeInt64String = function(a2, b2) {
      null != b2 && (b2 = jspb.arith.Int64.fromString(b2), this.writeFieldHeader_(a2, jspb.BinaryConstants.WireType.VARINT), this.encoder_.writeSplitVarint64(b2.lo, b2.hi));
    };
    jspb.BinaryWriter.prototype.writeUint32 = function(a2, b2) {
      null != b2 && (jspb.asserts.assert(0 <= b2 && b2 < jspb.BinaryConstants.TWO_TO_32), this.writeUnsignedVarint32_(a2, b2));
    };
    goog.exportProperty(jspb.BinaryWriter.prototype, "writeUint32", jspb.BinaryWriter.prototype.writeUint32);
    jspb.BinaryWriter.prototype.writeUint32String = function(a2, b2) {
      null != b2 && (b2 = parseInt(b2, 10), jspb.asserts.assert(0 <= b2 && b2 < jspb.BinaryConstants.TWO_TO_32), this.writeUnsignedVarint32_(a2, b2));
    };
    jspb.BinaryWriter.prototype.writeUint64 = function(a2, b2) {
      null != b2 && (jspb.asserts.assert(0 <= b2 && b2 < jspb.BinaryConstants.TWO_TO_64), this.writeUnsignedVarint64_(a2, b2));
    };
    goog.exportProperty(jspb.BinaryWriter.prototype, "writeUint64", jspb.BinaryWriter.prototype.writeUint64);
    jspb.BinaryWriter.prototype.writeUint64String = function(a2, b2) {
      null != b2 && (b2 = jspb.arith.UInt64.fromString(b2), this.writeFieldHeader_(a2, jspb.BinaryConstants.WireType.VARINT), this.encoder_.writeSplitVarint64(b2.lo, b2.hi));
    };
    jspb.BinaryWriter.prototype.writeSint32 = function(a2, b2) {
      null != b2 && (jspb.asserts.assert(b2 >= -jspb.BinaryConstants.TWO_TO_31 && b2 < jspb.BinaryConstants.TWO_TO_31), this.writeZigzagVarint32_(a2, b2));
    };
    goog.exportProperty(jspb.BinaryWriter.prototype, "writeSint32", jspb.BinaryWriter.prototype.writeSint32);
    jspb.BinaryWriter.prototype.writeSint64 = function(a2, b2) {
      null != b2 && (jspb.asserts.assert(b2 >= -jspb.BinaryConstants.TWO_TO_63 && b2 < jspb.BinaryConstants.TWO_TO_63), this.writeZigzagVarint64_(a2, b2));
    };
    goog.exportProperty(jspb.BinaryWriter.prototype, "writeSint64", jspb.BinaryWriter.prototype.writeSint64);
    jspb.BinaryWriter.prototype.writeSintHash64 = function(a2, b2) {
      null != b2 && this.writeZigzagVarintHash64_(a2, b2);
    };
    jspb.BinaryWriter.prototype.writeSint64String = function(a2, b2) {
      null != b2 && this.writeZigzagVarint64String_(a2, b2);
    };
    jspb.BinaryWriter.prototype.writeFixed32 = function(a2, b2) {
      null != b2 && (jspb.asserts.assert(0 <= b2 && b2 < jspb.BinaryConstants.TWO_TO_32), this.writeFieldHeader_(a2, jspb.BinaryConstants.WireType.FIXED32), this.encoder_.writeUint32(b2));
    };
    goog.exportProperty(jspb.BinaryWriter.prototype, "writeFixed32", jspb.BinaryWriter.prototype.writeFixed32);
    jspb.BinaryWriter.prototype.writeFixed64 = function(a2, b2) {
      null != b2 && (jspb.asserts.assert(0 <= b2 && b2 < jspb.BinaryConstants.TWO_TO_64), this.writeFieldHeader_(a2, jspb.BinaryConstants.WireType.FIXED64), this.encoder_.writeUint64(b2));
    };
    goog.exportProperty(jspb.BinaryWriter.prototype, "writeFixed64", jspb.BinaryWriter.prototype.writeFixed64);
    jspb.BinaryWriter.prototype.writeFixed64String = function(a2, b2) {
      null != b2 && (b2 = jspb.arith.UInt64.fromString(b2), this.writeFieldHeader_(a2, jspb.BinaryConstants.WireType.FIXED64), this.encoder_.writeSplitFixed64(b2.lo, b2.hi));
    };
    jspb.BinaryWriter.prototype.writeSfixed32 = function(a2, b2) {
      null != b2 && (jspb.asserts.assert(b2 >= -jspb.BinaryConstants.TWO_TO_31 && b2 < jspb.BinaryConstants.TWO_TO_31), this.writeFieldHeader_(a2, jspb.BinaryConstants.WireType.FIXED32), this.encoder_.writeInt32(b2));
    };
    goog.exportProperty(jspb.BinaryWriter.prototype, "writeSfixed32", jspb.BinaryWriter.prototype.writeSfixed32);
    jspb.BinaryWriter.prototype.writeSfixed64 = function(a2, b2) {
      null != b2 && (jspb.asserts.assert(b2 >= -jspb.BinaryConstants.TWO_TO_63 && b2 < jspb.BinaryConstants.TWO_TO_63), this.writeFieldHeader_(a2, jspb.BinaryConstants.WireType.FIXED64), this.encoder_.writeInt64(b2));
    };
    goog.exportProperty(jspb.BinaryWriter.prototype, "writeSfixed64", jspb.BinaryWriter.prototype.writeSfixed64);
    jspb.BinaryWriter.prototype.writeSfixed64String = function(a2, b2) {
      null != b2 && (b2 = jspb.arith.Int64.fromString(b2), this.writeFieldHeader_(a2, jspb.BinaryConstants.WireType.FIXED64), this.encoder_.writeSplitFixed64(b2.lo, b2.hi));
    };
    jspb.BinaryWriter.prototype.writeFloat = function(a2, b2) {
      null != b2 && (this.writeFieldHeader_(a2, jspb.BinaryConstants.WireType.FIXED32), this.encoder_.writeFloat(b2));
    };
    goog.exportProperty(jspb.BinaryWriter.prototype, "writeFloat", jspb.BinaryWriter.prototype.writeFloat);
    jspb.BinaryWriter.prototype.writeDouble = function(a2, b2) {
      null != b2 && (this.writeFieldHeader_(a2, jspb.BinaryConstants.WireType.FIXED64), this.encoder_.writeDouble(b2));
    };
    goog.exportProperty(jspb.BinaryWriter.prototype, "writeDouble", jspb.BinaryWriter.prototype.writeDouble);
    jspb.BinaryWriter.prototype.writeBool = function(a2, b2) {
      null != b2 && (jspb.asserts.assert("boolean" === typeof b2 || "number" === typeof b2), this.writeFieldHeader_(a2, jspb.BinaryConstants.WireType.VARINT), this.encoder_.writeBool(b2));
    };
    goog.exportProperty(jspb.BinaryWriter.prototype, "writeBool", jspb.BinaryWriter.prototype.writeBool);
    jspb.BinaryWriter.prototype.writeEnum = function(a2, b2) {
      null != b2 && (jspb.asserts.assert(b2 >= -jspb.BinaryConstants.TWO_TO_31 && b2 < jspb.BinaryConstants.TWO_TO_31), this.writeFieldHeader_(a2, jspb.BinaryConstants.WireType.VARINT), this.encoder_.writeSignedVarint32(b2));
    };
    goog.exportProperty(jspb.BinaryWriter.prototype, "writeEnum", jspb.BinaryWriter.prototype.writeEnum);
    jspb.BinaryWriter.prototype.writeString = function(a2, b2) {
      null != b2 && (a2 = this.beginDelimited_(a2), this.encoder_.writeString(b2), this.endDelimited_(a2));
    };
    goog.exportProperty(jspb.BinaryWriter.prototype, "writeString", jspb.BinaryWriter.prototype.writeString);
    jspb.BinaryWriter.prototype.writeBytes = function(a2, b2) {
      null != b2 && (b2 = jspb.utils.byteSourceToUint8Array(b2), this.writeFieldHeader_(a2, jspb.BinaryConstants.WireType.DELIMITED), this.encoder_.writeUnsignedVarint32(b2.length), this.appendUint8Array_(b2));
    };
    goog.exportProperty(jspb.BinaryWriter.prototype, "writeBytes", jspb.BinaryWriter.prototype.writeBytes);
    jspb.BinaryWriter.prototype.writeMessage = function(a2, b2, c2) {
      null != b2 && (a2 = this.beginDelimited_(a2), c2(b2, this), this.endDelimited_(a2));
    };
    goog.exportProperty(jspb.BinaryWriter.prototype, "writeMessage", jspb.BinaryWriter.prototype.writeMessage);
    jspb.BinaryWriter.prototype.writeMessageSet = function(a2, b2, c2) {
      null != b2 && (this.writeFieldHeader_(1, jspb.BinaryConstants.WireType.START_GROUP), this.writeFieldHeader_(2, jspb.BinaryConstants.WireType.VARINT), this.encoder_.writeSignedVarint32(a2), a2 = this.beginDelimited_(3), c2(b2, this), this.endDelimited_(a2), this.writeFieldHeader_(1, jspb.BinaryConstants.WireType.END_GROUP));
    };
    jspb.BinaryWriter.prototype.writeGroup = function(a2, b2, c2) {
      null != b2 && (this.writeFieldHeader_(a2, jspb.BinaryConstants.WireType.START_GROUP), c2(b2, this), this.writeFieldHeader_(a2, jspb.BinaryConstants.WireType.END_GROUP));
    };
    goog.exportProperty(jspb.BinaryWriter.prototype, "writeGroup", jspb.BinaryWriter.prototype.writeGroup);
    jspb.BinaryWriter.prototype.writeFixedHash64 = function(a2, b2) {
      null != b2 && (jspb.asserts.assert(8 == b2.length), this.writeFieldHeader_(a2, jspb.BinaryConstants.WireType.FIXED64), this.encoder_.writeFixedHash64(b2));
    };
    jspb.BinaryWriter.prototype.writeVarintHash64 = function(a2, b2) {
      null != b2 && (jspb.asserts.assert(8 == b2.length), this.writeFieldHeader_(a2, jspb.BinaryConstants.WireType.VARINT), this.encoder_.writeVarintHash64(b2));
    };
    jspb.BinaryWriter.prototype.writeSplitFixed64 = function(a2, b2, c2) {
      this.writeFieldHeader_(a2, jspb.BinaryConstants.WireType.FIXED64);
      this.encoder_.writeSplitFixed64(b2, c2);
    };
    jspb.BinaryWriter.prototype.writeSplitVarint64 = function(a2, b2, c2) {
      this.writeFieldHeader_(a2, jspb.BinaryConstants.WireType.VARINT);
      this.encoder_.writeSplitVarint64(b2, c2);
    };
    jspb.BinaryWriter.prototype.writeSplitZigzagVarint64 = function(a2, b2, c2) {
      this.writeFieldHeader_(a2, jspb.BinaryConstants.WireType.VARINT);
      var d2 = this.encoder_;
      jspb.utils.toZigzag64(b2, c2, function(a3, b3) {
        d2.writeSplitVarint64(a3 >>> 0, b3 >>> 0);
      });
    };
    jspb.BinaryWriter.prototype.writeRepeatedInt32 = function(a2, b2) {
      if (null != b2)
        for (var c2 = 0; c2 < b2.length; c2++)
          this.writeSignedVarint32_(a2, b2[c2]);
    };
    goog.exportProperty(jspb.BinaryWriter.prototype, "writeRepeatedInt32", jspb.BinaryWriter.prototype.writeRepeatedInt32);
    jspb.BinaryWriter.prototype.writeRepeatedInt32String = function(a2, b2) {
      if (null != b2)
        for (var c2 = 0; c2 < b2.length; c2++)
          this.writeInt32String(a2, b2[c2]);
    };
    jspb.BinaryWriter.prototype.writeRepeatedInt64 = function(a2, b2) {
      if (null != b2)
        for (var c2 = 0; c2 < b2.length; c2++)
          this.writeSignedVarint64_(a2, b2[c2]);
    };
    goog.exportProperty(jspb.BinaryWriter.prototype, "writeRepeatedInt64", jspb.BinaryWriter.prototype.writeRepeatedInt64);
    jspb.BinaryWriter.prototype.writeRepeatedSplitFixed64 = function(a2, b2, c2, d2) {
      if (null != b2)
        for (var e2 = 0; e2 < b2.length; e2++)
          this.writeSplitFixed64(a2, c2(b2[e2]), d2(b2[e2]));
    };
    jspb.BinaryWriter.prototype.writeRepeatedSplitVarint64 = function(a2, b2, c2, d2) {
      if (null != b2)
        for (var e2 = 0; e2 < b2.length; e2++)
          this.writeSplitVarint64(a2, c2(b2[e2]), d2(b2[e2]));
    };
    jspb.BinaryWriter.prototype.writeRepeatedSplitZigzagVarint64 = function(a2, b2, c2, d2) {
      if (null != b2)
        for (var e2 = 0; e2 < b2.length; e2++)
          this.writeSplitZigzagVarint64(a2, c2(b2[e2]), d2(b2[e2]));
    };
    jspb.BinaryWriter.prototype.writeRepeatedInt64String = function(a2, b2) {
      if (null != b2)
        for (var c2 = 0; c2 < b2.length; c2++)
          this.writeInt64String(a2, b2[c2]);
    };
    jspb.BinaryWriter.prototype.writeRepeatedUint32 = function(a2, b2) {
      if (null != b2)
        for (var c2 = 0; c2 < b2.length; c2++)
          this.writeUnsignedVarint32_(a2, b2[c2]);
    };
    goog.exportProperty(jspb.BinaryWriter.prototype, "writeRepeatedUint32", jspb.BinaryWriter.prototype.writeRepeatedUint32);
    jspb.BinaryWriter.prototype.writeRepeatedUint32String = function(a2, b2) {
      if (null != b2)
        for (var c2 = 0; c2 < b2.length; c2++)
          this.writeUint32String(a2, b2[c2]);
    };
    jspb.BinaryWriter.prototype.writeRepeatedUint64 = function(a2, b2) {
      if (null != b2)
        for (var c2 = 0; c2 < b2.length; c2++)
          this.writeUnsignedVarint64_(a2, b2[c2]);
    };
    goog.exportProperty(jspb.BinaryWriter.prototype, "writeRepeatedUint64", jspb.BinaryWriter.prototype.writeRepeatedUint64);
    jspb.BinaryWriter.prototype.writeRepeatedUint64String = function(a2, b2) {
      if (null != b2)
        for (var c2 = 0; c2 < b2.length; c2++)
          this.writeUint64String(a2, b2[c2]);
    };
    jspb.BinaryWriter.prototype.writeRepeatedSint32 = function(a2, b2) {
      if (null != b2)
        for (var c2 = 0; c2 < b2.length; c2++)
          this.writeZigzagVarint32_(a2, b2[c2]);
    };
    goog.exportProperty(jspb.BinaryWriter.prototype, "writeRepeatedSint32", jspb.BinaryWriter.prototype.writeRepeatedSint32);
    jspb.BinaryWriter.prototype.writeRepeatedSint64 = function(a2, b2) {
      if (null != b2)
        for (var c2 = 0; c2 < b2.length; c2++)
          this.writeZigzagVarint64_(a2, b2[c2]);
    };
    goog.exportProperty(jspb.BinaryWriter.prototype, "writeRepeatedSint64", jspb.BinaryWriter.prototype.writeRepeatedSint64);
    jspb.BinaryWriter.prototype.writeRepeatedSint64String = function(a2, b2) {
      if (null != b2)
        for (var c2 = 0; c2 < b2.length; c2++)
          this.writeZigzagVarint64String_(a2, b2[c2]);
    };
    jspb.BinaryWriter.prototype.writeRepeatedSintHash64 = function(a2, b2) {
      if (null != b2)
        for (var c2 = 0; c2 < b2.length; c2++)
          this.writeZigzagVarintHash64_(a2, b2[c2]);
    };
    jspb.BinaryWriter.prototype.writeRepeatedFixed32 = function(a2, b2) {
      if (null != b2)
        for (var c2 = 0; c2 < b2.length; c2++)
          this.writeFixed32(a2, b2[c2]);
    };
    goog.exportProperty(jspb.BinaryWriter.prototype, "writeRepeatedFixed32", jspb.BinaryWriter.prototype.writeRepeatedFixed32);
    jspb.BinaryWriter.prototype.writeRepeatedFixed64 = function(a2, b2) {
      if (null != b2)
        for (var c2 = 0; c2 < b2.length; c2++)
          this.writeFixed64(a2, b2[c2]);
    };
    goog.exportProperty(jspb.BinaryWriter.prototype, "writeRepeatedFixed64", jspb.BinaryWriter.prototype.writeRepeatedFixed64);
    jspb.BinaryWriter.prototype.writeRepeatedFixed64String = function(a2, b2) {
      if (null != b2)
        for (var c2 = 0; c2 < b2.length; c2++)
          this.writeFixed64String(a2, b2[c2]);
    };
    goog.exportProperty(jspb.BinaryWriter.prototype, "writeRepeatedFixed64String", jspb.BinaryWriter.prototype.writeRepeatedFixed64String);
    jspb.BinaryWriter.prototype.writeRepeatedSfixed32 = function(a2, b2) {
      if (null != b2)
        for (var c2 = 0; c2 < b2.length; c2++)
          this.writeSfixed32(a2, b2[c2]);
    };
    goog.exportProperty(jspb.BinaryWriter.prototype, "writeRepeatedSfixed32", jspb.BinaryWriter.prototype.writeRepeatedSfixed32);
    jspb.BinaryWriter.prototype.writeRepeatedSfixed64 = function(a2, b2) {
      if (null != b2)
        for (var c2 = 0; c2 < b2.length; c2++)
          this.writeSfixed64(a2, b2[c2]);
    };
    goog.exportProperty(jspb.BinaryWriter.prototype, "writeRepeatedSfixed64", jspb.BinaryWriter.prototype.writeRepeatedSfixed64);
    jspb.BinaryWriter.prototype.writeRepeatedSfixed64String = function(a2, b2) {
      if (null != b2)
        for (var c2 = 0; c2 < b2.length; c2++)
          this.writeSfixed64String(a2, b2[c2]);
    };
    jspb.BinaryWriter.prototype.writeRepeatedFloat = function(a2, b2) {
      if (null != b2)
        for (var c2 = 0; c2 < b2.length; c2++)
          this.writeFloat(a2, b2[c2]);
    };
    goog.exportProperty(jspb.BinaryWriter.prototype, "writeRepeatedFloat", jspb.BinaryWriter.prototype.writeRepeatedFloat);
    jspb.BinaryWriter.prototype.writeRepeatedDouble = function(a2, b2) {
      if (null != b2)
        for (var c2 = 0; c2 < b2.length; c2++)
          this.writeDouble(a2, b2[c2]);
    };
    goog.exportProperty(jspb.BinaryWriter.prototype, "writeRepeatedDouble", jspb.BinaryWriter.prototype.writeRepeatedDouble);
    jspb.BinaryWriter.prototype.writeRepeatedBool = function(a2, b2) {
      if (null != b2)
        for (var c2 = 0; c2 < b2.length; c2++)
          this.writeBool(a2, b2[c2]);
    };
    goog.exportProperty(jspb.BinaryWriter.prototype, "writeRepeatedBool", jspb.BinaryWriter.prototype.writeRepeatedBool);
    jspb.BinaryWriter.prototype.writeRepeatedEnum = function(a2, b2) {
      if (null != b2)
        for (var c2 = 0; c2 < b2.length; c2++)
          this.writeEnum(a2, b2[c2]);
    };
    goog.exportProperty(jspb.BinaryWriter.prototype, "writeRepeatedEnum", jspb.BinaryWriter.prototype.writeRepeatedEnum);
    jspb.BinaryWriter.prototype.writeRepeatedString = function(a2, b2) {
      if (null != b2)
        for (var c2 = 0; c2 < b2.length; c2++)
          this.writeString(a2, b2[c2]);
    };
    goog.exportProperty(jspb.BinaryWriter.prototype, "writeRepeatedString", jspb.BinaryWriter.prototype.writeRepeatedString);
    jspb.BinaryWriter.prototype.writeRepeatedBytes = function(a2, b2) {
      if (null != b2)
        for (var c2 = 0; c2 < b2.length; c2++)
          this.writeBytes(a2, b2[c2]);
    };
    goog.exportProperty(jspb.BinaryWriter.prototype, "writeRepeatedBytes", jspb.BinaryWriter.prototype.writeRepeatedBytes);
    jspb.BinaryWriter.prototype.writeRepeatedMessage = function(a2, b2, c2) {
      if (null != b2)
        for (var d2 = 0; d2 < b2.length; d2++) {
          var e2 = this.beginDelimited_(a2);
          c2(b2[d2], this);
          this.endDelimited_(e2);
        }
    };
    goog.exportProperty(jspb.BinaryWriter.prototype, "writeRepeatedMessage", jspb.BinaryWriter.prototype.writeRepeatedMessage);
    jspb.BinaryWriter.prototype.writeRepeatedGroup = function(a2, b2, c2) {
      if (null != b2)
        for (var d2 = 0; d2 < b2.length; d2++)
          this.writeFieldHeader_(a2, jspb.BinaryConstants.WireType.START_GROUP), c2(b2[d2], this), this.writeFieldHeader_(a2, jspb.BinaryConstants.WireType.END_GROUP);
    };
    goog.exportProperty(jspb.BinaryWriter.prototype, "writeRepeatedGroup", jspb.BinaryWriter.prototype.writeRepeatedGroup);
    jspb.BinaryWriter.prototype.writeRepeatedFixedHash64 = function(a2, b2) {
      if (null != b2)
        for (var c2 = 0; c2 < b2.length; c2++)
          this.writeFixedHash64(a2, b2[c2]);
    };
    jspb.BinaryWriter.prototype.writeRepeatedVarintHash64 = function(a2, b2) {
      if (null != b2)
        for (var c2 = 0; c2 < b2.length; c2++)
          this.writeVarintHash64(a2, b2[c2]);
    };
    jspb.BinaryWriter.prototype.writePackedInt32 = function(a2, b2) {
      if (null != b2 && b2.length) {
        a2 = this.beginDelimited_(a2);
        for (var c2 = 0; c2 < b2.length; c2++)
          this.encoder_.writeSignedVarint32(b2[c2]);
        this.endDelimited_(a2);
      }
    };
    goog.exportProperty(jspb.BinaryWriter.prototype, "writePackedInt32", jspb.BinaryWriter.prototype.writePackedInt32);
    jspb.BinaryWriter.prototype.writePackedInt32String = function(a2, b2) {
      if (null != b2 && b2.length) {
        a2 = this.beginDelimited_(a2);
        for (var c2 = 0; c2 < b2.length; c2++)
          this.encoder_.writeSignedVarint32(parseInt(b2[c2], 10));
        this.endDelimited_(a2);
      }
    };
    jspb.BinaryWriter.prototype.writePackedInt64 = function(a2, b2) {
      if (null != b2 && b2.length) {
        a2 = this.beginDelimited_(a2);
        for (var c2 = 0; c2 < b2.length; c2++)
          this.encoder_.writeSignedVarint64(b2[c2]);
        this.endDelimited_(a2);
      }
    };
    goog.exportProperty(jspb.BinaryWriter.prototype, "writePackedInt64", jspb.BinaryWriter.prototype.writePackedInt64);
    jspb.BinaryWriter.prototype.writePackedSplitFixed64 = function(a2, b2, c2, d2) {
      if (null != b2) {
        a2 = this.beginDelimited_(a2);
        for (var e2 = 0; e2 < b2.length; e2++)
          this.encoder_.writeSplitFixed64(c2(b2[e2]), d2(b2[e2]));
        this.endDelimited_(a2);
      }
    };
    jspb.BinaryWriter.prototype.writePackedSplitVarint64 = function(a2, b2, c2, d2) {
      if (null != b2) {
        a2 = this.beginDelimited_(a2);
        for (var e2 = 0; e2 < b2.length; e2++)
          this.encoder_.writeSplitVarint64(c2(b2[e2]), d2(b2[e2]));
        this.endDelimited_(a2);
      }
    };
    jspb.BinaryWriter.prototype.writePackedSplitZigzagVarint64 = function(a2, b2, c2, d2) {
      if (null != b2) {
        a2 = this.beginDelimited_(a2);
        for (var e2 = this.encoder_, f2 = 0; f2 < b2.length; f2++)
          jspb.utils.toZigzag64(c2(b2[f2]), d2(b2[f2]), function(a3, b3) {
            e2.writeSplitVarint64(a3 >>> 0, b3 >>> 0);
          });
        this.endDelimited_(a2);
      }
    };
    jspb.BinaryWriter.prototype.writePackedInt64String = function(a2, b2) {
      if (null != b2 && b2.length) {
        a2 = this.beginDelimited_(a2);
        for (var c2 = 0; c2 < b2.length; c2++) {
          var d2 = jspb.arith.Int64.fromString(b2[c2]);
          this.encoder_.writeSplitVarint64(d2.lo, d2.hi);
        }
        this.endDelimited_(a2);
      }
    };
    jspb.BinaryWriter.prototype.writePackedUint32 = function(a2, b2) {
      if (null != b2 && b2.length) {
        a2 = this.beginDelimited_(a2);
        for (var c2 = 0; c2 < b2.length; c2++)
          this.encoder_.writeUnsignedVarint32(b2[c2]);
        this.endDelimited_(a2);
      }
    };
    goog.exportProperty(jspb.BinaryWriter.prototype, "writePackedUint32", jspb.BinaryWriter.prototype.writePackedUint32);
    jspb.BinaryWriter.prototype.writePackedUint32String = function(a2, b2) {
      if (null != b2 && b2.length) {
        a2 = this.beginDelimited_(a2);
        for (var c2 = 0; c2 < b2.length; c2++)
          this.encoder_.writeUnsignedVarint32(parseInt(b2[c2], 10));
        this.endDelimited_(a2);
      }
    };
    jspb.BinaryWriter.prototype.writePackedUint64 = function(a2, b2) {
      if (null != b2 && b2.length) {
        a2 = this.beginDelimited_(a2);
        for (var c2 = 0; c2 < b2.length; c2++)
          this.encoder_.writeUnsignedVarint64(b2[c2]);
        this.endDelimited_(a2);
      }
    };
    goog.exportProperty(jspb.BinaryWriter.prototype, "writePackedUint64", jspb.BinaryWriter.prototype.writePackedUint64);
    jspb.BinaryWriter.prototype.writePackedUint64String = function(a2, b2) {
      if (null != b2 && b2.length) {
        a2 = this.beginDelimited_(a2);
        for (var c2 = 0; c2 < b2.length; c2++) {
          var d2 = jspb.arith.UInt64.fromString(b2[c2]);
          this.encoder_.writeSplitVarint64(d2.lo, d2.hi);
        }
        this.endDelimited_(a2);
      }
    };
    jspb.BinaryWriter.prototype.writePackedSint32 = function(a2, b2) {
      if (null != b2 && b2.length) {
        a2 = this.beginDelimited_(a2);
        for (var c2 = 0; c2 < b2.length; c2++)
          this.encoder_.writeZigzagVarint32(b2[c2]);
        this.endDelimited_(a2);
      }
    };
    goog.exportProperty(jspb.BinaryWriter.prototype, "writePackedSint32", jspb.BinaryWriter.prototype.writePackedSint32);
    jspb.BinaryWriter.prototype.writePackedSint64 = function(a2, b2) {
      if (null != b2 && b2.length) {
        a2 = this.beginDelimited_(a2);
        for (var c2 = 0; c2 < b2.length; c2++)
          this.encoder_.writeZigzagVarint64(b2[c2]);
        this.endDelimited_(a2);
      }
    };
    goog.exportProperty(jspb.BinaryWriter.prototype, "writePackedSint64", jspb.BinaryWriter.prototype.writePackedSint64);
    jspb.BinaryWriter.prototype.writePackedSint64String = function(a2, b2) {
      if (null != b2 && b2.length) {
        a2 = this.beginDelimited_(a2);
        for (var c2 = 0; c2 < b2.length; c2++)
          this.encoder_.writeZigzagVarintHash64(jspb.utils.decimalStringToHash64(b2[c2]));
        this.endDelimited_(a2);
      }
    };
    jspb.BinaryWriter.prototype.writePackedSintHash64 = function(a2, b2) {
      if (null != b2 && b2.length) {
        a2 = this.beginDelimited_(a2);
        for (var c2 = 0; c2 < b2.length; c2++)
          this.encoder_.writeZigzagVarintHash64(b2[c2]);
        this.endDelimited_(a2);
      }
    };
    jspb.BinaryWriter.prototype.writePackedFixed32 = function(a2, b2) {
      if (null != b2 && b2.length)
        for (this.writeFieldHeader_(a2, jspb.BinaryConstants.WireType.DELIMITED), this.encoder_.writeUnsignedVarint32(4 * b2.length), a2 = 0; a2 < b2.length; a2++)
          this.encoder_.writeUint32(b2[a2]);
    };
    goog.exportProperty(jspb.BinaryWriter.prototype, "writePackedFixed32", jspb.BinaryWriter.prototype.writePackedFixed32);
    jspb.BinaryWriter.prototype.writePackedFixed64 = function(a2, b2) {
      if (null != b2 && b2.length)
        for (this.writeFieldHeader_(a2, jspb.BinaryConstants.WireType.DELIMITED), this.encoder_.writeUnsignedVarint32(8 * b2.length), a2 = 0; a2 < b2.length; a2++)
          this.encoder_.writeUint64(b2[a2]);
    };
    goog.exportProperty(jspb.BinaryWriter.prototype, "writePackedFixed64", jspb.BinaryWriter.prototype.writePackedFixed64);
    jspb.BinaryWriter.prototype.writePackedFixed64String = function(a2, b2) {
      if (null != b2 && b2.length)
        for (this.writeFieldHeader_(a2, jspb.BinaryConstants.WireType.DELIMITED), this.encoder_.writeUnsignedVarint32(8 * b2.length), a2 = 0; a2 < b2.length; a2++) {
          var c2 = jspb.arith.UInt64.fromString(b2[a2]);
          this.encoder_.writeSplitFixed64(c2.lo, c2.hi);
        }
    };
    jspb.BinaryWriter.prototype.writePackedSfixed32 = function(a2, b2) {
      if (null != b2 && b2.length)
        for (this.writeFieldHeader_(a2, jspb.BinaryConstants.WireType.DELIMITED), this.encoder_.writeUnsignedVarint32(4 * b2.length), a2 = 0; a2 < b2.length; a2++)
          this.encoder_.writeInt32(b2[a2]);
    };
    goog.exportProperty(jspb.BinaryWriter.prototype, "writePackedSfixed32", jspb.BinaryWriter.prototype.writePackedSfixed32);
    jspb.BinaryWriter.prototype.writePackedSfixed64 = function(a2, b2) {
      if (null != b2 && b2.length)
        for (this.writeFieldHeader_(a2, jspb.BinaryConstants.WireType.DELIMITED), this.encoder_.writeUnsignedVarint32(8 * b2.length), a2 = 0; a2 < b2.length; a2++)
          this.encoder_.writeInt64(b2[a2]);
    };
    goog.exportProperty(jspb.BinaryWriter.prototype, "writePackedSfixed64", jspb.BinaryWriter.prototype.writePackedSfixed64);
    jspb.BinaryWriter.prototype.writePackedSfixed64String = function(a2, b2) {
      if (null != b2 && b2.length)
        for (this.writeFieldHeader_(a2, jspb.BinaryConstants.WireType.DELIMITED), this.encoder_.writeUnsignedVarint32(8 * b2.length), a2 = 0; a2 < b2.length; a2++)
          this.encoder_.writeInt64String(b2[a2]);
    };
    jspb.BinaryWriter.prototype.writePackedFloat = function(a2, b2) {
      if (null != b2 && b2.length)
        for (this.writeFieldHeader_(a2, jspb.BinaryConstants.WireType.DELIMITED), this.encoder_.writeUnsignedVarint32(4 * b2.length), a2 = 0; a2 < b2.length; a2++)
          this.encoder_.writeFloat(b2[a2]);
    };
    goog.exportProperty(jspb.BinaryWriter.prototype, "writePackedFloat", jspb.BinaryWriter.prototype.writePackedFloat);
    jspb.BinaryWriter.prototype.writePackedDouble = function(a2, b2) {
      if (null != b2 && b2.length)
        for (this.writeFieldHeader_(a2, jspb.BinaryConstants.WireType.DELIMITED), this.encoder_.writeUnsignedVarint32(8 * b2.length), a2 = 0; a2 < b2.length; a2++)
          this.encoder_.writeDouble(b2[a2]);
    };
    goog.exportProperty(jspb.BinaryWriter.prototype, "writePackedDouble", jspb.BinaryWriter.prototype.writePackedDouble);
    jspb.BinaryWriter.prototype.writePackedBool = function(a2, b2) {
      if (null != b2 && b2.length)
        for (this.writeFieldHeader_(a2, jspb.BinaryConstants.WireType.DELIMITED), this.encoder_.writeUnsignedVarint32(b2.length), a2 = 0; a2 < b2.length; a2++)
          this.encoder_.writeBool(b2[a2]);
    };
    goog.exportProperty(jspb.BinaryWriter.prototype, "writePackedBool", jspb.BinaryWriter.prototype.writePackedBool);
    jspb.BinaryWriter.prototype.writePackedEnum = function(a2, b2) {
      if (null != b2 && b2.length) {
        a2 = this.beginDelimited_(a2);
        for (var c2 = 0; c2 < b2.length; c2++)
          this.encoder_.writeEnum(b2[c2]);
        this.endDelimited_(a2);
      }
    };
    goog.exportProperty(jspb.BinaryWriter.prototype, "writePackedEnum", jspb.BinaryWriter.prototype.writePackedEnum);
    jspb.BinaryWriter.prototype.writePackedFixedHash64 = function(a2, b2) {
      if (null != b2 && b2.length)
        for (this.writeFieldHeader_(a2, jspb.BinaryConstants.WireType.DELIMITED), this.encoder_.writeUnsignedVarint32(8 * b2.length), a2 = 0; a2 < b2.length; a2++)
          this.encoder_.writeFixedHash64(b2[a2]);
    };
    jspb.BinaryWriter.prototype.writePackedVarintHash64 = function(a2, b2) {
      if (null != b2 && b2.length) {
        a2 = this.beginDelimited_(a2);
        for (var c2 = 0; c2 < b2.length; c2++)
          this.encoder_.writeVarintHash64(b2[c2]);
        this.endDelimited_(a2);
      }
    };
    jspb.Map = function(a2, b2) {
      this.arr_ = a2;
      this.valueCtor_ = b2;
      this.map_ = {};
      this.arrClean = true;
      0 < this.arr_.length && this.loadFromArray_();
    };
    goog.exportSymbol("jspb.Map", jspb.Map);
    jspb.Map.prototype.loadFromArray_ = function() {
      for (var a2 = 0; a2 < this.arr_.length; a2++) {
        var b2 = this.arr_[a2], c2 = b2[0];
        this.map_[c2.toString()] = new jspb.Map.Entry_(c2, b2[1]);
      }
      this.arrClean = true;
    };
    jspb.Map.prototype.toArray = function() {
      if (this.arrClean) {
        if (this.valueCtor_) {
          var a2 = this.map_, b2;
          for (b2 in a2)
            if (Object.prototype.hasOwnProperty.call(a2, b2)) {
              var c2 = a2[b2].valueWrapper;
              c2 && c2.toArray();
            }
        }
      } else {
        this.arr_.length = 0;
        a2 = this.stringKeys_();
        a2.sort();
        for (b2 = 0; b2 < a2.length; b2++) {
          var d2 = this.map_[a2[b2]];
          (c2 = d2.valueWrapper) && c2.toArray();
          this.arr_.push([d2.key, d2.value]);
        }
        this.arrClean = true;
      }
      return this.arr_;
    };
    goog.exportProperty(jspb.Map.prototype, "toArray", jspb.Map.prototype.toArray);
    jspb.Map.prototype.toObject = function(a2, b2) {
      for (var c2 = this.toArray(), d2 = [], e2 = 0; e2 < c2.length; e2++) {
        var f2 = this.map_[c2[e2][0].toString()];
        this.wrapEntry_(f2);
        var g = f2.valueWrapper;
        g ? (jspb.asserts.assert(b2), d2.push([f2.key, b2(a2, g)])) : d2.push([f2.key, f2.value]);
      }
      return d2;
    };
    goog.exportProperty(jspb.Map.prototype, "toObject", jspb.Map.prototype.toObject);
    jspb.Map.fromObject = function(a2, b2, c2) {
      b2 = new jspb.Map([], b2);
      for (var d2 = 0; d2 < a2.length; d2++) {
        var e2 = a2[d2][0], f2 = c2(a2[d2][1]);
        b2.set(e2, f2);
      }
      return b2;
    };
    goog.exportProperty(jspb.Map, "fromObject", jspb.Map.fromObject);
    jspb.Map.ArrayIteratorIterable_ = function(a2) {
      this.idx_ = 0;
      this.arr_ = a2;
    };
    jspb.Map.ArrayIteratorIterable_.prototype.next = function() {
      return this.idx_ < this.arr_.length ? { done: false, value: this.arr_[this.idx_++] } : { done: true, value: void 0 };
    };
    "undefined" != typeof Symbol && (jspb.Map.ArrayIteratorIterable_.prototype[Symbol.iterator] = function() {
      return this;
    });
    jspb.Map.prototype.getLength = function() {
      return this.stringKeys_().length;
    };
    goog.exportProperty(jspb.Map.prototype, "getLength", jspb.Map.prototype.getLength);
    jspb.Map.prototype.clear = function() {
      this.map_ = {};
      this.arrClean = false;
    };
    goog.exportProperty(jspb.Map.prototype, "clear", jspb.Map.prototype.clear);
    jspb.Map.prototype.del = function(a2) {
      a2 = a2.toString();
      var b2 = this.map_.hasOwnProperty(a2);
      delete this.map_[a2];
      this.arrClean = false;
      return b2;
    };
    goog.exportProperty(jspb.Map.prototype, "del", jspb.Map.prototype.del);
    jspb.Map.prototype.getEntryList = function() {
      var a2 = [], b2 = this.stringKeys_();
      b2.sort();
      for (var c2 = 0; c2 < b2.length; c2++) {
        var d2 = this.map_[b2[c2]];
        a2.push([d2.key, d2.value]);
      }
      return a2;
    };
    goog.exportProperty(jspb.Map.prototype, "getEntryList", jspb.Map.prototype.getEntryList);
    jspb.Map.prototype.entries = function() {
      var a2 = [], b2 = this.stringKeys_();
      b2.sort();
      for (var c2 = 0; c2 < b2.length; c2++) {
        var d2 = this.map_[b2[c2]];
        a2.push([d2.key, this.wrapEntry_(d2)]);
      }
      return new jspb.Map.ArrayIteratorIterable_(a2);
    };
    goog.exportProperty(jspb.Map.prototype, "entries", jspb.Map.prototype.entries);
    jspb.Map.prototype.keys = function() {
      var a2 = [], b2 = this.stringKeys_();
      b2.sort();
      for (var c2 = 0; c2 < b2.length; c2++)
        a2.push(this.map_[b2[c2]].key);
      return new jspb.Map.ArrayIteratorIterable_(a2);
    };
    goog.exportProperty(jspb.Map.prototype, "keys", jspb.Map.prototype.keys);
    jspb.Map.prototype.values = function() {
      var a2 = [], b2 = this.stringKeys_();
      b2.sort();
      for (var c2 = 0; c2 < b2.length; c2++)
        a2.push(this.wrapEntry_(this.map_[b2[c2]]));
      return new jspb.Map.ArrayIteratorIterable_(a2);
    };
    goog.exportProperty(jspb.Map.prototype, "values", jspb.Map.prototype.values);
    jspb.Map.prototype.forEach = function(a2, b2) {
      var c2 = this.stringKeys_();
      c2.sort();
      for (var d2 = 0; d2 < c2.length; d2++) {
        var e2 = this.map_[c2[d2]];
        a2.call(b2, this.wrapEntry_(e2), e2.key, this);
      }
    };
    goog.exportProperty(jspb.Map.prototype, "forEach", jspb.Map.prototype.forEach);
    jspb.Map.prototype.set = function(a2, b2) {
      var c2 = new jspb.Map.Entry_(a2);
      this.valueCtor_ ? (c2.valueWrapper = b2, c2.value = b2.toArray()) : c2.value = b2;
      this.map_[a2.toString()] = c2;
      this.arrClean = false;
      return this;
    };
    goog.exportProperty(jspb.Map.prototype, "set", jspb.Map.prototype.set);
    jspb.Map.prototype.wrapEntry_ = function(a2) {
      return this.valueCtor_ ? (a2.valueWrapper || (a2.valueWrapper = new this.valueCtor_(a2.value)), a2.valueWrapper) : a2.value;
    };
    jspb.Map.prototype.get = function(a2) {
      if (a2 = this.map_[a2.toString()])
        return this.wrapEntry_(a2);
    };
    goog.exportProperty(jspb.Map.prototype, "get", jspb.Map.prototype.get);
    jspb.Map.prototype.has = function(a2) {
      return a2.toString() in this.map_;
    };
    goog.exportProperty(jspb.Map.prototype, "has", jspb.Map.prototype.has);
    jspb.Map.prototype.serializeBinary = function(a2, b2, c2, d2, e2) {
      var f2 = this.stringKeys_();
      f2.sort();
      for (var g = 0; g < f2.length; g++) {
        var h = this.map_[f2[g]];
        b2.beginSubMessage(a2);
        c2.call(b2, 1, h.key);
        this.valueCtor_ ? d2.call(b2, 2, this.wrapEntry_(h), e2) : d2.call(b2, 2, h.value);
        b2.endSubMessage();
      }
    };
    goog.exportProperty(jspb.Map.prototype, "serializeBinary", jspb.Map.prototype.serializeBinary);
    jspb.Map.deserializeBinary = function(a2, b2, c2, d2, e2, f2, g) {
      for (; b2.nextField() && !b2.isEndGroup(); ) {
        var h = b2.getFieldNumber();
        1 == h ? f2 = c2.call(b2) : 2 == h && (a2.valueCtor_ ? (jspb.asserts.assert(e2), g || (g = new a2.valueCtor_()), d2.call(b2, g, e2)) : g = d2.call(b2));
      }
      jspb.asserts.assert(void 0 != f2);
      jspb.asserts.assert(void 0 != g);
      a2.set(f2, g);
    };
    goog.exportProperty(jspb.Map, "deserializeBinary", jspb.Map.deserializeBinary);
    jspb.Map.prototype.stringKeys_ = function() {
      var a2 = this.map_, b2 = [], c2;
      for (c2 in a2)
        Object.prototype.hasOwnProperty.call(a2, c2) && b2.push(c2);
      return b2;
    };
    jspb.Map.Entry_ = function(a2, b2) {
      this.key = a2;
      this.value = b2;
      this.valueWrapper = void 0;
    };
    jspb.ExtensionFieldInfo = function(a2, b2, c2, d2, e2) {
      this.fieldIndex = a2;
      this.fieldName = b2;
      this.ctor = c2;
      this.toObjectFn = d2;
      this.isRepeated = e2;
    };
    goog.exportSymbol("jspb.ExtensionFieldInfo", jspb.ExtensionFieldInfo);
    jspb.ExtensionFieldBinaryInfo = function(a2, b2, c2, d2, e2, f2) {
      this.fieldInfo = a2;
      this.binaryReaderFn = b2;
      this.binaryWriterFn = c2;
      this.binaryMessageSerializeFn = d2;
      this.binaryMessageDeserializeFn = e2;
      this.isPacked = f2;
    };
    goog.exportSymbol("jspb.ExtensionFieldBinaryInfo", jspb.ExtensionFieldBinaryInfo);
    jspb.ExtensionFieldInfo.prototype.isMessageType = function() {
      return !!this.ctor;
    };
    goog.exportProperty(jspb.ExtensionFieldInfo.prototype, "isMessageType", jspb.ExtensionFieldInfo.prototype.isMessageType);
    jspb.Message = function() {
    };
    goog.exportSymbol("jspb.Message", jspb.Message);
    jspb.Message.GENERATE_TO_OBJECT = true;
    goog.exportProperty(jspb.Message, "GENERATE_TO_OBJECT", jspb.Message.GENERATE_TO_OBJECT);
    jspb.Message.GENERATE_FROM_OBJECT = !goog.DISALLOW_TEST_ONLY_CODE;
    goog.exportProperty(jspb.Message, "GENERATE_FROM_OBJECT", jspb.Message.GENERATE_FROM_OBJECT);
    jspb.Message.GENERATE_TO_STRING = true;
    jspb.Message.ASSUME_LOCAL_ARRAYS = false;
    jspb.Message.SERIALIZE_EMPTY_TRAILING_FIELDS = true;
    jspb.Message.SUPPORTS_UINT8ARRAY_ = "function" == typeof Uint8Array;
    jspb.Message.prototype.getJsPbMessageId = function() {
      return this.messageId_;
    };
    goog.exportProperty(jspb.Message.prototype, "getJsPbMessageId", jspb.Message.prototype.getJsPbMessageId);
    jspb.Message.getIndex_ = function(a2, b2) {
      return b2 + a2.arrayIndexOffset_;
    };
    jspb.Message.hiddenES6Property_ = function() {
    };
    jspb.Message.getFieldNumber_ = function(a2, b2) {
      return b2 - a2.arrayIndexOffset_;
    };
    jspb.Message.initialize = function(a2, b2, c2, d2, e2, f2) {
      a2.wrappers_ = null;
      b2 || (b2 = c2 ? [c2] : []);
      a2.messageId_ = c2 ? String(c2) : void 0;
      a2.arrayIndexOffset_ = 0 === c2 ? -1 : 0;
      a2.array = b2;
      jspb.Message.initPivotAndExtensionObject_(a2, d2);
      a2.convertedPrimitiveFields_ = {};
      jspb.Message.SERIALIZE_EMPTY_TRAILING_FIELDS || (a2.repeatedFields = e2);
      if (e2)
        for (b2 = 0; b2 < e2.length; b2++)
          c2 = e2[b2], c2 < a2.pivot_ ? (c2 = jspb.Message.getIndex_(a2, c2), a2.array[c2] = a2.array[c2] || jspb.Message.EMPTY_LIST_SENTINEL_) : (jspb.Message.maybeInitEmptyExtensionObject_(a2), a2.extensionObject_[c2] = a2.extensionObject_[c2] || jspb.Message.EMPTY_LIST_SENTINEL_);
      if (f2 && f2.length)
        for (b2 = 0; b2 < f2.length; b2++)
          jspb.Message.computeOneofCase(a2, f2[b2]);
    };
    goog.exportProperty(jspb.Message, "initialize", jspb.Message.initialize);
    jspb.Message.EMPTY_LIST_SENTINEL_ = goog.DEBUG && Object.freeze ? Object.freeze([]) : [];
    jspb.Message.isArray_ = function(a2) {
      return jspb.Message.ASSUME_LOCAL_ARRAYS ? a2 instanceof Array : Array.isArray(a2);
    };
    jspb.Message.isExtensionObject_ = function(a2) {
      return null !== a2 && "object" == typeof a2 && !jspb.Message.isArray_(a2) && !(jspb.Message.SUPPORTS_UINT8ARRAY_ && a2 instanceof Uint8Array);
    };
    jspb.Message.initPivotAndExtensionObject_ = function(a2, b2) {
      var c2 = a2.array.length, d2 = -1;
      if (c2 && (d2 = c2 - 1, c2 = a2.array[d2], jspb.Message.isExtensionObject_(c2))) {
        a2.pivot_ = jspb.Message.getFieldNumber_(a2, d2);
        a2.extensionObject_ = c2;
        return;
      }
      -1 < b2 ? (a2.pivot_ = Math.max(b2, jspb.Message.getFieldNumber_(a2, d2 + 1)), a2.extensionObject_ = null) : a2.pivot_ = Number.MAX_VALUE;
    };
    jspb.Message.maybeInitEmptyExtensionObject_ = function(a2) {
      var b2 = jspb.Message.getIndex_(a2, a2.pivot_);
      a2.array[b2] || (a2.extensionObject_ = a2.array[b2] = {});
    };
    jspb.Message.toObjectList = function(a2, b2, c2) {
      for (var d2 = [], e2 = 0; e2 < a2.length; e2++)
        d2[e2] = b2.call(a2[e2], c2, a2[e2]);
      return d2;
    };
    goog.exportProperty(jspb.Message, "toObjectList", jspb.Message.toObjectList);
    jspb.Message.toObjectExtension = function(a2, b2, c2, d2, e2) {
      for (var f2 in c2) {
        var g = c2[f2], h = d2.call(a2, g);
        if (null != h) {
          for (var k in g.fieldName)
            if (g.fieldName.hasOwnProperty(k))
              break;
          b2[k] = g.toObjectFn ? g.isRepeated ? jspb.Message.toObjectList(h, g.toObjectFn, e2) : g.toObjectFn(e2, h) : h;
        }
      }
    };
    goog.exportProperty(jspb.Message, "toObjectExtension", jspb.Message.toObjectExtension);
    jspb.Message.serializeBinaryExtensions = function(a2, b2, c2, d2) {
      for (var e2 in c2) {
        var f2 = c2[e2], g = f2.fieldInfo;
        if (!f2.binaryWriterFn)
          throw Error("Message extension present that was generated without binary serialization support");
        var h = d2.call(a2, g);
        if (null != h)
          if (g.isMessageType())
            if (f2.binaryMessageSerializeFn)
              f2.binaryWriterFn.call(b2, g.fieldIndex, h, f2.binaryMessageSerializeFn);
            else
              throw Error("Message extension present holding submessage without binary support enabled, and message is being serialized to binary format");
          else
            f2.binaryWriterFn.call(b2, g.fieldIndex, h);
      }
    };
    goog.exportProperty(jspb.Message, "serializeBinaryExtensions", jspb.Message.serializeBinaryExtensions);
    jspb.Message.readBinaryExtension = function(a2, b2, c2, d2, e2) {
      var f2 = c2[b2.getFieldNumber()];
      if (f2) {
        c2 = f2.fieldInfo;
        if (!f2.binaryReaderFn)
          throw Error("Deserializing extension whose generated code does not support binary format");
        if (c2.isMessageType()) {
          var g = new c2.ctor();
          f2.binaryReaderFn.call(b2, g, f2.binaryMessageDeserializeFn);
        } else
          g = f2.binaryReaderFn.call(b2);
        c2.isRepeated && !f2.isPacked ? (b2 = d2.call(a2, c2)) ? b2.push(g) : e2.call(a2, c2, [g]) : e2.call(a2, c2, g);
      } else
        b2.skipField();
    };
    goog.exportProperty(jspb.Message, "readBinaryExtension", jspb.Message.readBinaryExtension);
    jspb.Message.getField = function(a2, b2) {
      if (b2 < a2.pivot_) {
        b2 = jspb.Message.getIndex_(a2, b2);
        var c2 = a2.array[b2];
        return c2 === jspb.Message.EMPTY_LIST_SENTINEL_ ? a2.array[b2] = [] : c2;
      }
      if (a2.extensionObject_)
        return c2 = a2.extensionObject_[b2], c2 === jspb.Message.EMPTY_LIST_SENTINEL_ ? a2.extensionObject_[b2] = [] : c2;
    };
    goog.exportProperty(jspb.Message, "getField", jspb.Message.getField);
    jspb.Message.getRepeatedField = function(a2, b2) {
      return jspb.Message.getField(a2, b2);
    };
    goog.exportProperty(jspb.Message, "getRepeatedField", jspb.Message.getRepeatedField);
    jspb.Message.getOptionalFloatingPointField = function(a2, b2) {
      a2 = jspb.Message.getField(a2, b2);
      return null == a2 ? a2 : +a2;
    };
    goog.exportProperty(jspb.Message, "getOptionalFloatingPointField", jspb.Message.getOptionalFloatingPointField);
    jspb.Message.getBooleanField = function(a2, b2) {
      a2 = jspb.Message.getField(a2, b2);
      return null == a2 ? a2 : !!a2;
    };
    goog.exportProperty(jspb.Message, "getBooleanField", jspb.Message.getBooleanField);
    jspb.Message.getRepeatedFloatingPointField = function(a2, b2) {
      var c2 = jspb.Message.getRepeatedField(a2, b2);
      a2.convertedPrimitiveFields_ || (a2.convertedPrimitiveFields_ = {});
      if (!a2.convertedPrimitiveFields_[b2]) {
        for (var d2 = 0; d2 < c2.length; d2++)
          c2[d2] = +c2[d2];
        a2.convertedPrimitiveFields_[b2] = true;
      }
      return c2;
    };
    goog.exportProperty(jspb.Message, "getRepeatedFloatingPointField", jspb.Message.getRepeatedFloatingPointField);
    jspb.Message.getRepeatedBooleanField = function(a2, b2) {
      var c2 = jspb.Message.getRepeatedField(a2, b2);
      a2.convertedPrimitiveFields_ || (a2.convertedPrimitiveFields_ = {});
      if (!a2.convertedPrimitiveFields_[b2]) {
        for (var d2 = 0; d2 < c2.length; d2++)
          c2[d2] = !!c2[d2];
        a2.convertedPrimitiveFields_[b2] = true;
      }
      return c2;
    };
    goog.exportProperty(jspb.Message, "getRepeatedBooleanField", jspb.Message.getRepeatedBooleanField);
    jspb.Message.bytesAsB64 = function(a2) {
      if (null == a2 || "string" === typeof a2)
        return a2;
      if (jspb.Message.SUPPORTS_UINT8ARRAY_ && a2 instanceof Uint8Array)
        return goog.crypt.base64.encodeByteArray(a2);
      jspb.asserts.fail("Cannot coerce to b64 string: " + goog.typeOf(a2));
      return null;
    };
    goog.exportProperty(jspb.Message, "bytesAsB64", jspb.Message.bytesAsB64);
    jspb.Message.bytesAsU8 = function(a2) {
      if (null == a2 || a2 instanceof Uint8Array)
        return a2;
      if ("string" === typeof a2)
        return goog.crypt.base64.decodeStringToUint8Array(a2);
      jspb.asserts.fail("Cannot coerce to Uint8Array: " + goog.typeOf(a2));
      return null;
    };
    goog.exportProperty(jspb.Message, "bytesAsU8", jspb.Message.bytesAsU8);
    jspb.Message.bytesListAsB64 = function(a2) {
      jspb.Message.assertConsistentTypes_(a2);
      return a2.length && "string" !== typeof a2[0] ? goog.array.map(a2, jspb.Message.bytesAsB64) : a2;
    };
    goog.exportProperty(jspb.Message, "bytesListAsB64", jspb.Message.bytesListAsB64);
    jspb.Message.bytesListAsU8 = function(a2) {
      jspb.Message.assertConsistentTypes_(a2);
      return !a2.length || a2[0] instanceof Uint8Array ? a2 : goog.array.map(a2, jspb.Message.bytesAsU8);
    };
    goog.exportProperty(jspb.Message, "bytesListAsU8", jspb.Message.bytesListAsU8);
    jspb.Message.assertConsistentTypes_ = function(a2) {
      if (goog.DEBUG && a2 && 1 < a2.length) {
        var b2 = goog.typeOf(a2[0]);
        goog.array.forEach(a2, function(a3) {
          goog.typeOf(a3) != b2 && jspb.asserts.fail("Inconsistent type in JSPB repeated field array. Got " + goog.typeOf(a3) + " expected " + b2);
        });
      }
    };
    jspb.Message.getFieldWithDefault = function(a2, b2, c2) {
      a2 = jspb.Message.getField(a2, b2);
      return null == a2 ? c2 : a2;
    };
    goog.exportProperty(jspb.Message, "getFieldWithDefault", jspb.Message.getFieldWithDefault);
    jspb.Message.getBooleanFieldWithDefault = function(a2, b2, c2) {
      a2 = jspb.Message.getBooleanField(a2, b2);
      return null == a2 ? c2 : a2;
    };
    goog.exportProperty(jspb.Message, "getBooleanFieldWithDefault", jspb.Message.getBooleanFieldWithDefault);
    jspb.Message.getFloatingPointFieldWithDefault = function(a2, b2, c2) {
      a2 = jspb.Message.getOptionalFloatingPointField(a2, b2);
      return null == a2 ? c2 : a2;
    };
    goog.exportProperty(jspb.Message, "getFloatingPointFieldWithDefault", jspb.Message.getFloatingPointFieldWithDefault);
    jspb.Message.getFieldProto3 = jspb.Message.getFieldWithDefault;
    goog.exportProperty(jspb.Message, "getFieldProto3", jspb.Message.getFieldProto3);
    jspb.Message.getMapField = function(a2, b2, c2, d2) {
      a2.wrappers_ || (a2.wrappers_ = {});
      if (b2 in a2.wrappers_)
        return a2.wrappers_[b2];
      var e2 = jspb.Message.getField(a2, b2);
      if (!e2) {
        if (c2)
          return;
        e2 = [];
        jspb.Message.setField(a2, b2, e2);
      }
      return a2.wrappers_[b2] = new jspb.Map(e2, d2);
    };
    goog.exportProperty(jspb.Message, "getMapField", jspb.Message.getMapField);
    jspb.Message.setField = function(a2, b2, c2) {
      jspb.asserts.assertInstanceof(a2, jspb.Message);
      b2 < a2.pivot_ ? a2.array[jspb.Message.getIndex_(a2, b2)] = c2 : (jspb.Message.maybeInitEmptyExtensionObject_(a2), a2.extensionObject_[b2] = c2);
      return a2;
    };
    goog.exportProperty(jspb.Message, "setField", jspb.Message.setField);
    jspb.Message.setProto3IntField = function(a2, b2, c2) {
      return jspb.Message.setFieldIgnoringDefault_(a2, b2, c2, 0);
    };
    goog.exportProperty(jspb.Message, "setProto3IntField", jspb.Message.setProto3IntField);
    jspb.Message.setProto3FloatField = function(a2, b2, c2) {
      return jspb.Message.setFieldIgnoringDefault_(a2, b2, c2, 0);
    };
    goog.exportProperty(jspb.Message, "setProto3FloatField", jspb.Message.setProto3FloatField);
    jspb.Message.setProto3BooleanField = function(a2, b2, c2) {
      return jspb.Message.setFieldIgnoringDefault_(a2, b2, c2, false);
    };
    goog.exportProperty(jspb.Message, "setProto3BooleanField", jspb.Message.setProto3BooleanField);
    jspb.Message.setProto3StringField = function(a2, b2, c2) {
      return jspb.Message.setFieldIgnoringDefault_(a2, b2, c2, "");
    };
    goog.exportProperty(jspb.Message, "setProto3StringField", jspb.Message.setProto3StringField);
    jspb.Message.setProto3BytesField = function(a2, b2, c2) {
      return jspb.Message.setFieldIgnoringDefault_(a2, b2, c2, "");
    };
    goog.exportProperty(jspb.Message, "setProto3BytesField", jspb.Message.setProto3BytesField);
    jspb.Message.setProto3EnumField = function(a2, b2, c2) {
      return jspb.Message.setFieldIgnoringDefault_(a2, b2, c2, 0);
    };
    goog.exportProperty(jspb.Message, "setProto3EnumField", jspb.Message.setProto3EnumField);
    jspb.Message.setProto3StringIntField = function(a2, b2, c2) {
      return jspb.Message.setFieldIgnoringDefault_(a2, b2, c2, "0");
    };
    goog.exportProperty(jspb.Message, "setProto3StringIntField", jspb.Message.setProto3StringIntField);
    jspb.Message.setFieldIgnoringDefault_ = function(a2, b2, c2, d2) {
      jspb.asserts.assertInstanceof(a2, jspb.Message);
      c2 !== d2 ? jspb.Message.setField(a2, b2, c2) : b2 < a2.pivot_ ? a2.array[jspb.Message.getIndex_(a2, b2)] = null : (jspb.Message.maybeInitEmptyExtensionObject_(a2), delete a2.extensionObject_[b2]);
      return a2;
    };
    jspb.Message.addToRepeatedField = function(a2, b2, c2, d2) {
      jspb.asserts.assertInstanceof(a2, jspb.Message);
      b2 = jspb.Message.getRepeatedField(a2, b2);
      void 0 != d2 ? b2.splice(d2, 0, c2) : b2.push(c2);
      return a2;
    };
    goog.exportProperty(jspb.Message, "addToRepeatedField", jspb.Message.addToRepeatedField);
    jspb.Message.setOneofField = function(a2, b2, c2, d2) {
      jspb.asserts.assertInstanceof(a2, jspb.Message);
      (c2 = jspb.Message.computeOneofCase(a2, c2)) && c2 !== b2 && void 0 !== d2 && (a2.wrappers_ && c2 in a2.wrappers_ && (a2.wrappers_[c2] = void 0), jspb.Message.setField(a2, c2, void 0));
      return jspb.Message.setField(a2, b2, d2);
    };
    goog.exportProperty(jspb.Message, "setOneofField", jspb.Message.setOneofField);
    jspb.Message.computeOneofCase = function(a2, b2) {
      for (var c2, d2, e2 = 0; e2 < b2.length; e2++) {
        var f2 = b2[e2], g = jspb.Message.getField(a2, f2);
        null != g && (c2 = f2, d2 = g, jspb.Message.setField(a2, f2, void 0));
      }
      return c2 ? (jspb.Message.setField(a2, c2, d2), c2) : 0;
    };
    goog.exportProperty(jspb.Message, "computeOneofCase", jspb.Message.computeOneofCase);
    jspb.Message.getWrapperField = function(a2, b2, c2, d2) {
      a2.wrappers_ || (a2.wrappers_ = {});
      if (!a2.wrappers_[c2]) {
        var e2 = jspb.Message.getField(a2, c2);
        if (d2 || e2)
          a2.wrappers_[c2] = new b2(e2);
      }
      return a2.wrappers_[c2];
    };
    goog.exportProperty(jspb.Message, "getWrapperField", jspb.Message.getWrapperField);
    jspb.Message.getRepeatedWrapperField = function(a2, b2, c2) {
      jspb.Message.wrapRepeatedField_(a2, b2, c2);
      b2 = a2.wrappers_[c2];
      b2 == jspb.Message.EMPTY_LIST_SENTINEL_ && (b2 = a2.wrappers_[c2] = []);
      return b2;
    };
    goog.exportProperty(jspb.Message, "getRepeatedWrapperField", jspb.Message.getRepeatedWrapperField);
    jspb.Message.wrapRepeatedField_ = function(a2, b2, c2) {
      a2.wrappers_ || (a2.wrappers_ = {});
      if (!a2.wrappers_[c2]) {
        for (var d2 = jspb.Message.getRepeatedField(a2, c2), e2 = [], f2 = 0; f2 < d2.length; f2++)
          e2[f2] = new b2(d2[f2]);
        a2.wrappers_[c2] = e2;
      }
    };
    jspb.Message.setWrapperField = function(a2, b2, c2) {
      jspb.asserts.assertInstanceof(a2, jspb.Message);
      a2.wrappers_ || (a2.wrappers_ = {});
      var d2 = c2 ? c2.toArray() : c2;
      a2.wrappers_[b2] = c2;
      return jspb.Message.setField(a2, b2, d2);
    };
    goog.exportProperty(jspb.Message, "setWrapperField", jspb.Message.setWrapperField);
    jspb.Message.setOneofWrapperField = function(a2, b2, c2, d2) {
      jspb.asserts.assertInstanceof(a2, jspb.Message);
      a2.wrappers_ || (a2.wrappers_ = {});
      var e2 = d2 ? d2.toArray() : d2;
      a2.wrappers_[b2] = d2;
      return jspb.Message.setOneofField(a2, b2, c2, e2);
    };
    goog.exportProperty(jspb.Message, "setOneofWrapperField", jspb.Message.setOneofWrapperField);
    jspb.Message.setRepeatedWrapperField = function(a2, b2, c2) {
      jspb.asserts.assertInstanceof(a2, jspb.Message);
      a2.wrappers_ || (a2.wrappers_ = {});
      c2 = c2 || [];
      for (var d2 = [], e2 = 0; e2 < c2.length; e2++)
        d2[e2] = c2[e2].toArray();
      a2.wrappers_[b2] = c2;
      return jspb.Message.setField(a2, b2, d2);
    };
    goog.exportProperty(jspb.Message, "setRepeatedWrapperField", jspb.Message.setRepeatedWrapperField);
    jspb.Message.addToRepeatedWrapperField = function(a2, b2, c2, d2, e2) {
      jspb.Message.wrapRepeatedField_(a2, d2, b2);
      var f2 = a2.wrappers_[b2];
      f2 || (f2 = a2.wrappers_[b2] = []);
      c2 = c2 ? c2 : new d2();
      a2 = jspb.Message.getRepeatedField(a2, b2);
      void 0 != e2 ? (f2.splice(e2, 0, c2), a2.splice(e2, 0, c2.toArray())) : (f2.push(c2), a2.push(c2.toArray()));
      return c2;
    };
    goog.exportProperty(jspb.Message, "addToRepeatedWrapperField", jspb.Message.addToRepeatedWrapperField);
    jspb.Message.toMap = function(a2, b2, c2, d2) {
      for (var e2 = {}, f2 = 0; f2 < a2.length; f2++)
        e2[b2.call(a2[f2])] = c2 ? c2.call(a2[f2], d2, a2[f2]) : a2[f2];
      return e2;
    };
    goog.exportProperty(jspb.Message, "toMap", jspb.Message.toMap);
    jspb.Message.prototype.syncMapFields_ = function() {
      if (this.wrappers_)
        for (var a2 in this.wrappers_) {
          var b2 = this.wrappers_[a2];
          if (Array.isArray(b2))
            for (var c2 = 0; c2 < b2.length; c2++)
              b2[c2] && b2[c2].toArray();
          else
            b2 && b2.toArray();
        }
    };
    jspb.Message.prototype.toArray = function() {
      this.syncMapFields_();
      return this.array;
    };
    goog.exportProperty(jspb.Message.prototype, "toArray", jspb.Message.prototype.toArray);
    jspb.Message.GENERATE_TO_STRING && (jspb.Message.prototype.toString = function() {
      this.syncMapFields_();
      return this.array.toString();
    });
    jspb.Message.prototype.getExtension = function(a2) {
      if (this.extensionObject_) {
        this.wrappers_ || (this.wrappers_ = {});
        var b2 = a2.fieldIndex;
        if (a2.isRepeated) {
          if (a2.isMessageType())
            return this.wrappers_[b2] || (this.wrappers_[b2] = goog.array.map(this.extensionObject_[b2] || [], function(b3) {
              return new a2.ctor(b3);
            })), this.wrappers_[b2];
        } else if (a2.isMessageType())
          return !this.wrappers_[b2] && this.extensionObject_[b2] && (this.wrappers_[b2] = new a2.ctor(this.extensionObject_[b2])), this.wrappers_[b2];
        return this.extensionObject_[b2];
      }
    };
    goog.exportProperty(jspb.Message.prototype, "getExtension", jspb.Message.prototype.getExtension);
    jspb.Message.prototype.setExtension = function(a2, b2) {
      this.wrappers_ || (this.wrappers_ = {});
      jspb.Message.maybeInitEmptyExtensionObject_(this);
      var c2 = a2.fieldIndex;
      a2.isRepeated ? (b2 = b2 || [], a2.isMessageType() ? (this.wrappers_[c2] = b2, this.extensionObject_[c2] = goog.array.map(b2, function(a3) {
        return a3.toArray();
      })) : this.extensionObject_[c2] = b2) : a2.isMessageType() ? (this.wrappers_[c2] = b2, this.extensionObject_[c2] = b2 ? b2.toArray() : b2) : this.extensionObject_[c2] = b2;
      return this;
    };
    goog.exportProperty(jspb.Message.prototype, "setExtension", jspb.Message.prototype.setExtension);
    jspb.Message.difference = function(a2, b2) {
      if (!(a2 instanceof b2.constructor))
        throw Error("Messages have different types.");
      var c2 = a2.toArray();
      b2 = b2.toArray();
      var d2 = [], e2 = 0, f2 = c2.length > b2.length ? c2.length : b2.length;
      a2.getJsPbMessageId() && (d2[0] = a2.getJsPbMessageId(), e2 = 1);
      for (; e2 < f2; e2++)
        jspb.Message.compareFields(c2[e2], b2[e2]) || (d2[e2] = b2[e2]);
      return new a2.constructor(d2);
    };
    goog.exportProperty(jspb.Message, "difference", jspb.Message.difference);
    jspb.Message.equals = function(a2, b2) {
      return a2 == b2 || !(!a2 || !b2) && a2 instanceof b2.constructor && jspb.Message.compareFields(a2.toArray(), b2.toArray());
    };
    goog.exportProperty(jspb.Message, "equals", jspb.Message.equals);
    jspb.Message.compareExtensions = function(a2, b2) {
      a2 = a2 || {};
      b2 = b2 || {};
      var c2 = {}, d2;
      for (d2 in a2)
        c2[d2] = 0;
      for (d2 in b2)
        c2[d2] = 0;
      for (d2 in c2)
        if (!jspb.Message.compareFields(a2[d2], b2[d2]))
          return false;
      return true;
    };
    goog.exportProperty(jspb.Message, "compareExtensions", jspb.Message.compareExtensions);
    jspb.Message.compareFields = function(a2, b2) {
      if (a2 == b2)
        return true;
      if (!goog.isObject(a2) || !goog.isObject(b2))
        return "number" === typeof a2 && isNaN(a2) || "number" === typeof b2 && isNaN(b2) ? String(a2) == String(b2) : false;
      if (a2.constructor != b2.constructor)
        return false;
      if (jspb.Message.SUPPORTS_UINT8ARRAY_ && a2.constructor === Uint8Array) {
        if (a2.length != b2.length)
          return false;
        for (var c2 = 0; c2 < a2.length; c2++)
          if (a2[c2] != b2[c2])
            return false;
        return true;
      }
      if (a2.constructor === Array) {
        var d2 = void 0, e2 = void 0, f2 = Math.max(a2.length, b2.length);
        for (c2 = 0; c2 < f2; c2++) {
          var g = a2[c2], h = b2[c2];
          g && g.constructor == Object && (jspb.asserts.assert(void 0 === d2), jspb.asserts.assert(c2 === a2.length - 1), d2 = g, g = void 0);
          h && h.constructor == Object && (jspb.asserts.assert(void 0 === e2), jspb.asserts.assert(c2 === b2.length - 1), e2 = h, h = void 0);
          if (!jspb.Message.compareFields(g, h))
            return false;
        }
        return d2 || e2 ? (d2 = d2 || {}, e2 = e2 || {}, jspb.Message.compareExtensions(d2, e2)) : true;
      }
      if (a2.constructor === Object)
        return jspb.Message.compareExtensions(a2, b2);
      throw Error("Invalid type in JSPB array");
    };
    goog.exportProperty(jspb.Message, "compareFields", jspb.Message.compareFields);
    jspb.Message.prototype.cloneMessage = function() {
      return jspb.Message.cloneMessage(this);
    };
    goog.exportProperty(jspb.Message.prototype, "cloneMessage", jspb.Message.prototype.cloneMessage);
    jspb.Message.prototype.clone = function() {
      return jspb.Message.cloneMessage(this);
    };
    goog.exportProperty(jspb.Message.prototype, "clone", jspb.Message.prototype.clone);
    jspb.Message.clone = function(a2) {
      return jspb.Message.cloneMessage(a2);
    };
    goog.exportProperty(jspb.Message, "clone", jspb.Message.clone);
    jspb.Message.cloneMessage = function(a2) {
      return new a2.constructor(jspb.Message.clone_(a2.toArray()));
    };
    jspb.Message.copyInto = function(a2, b2) {
      jspb.asserts.assertInstanceof(a2, jspb.Message);
      jspb.asserts.assertInstanceof(b2, jspb.Message);
      jspb.asserts.assert(a2.constructor == b2.constructor, "Copy source and target message should have the same type.");
      a2 = jspb.Message.clone(a2);
      for (var c2 = b2.toArray(), d2 = a2.toArray(), e2 = c2.length = 0; e2 < d2.length; e2++)
        c2[e2] = d2[e2];
      b2.wrappers_ = a2.wrappers_;
      b2.extensionObject_ = a2.extensionObject_;
    };
    goog.exportProperty(jspb.Message, "copyInto", jspb.Message.copyInto);
    jspb.Message.clone_ = function(a2) {
      if (Array.isArray(a2)) {
        for (var b2 = Array(a2.length), c2 = 0; c2 < a2.length; c2++) {
          var d2 = a2[c2];
          null != d2 && (b2[c2] = "object" == typeof d2 ? jspb.Message.clone_(jspb.asserts.assert(d2)) : d2);
        }
        return b2;
      }
      if (jspb.Message.SUPPORTS_UINT8ARRAY_ && a2 instanceof Uint8Array)
        return new Uint8Array(a2);
      b2 = {};
      for (c2 in a2)
        d2 = a2[c2], null != d2 && (b2[c2] = "object" == typeof d2 ? jspb.Message.clone_(jspb.asserts.assert(d2)) : d2);
      return b2;
    };
    jspb.Message.registerMessageType = function(a2, b2) {
      b2.messageId = a2;
    };
    goog.exportProperty(jspb.Message, "registerMessageType", jspb.Message.registerMessageType);
    jspb.Message.messageSetExtensions = {};
    jspb.Message.messageSetExtensionsBinary = {};
    jspb.Export = {};
    "object" === typeof exports && (exports.Map = jspb.Map, exports.Message = jspb.Message, exports.BinaryReader = jspb.BinaryReader, exports.BinaryWriter = jspb.BinaryWriter, exports.ExtensionFieldInfo = jspb.ExtensionFieldInfo, exports.ExtensionFieldBinaryInfo = jspb.ExtensionFieldBinaryInfo, exports.exportSymbol = goog.exportSymbol, exports.inherits = goog.inherits, exports.object = { extend: goog.object.extend }, exports.typeOf = goog.typeOf);
  }
});

// static-codegen5/tfplugin5.3_pb.js
var require_tfplugin5_3_pb = __commonJS({
  "static-codegen5/tfplugin5.3_pb.js"(exports2) {
    "use strict";
    var jspb2 = require_google_protobuf();
    var goog2 = jspb2;
    var global2 = function() {
      if (this) {
        return this;
      }
      if (typeof window !== "undefined") {
        return window;
      }
      if (typeof global2 !== "undefined") {
        return global2;
      }
      if (typeof self !== "undefined") {
        return self;
      }
      return Function("return this")();
    }.call(null);
    goog2.exportSymbol("proto.tfplugin5.ApplyResourceChange", null, global2);
    goog2.exportSymbol("proto.tfplugin5.ApplyResourceChange.Request", null, global2);
    goog2.exportSymbol("proto.tfplugin5.ApplyResourceChange.Response", null, global2);
    goog2.exportSymbol("proto.tfplugin5.AttributePath", null, global2);
    goog2.exportSymbol("proto.tfplugin5.AttributePath.Step", null, global2);
    goog2.exportSymbol("proto.tfplugin5.AttributePath.Step.SelectorCase", null, global2);
    goog2.exportSymbol("proto.tfplugin5.Configure", null, global2);
    goog2.exportSymbol("proto.tfplugin5.Configure.Request", null, global2);
    goog2.exportSymbol("proto.tfplugin5.Configure.Response", null, global2);
    goog2.exportSymbol("proto.tfplugin5.Diagnostic", null, global2);
    goog2.exportSymbol("proto.tfplugin5.Diagnostic.Severity", null, global2);
    goog2.exportSymbol("proto.tfplugin5.DynamicValue", null, global2);
    goog2.exportSymbol("proto.tfplugin5.GetProviderSchema", null, global2);
    goog2.exportSymbol("proto.tfplugin5.GetProviderSchema.Request", null, global2);
    goog2.exportSymbol("proto.tfplugin5.GetProviderSchema.Response", null, global2);
    goog2.exportSymbol("proto.tfplugin5.GetProviderSchema.ServerCapabilities", null, global2);
    goog2.exportSymbol("proto.tfplugin5.GetProvisionerSchema", null, global2);
    goog2.exportSymbol("proto.tfplugin5.GetProvisionerSchema.Request", null, global2);
    goog2.exportSymbol("proto.tfplugin5.GetProvisionerSchema.Response", null, global2);
    goog2.exportSymbol("proto.tfplugin5.ImportResourceState", null, global2);
    goog2.exportSymbol("proto.tfplugin5.ImportResourceState.ImportedResource", null, global2);
    goog2.exportSymbol("proto.tfplugin5.ImportResourceState.Request", null, global2);
    goog2.exportSymbol("proto.tfplugin5.ImportResourceState.Response", null, global2);
    goog2.exportSymbol("proto.tfplugin5.PlanResourceChange", null, global2);
    goog2.exportSymbol("proto.tfplugin5.PlanResourceChange.Request", null, global2);
    goog2.exportSymbol("proto.tfplugin5.PlanResourceChange.Response", null, global2);
    goog2.exportSymbol("proto.tfplugin5.PrepareProviderConfig", null, global2);
    goog2.exportSymbol("proto.tfplugin5.PrepareProviderConfig.Request", null, global2);
    goog2.exportSymbol("proto.tfplugin5.PrepareProviderConfig.Response", null, global2);
    goog2.exportSymbol("proto.tfplugin5.ProvisionResource", null, global2);
    goog2.exportSymbol("proto.tfplugin5.ProvisionResource.Request", null, global2);
    goog2.exportSymbol("proto.tfplugin5.ProvisionResource.Response", null, global2);
    goog2.exportSymbol("proto.tfplugin5.RawState", null, global2);
    goog2.exportSymbol("proto.tfplugin5.ReadDataSource", null, global2);
    goog2.exportSymbol("proto.tfplugin5.ReadDataSource.Request", null, global2);
    goog2.exportSymbol("proto.tfplugin5.ReadDataSource.Response", null, global2);
    goog2.exportSymbol("proto.tfplugin5.ReadResource", null, global2);
    goog2.exportSymbol("proto.tfplugin5.ReadResource.Request", null, global2);
    goog2.exportSymbol("proto.tfplugin5.ReadResource.Response", null, global2);
    goog2.exportSymbol("proto.tfplugin5.Schema", null, global2);
    goog2.exportSymbol("proto.tfplugin5.Schema.Attribute", null, global2);
    goog2.exportSymbol("proto.tfplugin5.Schema.Block", null, global2);
    goog2.exportSymbol("proto.tfplugin5.Schema.NestedBlock", null, global2);
    goog2.exportSymbol("proto.tfplugin5.Schema.NestedBlock.NestingMode", null, global2);
    goog2.exportSymbol("proto.tfplugin5.Stop", null, global2);
    goog2.exportSymbol("proto.tfplugin5.Stop.Request", null, global2);
    goog2.exportSymbol("proto.tfplugin5.Stop.Response", null, global2);
    goog2.exportSymbol("proto.tfplugin5.StringKind", null, global2);
    goog2.exportSymbol("proto.tfplugin5.UpgradeResourceState", null, global2);
    goog2.exportSymbol("proto.tfplugin5.UpgradeResourceState.Request", null, global2);
    goog2.exportSymbol("proto.tfplugin5.UpgradeResourceState.Response", null, global2);
    goog2.exportSymbol("proto.tfplugin5.ValidateDataSourceConfig", null, global2);
    goog2.exportSymbol("proto.tfplugin5.ValidateDataSourceConfig.Request", null, global2);
    goog2.exportSymbol("proto.tfplugin5.ValidateDataSourceConfig.Response", null, global2);
    goog2.exportSymbol("proto.tfplugin5.ValidateProvisionerConfig", null, global2);
    goog2.exportSymbol("proto.tfplugin5.ValidateProvisionerConfig.Request", null, global2);
    goog2.exportSymbol("proto.tfplugin5.ValidateProvisionerConfig.Response", null, global2);
    goog2.exportSymbol("proto.tfplugin5.ValidateResourceTypeConfig", null, global2);
    goog2.exportSymbol("proto.tfplugin5.ValidateResourceTypeConfig.Request", null, global2);
    goog2.exportSymbol("proto.tfplugin5.ValidateResourceTypeConfig.Response", null, global2);
    proto.tfplugin5.DynamicValue = function(opt_data) {
      jspb2.Message.initialize(this, opt_data, 0, -1, null, null);
    };
    goog2.inherits(proto.tfplugin5.DynamicValue, jspb2.Message);
    if (goog2.DEBUG && !COMPILED) {
      proto.tfplugin5.DynamicValue.displayName = "proto.tfplugin5.DynamicValue";
    }
    proto.tfplugin5.Diagnostic = function(opt_data) {
      jspb2.Message.initialize(this, opt_data, 0, -1, null, null);
    };
    goog2.inherits(proto.tfplugin5.Diagnostic, jspb2.Message);
    if (goog2.DEBUG && !COMPILED) {
      proto.tfplugin5.Diagnostic.displayName = "proto.tfplugin5.Diagnostic";
    }
    proto.tfplugin5.AttributePath = function(opt_data) {
      jspb2.Message.initialize(this, opt_data, 0, -1, proto.tfplugin5.AttributePath.repeatedFields_, null);
    };
    goog2.inherits(proto.tfplugin5.AttributePath, jspb2.Message);
    if (goog2.DEBUG && !COMPILED) {
      proto.tfplugin5.AttributePath.displayName = "proto.tfplugin5.AttributePath";
    }
    proto.tfplugin5.AttributePath.Step = function(opt_data) {
      jspb2.Message.initialize(this, opt_data, 0, -1, null, proto.tfplugin5.AttributePath.Step.oneofGroups_);
    };
    goog2.inherits(proto.tfplugin5.AttributePath.Step, jspb2.Message);
    if (goog2.DEBUG && !COMPILED) {
      proto.tfplugin5.AttributePath.Step.displayName = "proto.tfplugin5.AttributePath.Step";
    }
    proto.tfplugin5.Stop = function(opt_data) {
      jspb2.Message.initialize(this, opt_data, 0, -1, null, null);
    };
    goog2.inherits(proto.tfplugin5.Stop, jspb2.Message);
    if (goog2.DEBUG && !COMPILED) {
      proto.tfplugin5.Stop.displayName = "proto.tfplugin5.Stop";
    }
    proto.tfplugin5.Stop.Request = function(opt_data) {
      jspb2.Message.initialize(this, opt_data, 0, -1, null, null);
    };
    goog2.inherits(proto.tfplugin5.Stop.Request, jspb2.Message);
    if (goog2.DEBUG && !COMPILED) {
      proto.tfplugin5.Stop.Request.displayName = "proto.tfplugin5.Stop.Request";
    }
    proto.tfplugin5.Stop.Response = function(opt_data) {
      jspb2.Message.initialize(this, opt_data, 0, -1, null, null);
    };
    goog2.inherits(proto.tfplugin5.Stop.Response, jspb2.Message);
    if (goog2.DEBUG && !COMPILED) {
      proto.tfplugin5.Stop.Response.displayName = "proto.tfplugin5.Stop.Response";
    }
    proto.tfplugin5.RawState = function(opt_data) {
      jspb2.Message.initialize(this, opt_data, 0, -1, null, null);
    };
    goog2.inherits(proto.tfplugin5.RawState, jspb2.Message);
    if (goog2.DEBUG && !COMPILED) {
      proto.tfplugin5.RawState.displayName = "proto.tfplugin5.RawState";
    }
    proto.tfplugin5.Schema = function(opt_data) {
      jspb2.Message.initialize(this, opt_data, 0, -1, null, null);
    };
    goog2.inherits(proto.tfplugin5.Schema, jspb2.Message);
    if (goog2.DEBUG && !COMPILED) {
      proto.tfplugin5.Schema.displayName = "proto.tfplugin5.Schema";
    }
    proto.tfplugin5.Schema.Block = function(opt_data) {
      jspb2.Message.initialize(this, opt_data, 0, -1, proto.tfplugin5.Schema.Block.repeatedFields_, null);
    };
    goog2.inherits(proto.tfplugin5.Schema.Block, jspb2.Message);
    if (goog2.DEBUG && !COMPILED) {
      proto.tfplugin5.Schema.Block.displayName = "proto.tfplugin5.Schema.Block";
    }
    proto.tfplugin5.Schema.Attribute = function(opt_data) {
      jspb2.Message.initialize(this, opt_data, 0, -1, null, null);
    };
    goog2.inherits(proto.tfplugin5.Schema.Attribute, jspb2.Message);
    if (goog2.DEBUG && !COMPILED) {
      proto.tfplugin5.Schema.Attribute.displayName = "proto.tfplugin5.Schema.Attribute";
    }
    proto.tfplugin5.Schema.NestedBlock = function(opt_data) {
      jspb2.Message.initialize(this, opt_data, 0, -1, null, null);
    };
    goog2.inherits(proto.tfplugin5.Schema.NestedBlock, jspb2.Message);
    if (goog2.DEBUG && !COMPILED) {
      proto.tfplugin5.Schema.NestedBlock.displayName = "proto.tfplugin5.Schema.NestedBlock";
    }
    proto.tfplugin5.GetProviderSchema = function(opt_data) {
      jspb2.Message.initialize(this, opt_data, 0, -1, null, null);
    };
    goog2.inherits(proto.tfplugin5.GetProviderSchema, jspb2.Message);
    if (goog2.DEBUG && !COMPILED) {
      proto.tfplugin5.GetProviderSchema.displayName = "proto.tfplugin5.GetProviderSchema";
    }
    proto.tfplugin5.GetProviderSchema.Request = function(opt_data) {
      jspb2.Message.initialize(this, opt_data, 0, -1, null, null);
    };
    goog2.inherits(proto.tfplugin5.GetProviderSchema.Request, jspb2.Message);
    if (goog2.DEBUG && !COMPILED) {
      proto.tfplugin5.GetProviderSchema.Request.displayName = "proto.tfplugin5.GetProviderSchema.Request";
    }
    proto.tfplugin5.GetProviderSchema.Response = function(opt_data) {
      jspb2.Message.initialize(this, opt_data, 0, -1, proto.tfplugin5.GetProviderSchema.Response.repeatedFields_, null);
    };
    goog2.inherits(proto.tfplugin5.GetProviderSchema.Response, jspb2.Message);
    if (goog2.DEBUG && !COMPILED) {
      proto.tfplugin5.GetProviderSchema.Response.displayName = "proto.tfplugin5.GetProviderSchema.Response";
    }
    proto.tfplugin5.GetProviderSchema.ServerCapabilities = function(opt_data) {
      jspb2.Message.initialize(this, opt_data, 0, -1, null, null);
    };
    goog2.inherits(proto.tfplugin5.GetProviderSchema.ServerCapabilities, jspb2.Message);
    if (goog2.DEBUG && !COMPILED) {
      proto.tfplugin5.GetProviderSchema.ServerCapabilities.displayName = "proto.tfplugin5.GetProviderSchema.ServerCapabilities";
    }
    proto.tfplugin5.PrepareProviderConfig = function(opt_data) {
      jspb2.Message.initialize(this, opt_data, 0, -1, null, null);
    };
    goog2.inherits(proto.tfplugin5.PrepareProviderConfig, jspb2.Message);
    if (goog2.DEBUG && !COMPILED) {
      proto.tfplugin5.PrepareProviderConfig.displayName = "proto.tfplugin5.PrepareProviderConfig";
    }
    proto.tfplugin5.PrepareProviderConfig.Request = function(opt_data) {
      jspb2.Message.initialize(this, opt_data, 0, -1, null, null);
    };
    goog2.inherits(proto.tfplugin5.PrepareProviderConfig.Request, jspb2.Message);
    if (goog2.DEBUG && !COMPILED) {
      proto.tfplugin5.PrepareProviderConfig.Request.displayName = "proto.tfplugin5.PrepareProviderConfig.Request";
    }
    proto.tfplugin5.PrepareProviderConfig.Response = function(opt_data) {
      jspb2.Message.initialize(this, opt_data, 0, -1, proto.tfplugin5.PrepareProviderConfig.Response.repeatedFields_, null);
    };
    goog2.inherits(proto.tfplugin5.PrepareProviderConfig.Response, jspb2.Message);
    if (goog2.DEBUG && !COMPILED) {
      proto.tfplugin5.PrepareProviderConfig.Response.displayName = "proto.tfplugin5.PrepareProviderConfig.Response";
    }
    proto.tfplugin5.UpgradeResourceState = function(opt_data) {
      jspb2.Message.initialize(this, opt_data, 0, -1, null, null);
    };
    goog2.inherits(proto.tfplugin5.UpgradeResourceState, jspb2.Message);
    if (goog2.DEBUG && !COMPILED) {
      proto.tfplugin5.UpgradeResourceState.displayName = "proto.tfplugin5.UpgradeResourceState";
    }
    proto.tfplugin5.UpgradeResourceState.Request = function(opt_data) {
      jspb2.Message.initialize(this, opt_data, 0, -1, null, null);
    };
    goog2.inherits(proto.tfplugin5.UpgradeResourceState.Request, jspb2.Message);
    if (goog2.DEBUG && !COMPILED) {
      proto.tfplugin5.UpgradeResourceState.Request.displayName = "proto.tfplugin5.UpgradeResourceState.Request";
    }
    proto.tfplugin5.UpgradeResourceState.Response = function(opt_data) {
      jspb2.Message.initialize(this, opt_data, 0, -1, proto.tfplugin5.UpgradeResourceState.Response.repeatedFields_, null);
    };
    goog2.inherits(proto.tfplugin5.UpgradeResourceState.Response, jspb2.Message);
    if (goog2.DEBUG && !COMPILED) {
      proto.tfplugin5.UpgradeResourceState.Response.displayName = "proto.tfplugin5.UpgradeResourceState.Response";
    }
    proto.tfplugin5.ValidateResourceTypeConfig = function(opt_data) {
      jspb2.Message.initialize(this, opt_data, 0, -1, null, null);
    };
    goog2.inherits(proto.tfplugin5.ValidateResourceTypeConfig, jspb2.Message);
    if (goog2.DEBUG && !COMPILED) {
      proto.tfplugin5.ValidateResourceTypeConfig.displayName = "proto.tfplugin5.ValidateResourceTypeConfig";
    }
    proto.tfplugin5.ValidateResourceTypeConfig.Request = function(opt_data) {
      jspb2.Message.initialize(this, opt_data, 0, -1, null, null);
    };
    goog2.inherits(proto.tfplugin5.ValidateResourceTypeConfig.Request, jspb2.Message);
    if (goog2.DEBUG && !COMPILED) {
      proto.tfplugin5.ValidateResourceTypeConfig.Request.displayName = "proto.tfplugin5.ValidateResourceTypeConfig.Request";
    }
    proto.tfplugin5.ValidateResourceTypeConfig.Response = function(opt_data) {
      jspb2.Message.initialize(this, opt_data, 0, -1, proto.tfplugin5.ValidateResourceTypeConfig.Response.repeatedFields_, null);
    };
    goog2.inherits(proto.tfplugin5.ValidateResourceTypeConfig.Response, jspb2.Message);
    if (goog2.DEBUG && !COMPILED) {
      proto.tfplugin5.ValidateResourceTypeConfig.Response.displayName = "proto.tfplugin5.ValidateResourceTypeConfig.Response";
    }
    proto.tfplugin5.ValidateDataSourceConfig = function(opt_data) {
      jspb2.Message.initialize(this, opt_data, 0, -1, null, null);
    };
    goog2.inherits(proto.tfplugin5.ValidateDataSourceConfig, jspb2.Message);
    if (goog2.DEBUG && !COMPILED) {
      proto.tfplugin5.ValidateDataSourceConfig.displayName = "proto.tfplugin5.ValidateDataSourceConfig";
    }
    proto.tfplugin5.ValidateDataSourceConfig.Request = function(opt_data) {
      jspb2.Message.initialize(this, opt_data, 0, -1, null, null);
    };
    goog2.inherits(proto.tfplugin5.ValidateDataSourceConfig.Request, jspb2.Message);
    if (goog2.DEBUG && !COMPILED) {
      proto.tfplugin5.ValidateDataSourceConfig.Request.displayName = "proto.tfplugin5.ValidateDataSourceConfig.Request";
    }
    proto.tfplugin5.ValidateDataSourceConfig.Response = function(opt_data) {
      jspb2.Message.initialize(this, opt_data, 0, -1, proto.tfplugin5.ValidateDataSourceConfig.Response.repeatedFields_, null);
    };
    goog2.inherits(proto.tfplugin5.ValidateDataSourceConfig.Response, jspb2.Message);
    if (goog2.DEBUG && !COMPILED) {
      proto.tfplugin5.ValidateDataSourceConfig.Response.displayName = "proto.tfplugin5.ValidateDataSourceConfig.Response";
    }
    proto.tfplugin5.Configure = function(opt_data) {
      jspb2.Message.initialize(this, opt_data, 0, -1, null, null);
    };
    goog2.inherits(proto.tfplugin5.Configure, jspb2.Message);
    if (goog2.DEBUG && !COMPILED) {
      proto.tfplugin5.Configure.displayName = "proto.tfplugin5.Configure";
    }
    proto.tfplugin5.Configure.Request = function(opt_data) {
      jspb2.Message.initialize(this, opt_data, 0, -1, null, null);
    };
    goog2.inherits(proto.tfplugin5.Configure.Request, jspb2.Message);
    if (goog2.DEBUG && !COMPILED) {
      proto.tfplugin5.Configure.Request.displayName = "proto.tfplugin5.Configure.Request";
    }
    proto.tfplugin5.Configure.Response = function(opt_data) {
      jspb2.Message.initialize(this, opt_data, 0, -1, proto.tfplugin5.Configure.Response.repeatedFields_, null);
    };
    goog2.inherits(proto.tfplugin5.Configure.Response, jspb2.Message);
    if (goog2.DEBUG && !COMPILED) {
      proto.tfplugin5.Configure.Response.displayName = "proto.tfplugin5.Configure.Response";
    }
    proto.tfplugin5.ReadResource = function(opt_data) {
      jspb2.Message.initialize(this, opt_data, 0, -1, null, null);
    };
    goog2.inherits(proto.tfplugin5.ReadResource, jspb2.Message);
    if (goog2.DEBUG && !COMPILED) {
      proto.tfplugin5.ReadResource.displayName = "proto.tfplugin5.ReadResource";
    }
    proto.tfplugin5.ReadResource.Request = function(opt_data) {
      jspb2.Message.initialize(this, opt_data, 0, -1, null, null);
    };
    goog2.inherits(proto.tfplugin5.ReadResource.Request, jspb2.Message);
    if (goog2.DEBUG && !COMPILED) {
      proto.tfplugin5.ReadResource.Request.displayName = "proto.tfplugin5.ReadResource.Request";
    }
    proto.tfplugin5.ReadResource.Response = function(opt_data) {
      jspb2.Message.initialize(this, opt_data, 0, -1, proto.tfplugin5.ReadResource.Response.repeatedFields_, null);
    };
    goog2.inherits(proto.tfplugin5.ReadResource.Response, jspb2.Message);
    if (goog2.DEBUG && !COMPILED) {
      proto.tfplugin5.ReadResource.Response.displayName = "proto.tfplugin5.ReadResource.Response";
    }
    proto.tfplugin5.PlanResourceChange = function(opt_data) {
      jspb2.Message.initialize(this, opt_data, 0, -1, null, null);
    };
    goog2.inherits(proto.tfplugin5.PlanResourceChange, jspb2.Message);
    if (goog2.DEBUG && !COMPILED) {
      proto.tfplugin5.PlanResourceChange.displayName = "proto.tfplugin5.PlanResourceChange";
    }
    proto.tfplugin5.PlanResourceChange.Request = function(opt_data) {
      jspb2.Message.initialize(this, opt_data, 0, -1, null, null);
    };
    goog2.inherits(proto.tfplugin5.PlanResourceChange.Request, jspb2.Message);
    if (goog2.DEBUG && !COMPILED) {
      proto.tfplugin5.PlanResourceChange.Request.displayName = "proto.tfplugin5.PlanResourceChange.Request";
    }
    proto.tfplugin5.PlanResourceChange.Response = function(opt_data) {
      jspb2.Message.initialize(this, opt_data, 0, -1, proto.tfplugin5.PlanResourceChange.Response.repeatedFields_, null);
    };
    goog2.inherits(proto.tfplugin5.PlanResourceChange.Response, jspb2.Message);
    if (goog2.DEBUG && !COMPILED) {
      proto.tfplugin5.PlanResourceChange.Response.displayName = "proto.tfplugin5.PlanResourceChange.Response";
    }
    proto.tfplugin5.ApplyResourceChange = function(opt_data) {
      jspb2.Message.initialize(this, opt_data, 0, -1, null, null);
    };
    goog2.inherits(proto.tfplugin5.ApplyResourceChange, jspb2.Message);
    if (goog2.DEBUG && !COMPILED) {
      proto.tfplugin5.ApplyResourceChange.displayName = "proto.tfplugin5.ApplyResourceChange";
    }
    proto.tfplugin5.ApplyResourceChange.Request = function(opt_data) {
      jspb2.Message.initialize(this, opt_data, 0, -1, null, null);
    };
    goog2.inherits(proto.tfplugin5.ApplyResourceChange.Request, jspb2.Message);
    if (goog2.DEBUG && !COMPILED) {
      proto.tfplugin5.ApplyResourceChange.Request.displayName = "proto.tfplugin5.ApplyResourceChange.Request";
    }
    proto.tfplugin5.ApplyResourceChange.Response = function(opt_data) {
      jspb2.Message.initialize(this, opt_data, 0, -1, proto.tfplugin5.ApplyResourceChange.Response.repeatedFields_, null);
    };
    goog2.inherits(proto.tfplugin5.ApplyResourceChange.Response, jspb2.Message);
    if (goog2.DEBUG && !COMPILED) {
      proto.tfplugin5.ApplyResourceChange.Response.displayName = "proto.tfplugin5.ApplyResourceChange.Response";
    }
    proto.tfplugin5.ImportResourceState = function(opt_data) {
      jspb2.Message.initialize(this, opt_data, 0, -1, null, null);
    };
    goog2.inherits(proto.tfplugin5.ImportResourceState, jspb2.Message);
    if (goog2.DEBUG && !COMPILED) {
      proto.tfplugin5.ImportResourceState.displayName = "proto.tfplugin5.ImportResourceState";
    }
    proto.tfplugin5.ImportResourceState.Request = function(opt_data) {
      jspb2.Message.initialize(this, opt_data, 0, -1, null, null);
    };
    goog2.inherits(proto.tfplugin5.ImportResourceState.Request, jspb2.Message);
    if (goog2.DEBUG && !COMPILED) {
      proto.tfplugin5.ImportResourceState.Request.displayName = "proto.tfplugin5.ImportResourceState.Request";
    }
    proto.tfplugin5.ImportResourceState.ImportedResource = function(opt_data) {
      jspb2.Message.initialize(this, opt_data, 0, -1, null, null);
    };
    goog2.inherits(proto.tfplugin5.ImportResourceState.ImportedResource, jspb2.Message);
    if (goog2.DEBUG && !COMPILED) {
      proto.tfplugin5.ImportResourceState.ImportedResource.displayName = "proto.tfplugin5.ImportResourceState.ImportedResource";
    }
    proto.tfplugin5.ImportResourceState.Response = function(opt_data) {
      jspb2.Message.initialize(this, opt_data, 0, -1, proto.tfplugin5.ImportResourceState.Response.repeatedFields_, null);
    };
    goog2.inherits(proto.tfplugin5.ImportResourceState.Response, jspb2.Message);
    if (goog2.DEBUG && !COMPILED) {
      proto.tfplugin5.ImportResourceState.Response.displayName = "proto.tfplugin5.ImportResourceState.Response";
    }
    proto.tfplugin5.ReadDataSource = function(opt_data) {
      jspb2.Message.initialize(this, opt_data, 0, -1, null, null);
    };
    goog2.inherits(proto.tfplugin5.ReadDataSource, jspb2.Message);
    if (goog2.DEBUG && !COMPILED) {
      proto.tfplugin5.ReadDataSource.displayName = "proto.tfplugin5.ReadDataSource";
    }
    proto.tfplugin5.ReadDataSource.Request = function(opt_data) {
      jspb2.Message.initialize(this, opt_data, 0, -1, null, null);
    };
    goog2.inherits(proto.tfplugin5.ReadDataSource.Request, jspb2.Message);
    if (goog2.DEBUG && !COMPILED) {
      proto.tfplugin5.ReadDataSource.Request.displayName = "proto.tfplugin5.ReadDataSource.Request";
    }
    proto.tfplugin5.ReadDataSource.Response = function(opt_data) {
      jspb2.Message.initialize(this, opt_data, 0, -1, proto.tfplugin5.ReadDataSource.Response.repeatedFields_, null);
    };
    goog2.inherits(proto.tfplugin5.ReadDataSource.Response, jspb2.Message);
    if (goog2.DEBUG && !COMPILED) {
      proto.tfplugin5.ReadDataSource.Response.displayName = "proto.tfplugin5.ReadDataSource.Response";
    }
    proto.tfplugin5.GetProvisionerSchema = function(opt_data) {
      jspb2.Message.initialize(this, opt_data, 0, -1, null, null);
    };
    goog2.inherits(proto.tfplugin5.GetProvisionerSchema, jspb2.Message);
    if (goog2.DEBUG && !COMPILED) {
      proto.tfplugin5.GetProvisionerSchema.displayName = "proto.tfplugin5.GetProvisionerSchema";
    }
    proto.tfplugin5.GetProvisionerSchema.Request = function(opt_data) {
      jspb2.Message.initialize(this, opt_data, 0, -1, null, null);
    };
    goog2.inherits(proto.tfplugin5.GetProvisionerSchema.Request, jspb2.Message);
    if (goog2.DEBUG && !COMPILED) {
      proto.tfplugin5.GetProvisionerSchema.Request.displayName = "proto.tfplugin5.GetProvisionerSchema.Request";
    }
    proto.tfplugin5.GetProvisionerSchema.Response = function(opt_data) {
      jspb2.Message.initialize(this, opt_data, 0, -1, proto.tfplugin5.GetProvisionerSchema.Response.repeatedFields_, null);
    };
    goog2.inherits(proto.tfplugin5.GetProvisionerSchema.Response, jspb2.Message);
    if (goog2.DEBUG && !COMPILED) {
      proto.tfplugin5.GetProvisionerSchema.Response.displayName = "proto.tfplugin5.GetProvisionerSchema.Response";
    }
    proto.tfplugin5.ValidateProvisionerConfig = function(opt_data) {
      jspb2.Message.initialize(this, opt_data, 0, -1, null, null);
    };
    goog2.inherits(proto.tfplugin5.ValidateProvisionerConfig, jspb2.Message);
    if (goog2.DEBUG && !COMPILED) {
      proto.tfplugin5.ValidateProvisionerConfig.displayName = "proto.tfplugin5.ValidateProvisionerConfig";
    }
    proto.tfplugin5.ValidateProvisionerConfig.Request = function(opt_data) {
      jspb2.Message.initialize(this, opt_data, 0, -1, null, null);
    };
    goog2.inherits(proto.tfplugin5.ValidateProvisionerConfig.Request, jspb2.Message);
    if (goog2.DEBUG && !COMPILED) {
      proto.tfplugin5.ValidateProvisionerConfig.Request.displayName = "proto.tfplugin5.ValidateProvisionerConfig.Request";
    }
    proto.tfplugin5.ValidateProvisionerConfig.Response = function(opt_data) {
      jspb2.Message.initialize(this, opt_data, 0, -1, proto.tfplugin5.ValidateProvisionerConfig.Response.repeatedFields_, null);
    };
    goog2.inherits(proto.tfplugin5.ValidateProvisionerConfig.Response, jspb2.Message);
    if (goog2.DEBUG && !COMPILED) {
      proto.tfplugin5.ValidateProvisionerConfig.Response.displayName = "proto.tfplugin5.ValidateProvisionerConfig.Response";
    }
    proto.tfplugin5.ProvisionResource = function(opt_data) {
      jspb2.Message.initialize(this, opt_data, 0, -1, null, null);
    };
    goog2.inherits(proto.tfplugin5.ProvisionResource, jspb2.Message);
    if (goog2.DEBUG && !COMPILED) {
      proto.tfplugin5.ProvisionResource.displayName = "proto.tfplugin5.ProvisionResource";
    }
    proto.tfplugin5.ProvisionResource.Request = function(opt_data) {
      jspb2.Message.initialize(this, opt_data, 0, -1, null, null);
    };
    goog2.inherits(proto.tfplugin5.ProvisionResource.Request, jspb2.Message);
    if (goog2.DEBUG && !COMPILED) {
      proto.tfplugin5.ProvisionResource.Request.displayName = "proto.tfplugin5.ProvisionResource.Request";
    }
    proto.tfplugin5.ProvisionResource.Response = function(opt_data) {
      jspb2.Message.initialize(this, opt_data, 0, -1, proto.tfplugin5.ProvisionResource.Response.repeatedFields_, null);
    };
    goog2.inherits(proto.tfplugin5.ProvisionResource.Response, jspb2.Message);
    if (goog2.DEBUG && !COMPILED) {
      proto.tfplugin5.ProvisionResource.Response.displayName = "proto.tfplugin5.ProvisionResource.Response";
    }
    if (jspb2.Message.GENERATE_TO_OBJECT) {
      proto.tfplugin5.DynamicValue.prototype.toObject = function(opt_includeInstance) {
        return proto.tfplugin5.DynamicValue.toObject(opt_includeInstance, this);
      };
      proto.tfplugin5.DynamicValue.toObject = function(includeInstance, msg) {
        var f2, obj = {
          msgpack: msg.getMsgpack_asB64(),
          json: msg.getJson_asB64()
        };
        if (includeInstance) {
          obj.$jspbMessageInstance = msg;
        }
        return obj;
      };
    }
    proto.tfplugin5.DynamicValue.deserializeBinary = function(bytes) {
      var reader = new jspb2.BinaryReader(bytes);
      var msg = new proto.tfplugin5.DynamicValue();
      return proto.tfplugin5.DynamicValue.deserializeBinaryFromReader(msg, reader);
    };
    proto.tfplugin5.DynamicValue.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
          case 1:
            var value = (
              /** @type {!Uint8Array} */
              reader.readBytes()
            );
            msg.setMsgpack(value);
            break;
          case 2:
            var value = (
              /** @type {!Uint8Array} */
              reader.readBytes()
            );
            msg.setJson(value);
            break;
          default:
            reader.skipField();
            break;
        }
      }
      return msg;
    };
    proto.tfplugin5.DynamicValue.prototype.serializeBinary = function() {
      var writer = new jspb2.BinaryWriter();
      proto.tfplugin5.DynamicValue.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };
    proto.tfplugin5.DynamicValue.serializeBinaryToWriter = function(message, writer) {
      var f2 = void 0;
      f2 = message.getMsgpack_asU8();
      if (f2.length > 0) {
        writer.writeBytes(
          1,
          f2
        );
      }
      f2 = message.getJson_asU8();
      if (f2.length > 0) {
        writer.writeBytes(
          2,
          f2
        );
      }
    };
    proto.tfplugin5.DynamicValue.prototype.getMsgpack = function() {
      return (
        /** @type {!(string|Uint8Array)} */
        jspb2.Message.getFieldWithDefault(this, 1, "")
      );
    };
    proto.tfplugin5.DynamicValue.prototype.getMsgpack_asB64 = function() {
      return (
        /** @type {string} */
        jspb2.Message.bytesAsB64(
          this.getMsgpack()
        )
      );
    };
    proto.tfplugin5.DynamicValue.prototype.getMsgpack_asU8 = function() {
      return (
        /** @type {!Uint8Array} */
        jspb2.Message.bytesAsU8(
          this.getMsgpack()
        )
      );
    };
    proto.tfplugin5.DynamicValue.prototype.setMsgpack = function(value) {
      return jspb2.Message.setProto3BytesField(this, 1, value);
    };
    proto.tfplugin5.DynamicValue.prototype.getJson = function() {
      return (
        /** @type {!(string|Uint8Array)} */
        jspb2.Message.getFieldWithDefault(this, 2, "")
      );
    };
    proto.tfplugin5.DynamicValue.prototype.getJson_asB64 = function() {
      return (
        /** @type {string} */
        jspb2.Message.bytesAsB64(
          this.getJson()
        )
      );
    };
    proto.tfplugin5.DynamicValue.prototype.getJson_asU8 = function() {
      return (
        /** @type {!Uint8Array} */
        jspb2.Message.bytesAsU8(
          this.getJson()
        )
      );
    };
    proto.tfplugin5.DynamicValue.prototype.setJson = function(value) {
      return jspb2.Message.setProto3BytesField(this, 2, value);
    };
    if (jspb2.Message.GENERATE_TO_OBJECT) {
      proto.tfplugin5.Diagnostic.prototype.toObject = function(opt_includeInstance) {
        return proto.tfplugin5.Diagnostic.toObject(opt_includeInstance, this);
      };
      proto.tfplugin5.Diagnostic.toObject = function(includeInstance, msg) {
        var f2, obj = {
          severity: jspb2.Message.getFieldWithDefault(msg, 1, 0),
          summary: jspb2.Message.getFieldWithDefault(msg, 2, ""),
          detail: jspb2.Message.getFieldWithDefault(msg, 3, ""),
          attribute: (f2 = msg.getAttribute()) && proto.tfplugin5.AttributePath.toObject(includeInstance, f2)
        };
        if (includeInstance) {
          obj.$jspbMessageInstance = msg;
        }
        return obj;
      };
    }
    proto.tfplugin5.Diagnostic.deserializeBinary = function(bytes) {
      var reader = new jspb2.BinaryReader(bytes);
      var msg = new proto.tfplugin5.Diagnostic();
      return proto.tfplugin5.Diagnostic.deserializeBinaryFromReader(msg, reader);
    };
    proto.tfplugin5.Diagnostic.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
          case 1:
            var value = (
              /** @type {!proto.tfplugin5.Diagnostic.Severity} */
              reader.readEnum()
            );
            msg.setSeverity(value);
            break;
          case 2:
            var value = (
              /** @type {string} */
              reader.readString()
            );
            msg.setSummary(value);
            break;
          case 3:
            var value = (
              /** @type {string} */
              reader.readString()
            );
            msg.setDetail(value);
            break;
          case 4:
            var value = new proto.tfplugin5.AttributePath();
            reader.readMessage(value, proto.tfplugin5.AttributePath.deserializeBinaryFromReader);
            msg.setAttribute(value);
            break;
          default:
            reader.skipField();
            break;
        }
      }
      return msg;
    };
    proto.tfplugin5.Diagnostic.prototype.serializeBinary = function() {
      var writer = new jspb2.BinaryWriter();
      proto.tfplugin5.Diagnostic.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };
    proto.tfplugin5.Diagnostic.serializeBinaryToWriter = function(message, writer) {
      var f2 = void 0;
      f2 = message.getSeverity();
      if (f2 !== 0) {
        writer.writeEnum(
          1,
          f2
        );
      }
      f2 = message.getSummary();
      if (f2.length > 0) {
        writer.writeString(
          2,
          f2
        );
      }
      f2 = message.getDetail();
      if (f2.length > 0) {
        writer.writeString(
          3,
          f2
        );
      }
      f2 = message.getAttribute();
      if (f2 != null) {
        writer.writeMessage(
          4,
          f2,
          proto.tfplugin5.AttributePath.serializeBinaryToWriter
        );
      }
    };
    proto.tfplugin5.Diagnostic.Severity = {
      INVALID: 0,
      ERROR: 1,
      WARNING: 2
    };
    proto.tfplugin5.Diagnostic.prototype.getSeverity = function() {
      return (
        /** @type {!proto.tfplugin5.Diagnostic.Severity} */
        jspb2.Message.getFieldWithDefault(this, 1, 0)
      );
    };
    proto.tfplugin5.Diagnostic.prototype.setSeverity = function(value) {
      return jspb2.Message.setProto3EnumField(this, 1, value);
    };
    proto.tfplugin5.Diagnostic.prototype.getSummary = function() {
      return (
        /** @type {string} */
        jspb2.Message.getFieldWithDefault(this, 2, "")
      );
    };
    proto.tfplugin5.Diagnostic.prototype.setSummary = function(value) {
      return jspb2.Message.setProto3StringField(this, 2, value);
    };
    proto.tfplugin5.Diagnostic.prototype.getDetail = function() {
      return (
        /** @type {string} */
        jspb2.Message.getFieldWithDefault(this, 3, "")
      );
    };
    proto.tfplugin5.Diagnostic.prototype.setDetail = function(value) {
      return jspb2.Message.setProto3StringField(this, 3, value);
    };
    proto.tfplugin5.Diagnostic.prototype.getAttribute = function() {
      return (
        /** @type{?proto.tfplugin5.AttributePath} */
        jspb2.Message.getWrapperField(this, proto.tfplugin5.AttributePath, 4)
      );
    };
    proto.tfplugin5.Diagnostic.prototype.setAttribute = function(value) {
      return jspb2.Message.setWrapperField(this, 4, value);
    };
    proto.tfplugin5.Diagnostic.prototype.clearAttribute = function() {
      return this.setAttribute(void 0);
    };
    proto.tfplugin5.Diagnostic.prototype.hasAttribute = function() {
      return jspb2.Message.getField(this, 4) != null;
    };
    proto.tfplugin5.AttributePath.repeatedFields_ = [1];
    if (jspb2.Message.GENERATE_TO_OBJECT) {
      proto.tfplugin5.AttributePath.prototype.toObject = function(opt_includeInstance) {
        return proto.tfplugin5.AttributePath.toObject(opt_includeInstance, this);
      };
      proto.tfplugin5.AttributePath.toObject = function(includeInstance, msg) {
        var f2, obj = {
          stepsList: jspb2.Message.toObjectList(
            msg.getStepsList(),
            proto.tfplugin5.AttributePath.Step.toObject,
            includeInstance
          )
        };
        if (includeInstance) {
          obj.$jspbMessageInstance = msg;
        }
        return obj;
      };
    }
    proto.tfplugin5.AttributePath.deserializeBinary = function(bytes) {
      var reader = new jspb2.BinaryReader(bytes);
      var msg = new proto.tfplugin5.AttributePath();
      return proto.tfplugin5.AttributePath.deserializeBinaryFromReader(msg, reader);
    };
    proto.tfplugin5.AttributePath.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
          case 1:
            var value = new proto.tfplugin5.AttributePath.Step();
            reader.readMessage(value, proto.tfplugin5.AttributePath.Step.deserializeBinaryFromReader);
            msg.addSteps(value);
            break;
          default:
            reader.skipField();
            break;
        }
      }
      return msg;
    };
    proto.tfplugin5.AttributePath.prototype.serializeBinary = function() {
      var writer = new jspb2.BinaryWriter();
      proto.tfplugin5.AttributePath.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };
    proto.tfplugin5.AttributePath.serializeBinaryToWriter = function(message, writer) {
      var f2 = void 0;
      f2 = message.getStepsList();
      if (f2.length > 0) {
        writer.writeRepeatedMessage(
          1,
          f2,
          proto.tfplugin5.AttributePath.Step.serializeBinaryToWriter
        );
      }
    };
    proto.tfplugin5.AttributePath.Step.oneofGroups_ = [[1, 2, 3]];
    proto.tfplugin5.AttributePath.Step.SelectorCase = {
      SELECTOR_NOT_SET: 0,
      ATTRIBUTE_NAME: 1,
      ELEMENT_KEY_STRING: 2,
      ELEMENT_KEY_INT: 3
    };
    proto.tfplugin5.AttributePath.Step.prototype.getSelectorCase = function() {
      return (
        /** @type {proto.tfplugin5.AttributePath.Step.SelectorCase} */
        jspb2.Message.computeOneofCase(this, proto.tfplugin5.AttributePath.Step.oneofGroups_[0])
      );
    };
    if (jspb2.Message.GENERATE_TO_OBJECT) {
      proto.tfplugin5.AttributePath.Step.prototype.toObject = function(opt_includeInstance) {
        return proto.tfplugin5.AttributePath.Step.toObject(opt_includeInstance, this);
      };
      proto.tfplugin5.AttributePath.Step.toObject = function(includeInstance, msg) {
        var f2, obj = {
          attributeName: jspb2.Message.getFieldWithDefault(msg, 1, ""),
          elementKeyString: jspb2.Message.getFieldWithDefault(msg, 2, ""),
          elementKeyInt: jspb2.Message.getFieldWithDefault(msg, 3, 0)
        };
        if (includeInstance) {
          obj.$jspbMessageInstance = msg;
        }
        return obj;
      };
    }
    proto.tfplugin5.AttributePath.Step.deserializeBinary = function(bytes) {
      var reader = new jspb2.BinaryReader(bytes);
      var msg = new proto.tfplugin5.AttributePath.Step();
      return proto.tfplugin5.AttributePath.Step.deserializeBinaryFromReader(msg, reader);
    };
    proto.tfplugin5.AttributePath.Step.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
          case 1:
            var value = (
              /** @type {string} */
              reader.readString()
            );
            msg.setAttributeName(value);
            break;
          case 2:
            var value = (
              /** @type {string} */
              reader.readString()
            );
            msg.setElementKeyString(value);
            break;
          case 3:
            var value = (
              /** @type {number} */
              reader.readInt64()
            );
            msg.setElementKeyInt(value);
            break;
          default:
            reader.skipField();
            break;
        }
      }
      return msg;
    };
    proto.tfplugin5.AttributePath.Step.prototype.serializeBinary = function() {
      var writer = new jspb2.BinaryWriter();
      proto.tfplugin5.AttributePath.Step.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };
    proto.tfplugin5.AttributePath.Step.serializeBinaryToWriter = function(message, writer) {
      var f2 = void 0;
      f2 = /** @type {string} */
      jspb2.Message.getField(message, 1);
      if (f2 != null) {
        writer.writeString(
          1,
          f2
        );
      }
      f2 = /** @type {string} */
      jspb2.Message.getField(message, 2);
      if (f2 != null) {
        writer.writeString(
          2,
          f2
        );
      }
      f2 = /** @type {number} */
      jspb2.Message.getField(message, 3);
      if (f2 != null) {
        writer.writeInt64(
          3,
          f2
        );
      }
    };
    proto.tfplugin5.AttributePath.Step.prototype.getAttributeName = function() {
      return (
        /** @type {string} */
        jspb2.Message.getFieldWithDefault(this, 1, "")
      );
    };
    proto.tfplugin5.AttributePath.Step.prototype.setAttributeName = function(value) {
      return jspb2.Message.setOneofField(this, 1, proto.tfplugin5.AttributePath.Step.oneofGroups_[0], value);
    };
    proto.tfplugin5.AttributePath.Step.prototype.clearAttributeName = function() {
      return jspb2.Message.setOneofField(this, 1, proto.tfplugin5.AttributePath.Step.oneofGroups_[0], void 0);
    };
    proto.tfplugin5.AttributePath.Step.prototype.hasAttributeName = function() {
      return jspb2.Message.getField(this, 1) != null;
    };
    proto.tfplugin5.AttributePath.Step.prototype.getElementKeyString = function() {
      return (
        /** @type {string} */
        jspb2.Message.getFieldWithDefault(this, 2, "")
      );
    };
    proto.tfplugin5.AttributePath.Step.prototype.setElementKeyString = function(value) {
      return jspb2.Message.setOneofField(this, 2, proto.tfplugin5.AttributePath.Step.oneofGroups_[0], value);
    };
    proto.tfplugin5.AttributePath.Step.prototype.clearElementKeyString = function() {
      return jspb2.Message.setOneofField(this, 2, proto.tfplugin5.AttributePath.Step.oneofGroups_[0], void 0);
    };
    proto.tfplugin5.AttributePath.Step.prototype.hasElementKeyString = function() {
      return jspb2.Message.getField(this, 2) != null;
    };
    proto.tfplugin5.AttributePath.Step.prototype.getElementKeyInt = function() {
      return (
        /** @type {number} */
        jspb2.Message.getFieldWithDefault(this, 3, 0)
      );
    };
    proto.tfplugin5.AttributePath.Step.prototype.setElementKeyInt = function(value) {
      return jspb2.Message.setOneofField(this, 3, proto.tfplugin5.AttributePath.Step.oneofGroups_[0], value);
    };
    proto.tfplugin5.AttributePath.Step.prototype.clearElementKeyInt = function() {
      return jspb2.Message.setOneofField(this, 3, proto.tfplugin5.AttributePath.Step.oneofGroups_[0], void 0);
    };
    proto.tfplugin5.AttributePath.Step.prototype.hasElementKeyInt = function() {
      return jspb2.Message.getField(this, 3) != null;
    };
    proto.tfplugin5.AttributePath.prototype.getStepsList = function() {
      return (
        /** @type{!Array<!proto.tfplugin5.AttributePath.Step>} */
        jspb2.Message.getRepeatedWrapperField(this, proto.tfplugin5.AttributePath.Step, 1)
      );
    };
    proto.tfplugin5.AttributePath.prototype.setStepsList = function(value) {
      return jspb2.Message.setRepeatedWrapperField(this, 1, value);
    };
    proto.tfplugin5.AttributePath.prototype.addSteps = function(opt_value, opt_index) {
      return jspb2.Message.addToRepeatedWrapperField(this, 1, opt_value, proto.tfplugin5.AttributePath.Step, opt_index);
    };
    proto.tfplugin5.AttributePath.prototype.clearStepsList = function() {
      return this.setStepsList([]);
    };
    if (jspb2.Message.GENERATE_TO_OBJECT) {
      proto.tfplugin5.Stop.prototype.toObject = function(opt_includeInstance) {
        return proto.tfplugin5.Stop.toObject(opt_includeInstance, this);
      };
      proto.tfplugin5.Stop.toObject = function(includeInstance, msg) {
        var f2, obj = {};
        if (includeInstance) {
          obj.$jspbMessageInstance = msg;
        }
        return obj;
      };
    }
    proto.tfplugin5.Stop.deserializeBinary = function(bytes) {
      var reader = new jspb2.BinaryReader(bytes);
      var msg = new proto.tfplugin5.Stop();
      return proto.tfplugin5.Stop.deserializeBinaryFromReader(msg, reader);
    };
    proto.tfplugin5.Stop.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
          default:
            reader.skipField();
            break;
        }
      }
      return msg;
    };
    proto.tfplugin5.Stop.prototype.serializeBinary = function() {
      var writer = new jspb2.BinaryWriter();
      proto.tfplugin5.Stop.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };
    proto.tfplugin5.Stop.serializeBinaryToWriter = function(message, writer) {
      var f2 = void 0;
    };
    if (jspb2.Message.GENERATE_TO_OBJECT) {
      proto.tfplugin5.Stop.Request.prototype.toObject = function(opt_includeInstance) {
        return proto.tfplugin5.Stop.Request.toObject(opt_includeInstance, this);
      };
      proto.tfplugin5.Stop.Request.toObject = function(includeInstance, msg) {
        var f2, obj = {};
        if (includeInstance) {
          obj.$jspbMessageInstance = msg;
        }
        return obj;
      };
    }
    proto.tfplugin5.Stop.Request.deserializeBinary = function(bytes) {
      var reader = new jspb2.BinaryReader(bytes);
      var msg = new proto.tfplugin5.Stop.Request();
      return proto.tfplugin5.Stop.Request.deserializeBinaryFromReader(msg, reader);
    };
    proto.tfplugin5.Stop.Request.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
          default:
            reader.skipField();
            break;
        }
      }
      return msg;
    };
    proto.tfplugin5.Stop.Request.prototype.serializeBinary = function() {
      var writer = new jspb2.BinaryWriter();
      proto.tfplugin5.Stop.Request.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };
    proto.tfplugin5.Stop.Request.serializeBinaryToWriter = function(message, writer) {
      var f2 = void 0;
    };
    if (jspb2.Message.GENERATE_TO_OBJECT) {
      proto.tfplugin5.Stop.Response.prototype.toObject = function(opt_includeInstance) {
        return proto.tfplugin5.Stop.Response.toObject(opt_includeInstance, this);
      };
      proto.tfplugin5.Stop.Response.toObject = function(includeInstance, msg) {
        var f2, obj = {
          error: jspb2.Message.getFieldWithDefault(msg, 1, "")
        };
        if (includeInstance) {
          obj.$jspbMessageInstance = msg;
        }
        return obj;
      };
    }
    proto.tfplugin5.Stop.Response.deserializeBinary = function(bytes) {
      var reader = new jspb2.BinaryReader(bytes);
      var msg = new proto.tfplugin5.Stop.Response();
      return proto.tfplugin5.Stop.Response.deserializeBinaryFromReader(msg, reader);
    };
    proto.tfplugin5.Stop.Response.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
          case 1:
            var value = (
              /** @type {string} */
              reader.readString()
            );
            msg.setError(value);
            break;
          default:
            reader.skipField();
            break;
        }
      }
      return msg;
    };
    proto.tfplugin5.Stop.Response.prototype.serializeBinary = function() {
      var writer = new jspb2.BinaryWriter();
      proto.tfplugin5.Stop.Response.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };
    proto.tfplugin5.Stop.Response.serializeBinaryToWriter = function(message, writer) {
      var f2 = void 0;
      f2 = message.getError();
      if (f2.length > 0) {
        writer.writeString(
          1,
          f2
        );
      }
    };
    proto.tfplugin5.Stop.Response.prototype.getError = function() {
      return (
        /** @type {string} */
        jspb2.Message.getFieldWithDefault(this, 1, "")
      );
    };
    proto.tfplugin5.Stop.Response.prototype.setError = function(value) {
      return jspb2.Message.setProto3StringField(this, 1, value);
    };
    if (jspb2.Message.GENERATE_TO_OBJECT) {
      proto.tfplugin5.RawState.prototype.toObject = function(opt_includeInstance) {
        return proto.tfplugin5.RawState.toObject(opt_includeInstance, this);
      };
      proto.tfplugin5.RawState.toObject = function(includeInstance, msg) {
        var f2, obj = {
          json: msg.getJson_asB64(),
          flatmapMap: (f2 = msg.getFlatmapMap()) ? f2.toObject(includeInstance, void 0) : []
        };
        if (includeInstance) {
          obj.$jspbMessageInstance = msg;
        }
        return obj;
      };
    }
    proto.tfplugin5.RawState.deserializeBinary = function(bytes) {
      var reader = new jspb2.BinaryReader(bytes);
      var msg = new proto.tfplugin5.RawState();
      return proto.tfplugin5.RawState.deserializeBinaryFromReader(msg, reader);
    };
    proto.tfplugin5.RawState.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
          case 1:
            var value = (
              /** @type {!Uint8Array} */
              reader.readBytes()
            );
            msg.setJson(value);
            break;
          case 2:
            var value = msg.getFlatmapMap();
            reader.readMessage(value, function(message, reader2) {
              jspb2.Map.deserializeBinary(message, reader2, jspb2.BinaryReader.prototype.readString, jspb2.BinaryReader.prototype.readString, null, "", "");
            });
            break;
          default:
            reader.skipField();
            break;
        }
      }
      return msg;
    };
    proto.tfplugin5.RawState.prototype.serializeBinary = function() {
      var writer = new jspb2.BinaryWriter();
      proto.tfplugin5.RawState.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };
    proto.tfplugin5.RawState.serializeBinaryToWriter = function(message, writer) {
      var f2 = void 0;
      f2 = message.getJson_asU8();
      if (f2.length > 0) {
        writer.writeBytes(
          1,
          f2
        );
      }
      f2 = message.getFlatmapMap(true);
      if (f2 && f2.getLength() > 0) {
        f2.serializeBinary(2, writer, jspb2.BinaryWriter.prototype.writeString, jspb2.BinaryWriter.prototype.writeString);
      }
    };
    proto.tfplugin5.RawState.prototype.getJson = function() {
      return (
        /** @type {!(string|Uint8Array)} */
        jspb2.Message.getFieldWithDefault(this, 1, "")
      );
    };
    proto.tfplugin5.RawState.prototype.getJson_asB64 = function() {
      return (
        /** @type {string} */
        jspb2.Message.bytesAsB64(
          this.getJson()
        )
      );
    };
    proto.tfplugin5.RawState.prototype.getJson_asU8 = function() {
      return (
        /** @type {!Uint8Array} */
        jspb2.Message.bytesAsU8(
          this.getJson()
        )
      );
    };
    proto.tfplugin5.RawState.prototype.setJson = function(value) {
      return jspb2.Message.setProto3BytesField(this, 1, value);
    };
    proto.tfplugin5.RawState.prototype.getFlatmapMap = function(opt_noLazyCreate) {
      return (
        /** @type {!jspb.Map<string,string>} */
        jspb2.Message.getMapField(
          this,
          2,
          opt_noLazyCreate,
          null
        )
      );
    };
    proto.tfplugin5.RawState.prototype.clearFlatmapMap = function() {
      this.getFlatmapMap().clear();
      return this;
    };
    if (jspb2.Message.GENERATE_TO_OBJECT) {
      proto.tfplugin5.Schema.prototype.toObject = function(opt_includeInstance) {
        return proto.tfplugin5.Schema.toObject(opt_includeInstance, this);
      };
      proto.tfplugin5.Schema.toObject = function(includeInstance, msg) {
        var f2, obj = {
          version: jspb2.Message.getFieldWithDefault(msg, 1, 0),
          block: (f2 = msg.getBlock()) && proto.tfplugin5.Schema.Block.toObject(includeInstance, f2)
        };
        if (includeInstance) {
          obj.$jspbMessageInstance = msg;
        }
        return obj;
      };
    }
    proto.tfplugin5.Schema.deserializeBinary = function(bytes) {
      var reader = new jspb2.BinaryReader(bytes);
      var msg = new proto.tfplugin5.Schema();
      return proto.tfplugin5.Schema.deserializeBinaryFromReader(msg, reader);
    };
    proto.tfplugin5.Schema.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
          case 1:
            var value = (
              /** @type {number} */
              reader.readInt64()
            );
            msg.setVersion(value);
            break;
          case 2:
            var value = new proto.tfplugin5.Schema.Block();
            reader.readMessage(value, proto.tfplugin5.Schema.Block.deserializeBinaryFromReader);
            msg.setBlock(value);
            break;
          default:
            reader.skipField();
            break;
        }
      }
      return msg;
    };
    proto.tfplugin5.Schema.prototype.serializeBinary = function() {
      var writer = new jspb2.BinaryWriter();
      proto.tfplugin5.Schema.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };
    proto.tfplugin5.Schema.serializeBinaryToWriter = function(message, writer) {
      var f2 = void 0;
      f2 = message.getVersion();
      if (f2 !== 0) {
        writer.writeInt64(
          1,
          f2
        );
      }
      f2 = message.getBlock();
      if (f2 != null) {
        writer.writeMessage(
          2,
          f2,
          proto.tfplugin5.Schema.Block.serializeBinaryToWriter
        );
      }
    };
    proto.tfplugin5.Schema.Block.repeatedFields_ = [2, 3];
    if (jspb2.Message.GENERATE_TO_OBJECT) {
      proto.tfplugin5.Schema.Block.prototype.toObject = function(opt_includeInstance) {
        return proto.tfplugin5.Schema.Block.toObject(opt_includeInstance, this);
      };
      proto.tfplugin5.Schema.Block.toObject = function(includeInstance, msg) {
        var f2, obj = {
          version: jspb2.Message.getFieldWithDefault(msg, 1, 0),
          attributesList: jspb2.Message.toObjectList(
            msg.getAttributesList(),
            proto.tfplugin5.Schema.Attribute.toObject,
            includeInstance
          ),
          blockTypesList: jspb2.Message.toObjectList(
            msg.getBlockTypesList(),
            proto.tfplugin5.Schema.NestedBlock.toObject,
            includeInstance
          ),
          description: jspb2.Message.getFieldWithDefault(msg, 4, ""),
          descriptionKind: jspb2.Message.getFieldWithDefault(msg, 5, 0),
          deprecated: jspb2.Message.getBooleanFieldWithDefault(msg, 6, false)
        };
        if (includeInstance) {
          obj.$jspbMessageInstance = msg;
        }
        return obj;
      };
    }
    proto.tfplugin5.Schema.Block.deserializeBinary = function(bytes) {
      var reader = new jspb2.BinaryReader(bytes);
      var msg = new proto.tfplugin5.Schema.Block();
      return proto.tfplugin5.Schema.Block.deserializeBinaryFromReader(msg, reader);
    };
    proto.tfplugin5.Schema.Block.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
          case 1:
            var value = (
              /** @type {number} */
              reader.readInt64()
            );
            msg.setVersion(value);
            break;
          case 2:
            var value = new proto.tfplugin5.Schema.Attribute();
            reader.readMessage(value, proto.tfplugin5.Schema.Attribute.deserializeBinaryFromReader);
            msg.addAttributes(value);
            break;
          case 3:
            var value = new proto.tfplugin5.Schema.NestedBlock();
            reader.readMessage(value, proto.tfplugin5.Schema.NestedBlock.deserializeBinaryFromReader);
            msg.addBlockTypes(value);
            break;
          case 4:
            var value = (
              /** @type {string} */
              reader.readString()
            );
            msg.setDescription(value);
            break;
          case 5:
            var value = (
              /** @type {!proto.tfplugin5.StringKind} */
              reader.readEnum()
            );
            msg.setDescriptionKind(value);
            break;
          case 6:
            var value = (
              /** @type {boolean} */
              reader.readBool()
            );
            msg.setDeprecated(value);
            break;
          default:
            reader.skipField();
            break;
        }
      }
      return msg;
    };
    proto.tfplugin5.Schema.Block.prototype.serializeBinary = function() {
      var writer = new jspb2.BinaryWriter();
      proto.tfplugin5.Schema.Block.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };
    proto.tfplugin5.Schema.Block.serializeBinaryToWriter = function(message, writer) {
      var f2 = void 0;
      f2 = message.getVersion();
      if (f2 !== 0) {
        writer.writeInt64(
          1,
          f2
        );
      }
      f2 = message.getAttributesList();
      if (f2.length > 0) {
        writer.writeRepeatedMessage(
          2,
          f2,
          proto.tfplugin5.Schema.Attribute.serializeBinaryToWriter
        );
      }
      f2 = message.getBlockTypesList();
      if (f2.length > 0) {
        writer.writeRepeatedMessage(
          3,
          f2,
          proto.tfplugin5.Schema.NestedBlock.serializeBinaryToWriter
        );
      }
      f2 = message.getDescription();
      if (f2.length > 0) {
        writer.writeString(
          4,
          f2
        );
      }
      f2 = message.getDescriptionKind();
      if (f2 !== 0) {
        writer.writeEnum(
          5,
          f2
        );
      }
      f2 = message.getDeprecated();
      if (f2) {
        writer.writeBool(
          6,
          f2
        );
      }
    };
    proto.tfplugin5.Schema.Block.prototype.getVersion = function() {
      return (
        /** @type {number} */
        jspb2.Message.getFieldWithDefault(this, 1, 0)
      );
    };
    proto.tfplugin5.Schema.Block.prototype.setVersion = function(value) {
      return jspb2.Message.setProto3IntField(this, 1, value);
    };
    proto.tfplugin5.Schema.Block.prototype.getAttributesList = function() {
      return (
        /** @type{!Array<!proto.tfplugin5.Schema.Attribute>} */
        jspb2.Message.getRepeatedWrapperField(this, proto.tfplugin5.Schema.Attribute, 2)
      );
    };
    proto.tfplugin5.Schema.Block.prototype.setAttributesList = function(value) {
      return jspb2.Message.setRepeatedWrapperField(this, 2, value);
    };
    proto.tfplugin5.Schema.Block.prototype.addAttributes = function(opt_value, opt_index) {
      return jspb2.Message.addToRepeatedWrapperField(this, 2, opt_value, proto.tfplugin5.Schema.Attribute, opt_index);
    };
    proto.tfplugin5.Schema.Block.prototype.clearAttributesList = function() {
      return this.setAttributesList([]);
    };
    proto.tfplugin5.Schema.Block.prototype.getBlockTypesList = function() {
      return (
        /** @type{!Array<!proto.tfplugin5.Schema.NestedBlock>} */
        jspb2.Message.getRepeatedWrapperField(this, proto.tfplugin5.Schema.NestedBlock, 3)
      );
    };
    proto.tfplugin5.Schema.Block.prototype.setBlockTypesList = function(value) {
      return jspb2.Message.setRepeatedWrapperField(this, 3, value);
    };
    proto.tfplugin5.Schema.Block.prototype.addBlockTypes = function(opt_value, opt_index) {
      return jspb2.Message.addToRepeatedWrapperField(this, 3, opt_value, proto.tfplugin5.Schema.NestedBlock, opt_index);
    };
    proto.tfplugin5.Schema.Block.prototype.clearBlockTypesList = function() {
      return this.setBlockTypesList([]);
    };
    proto.tfplugin5.Schema.Block.prototype.getDescription = function() {
      return (
        /** @type {string} */
        jspb2.Message.getFieldWithDefault(this, 4, "")
      );
    };
    proto.tfplugin5.Schema.Block.prototype.setDescription = function(value) {
      return jspb2.Message.setProto3StringField(this, 4, value);
    };
    proto.tfplugin5.Schema.Block.prototype.getDescriptionKind = function() {
      return (
        /** @type {!proto.tfplugin5.StringKind} */
        jspb2.Message.getFieldWithDefault(this, 5, 0)
      );
    };
    proto.tfplugin5.Schema.Block.prototype.setDescriptionKind = function(value) {
      return jspb2.Message.setProto3EnumField(this, 5, value);
    };
    proto.tfplugin5.Schema.Block.prototype.getDeprecated = function() {
      return (
        /** @type {boolean} */
        jspb2.Message.getBooleanFieldWithDefault(this, 6, false)
      );
    };
    proto.tfplugin5.Schema.Block.prototype.setDeprecated = function(value) {
      return jspb2.Message.setProto3BooleanField(this, 6, value);
    };
    if (jspb2.Message.GENERATE_TO_OBJECT) {
      proto.tfplugin5.Schema.Attribute.prototype.toObject = function(opt_includeInstance) {
        return proto.tfplugin5.Schema.Attribute.toObject(opt_includeInstance, this);
      };
      proto.tfplugin5.Schema.Attribute.toObject = function(includeInstance, msg) {
        var f2, obj = {
          name: jspb2.Message.getFieldWithDefault(msg, 1, ""),
          type: msg.getType_asB64(),
          description: jspb2.Message.getFieldWithDefault(msg, 3, ""),
          required: jspb2.Message.getBooleanFieldWithDefault(msg, 4, false),
          optional: jspb2.Message.getBooleanFieldWithDefault(msg, 5, false),
          computed: jspb2.Message.getBooleanFieldWithDefault(msg, 6, false),
          sensitive: jspb2.Message.getBooleanFieldWithDefault(msg, 7, false),
          descriptionKind: jspb2.Message.getFieldWithDefault(msg, 8, 0),
          deprecated: jspb2.Message.getBooleanFieldWithDefault(msg, 9, false)
        };
        if (includeInstance) {
          obj.$jspbMessageInstance = msg;
        }
        return obj;
      };
    }
    proto.tfplugin5.Schema.Attribute.deserializeBinary = function(bytes) {
      var reader = new jspb2.BinaryReader(bytes);
      var msg = new proto.tfplugin5.Schema.Attribute();
      return proto.tfplugin5.Schema.Attribute.deserializeBinaryFromReader(msg, reader);
    };
    proto.tfplugin5.Schema.Attribute.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
          case 1:
            var value = (
              /** @type {string} */
              reader.readString()
            );
            msg.setName(value);
            break;
          case 2:
            var value = (
              /** @type {!Uint8Array} */
              reader.readBytes()
            );
            msg.setType(value);
            break;
          case 3:
            var value = (
              /** @type {string} */
              reader.readString()
            );
            msg.setDescription(value);
            break;
          case 4:
            var value = (
              /** @type {boolean} */
              reader.readBool()
            );
            msg.setRequired(value);
            break;
          case 5:
            var value = (
              /** @type {boolean} */
              reader.readBool()
            );
            msg.setOptional(value);
            break;
          case 6:
            var value = (
              /** @type {boolean} */
              reader.readBool()
            );
            msg.setComputed(value);
            break;
          case 7:
            var value = (
              /** @type {boolean} */
              reader.readBool()
            );
            msg.setSensitive(value);
            break;
          case 8:
            var value = (
              /** @type {!proto.tfplugin5.StringKind} */
              reader.readEnum()
            );
            msg.setDescriptionKind(value);
            break;
          case 9:
            var value = (
              /** @type {boolean} */
              reader.readBool()
            );
            msg.setDeprecated(value);
            break;
          default:
            reader.skipField();
            break;
        }
      }
      return msg;
    };
    proto.tfplugin5.Schema.Attribute.prototype.serializeBinary = function() {
      var writer = new jspb2.BinaryWriter();
      proto.tfplugin5.Schema.Attribute.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };
    proto.tfplugin5.Schema.Attribute.serializeBinaryToWriter = function(message, writer) {
      var f2 = void 0;
      f2 = message.getName();
      if (f2.length > 0) {
        writer.writeString(
          1,
          f2
        );
      }
      f2 = message.getType_asU8();
      if (f2.length > 0) {
        writer.writeBytes(
          2,
          f2
        );
      }
      f2 = message.getDescription();
      if (f2.length > 0) {
        writer.writeString(
          3,
          f2
        );
      }
      f2 = message.getRequired();
      if (f2) {
        writer.writeBool(
          4,
          f2
        );
      }
      f2 = message.getOptional();
      if (f2) {
        writer.writeBool(
          5,
          f2
        );
      }
      f2 = message.getComputed();
      if (f2) {
        writer.writeBool(
          6,
          f2
        );
      }
      f2 = message.getSensitive();
      if (f2) {
        writer.writeBool(
          7,
          f2
        );
      }
      f2 = message.getDescriptionKind();
      if (f2 !== 0) {
        writer.writeEnum(
          8,
          f2
        );
      }
      f2 = message.getDeprecated();
      if (f2) {
        writer.writeBool(
          9,
          f2
        );
      }
    };
    proto.tfplugin5.Schema.Attribute.prototype.getName = function() {
      return (
        /** @type {string} */
        jspb2.Message.getFieldWithDefault(this, 1, "")
      );
    };
    proto.tfplugin5.Schema.Attribute.prototype.setName = function(value) {
      return jspb2.Message.setProto3StringField(this, 1, value);
    };
    proto.tfplugin5.Schema.Attribute.prototype.getType = function() {
      return (
        /** @type {!(string|Uint8Array)} */
        jspb2.Message.getFieldWithDefault(this, 2, "")
      );
    };
    proto.tfplugin5.Schema.Attribute.prototype.getType_asB64 = function() {
      return (
        /** @type {string} */
        jspb2.Message.bytesAsB64(
          this.getType()
        )
      );
    };
    proto.tfplugin5.Schema.Attribute.prototype.getType_asU8 = function() {
      return (
        /** @type {!Uint8Array} */
        jspb2.Message.bytesAsU8(
          this.getType()
        )
      );
    };
    proto.tfplugin5.Schema.Attribute.prototype.setType = function(value) {
      return jspb2.Message.setProto3BytesField(this, 2, value);
    };
    proto.tfplugin5.Schema.Attribute.prototype.getDescription = function() {
      return (
        /** @type {string} */
        jspb2.Message.getFieldWithDefault(this, 3, "")
      );
    };
    proto.tfplugin5.Schema.Attribute.prototype.setDescription = function(value) {
      return jspb2.Message.setProto3StringField(this, 3, value);
    };
    proto.tfplugin5.Schema.Attribute.prototype.getRequired = function() {
      return (
        /** @type {boolean} */
        jspb2.Message.getBooleanFieldWithDefault(this, 4, false)
      );
    };
    proto.tfplugin5.Schema.Attribute.prototype.setRequired = function(value) {
      return jspb2.Message.setProto3BooleanField(this, 4, value);
    };
    proto.tfplugin5.Schema.Attribute.prototype.getOptional = function() {
      return (
        /** @type {boolean} */
        jspb2.Message.getBooleanFieldWithDefault(this, 5, false)
      );
    };
    proto.tfplugin5.Schema.Attribute.prototype.setOptional = function(value) {
      return jspb2.Message.setProto3BooleanField(this, 5, value);
    };
    proto.tfplugin5.Schema.Attribute.prototype.getComputed = function() {
      return (
        /** @type {boolean} */
        jspb2.Message.getBooleanFieldWithDefault(this, 6, false)
      );
    };
    proto.tfplugin5.Schema.Attribute.prototype.setComputed = function(value) {
      return jspb2.Message.setProto3BooleanField(this, 6, value);
    };
    proto.tfplugin5.Schema.Attribute.prototype.getSensitive = function() {
      return (
        /** @type {boolean} */
        jspb2.Message.getBooleanFieldWithDefault(this, 7, false)
      );
    };
    proto.tfplugin5.Schema.Attribute.prototype.setSensitive = function(value) {
      return jspb2.Message.setProto3BooleanField(this, 7, value);
    };
    proto.tfplugin5.Schema.Attribute.prototype.getDescriptionKind = function() {
      return (
        /** @type {!proto.tfplugin5.StringKind} */
        jspb2.Message.getFieldWithDefault(this, 8, 0)
      );
    };
    proto.tfplugin5.Schema.Attribute.prototype.setDescriptionKind = function(value) {
      return jspb2.Message.setProto3EnumField(this, 8, value);
    };
    proto.tfplugin5.Schema.Attribute.prototype.getDeprecated = function() {
      return (
        /** @type {boolean} */
        jspb2.Message.getBooleanFieldWithDefault(this, 9, false)
      );
    };
    proto.tfplugin5.Schema.Attribute.prototype.setDeprecated = function(value) {
      return jspb2.Message.setProto3BooleanField(this, 9, value);
    };
    if (jspb2.Message.GENERATE_TO_OBJECT) {
      proto.tfplugin5.Schema.NestedBlock.prototype.toObject = function(opt_includeInstance) {
        return proto.tfplugin5.Schema.NestedBlock.toObject(opt_includeInstance, this);
      };
      proto.tfplugin5.Schema.NestedBlock.toObject = function(includeInstance, msg) {
        var f2, obj = {
          typeName: jspb2.Message.getFieldWithDefault(msg, 1, ""),
          block: (f2 = msg.getBlock()) && proto.tfplugin5.Schema.Block.toObject(includeInstance, f2),
          nesting: jspb2.Message.getFieldWithDefault(msg, 3, 0),
          minItems: jspb2.Message.getFieldWithDefault(msg, 4, 0),
          maxItems: jspb2.Message.getFieldWithDefault(msg, 5, 0)
        };
        if (includeInstance) {
          obj.$jspbMessageInstance = msg;
        }
        return obj;
      };
    }
    proto.tfplugin5.Schema.NestedBlock.deserializeBinary = function(bytes) {
      var reader = new jspb2.BinaryReader(bytes);
      var msg = new proto.tfplugin5.Schema.NestedBlock();
      return proto.tfplugin5.Schema.NestedBlock.deserializeBinaryFromReader(msg, reader);
    };
    proto.tfplugin5.Schema.NestedBlock.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
          case 1:
            var value = (
              /** @type {string} */
              reader.readString()
            );
            msg.setTypeName(value);
            break;
          case 2:
            var value = new proto.tfplugin5.Schema.Block();
            reader.readMessage(value, proto.tfplugin5.Schema.Block.deserializeBinaryFromReader);
            msg.setBlock(value);
            break;
          case 3:
            var value = (
              /** @type {!proto.tfplugin5.Schema.NestedBlock.NestingMode} */
              reader.readEnum()
            );
            msg.setNesting(value);
            break;
          case 4:
            var value = (
              /** @type {number} */
              reader.readInt64()
            );
            msg.setMinItems(value);
            break;
          case 5:
            var value = (
              /** @type {number} */
              reader.readInt64()
            );
            msg.setMaxItems(value);
            break;
          default:
            reader.skipField();
            break;
        }
      }
      return msg;
    };
    proto.tfplugin5.Schema.NestedBlock.prototype.serializeBinary = function() {
      var writer = new jspb2.BinaryWriter();
      proto.tfplugin5.Schema.NestedBlock.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };
    proto.tfplugin5.Schema.NestedBlock.serializeBinaryToWriter = function(message, writer) {
      var f2 = void 0;
      f2 = message.getTypeName();
      if (f2.length > 0) {
        writer.writeString(
          1,
          f2
        );
      }
      f2 = message.getBlock();
      if (f2 != null) {
        writer.writeMessage(
          2,
          f2,
          proto.tfplugin5.Schema.Block.serializeBinaryToWriter
        );
      }
      f2 = message.getNesting();
      if (f2 !== 0) {
        writer.writeEnum(
          3,
          f2
        );
      }
      f2 = message.getMinItems();
      if (f2 !== 0) {
        writer.writeInt64(
          4,
          f2
        );
      }
      f2 = message.getMaxItems();
      if (f2 !== 0) {
        writer.writeInt64(
          5,
          f2
        );
      }
    };
    proto.tfplugin5.Schema.NestedBlock.NestingMode = {
      INVALID: 0,
      SINGLE: 1,
      LIST: 2,
      SET: 3,
      MAP: 4,
      GROUP: 5
    };
    proto.tfplugin5.Schema.NestedBlock.prototype.getTypeName = function() {
      return (
        /** @type {string} */
        jspb2.Message.getFieldWithDefault(this, 1, "")
      );
    };
    proto.tfplugin5.Schema.NestedBlock.prototype.setTypeName = function(value) {
      return jspb2.Message.setProto3StringField(this, 1, value);
    };
    proto.tfplugin5.Schema.NestedBlock.prototype.getBlock = function() {
      return (
        /** @type{?proto.tfplugin5.Schema.Block} */
        jspb2.Message.getWrapperField(this, proto.tfplugin5.Schema.Block, 2)
      );
    };
    proto.tfplugin5.Schema.NestedBlock.prototype.setBlock = function(value) {
      return jspb2.Message.setWrapperField(this, 2, value);
    };
    proto.tfplugin5.Schema.NestedBlock.prototype.clearBlock = function() {
      return this.setBlock(void 0);
    };
    proto.tfplugin5.Schema.NestedBlock.prototype.hasBlock = function() {
      return jspb2.Message.getField(this, 2) != null;
    };
    proto.tfplugin5.Schema.NestedBlock.prototype.getNesting = function() {
      return (
        /** @type {!proto.tfplugin5.Schema.NestedBlock.NestingMode} */
        jspb2.Message.getFieldWithDefault(this, 3, 0)
      );
    };
    proto.tfplugin5.Schema.NestedBlock.prototype.setNesting = function(value) {
      return jspb2.Message.setProto3EnumField(this, 3, value);
    };
    proto.tfplugin5.Schema.NestedBlock.prototype.getMinItems = function() {
      return (
        /** @type {number} */
        jspb2.Message.getFieldWithDefault(this, 4, 0)
      );
    };
    proto.tfplugin5.Schema.NestedBlock.prototype.setMinItems = function(value) {
      return jspb2.Message.setProto3IntField(this, 4, value);
    };
    proto.tfplugin5.Schema.NestedBlock.prototype.getMaxItems = function() {
      return (
        /** @type {number} */
        jspb2.Message.getFieldWithDefault(this, 5, 0)
      );
    };
    proto.tfplugin5.Schema.NestedBlock.prototype.setMaxItems = function(value) {
      return jspb2.Message.setProto3IntField(this, 5, value);
    };
    proto.tfplugin5.Schema.prototype.getVersion = function() {
      return (
        /** @type {number} */
        jspb2.Message.getFieldWithDefault(this, 1, 0)
      );
    };
    proto.tfplugin5.Schema.prototype.setVersion = function(value) {
      return jspb2.Message.setProto3IntField(this, 1, value);
    };
    proto.tfplugin5.Schema.prototype.getBlock = function() {
      return (
        /** @type{?proto.tfplugin5.Schema.Block} */
        jspb2.Message.getWrapperField(this, proto.tfplugin5.Schema.Block, 2)
      );
    };
    proto.tfplugin5.Schema.prototype.setBlock = function(value) {
      return jspb2.Message.setWrapperField(this, 2, value);
    };
    proto.tfplugin5.Schema.prototype.clearBlock = function() {
      return this.setBlock(void 0);
    };
    proto.tfplugin5.Schema.prototype.hasBlock = function() {
      return jspb2.Message.getField(this, 2) != null;
    };
    if (jspb2.Message.GENERATE_TO_OBJECT) {
      proto.tfplugin5.GetProviderSchema.prototype.toObject = function(opt_includeInstance) {
        return proto.tfplugin5.GetProviderSchema.toObject(opt_includeInstance, this);
      };
      proto.tfplugin5.GetProviderSchema.toObject = function(includeInstance, msg) {
        var f2, obj = {};
        if (includeInstance) {
          obj.$jspbMessageInstance = msg;
        }
        return obj;
      };
    }
    proto.tfplugin5.GetProviderSchema.deserializeBinary = function(bytes) {
      var reader = new jspb2.BinaryReader(bytes);
      var msg = new proto.tfplugin5.GetProviderSchema();
      return proto.tfplugin5.GetProviderSchema.deserializeBinaryFromReader(msg, reader);
    };
    proto.tfplugin5.GetProviderSchema.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
          default:
            reader.skipField();
            break;
        }
      }
      return msg;
    };
    proto.tfplugin5.GetProviderSchema.prototype.serializeBinary = function() {
      var writer = new jspb2.BinaryWriter();
      proto.tfplugin5.GetProviderSchema.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };
    proto.tfplugin5.GetProviderSchema.serializeBinaryToWriter = function(message, writer) {
      var f2 = void 0;
    };
    if (jspb2.Message.GENERATE_TO_OBJECT) {
      proto.tfplugin5.GetProviderSchema.Request.prototype.toObject = function(opt_includeInstance) {
        return proto.tfplugin5.GetProviderSchema.Request.toObject(opt_includeInstance, this);
      };
      proto.tfplugin5.GetProviderSchema.Request.toObject = function(includeInstance, msg) {
        var f2, obj = {};
        if (includeInstance) {
          obj.$jspbMessageInstance = msg;
        }
        return obj;
      };
    }
    proto.tfplugin5.GetProviderSchema.Request.deserializeBinary = function(bytes) {
      var reader = new jspb2.BinaryReader(bytes);
      var msg = new proto.tfplugin5.GetProviderSchema.Request();
      return proto.tfplugin5.GetProviderSchema.Request.deserializeBinaryFromReader(msg, reader);
    };
    proto.tfplugin5.GetProviderSchema.Request.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
          default:
            reader.skipField();
            break;
        }
      }
      return msg;
    };
    proto.tfplugin5.GetProviderSchema.Request.prototype.serializeBinary = function() {
      var writer = new jspb2.BinaryWriter();
      proto.tfplugin5.GetProviderSchema.Request.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };
    proto.tfplugin5.GetProviderSchema.Request.serializeBinaryToWriter = function(message, writer) {
      var f2 = void 0;
    };
    proto.tfplugin5.GetProviderSchema.Response.repeatedFields_ = [4];
    if (jspb2.Message.GENERATE_TO_OBJECT) {
      proto.tfplugin5.GetProviderSchema.Response.prototype.toObject = function(opt_includeInstance) {
        return proto.tfplugin5.GetProviderSchema.Response.toObject(opt_includeInstance, this);
      };
      proto.tfplugin5.GetProviderSchema.Response.toObject = function(includeInstance, msg) {
        var f2, obj = {
          provider: (f2 = msg.getProvider()) && proto.tfplugin5.Schema.toObject(includeInstance, f2),
          resourceSchemasMap: (f2 = msg.getResourceSchemasMap()) ? f2.toObject(includeInstance, proto.tfplugin5.Schema.toObject) : [],
          dataSourceSchemasMap: (f2 = msg.getDataSourceSchemasMap()) ? f2.toObject(includeInstance, proto.tfplugin5.Schema.toObject) : [],
          diagnosticsList: jspb2.Message.toObjectList(
            msg.getDiagnosticsList(),
            proto.tfplugin5.Diagnostic.toObject,
            includeInstance
          ),
          providerMeta: (f2 = msg.getProviderMeta()) && proto.tfplugin5.Schema.toObject(includeInstance, f2),
          serverCapabilities: (f2 = msg.getServerCapabilities()) && proto.tfplugin5.GetProviderSchema.ServerCapabilities.toObject(includeInstance, f2)
        };
        if (includeInstance) {
          obj.$jspbMessageInstance = msg;
        }
        return obj;
      };
    }
    proto.tfplugin5.GetProviderSchema.Response.deserializeBinary = function(bytes) {
      var reader = new jspb2.BinaryReader(bytes);
      var msg = new proto.tfplugin5.GetProviderSchema.Response();
      return proto.tfplugin5.GetProviderSchema.Response.deserializeBinaryFromReader(msg, reader);
    };
    proto.tfplugin5.GetProviderSchema.Response.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
          case 1:
            var value = new proto.tfplugin5.Schema();
            reader.readMessage(value, proto.tfplugin5.Schema.deserializeBinaryFromReader);
            msg.setProvider(value);
            break;
          case 2:
            var value = msg.getResourceSchemasMap();
            reader.readMessage(value, function(message, reader2) {
              jspb2.Map.deserializeBinary(message, reader2, jspb2.BinaryReader.prototype.readString, jspb2.BinaryReader.prototype.readMessage, proto.tfplugin5.Schema.deserializeBinaryFromReader, "", new proto.tfplugin5.Schema());
            });
            break;
          case 3:
            var value = msg.getDataSourceSchemasMap();
            reader.readMessage(value, function(message, reader2) {
              jspb2.Map.deserializeBinary(message, reader2, jspb2.BinaryReader.prototype.readString, jspb2.BinaryReader.prototype.readMessage, proto.tfplugin5.Schema.deserializeBinaryFromReader, "", new proto.tfplugin5.Schema());
            });
            break;
          case 4:
            var value = new proto.tfplugin5.Diagnostic();
            reader.readMessage(value, proto.tfplugin5.Diagnostic.deserializeBinaryFromReader);
            msg.addDiagnostics(value);
            break;
          case 5:
            var value = new proto.tfplugin5.Schema();
            reader.readMessage(value, proto.tfplugin5.Schema.deserializeBinaryFromReader);
            msg.setProviderMeta(value);
            break;
          case 6:
            var value = new proto.tfplugin5.GetProviderSchema.ServerCapabilities();
            reader.readMessage(value, proto.tfplugin5.GetProviderSchema.ServerCapabilities.deserializeBinaryFromReader);
            msg.setServerCapabilities(value);
            break;
          default:
            reader.skipField();
            break;
        }
      }
      return msg;
    };
    proto.tfplugin5.GetProviderSchema.Response.prototype.serializeBinary = function() {
      var writer = new jspb2.BinaryWriter();
      proto.tfplugin5.GetProviderSchema.Response.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };
    proto.tfplugin5.GetProviderSchema.Response.serializeBinaryToWriter = function(message, writer) {
      var f2 = void 0;
      f2 = message.getProvider();
      if (f2 != null) {
        writer.writeMessage(
          1,
          f2,
          proto.tfplugin5.Schema.serializeBinaryToWriter
        );
      }
      f2 = message.getResourceSchemasMap(true);
      if (f2 && f2.getLength() > 0) {
        f2.serializeBinary(2, writer, jspb2.BinaryWriter.prototype.writeString, jspb2.BinaryWriter.prototype.writeMessage, proto.tfplugin5.Schema.serializeBinaryToWriter);
      }
      f2 = message.getDataSourceSchemasMap(true);
      if (f2 && f2.getLength() > 0) {
        f2.serializeBinary(3, writer, jspb2.BinaryWriter.prototype.writeString, jspb2.BinaryWriter.prototype.writeMessage, proto.tfplugin5.Schema.serializeBinaryToWriter);
      }
      f2 = message.getDiagnosticsList();
      if (f2.length > 0) {
        writer.writeRepeatedMessage(
          4,
          f2,
          proto.tfplugin5.Diagnostic.serializeBinaryToWriter
        );
      }
      f2 = message.getProviderMeta();
      if (f2 != null) {
        writer.writeMessage(
          5,
          f2,
          proto.tfplugin5.Schema.serializeBinaryToWriter
        );
      }
      f2 = message.getServerCapabilities();
      if (f2 != null) {
        writer.writeMessage(
          6,
          f2,
          proto.tfplugin5.GetProviderSchema.ServerCapabilities.serializeBinaryToWriter
        );
      }
    };
    proto.tfplugin5.GetProviderSchema.Response.prototype.getProvider = function() {
      return (
        /** @type{?proto.tfplugin5.Schema} */
        jspb2.Message.getWrapperField(this, proto.tfplugin5.Schema, 1)
      );
    };
    proto.tfplugin5.GetProviderSchema.Response.prototype.setProvider = function(value) {
      return jspb2.Message.setWrapperField(this, 1, value);
    };
    proto.tfplugin5.GetProviderSchema.Response.prototype.clearProvider = function() {
      return this.setProvider(void 0);
    };
    proto.tfplugin5.GetProviderSchema.Response.prototype.hasProvider = function() {
      return jspb2.Message.getField(this, 1) != null;
    };
    proto.tfplugin5.GetProviderSchema.Response.prototype.getResourceSchemasMap = function(opt_noLazyCreate) {
      return (
        /** @type {!jspb.Map<string,!proto.tfplugin5.Schema>} */
        jspb2.Message.getMapField(
          this,
          2,
          opt_noLazyCreate,
          proto.tfplugin5.Schema
        )
      );
    };
    proto.tfplugin5.GetProviderSchema.Response.prototype.clearResourceSchemasMap = function() {
      this.getResourceSchemasMap().clear();
      return this;
    };
    proto.tfplugin5.GetProviderSchema.Response.prototype.getDataSourceSchemasMap = function(opt_noLazyCreate) {
      return (
        /** @type {!jspb.Map<string,!proto.tfplugin5.Schema>} */
        jspb2.Message.getMapField(
          this,
          3,
          opt_noLazyCreate,
          proto.tfplugin5.Schema
        )
      );
    };
    proto.tfplugin5.GetProviderSchema.Response.prototype.clearDataSourceSchemasMap = function() {
      this.getDataSourceSchemasMap().clear();
      return this;
    };
    proto.tfplugin5.GetProviderSchema.Response.prototype.getDiagnosticsList = function() {
      return (
        /** @type{!Array<!proto.tfplugin5.Diagnostic>} */
        jspb2.Message.getRepeatedWrapperField(this, proto.tfplugin5.Diagnostic, 4)
      );
    };
    proto.tfplugin5.GetProviderSchema.Response.prototype.setDiagnosticsList = function(value) {
      return jspb2.Message.setRepeatedWrapperField(this, 4, value);
    };
    proto.tfplugin5.GetProviderSchema.Response.prototype.addDiagnostics = function(opt_value, opt_index) {
      return jspb2.Message.addToRepeatedWrapperField(this, 4, opt_value, proto.tfplugin5.Diagnostic, opt_index);
    };
    proto.tfplugin5.GetProviderSchema.Response.prototype.clearDiagnosticsList = function() {
      return this.setDiagnosticsList([]);
    };
    proto.tfplugin5.GetProviderSchema.Response.prototype.getProviderMeta = function() {
      return (
        /** @type{?proto.tfplugin5.Schema} */
        jspb2.Message.getWrapperField(this, proto.tfplugin5.Schema, 5)
      );
    };
    proto.tfplugin5.GetProviderSchema.Response.prototype.setProviderMeta = function(value) {
      return jspb2.Message.setWrapperField(this, 5, value);
    };
    proto.tfplugin5.GetProviderSchema.Response.prototype.clearProviderMeta = function() {
      return this.setProviderMeta(void 0);
    };
    proto.tfplugin5.GetProviderSchema.Response.prototype.hasProviderMeta = function() {
      return jspb2.Message.getField(this, 5) != null;
    };
    proto.tfplugin5.GetProviderSchema.Response.prototype.getServerCapabilities = function() {
      return (
        /** @type{?proto.tfplugin5.GetProviderSchema.ServerCapabilities} */
        jspb2.Message.getWrapperField(this, proto.tfplugin5.GetProviderSchema.ServerCapabilities, 6)
      );
    };
    proto.tfplugin5.GetProviderSchema.Response.prototype.setServerCapabilities = function(value) {
      return jspb2.Message.setWrapperField(this, 6, value);
    };
    proto.tfplugin5.GetProviderSchema.Response.prototype.clearServerCapabilities = function() {
      return this.setServerCapabilities(void 0);
    };
    proto.tfplugin5.GetProviderSchema.Response.prototype.hasServerCapabilities = function() {
      return jspb2.Message.getField(this, 6) != null;
    };
    if (jspb2.Message.GENERATE_TO_OBJECT) {
      proto.tfplugin5.GetProviderSchema.ServerCapabilities.prototype.toObject = function(opt_includeInstance) {
        return proto.tfplugin5.GetProviderSchema.ServerCapabilities.toObject(opt_includeInstance, this);
      };
      proto.tfplugin5.GetProviderSchema.ServerCapabilities.toObject = function(includeInstance, msg) {
        var f2, obj = {
          planDestroy: jspb2.Message.getBooleanFieldWithDefault(msg, 1, false)
        };
        if (includeInstance) {
          obj.$jspbMessageInstance = msg;
        }
        return obj;
      };
    }
    proto.tfplugin5.GetProviderSchema.ServerCapabilities.deserializeBinary = function(bytes) {
      var reader = new jspb2.BinaryReader(bytes);
      var msg = new proto.tfplugin5.GetProviderSchema.ServerCapabilities();
      return proto.tfplugin5.GetProviderSchema.ServerCapabilities.deserializeBinaryFromReader(msg, reader);
    };
    proto.tfplugin5.GetProviderSchema.ServerCapabilities.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
          case 1:
            var value = (
              /** @type {boolean} */
              reader.readBool()
            );
            msg.setPlanDestroy(value);
            break;
          default:
            reader.skipField();
            break;
        }
      }
      return msg;
    };
    proto.tfplugin5.GetProviderSchema.ServerCapabilities.prototype.serializeBinary = function() {
      var writer = new jspb2.BinaryWriter();
      proto.tfplugin5.GetProviderSchema.ServerCapabilities.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };
    proto.tfplugin5.GetProviderSchema.ServerCapabilities.serializeBinaryToWriter = function(message, writer) {
      var f2 = void 0;
      f2 = message.getPlanDestroy();
      if (f2) {
        writer.writeBool(
          1,
          f2
        );
      }
    };
    proto.tfplugin5.GetProviderSchema.ServerCapabilities.prototype.getPlanDestroy = function() {
      return (
        /** @type {boolean} */
        jspb2.Message.getBooleanFieldWithDefault(this, 1, false)
      );
    };
    proto.tfplugin5.GetProviderSchema.ServerCapabilities.prototype.setPlanDestroy = function(value) {
      return jspb2.Message.setProto3BooleanField(this, 1, value);
    };
    if (jspb2.Message.GENERATE_TO_OBJECT) {
      proto.tfplugin5.PrepareProviderConfig.prototype.toObject = function(opt_includeInstance) {
        return proto.tfplugin5.PrepareProviderConfig.toObject(opt_includeInstance, this);
      };
      proto.tfplugin5.PrepareProviderConfig.toObject = function(includeInstance, msg) {
        var f2, obj = {};
        if (includeInstance) {
          obj.$jspbMessageInstance = msg;
        }
        return obj;
      };
    }
    proto.tfplugin5.PrepareProviderConfig.deserializeBinary = function(bytes) {
      var reader = new jspb2.BinaryReader(bytes);
      var msg = new proto.tfplugin5.PrepareProviderConfig();
      return proto.tfplugin5.PrepareProviderConfig.deserializeBinaryFromReader(msg, reader);
    };
    proto.tfplugin5.PrepareProviderConfig.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
          default:
            reader.skipField();
            break;
        }
      }
      return msg;
    };
    proto.tfplugin5.PrepareProviderConfig.prototype.serializeBinary = function() {
      var writer = new jspb2.BinaryWriter();
      proto.tfplugin5.PrepareProviderConfig.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };
    proto.tfplugin5.PrepareProviderConfig.serializeBinaryToWriter = function(message, writer) {
      var f2 = void 0;
    };
    if (jspb2.Message.GENERATE_TO_OBJECT) {
      proto.tfplugin5.PrepareProviderConfig.Request.prototype.toObject = function(opt_includeInstance) {
        return proto.tfplugin5.PrepareProviderConfig.Request.toObject(opt_includeInstance, this);
      };
      proto.tfplugin5.PrepareProviderConfig.Request.toObject = function(includeInstance, msg) {
        var f2, obj = {
          config: (f2 = msg.getConfig()) && proto.tfplugin5.DynamicValue.toObject(includeInstance, f2)
        };
        if (includeInstance) {
          obj.$jspbMessageInstance = msg;
        }
        return obj;
      };
    }
    proto.tfplugin5.PrepareProviderConfig.Request.deserializeBinary = function(bytes) {
      var reader = new jspb2.BinaryReader(bytes);
      var msg = new proto.tfplugin5.PrepareProviderConfig.Request();
      return proto.tfplugin5.PrepareProviderConfig.Request.deserializeBinaryFromReader(msg, reader);
    };
    proto.tfplugin5.PrepareProviderConfig.Request.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
          case 1:
            var value = new proto.tfplugin5.DynamicValue();
            reader.readMessage(value, proto.tfplugin5.DynamicValue.deserializeBinaryFromReader);
            msg.setConfig(value);
            break;
          default:
            reader.skipField();
            break;
        }
      }
      return msg;
    };
    proto.tfplugin5.PrepareProviderConfig.Request.prototype.serializeBinary = function() {
      var writer = new jspb2.BinaryWriter();
      proto.tfplugin5.PrepareProviderConfig.Request.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };
    proto.tfplugin5.PrepareProviderConfig.Request.serializeBinaryToWriter = function(message, writer) {
      var f2 = void 0;
      f2 = message.getConfig();
      if (f2 != null) {
        writer.writeMessage(
          1,
          f2,
          proto.tfplugin5.DynamicValue.serializeBinaryToWriter
        );
      }
    };
    proto.tfplugin5.PrepareProviderConfig.Request.prototype.getConfig = function() {
      return (
        /** @type{?proto.tfplugin5.DynamicValue} */
        jspb2.Message.getWrapperField(this, proto.tfplugin5.DynamicValue, 1)
      );
    };
    proto.tfplugin5.PrepareProviderConfig.Request.prototype.setConfig = function(value) {
      return jspb2.Message.setWrapperField(this, 1, value);
    };
    proto.tfplugin5.PrepareProviderConfig.Request.prototype.clearConfig = function() {
      return this.setConfig(void 0);
    };
    proto.tfplugin5.PrepareProviderConfig.Request.prototype.hasConfig = function() {
      return jspb2.Message.getField(this, 1) != null;
    };
    proto.tfplugin5.PrepareProviderConfig.Response.repeatedFields_ = [2];
    if (jspb2.Message.GENERATE_TO_OBJECT) {
      proto.tfplugin5.PrepareProviderConfig.Response.prototype.toObject = function(opt_includeInstance) {
        return proto.tfplugin5.PrepareProviderConfig.Response.toObject(opt_includeInstance, this);
      };
      proto.tfplugin5.PrepareProviderConfig.Response.toObject = function(includeInstance, msg) {
        var f2, obj = {
          preparedConfig: (f2 = msg.getPreparedConfig()) && proto.tfplugin5.DynamicValue.toObject(includeInstance, f2),
          diagnosticsList: jspb2.Message.toObjectList(
            msg.getDiagnosticsList(),
            proto.tfplugin5.Diagnostic.toObject,
            includeInstance
          )
        };
        if (includeInstance) {
          obj.$jspbMessageInstance = msg;
        }
        return obj;
      };
    }
    proto.tfplugin5.PrepareProviderConfig.Response.deserializeBinary = function(bytes) {
      var reader = new jspb2.BinaryReader(bytes);
      var msg = new proto.tfplugin5.PrepareProviderConfig.Response();
      return proto.tfplugin5.PrepareProviderConfig.Response.deserializeBinaryFromReader(msg, reader);
    };
    proto.tfplugin5.PrepareProviderConfig.Response.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
          case 1:
            var value = new proto.tfplugin5.DynamicValue();
            reader.readMessage(value, proto.tfplugin5.DynamicValue.deserializeBinaryFromReader);
            msg.setPreparedConfig(value);
            break;
          case 2:
            var value = new proto.tfplugin5.Diagnostic();
            reader.readMessage(value, proto.tfplugin5.Diagnostic.deserializeBinaryFromReader);
            msg.addDiagnostics(value);
            break;
          default:
            reader.skipField();
            break;
        }
      }
      return msg;
    };
    proto.tfplugin5.PrepareProviderConfig.Response.prototype.serializeBinary = function() {
      var writer = new jspb2.BinaryWriter();
      proto.tfplugin5.PrepareProviderConfig.Response.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };
    proto.tfplugin5.PrepareProviderConfig.Response.serializeBinaryToWriter = function(message, writer) {
      var f2 = void 0;
      f2 = message.getPreparedConfig();
      if (f2 != null) {
        writer.writeMessage(
          1,
          f2,
          proto.tfplugin5.DynamicValue.serializeBinaryToWriter
        );
      }
      f2 = message.getDiagnosticsList();
      if (f2.length > 0) {
        writer.writeRepeatedMessage(
          2,
          f2,
          proto.tfplugin5.Diagnostic.serializeBinaryToWriter
        );
      }
    };
    proto.tfplugin5.PrepareProviderConfig.Response.prototype.getPreparedConfig = function() {
      return (
        /** @type{?proto.tfplugin5.DynamicValue} */
        jspb2.Message.getWrapperField(this, proto.tfplugin5.DynamicValue, 1)
      );
    };
    proto.tfplugin5.PrepareProviderConfig.Response.prototype.setPreparedConfig = function(value) {
      return jspb2.Message.setWrapperField(this, 1, value);
    };
    proto.tfplugin5.PrepareProviderConfig.Response.prototype.clearPreparedConfig = function() {
      return this.setPreparedConfig(void 0);
    };
    proto.tfplugin5.PrepareProviderConfig.Response.prototype.hasPreparedConfig = function() {
      return jspb2.Message.getField(this, 1) != null;
    };
    proto.tfplugin5.PrepareProviderConfig.Response.prototype.getDiagnosticsList = function() {
      return (
        /** @type{!Array<!proto.tfplugin5.Diagnostic>} */
        jspb2.Message.getRepeatedWrapperField(this, proto.tfplugin5.Diagnostic, 2)
      );
    };
    proto.tfplugin5.PrepareProviderConfig.Response.prototype.setDiagnosticsList = function(value) {
      return jspb2.Message.setRepeatedWrapperField(this, 2, value);
    };
    proto.tfplugin5.PrepareProviderConfig.Response.prototype.addDiagnostics = function(opt_value, opt_index) {
      return jspb2.Message.addToRepeatedWrapperField(this, 2, opt_value, proto.tfplugin5.Diagnostic, opt_index);
    };
    proto.tfplugin5.PrepareProviderConfig.Response.prototype.clearDiagnosticsList = function() {
      return this.setDiagnosticsList([]);
    };
    if (jspb2.Message.GENERATE_TO_OBJECT) {
      proto.tfplugin5.UpgradeResourceState.prototype.toObject = function(opt_includeInstance) {
        return proto.tfplugin5.UpgradeResourceState.toObject(opt_includeInstance, this);
      };
      proto.tfplugin5.UpgradeResourceState.toObject = function(includeInstance, msg) {
        var f2, obj = {};
        if (includeInstance) {
          obj.$jspbMessageInstance = msg;
        }
        return obj;
      };
    }
    proto.tfplugin5.UpgradeResourceState.deserializeBinary = function(bytes) {
      var reader = new jspb2.BinaryReader(bytes);
      var msg = new proto.tfplugin5.UpgradeResourceState();
      return proto.tfplugin5.UpgradeResourceState.deserializeBinaryFromReader(msg, reader);
    };
    proto.tfplugin5.UpgradeResourceState.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
          default:
            reader.skipField();
            break;
        }
      }
      return msg;
    };
    proto.tfplugin5.UpgradeResourceState.prototype.serializeBinary = function() {
      var writer = new jspb2.BinaryWriter();
      proto.tfplugin5.UpgradeResourceState.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };
    proto.tfplugin5.UpgradeResourceState.serializeBinaryToWriter = function(message, writer) {
      var f2 = void 0;
    };
    if (jspb2.Message.GENERATE_TO_OBJECT) {
      proto.tfplugin5.UpgradeResourceState.Request.prototype.toObject = function(opt_includeInstance) {
        return proto.tfplugin5.UpgradeResourceState.Request.toObject(opt_includeInstance, this);
      };
      proto.tfplugin5.UpgradeResourceState.Request.toObject = function(includeInstance, msg) {
        var f2, obj = {
          typeName: jspb2.Message.getFieldWithDefault(msg, 1, ""),
          version: jspb2.Message.getFieldWithDefault(msg, 2, 0),
          rawState: (f2 = msg.getRawState()) && proto.tfplugin5.RawState.toObject(includeInstance, f2)
        };
        if (includeInstance) {
          obj.$jspbMessageInstance = msg;
        }
        return obj;
      };
    }
    proto.tfplugin5.UpgradeResourceState.Request.deserializeBinary = function(bytes) {
      var reader = new jspb2.BinaryReader(bytes);
      var msg = new proto.tfplugin5.UpgradeResourceState.Request();
      return proto.tfplugin5.UpgradeResourceState.Request.deserializeBinaryFromReader(msg, reader);
    };
    proto.tfplugin5.UpgradeResourceState.Request.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
          case 1:
            var value = (
              /** @type {string} */
              reader.readString()
            );
            msg.setTypeName(value);
            break;
          case 2:
            var value = (
              /** @type {number} */
              reader.readInt64()
            );
            msg.setVersion(value);
            break;
          case 3:
            var value = new proto.tfplugin5.RawState();
            reader.readMessage(value, proto.tfplugin5.RawState.deserializeBinaryFromReader);
            msg.setRawState(value);
            break;
          default:
            reader.skipField();
            break;
        }
      }
      return msg;
    };
    proto.tfplugin5.UpgradeResourceState.Request.prototype.serializeBinary = function() {
      var writer = new jspb2.BinaryWriter();
      proto.tfplugin5.UpgradeResourceState.Request.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };
    proto.tfplugin5.UpgradeResourceState.Request.serializeBinaryToWriter = function(message, writer) {
      var f2 = void 0;
      f2 = message.getTypeName();
      if (f2.length > 0) {
        writer.writeString(
          1,
          f2
        );
      }
      f2 = message.getVersion();
      if (f2 !== 0) {
        writer.writeInt64(
          2,
          f2
        );
      }
      f2 = message.getRawState();
      if (f2 != null) {
        writer.writeMessage(
          3,
          f2,
          proto.tfplugin5.RawState.serializeBinaryToWriter
        );
      }
    };
    proto.tfplugin5.UpgradeResourceState.Request.prototype.getTypeName = function() {
      return (
        /** @type {string} */
        jspb2.Message.getFieldWithDefault(this, 1, "")
      );
    };
    proto.tfplugin5.UpgradeResourceState.Request.prototype.setTypeName = function(value) {
      return jspb2.Message.setProto3StringField(this, 1, value);
    };
    proto.tfplugin5.UpgradeResourceState.Request.prototype.getVersion = function() {
      return (
        /** @type {number} */
        jspb2.Message.getFieldWithDefault(this, 2, 0)
      );
    };
    proto.tfplugin5.UpgradeResourceState.Request.prototype.setVersion = function(value) {
      return jspb2.Message.setProto3IntField(this, 2, value);
    };
    proto.tfplugin5.UpgradeResourceState.Request.prototype.getRawState = function() {
      return (
        /** @type{?proto.tfplugin5.RawState} */
        jspb2.Message.getWrapperField(this, proto.tfplugin5.RawState, 3)
      );
    };
    proto.tfplugin5.UpgradeResourceState.Request.prototype.setRawState = function(value) {
      return jspb2.Message.setWrapperField(this, 3, value);
    };
    proto.tfplugin5.UpgradeResourceState.Request.prototype.clearRawState = function() {
      return this.setRawState(void 0);
    };
    proto.tfplugin5.UpgradeResourceState.Request.prototype.hasRawState = function() {
      return jspb2.Message.getField(this, 3) != null;
    };
    proto.tfplugin5.UpgradeResourceState.Response.repeatedFields_ = [2];
    if (jspb2.Message.GENERATE_TO_OBJECT) {
      proto.tfplugin5.UpgradeResourceState.Response.prototype.toObject = function(opt_includeInstance) {
        return proto.tfplugin5.UpgradeResourceState.Response.toObject(opt_includeInstance, this);
      };
      proto.tfplugin5.UpgradeResourceState.Response.toObject = function(includeInstance, msg) {
        var f2, obj = {
          upgradedState: (f2 = msg.getUpgradedState()) && proto.tfplugin5.DynamicValue.toObject(includeInstance, f2),
          diagnosticsList: jspb2.Message.toObjectList(
            msg.getDiagnosticsList(),
            proto.tfplugin5.Diagnostic.toObject,
            includeInstance
          )
        };
        if (includeInstance) {
          obj.$jspbMessageInstance = msg;
        }
        return obj;
      };
    }
    proto.tfplugin5.UpgradeResourceState.Response.deserializeBinary = function(bytes) {
      var reader = new jspb2.BinaryReader(bytes);
      var msg = new proto.tfplugin5.UpgradeResourceState.Response();
      return proto.tfplugin5.UpgradeResourceState.Response.deserializeBinaryFromReader(msg, reader);
    };
    proto.tfplugin5.UpgradeResourceState.Response.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
          case 1:
            var value = new proto.tfplugin5.DynamicValue();
            reader.readMessage(value, proto.tfplugin5.DynamicValue.deserializeBinaryFromReader);
            msg.setUpgradedState(value);
            break;
          case 2:
            var value = new proto.tfplugin5.Diagnostic();
            reader.readMessage(value, proto.tfplugin5.Diagnostic.deserializeBinaryFromReader);
            msg.addDiagnostics(value);
            break;
          default:
            reader.skipField();
            break;
        }
      }
      return msg;
    };
    proto.tfplugin5.UpgradeResourceState.Response.prototype.serializeBinary = function() {
      var writer = new jspb2.BinaryWriter();
      proto.tfplugin5.UpgradeResourceState.Response.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };
    proto.tfplugin5.UpgradeResourceState.Response.serializeBinaryToWriter = function(message, writer) {
      var f2 = void 0;
      f2 = message.getUpgradedState();
      if (f2 != null) {
        writer.writeMessage(
          1,
          f2,
          proto.tfplugin5.DynamicValue.serializeBinaryToWriter
        );
      }
      f2 = message.getDiagnosticsList();
      if (f2.length > 0) {
        writer.writeRepeatedMessage(
          2,
          f2,
          proto.tfplugin5.Diagnostic.serializeBinaryToWriter
        );
      }
    };
    proto.tfplugin5.UpgradeResourceState.Response.prototype.getUpgradedState = function() {
      return (
        /** @type{?proto.tfplugin5.DynamicValue} */
        jspb2.Message.getWrapperField(this, proto.tfplugin5.DynamicValue, 1)
      );
    };
    proto.tfplugin5.UpgradeResourceState.Response.prototype.setUpgradedState = function(value) {
      return jspb2.Message.setWrapperField(this, 1, value);
    };
    proto.tfplugin5.UpgradeResourceState.Response.prototype.clearUpgradedState = function() {
      return this.setUpgradedState(void 0);
    };
    proto.tfplugin5.UpgradeResourceState.Response.prototype.hasUpgradedState = function() {
      return jspb2.Message.getField(this, 1) != null;
    };
    proto.tfplugin5.UpgradeResourceState.Response.prototype.getDiagnosticsList = function() {
      return (
        /** @type{!Array<!proto.tfplugin5.Diagnostic>} */
        jspb2.Message.getRepeatedWrapperField(this, proto.tfplugin5.Diagnostic, 2)
      );
    };
    proto.tfplugin5.UpgradeResourceState.Response.prototype.setDiagnosticsList = function(value) {
      return jspb2.Message.setRepeatedWrapperField(this, 2, value);
    };
    proto.tfplugin5.UpgradeResourceState.Response.prototype.addDiagnostics = function(opt_value, opt_index) {
      return jspb2.Message.addToRepeatedWrapperField(this, 2, opt_value, proto.tfplugin5.Diagnostic, opt_index);
    };
    proto.tfplugin5.UpgradeResourceState.Response.prototype.clearDiagnosticsList = function() {
      return this.setDiagnosticsList([]);
    };
    if (jspb2.Message.GENERATE_TO_OBJECT) {
      proto.tfplugin5.ValidateResourceTypeConfig.prototype.toObject = function(opt_includeInstance) {
        return proto.tfplugin5.ValidateResourceTypeConfig.toObject(opt_includeInstance, this);
      };
      proto.tfplugin5.ValidateResourceTypeConfig.toObject = function(includeInstance, msg) {
        var f2, obj = {};
        if (includeInstance) {
          obj.$jspbMessageInstance = msg;
        }
        return obj;
      };
    }
    proto.tfplugin5.ValidateResourceTypeConfig.deserializeBinary = function(bytes) {
      var reader = new jspb2.BinaryReader(bytes);
      var msg = new proto.tfplugin5.ValidateResourceTypeConfig();
      return proto.tfplugin5.ValidateResourceTypeConfig.deserializeBinaryFromReader(msg, reader);
    };
    proto.tfplugin5.ValidateResourceTypeConfig.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
          default:
            reader.skipField();
            break;
        }
      }
      return msg;
    };
    proto.tfplugin5.ValidateResourceTypeConfig.prototype.serializeBinary = function() {
      var writer = new jspb2.BinaryWriter();
      proto.tfplugin5.ValidateResourceTypeConfig.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };
    proto.tfplugin5.ValidateResourceTypeConfig.serializeBinaryToWriter = function(message, writer) {
      var f2 = void 0;
    };
    if (jspb2.Message.GENERATE_TO_OBJECT) {
      proto.tfplugin5.ValidateResourceTypeConfig.Request.prototype.toObject = function(opt_includeInstance) {
        return proto.tfplugin5.ValidateResourceTypeConfig.Request.toObject(opt_includeInstance, this);
      };
      proto.tfplugin5.ValidateResourceTypeConfig.Request.toObject = function(includeInstance, msg) {
        var f2, obj = {
          typeName: jspb2.Message.getFieldWithDefault(msg, 1, ""),
          config: (f2 = msg.getConfig()) && proto.tfplugin5.DynamicValue.toObject(includeInstance, f2)
        };
        if (includeInstance) {
          obj.$jspbMessageInstance = msg;
        }
        return obj;
      };
    }
    proto.tfplugin5.ValidateResourceTypeConfig.Request.deserializeBinary = function(bytes) {
      var reader = new jspb2.BinaryReader(bytes);
      var msg = new proto.tfplugin5.ValidateResourceTypeConfig.Request();
      return proto.tfplugin5.ValidateResourceTypeConfig.Request.deserializeBinaryFromReader(msg, reader);
    };
    proto.tfplugin5.ValidateResourceTypeConfig.Request.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
          case 1:
            var value = (
              /** @type {string} */
              reader.readString()
            );
            msg.setTypeName(value);
            break;
          case 2:
            var value = new proto.tfplugin5.DynamicValue();
            reader.readMessage(value, proto.tfplugin5.DynamicValue.deserializeBinaryFromReader);
            msg.setConfig(value);
            break;
          default:
            reader.skipField();
            break;
        }
      }
      return msg;
    };
    proto.tfplugin5.ValidateResourceTypeConfig.Request.prototype.serializeBinary = function() {
      var writer = new jspb2.BinaryWriter();
      proto.tfplugin5.ValidateResourceTypeConfig.Request.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };
    proto.tfplugin5.ValidateResourceTypeConfig.Request.serializeBinaryToWriter = function(message, writer) {
      var f2 = void 0;
      f2 = message.getTypeName();
      if (f2.length > 0) {
        writer.writeString(
          1,
          f2
        );
      }
      f2 = message.getConfig();
      if (f2 != null) {
        writer.writeMessage(
          2,
          f2,
          proto.tfplugin5.DynamicValue.serializeBinaryToWriter
        );
      }
    };
    proto.tfplugin5.ValidateResourceTypeConfig.Request.prototype.getTypeName = function() {
      return (
        /** @type {string} */
        jspb2.Message.getFieldWithDefault(this, 1, "")
      );
    };
    proto.tfplugin5.ValidateResourceTypeConfig.Request.prototype.setTypeName = function(value) {
      return jspb2.Message.setProto3StringField(this, 1, value);
    };
    proto.tfplugin5.ValidateResourceTypeConfig.Request.prototype.getConfig = function() {
      return (
        /** @type{?proto.tfplugin5.DynamicValue} */
        jspb2.Message.getWrapperField(this, proto.tfplugin5.DynamicValue, 2)
      );
    };
    proto.tfplugin5.ValidateResourceTypeConfig.Request.prototype.setConfig = function(value) {
      return jspb2.Message.setWrapperField(this, 2, value);
    };
    proto.tfplugin5.ValidateResourceTypeConfig.Request.prototype.clearConfig = function() {
      return this.setConfig(void 0);
    };
    proto.tfplugin5.ValidateResourceTypeConfig.Request.prototype.hasConfig = function() {
      return jspb2.Message.getField(this, 2) != null;
    };
    proto.tfplugin5.ValidateResourceTypeConfig.Response.repeatedFields_ = [1];
    if (jspb2.Message.GENERATE_TO_OBJECT) {
      proto.tfplugin5.ValidateResourceTypeConfig.Response.prototype.toObject = function(opt_includeInstance) {
        return proto.tfplugin5.ValidateResourceTypeConfig.Response.toObject(opt_includeInstance, this);
      };
      proto.tfplugin5.ValidateResourceTypeConfig.Response.toObject = function(includeInstance, msg) {
        var f2, obj = {
          diagnosticsList: jspb2.Message.toObjectList(
            msg.getDiagnosticsList(),
            proto.tfplugin5.Diagnostic.toObject,
            includeInstance
          )
        };
        if (includeInstance) {
          obj.$jspbMessageInstance = msg;
        }
        return obj;
      };
    }
    proto.tfplugin5.ValidateResourceTypeConfig.Response.deserializeBinary = function(bytes) {
      var reader = new jspb2.BinaryReader(bytes);
      var msg = new proto.tfplugin5.ValidateResourceTypeConfig.Response();
      return proto.tfplugin5.ValidateResourceTypeConfig.Response.deserializeBinaryFromReader(msg, reader);
    };
    proto.tfplugin5.ValidateResourceTypeConfig.Response.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
          case 1:
            var value = new proto.tfplugin5.Diagnostic();
            reader.readMessage(value, proto.tfplugin5.Diagnostic.deserializeBinaryFromReader);
            msg.addDiagnostics(value);
            break;
          default:
            reader.skipField();
            break;
        }
      }
      return msg;
    };
    proto.tfplugin5.ValidateResourceTypeConfig.Response.prototype.serializeBinary = function() {
      var writer = new jspb2.BinaryWriter();
      proto.tfplugin5.ValidateResourceTypeConfig.Response.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };
    proto.tfplugin5.ValidateResourceTypeConfig.Response.serializeBinaryToWriter = function(message, writer) {
      var f2 = void 0;
      f2 = message.getDiagnosticsList();
      if (f2.length > 0) {
        writer.writeRepeatedMessage(
          1,
          f2,
          proto.tfplugin5.Diagnostic.serializeBinaryToWriter
        );
      }
    };
    proto.tfplugin5.ValidateResourceTypeConfig.Response.prototype.getDiagnosticsList = function() {
      return (
        /** @type{!Array<!proto.tfplugin5.Diagnostic>} */
        jspb2.Message.getRepeatedWrapperField(this, proto.tfplugin5.Diagnostic, 1)
      );
    };
    proto.tfplugin5.ValidateResourceTypeConfig.Response.prototype.setDiagnosticsList = function(value) {
      return jspb2.Message.setRepeatedWrapperField(this, 1, value);
    };
    proto.tfplugin5.ValidateResourceTypeConfig.Response.prototype.addDiagnostics = function(opt_value, opt_index) {
      return jspb2.Message.addToRepeatedWrapperField(this, 1, opt_value, proto.tfplugin5.Diagnostic, opt_index);
    };
    proto.tfplugin5.ValidateResourceTypeConfig.Response.prototype.clearDiagnosticsList = function() {
      return this.setDiagnosticsList([]);
    };
    if (jspb2.Message.GENERATE_TO_OBJECT) {
      proto.tfplugin5.ValidateDataSourceConfig.prototype.toObject = function(opt_includeInstance) {
        return proto.tfplugin5.ValidateDataSourceConfig.toObject(opt_includeInstance, this);
      };
      proto.tfplugin5.ValidateDataSourceConfig.toObject = function(includeInstance, msg) {
        var f2, obj = {};
        if (includeInstance) {
          obj.$jspbMessageInstance = msg;
        }
        return obj;
      };
    }
    proto.tfplugin5.ValidateDataSourceConfig.deserializeBinary = function(bytes) {
      var reader = new jspb2.BinaryReader(bytes);
      var msg = new proto.tfplugin5.ValidateDataSourceConfig();
      return proto.tfplugin5.ValidateDataSourceConfig.deserializeBinaryFromReader(msg, reader);
    };
    proto.tfplugin5.ValidateDataSourceConfig.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
          default:
            reader.skipField();
            break;
        }
      }
      return msg;
    };
    proto.tfplugin5.ValidateDataSourceConfig.prototype.serializeBinary = function() {
      var writer = new jspb2.BinaryWriter();
      proto.tfplugin5.ValidateDataSourceConfig.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };
    proto.tfplugin5.ValidateDataSourceConfig.serializeBinaryToWriter = function(message, writer) {
      var f2 = void 0;
    };
    if (jspb2.Message.GENERATE_TO_OBJECT) {
      proto.tfplugin5.ValidateDataSourceConfig.Request.prototype.toObject = function(opt_includeInstance) {
        return proto.tfplugin5.ValidateDataSourceConfig.Request.toObject(opt_includeInstance, this);
      };
      proto.tfplugin5.ValidateDataSourceConfig.Request.toObject = function(includeInstance, msg) {
        var f2, obj = {
          typeName: jspb2.Message.getFieldWithDefault(msg, 1, ""),
          config: (f2 = msg.getConfig()) && proto.tfplugin5.DynamicValue.toObject(includeInstance, f2)
        };
        if (includeInstance) {
          obj.$jspbMessageInstance = msg;
        }
        return obj;
      };
    }
    proto.tfplugin5.ValidateDataSourceConfig.Request.deserializeBinary = function(bytes) {
      var reader = new jspb2.BinaryReader(bytes);
      var msg = new proto.tfplugin5.ValidateDataSourceConfig.Request();
      return proto.tfplugin5.ValidateDataSourceConfig.Request.deserializeBinaryFromReader(msg, reader);
    };
    proto.tfplugin5.ValidateDataSourceConfig.Request.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
          case 1:
            var value = (
              /** @type {string} */
              reader.readString()
            );
            msg.setTypeName(value);
            break;
          case 2:
            var value = new proto.tfplugin5.DynamicValue();
            reader.readMessage(value, proto.tfplugin5.DynamicValue.deserializeBinaryFromReader);
            msg.setConfig(value);
            break;
          default:
            reader.skipField();
            break;
        }
      }
      return msg;
    };
    proto.tfplugin5.ValidateDataSourceConfig.Request.prototype.serializeBinary = function() {
      var writer = new jspb2.BinaryWriter();
      proto.tfplugin5.ValidateDataSourceConfig.Request.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };
    proto.tfplugin5.ValidateDataSourceConfig.Request.serializeBinaryToWriter = function(message, writer) {
      var f2 = void 0;
      f2 = message.getTypeName();
      if (f2.length > 0) {
        writer.writeString(
          1,
          f2
        );
      }
      f2 = message.getConfig();
      if (f2 != null) {
        writer.writeMessage(
          2,
          f2,
          proto.tfplugin5.DynamicValue.serializeBinaryToWriter
        );
      }
    };
    proto.tfplugin5.ValidateDataSourceConfig.Request.prototype.getTypeName = function() {
      return (
        /** @type {string} */
        jspb2.Message.getFieldWithDefault(this, 1, "")
      );
    };
    proto.tfplugin5.ValidateDataSourceConfig.Request.prototype.setTypeName = function(value) {
      return jspb2.Message.setProto3StringField(this, 1, value);
    };
    proto.tfplugin5.ValidateDataSourceConfig.Request.prototype.getConfig = function() {
      return (
        /** @type{?proto.tfplugin5.DynamicValue} */
        jspb2.Message.getWrapperField(this, proto.tfplugin5.DynamicValue, 2)
      );
    };
    proto.tfplugin5.ValidateDataSourceConfig.Request.prototype.setConfig = function(value) {
      return jspb2.Message.setWrapperField(this, 2, value);
    };
    proto.tfplugin5.ValidateDataSourceConfig.Request.prototype.clearConfig = function() {
      return this.setConfig(void 0);
    };
    proto.tfplugin5.ValidateDataSourceConfig.Request.prototype.hasConfig = function() {
      return jspb2.Message.getField(this, 2) != null;
    };
    proto.tfplugin5.ValidateDataSourceConfig.Response.repeatedFields_ = [1];
    if (jspb2.Message.GENERATE_TO_OBJECT) {
      proto.tfplugin5.ValidateDataSourceConfig.Response.prototype.toObject = function(opt_includeInstance) {
        return proto.tfplugin5.ValidateDataSourceConfig.Response.toObject(opt_includeInstance, this);
      };
      proto.tfplugin5.ValidateDataSourceConfig.Response.toObject = function(includeInstance, msg) {
        var f2, obj = {
          diagnosticsList: jspb2.Message.toObjectList(
            msg.getDiagnosticsList(),
            proto.tfplugin5.Diagnostic.toObject,
            includeInstance
          )
        };
        if (includeInstance) {
          obj.$jspbMessageInstance = msg;
        }
        return obj;
      };
    }
    proto.tfplugin5.ValidateDataSourceConfig.Response.deserializeBinary = function(bytes) {
      var reader = new jspb2.BinaryReader(bytes);
      var msg = new proto.tfplugin5.ValidateDataSourceConfig.Response();
      return proto.tfplugin5.ValidateDataSourceConfig.Response.deserializeBinaryFromReader(msg, reader);
    };
    proto.tfplugin5.ValidateDataSourceConfig.Response.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
          case 1:
            var value = new proto.tfplugin5.Diagnostic();
            reader.readMessage(value, proto.tfplugin5.Diagnostic.deserializeBinaryFromReader);
            msg.addDiagnostics(value);
            break;
          default:
            reader.skipField();
            break;
        }
      }
      return msg;
    };
    proto.tfplugin5.ValidateDataSourceConfig.Response.prototype.serializeBinary = function() {
      var writer = new jspb2.BinaryWriter();
      proto.tfplugin5.ValidateDataSourceConfig.Response.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };
    proto.tfplugin5.ValidateDataSourceConfig.Response.serializeBinaryToWriter = function(message, writer) {
      var f2 = void 0;
      f2 = message.getDiagnosticsList();
      if (f2.length > 0) {
        writer.writeRepeatedMessage(
          1,
          f2,
          proto.tfplugin5.Diagnostic.serializeBinaryToWriter
        );
      }
    };
    proto.tfplugin5.ValidateDataSourceConfig.Response.prototype.getDiagnosticsList = function() {
      return (
        /** @type{!Array<!proto.tfplugin5.Diagnostic>} */
        jspb2.Message.getRepeatedWrapperField(this, proto.tfplugin5.Diagnostic, 1)
      );
    };
    proto.tfplugin5.ValidateDataSourceConfig.Response.prototype.setDiagnosticsList = function(value) {
      return jspb2.Message.setRepeatedWrapperField(this, 1, value);
    };
    proto.tfplugin5.ValidateDataSourceConfig.Response.prototype.addDiagnostics = function(opt_value, opt_index) {
      return jspb2.Message.addToRepeatedWrapperField(this, 1, opt_value, proto.tfplugin5.Diagnostic, opt_index);
    };
    proto.tfplugin5.ValidateDataSourceConfig.Response.prototype.clearDiagnosticsList = function() {
      return this.setDiagnosticsList([]);
    };
    if (jspb2.Message.GENERATE_TO_OBJECT) {
      proto.tfplugin5.Configure.prototype.toObject = function(opt_includeInstance) {
        return proto.tfplugin5.Configure.toObject(opt_includeInstance, this);
      };
      proto.tfplugin5.Configure.toObject = function(includeInstance, msg) {
        var f2, obj = {};
        if (includeInstance) {
          obj.$jspbMessageInstance = msg;
        }
        return obj;
      };
    }
    proto.tfplugin5.Configure.deserializeBinary = function(bytes) {
      var reader = new jspb2.BinaryReader(bytes);
      var msg = new proto.tfplugin5.Configure();
      return proto.tfplugin5.Configure.deserializeBinaryFromReader(msg, reader);
    };
    proto.tfplugin5.Configure.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
          default:
            reader.skipField();
            break;
        }
      }
      return msg;
    };
    proto.tfplugin5.Configure.prototype.serializeBinary = function() {
      var writer = new jspb2.BinaryWriter();
      proto.tfplugin5.Configure.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };
    proto.tfplugin5.Configure.serializeBinaryToWriter = function(message, writer) {
      var f2 = void 0;
    };
    if (jspb2.Message.GENERATE_TO_OBJECT) {
      proto.tfplugin5.Configure.Request.prototype.toObject = function(opt_includeInstance) {
        return proto.tfplugin5.Configure.Request.toObject(opt_includeInstance, this);
      };
      proto.tfplugin5.Configure.Request.toObject = function(includeInstance, msg) {
        var f2, obj = {
          terraformVersion: jspb2.Message.getFieldWithDefault(msg, 1, ""),
          config: (f2 = msg.getConfig()) && proto.tfplugin5.DynamicValue.toObject(includeInstance, f2)
        };
        if (includeInstance) {
          obj.$jspbMessageInstance = msg;
        }
        return obj;
      };
    }
    proto.tfplugin5.Configure.Request.deserializeBinary = function(bytes) {
      var reader = new jspb2.BinaryReader(bytes);
      var msg = new proto.tfplugin5.Configure.Request();
      return proto.tfplugin5.Configure.Request.deserializeBinaryFromReader(msg, reader);
    };
    proto.tfplugin5.Configure.Request.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
          case 1:
            var value = (
              /** @type {string} */
              reader.readString()
            );
            msg.setTerraformVersion(value);
            break;
          case 2:
            var value = new proto.tfplugin5.DynamicValue();
            reader.readMessage(value, proto.tfplugin5.DynamicValue.deserializeBinaryFromReader);
            msg.setConfig(value);
            break;
          default:
            reader.skipField();
            break;
        }
      }
      return msg;
    };
    proto.tfplugin5.Configure.Request.prototype.serializeBinary = function() {
      var writer = new jspb2.BinaryWriter();
      proto.tfplugin5.Configure.Request.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };
    proto.tfplugin5.Configure.Request.serializeBinaryToWriter = function(message, writer) {
      var f2 = void 0;
      f2 = message.getTerraformVersion();
      if (f2.length > 0) {
        writer.writeString(
          1,
          f2
        );
      }
      f2 = message.getConfig();
      if (f2 != null) {
        writer.writeMessage(
          2,
          f2,
          proto.tfplugin5.DynamicValue.serializeBinaryToWriter
        );
      }
    };
    proto.tfplugin5.Configure.Request.prototype.getTerraformVersion = function() {
      return (
        /** @type {string} */
        jspb2.Message.getFieldWithDefault(this, 1, "")
      );
    };
    proto.tfplugin5.Configure.Request.prototype.setTerraformVersion = function(value) {
      return jspb2.Message.setProto3StringField(this, 1, value);
    };
    proto.tfplugin5.Configure.Request.prototype.getConfig = function() {
      return (
        /** @type{?proto.tfplugin5.DynamicValue} */
        jspb2.Message.getWrapperField(this, proto.tfplugin5.DynamicValue, 2)
      );
    };
    proto.tfplugin5.Configure.Request.prototype.setConfig = function(value) {
      return jspb2.Message.setWrapperField(this, 2, value);
    };
    proto.tfplugin5.Configure.Request.prototype.clearConfig = function() {
      return this.setConfig(void 0);
    };
    proto.tfplugin5.Configure.Request.prototype.hasConfig = function() {
      return jspb2.Message.getField(this, 2) != null;
    };
    proto.tfplugin5.Configure.Response.repeatedFields_ = [1];
    if (jspb2.Message.GENERATE_TO_OBJECT) {
      proto.tfplugin5.Configure.Response.prototype.toObject = function(opt_includeInstance) {
        return proto.tfplugin5.Configure.Response.toObject(opt_includeInstance, this);
      };
      proto.tfplugin5.Configure.Response.toObject = function(includeInstance, msg) {
        var f2, obj = {
          diagnosticsList: jspb2.Message.toObjectList(
            msg.getDiagnosticsList(),
            proto.tfplugin5.Diagnostic.toObject,
            includeInstance
          )
        };
        if (includeInstance) {
          obj.$jspbMessageInstance = msg;
        }
        return obj;
      };
    }
    proto.tfplugin5.Configure.Response.deserializeBinary = function(bytes) {
      var reader = new jspb2.BinaryReader(bytes);
      var msg = new proto.tfplugin5.Configure.Response();
      return proto.tfplugin5.Configure.Response.deserializeBinaryFromReader(msg, reader);
    };
    proto.tfplugin5.Configure.Response.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
          case 1:
            var value = new proto.tfplugin5.Diagnostic();
            reader.readMessage(value, proto.tfplugin5.Diagnostic.deserializeBinaryFromReader);
            msg.addDiagnostics(value);
            break;
          default:
            reader.skipField();
            break;
        }
      }
      return msg;
    };
    proto.tfplugin5.Configure.Response.prototype.serializeBinary = function() {
      var writer = new jspb2.BinaryWriter();
      proto.tfplugin5.Configure.Response.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };
    proto.tfplugin5.Configure.Response.serializeBinaryToWriter = function(message, writer) {
      var f2 = void 0;
      f2 = message.getDiagnosticsList();
      if (f2.length > 0) {
        writer.writeRepeatedMessage(
          1,
          f2,
          proto.tfplugin5.Diagnostic.serializeBinaryToWriter
        );
      }
    };
    proto.tfplugin5.Configure.Response.prototype.getDiagnosticsList = function() {
      return (
        /** @type{!Array<!proto.tfplugin5.Diagnostic>} */
        jspb2.Message.getRepeatedWrapperField(this, proto.tfplugin5.Diagnostic, 1)
      );
    };
    proto.tfplugin5.Configure.Response.prototype.setDiagnosticsList = function(value) {
      return jspb2.Message.setRepeatedWrapperField(this, 1, value);
    };
    proto.tfplugin5.Configure.Response.prototype.addDiagnostics = function(opt_value, opt_index) {
      return jspb2.Message.addToRepeatedWrapperField(this, 1, opt_value, proto.tfplugin5.Diagnostic, opt_index);
    };
    proto.tfplugin5.Configure.Response.prototype.clearDiagnosticsList = function() {
      return this.setDiagnosticsList([]);
    };
    if (jspb2.Message.GENERATE_TO_OBJECT) {
      proto.tfplugin5.ReadResource.prototype.toObject = function(opt_includeInstance) {
        return proto.tfplugin5.ReadResource.toObject(opt_includeInstance, this);
      };
      proto.tfplugin5.ReadResource.toObject = function(includeInstance, msg) {
        var f2, obj = {};
        if (includeInstance) {
          obj.$jspbMessageInstance = msg;
        }
        return obj;
      };
    }
    proto.tfplugin5.ReadResource.deserializeBinary = function(bytes) {
      var reader = new jspb2.BinaryReader(bytes);
      var msg = new proto.tfplugin5.ReadResource();
      return proto.tfplugin5.ReadResource.deserializeBinaryFromReader(msg, reader);
    };
    proto.tfplugin5.ReadResource.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
          default:
            reader.skipField();
            break;
        }
      }
      return msg;
    };
    proto.tfplugin5.ReadResource.prototype.serializeBinary = function() {
      var writer = new jspb2.BinaryWriter();
      proto.tfplugin5.ReadResource.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };
    proto.tfplugin5.ReadResource.serializeBinaryToWriter = function(message, writer) {
      var f2 = void 0;
    };
    if (jspb2.Message.GENERATE_TO_OBJECT) {
      proto.tfplugin5.ReadResource.Request.prototype.toObject = function(opt_includeInstance) {
        return proto.tfplugin5.ReadResource.Request.toObject(opt_includeInstance, this);
      };
      proto.tfplugin5.ReadResource.Request.toObject = function(includeInstance, msg) {
        var f2, obj = {
          typeName: jspb2.Message.getFieldWithDefault(msg, 1, ""),
          currentState: (f2 = msg.getCurrentState()) && proto.tfplugin5.DynamicValue.toObject(includeInstance, f2),
          pb_private: msg.getPrivate_asB64(),
          providerMeta: (f2 = msg.getProviderMeta()) && proto.tfplugin5.DynamicValue.toObject(includeInstance, f2)
        };
        if (includeInstance) {
          obj.$jspbMessageInstance = msg;
        }
        return obj;
      };
    }
    proto.tfplugin5.ReadResource.Request.deserializeBinary = function(bytes) {
      var reader = new jspb2.BinaryReader(bytes);
      var msg = new proto.tfplugin5.ReadResource.Request();
      return proto.tfplugin5.ReadResource.Request.deserializeBinaryFromReader(msg, reader);
    };
    proto.tfplugin5.ReadResource.Request.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
          case 1:
            var value = (
              /** @type {string} */
              reader.readString()
            );
            msg.setTypeName(value);
            break;
          case 2:
            var value = new proto.tfplugin5.DynamicValue();
            reader.readMessage(value, proto.tfplugin5.DynamicValue.deserializeBinaryFromReader);
            msg.setCurrentState(value);
            break;
          case 3:
            var value = (
              /** @type {!Uint8Array} */
              reader.readBytes()
            );
            msg.setPrivate(value);
            break;
          case 4:
            var value = new proto.tfplugin5.DynamicValue();
            reader.readMessage(value, proto.tfplugin5.DynamicValue.deserializeBinaryFromReader);
            msg.setProviderMeta(value);
            break;
          default:
            reader.skipField();
            break;
        }
      }
      return msg;
    };
    proto.tfplugin5.ReadResource.Request.prototype.serializeBinary = function() {
      var writer = new jspb2.BinaryWriter();
      proto.tfplugin5.ReadResource.Request.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };
    proto.tfplugin5.ReadResource.Request.serializeBinaryToWriter = function(message, writer) {
      var f2 = void 0;
      f2 = message.getTypeName();
      if (f2.length > 0) {
        writer.writeString(
          1,
          f2
        );
      }
      f2 = message.getCurrentState();
      if (f2 != null) {
        writer.writeMessage(
          2,
          f2,
          proto.tfplugin5.DynamicValue.serializeBinaryToWriter
        );
      }
      f2 = message.getPrivate_asU8();
      if (f2.length > 0) {
        writer.writeBytes(
          3,
          f2
        );
      }
      f2 = message.getProviderMeta();
      if (f2 != null) {
        writer.writeMessage(
          4,
          f2,
          proto.tfplugin5.DynamicValue.serializeBinaryToWriter
        );
      }
    };
    proto.tfplugin5.ReadResource.Request.prototype.getTypeName = function() {
      return (
        /** @type {string} */
        jspb2.Message.getFieldWithDefault(this, 1, "")
      );
    };
    proto.tfplugin5.ReadResource.Request.prototype.setTypeName = function(value) {
      return jspb2.Message.setProto3StringField(this, 1, value);
    };
    proto.tfplugin5.ReadResource.Request.prototype.getCurrentState = function() {
      return (
        /** @type{?proto.tfplugin5.DynamicValue} */
        jspb2.Message.getWrapperField(this, proto.tfplugin5.DynamicValue, 2)
      );
    };
    proto.tfplugin5.ReadResource.Request.prototype.setCurrentState = function(value) {
      return jspb2.Message.setWrapperField(this, 2, value);
    };
    proto.tfplugin5.ReadResource.Request.prototype.clearCurrentState = function() {
      return this.setCurrentState(void 0);
    };
    proto.tfplugin5.ReadResource.Request.prototype.hasCurrentState = function() {
      return jspb2.Message.getField(this, 2) != null;
    };
    proto.tfplugin5.ReadResource.Request.prototype.getPrivate = function() {
      return (
        /** @type {!(string|Uint8Array)} */
        jspb2.Message.getFieldWithDefault(this, 3, "")
      );
    };
    proto.tfplugin5.ReadResource.Request.prototype.getPrivate_asB64 = function() {
      return (
        /** @type {string} */
        jspb2.Message.bytesAsB64(
          this.getPrivate()
        )
      );
    };
    proto.tfplugin5.ReadResource.Request.prototype.getPrivate_asU8 = function() {
      return (
        /** @type {!Uint8Array} */
        jspb2.Message.bytesAsU8(
          this.getPrivate()
        )
      );
    };
    proto.tfplugin5.ReadResource.Request.prototype.setPrivate = function(value) {
      return jspb2.Message.setProto3BytesField(this, 3, value);
    };
    proto.tfplugin5.ReadResource.Request.prototype.getProviderMeta = function() {
      return (
        /** @type{?proto.tfplugin5.DynamicValue} */
        jspb2.Message.getWrapperField(this, proto.tfplugin5.DynamicValue, 4)
      );
    };
    proto.tfplugin5.ReadResource.Request.prototype.setProviderMeta = function(value) {
      return jspb2.Message.setWrapperField(this, 4, value);
    };
    proto.tfplugin5.ReadResource.Request.prototype.clearProviderMeta = function() {
      return this.setProviderMeta(void 0);
    };
    proto.tfplugin5.ReadResource.Request.prototype.hasProviderMeta = function() {
      return jspb2.Message.getField(this, 4) != null;
    };
    proto.tfplugin5.ReadResource.Response.repeatedFields_ = [2];
    if (jspb2.Message.GENERATE_TO_OBJECT) {
      proto.tfplugin5.ReadResource.Response.prototype.toObject = function(opt_includeInstance) {
        return proto.tfplugin5.ReadResource.Response.toObject(opt_includeInstance, this);
      };
      proto.tfplugin5.ReadResource.Response.toObject = function(includeInstance, msg) {
        var f2, obj = {
          newState: (f2 = msg.getNewState()) && proto.tfplugin5.DynamicValue.toObject(includeInstance, f2),
          diagnosticsList: jspb2.Message.toObjectList(
            msg.getDiagnosticsList(),
            proto.tfplugin5.Diagnostic.toObject,
            includeInstance
          ),
          pb_private: msg.getPrivate_asB64()
        };
        if (includeInstance) {
          obj.$jspbMessageInstance = msg;
        }
        return obj;
      };
    }
    proto.tfplugin5.ReadResource.Response.deserializeBinary = function(bytes) {
      var reader = new jspb2.BinaryReader(bytes);
      var msg = new proto.tfplugin5.ReadResource.Response();
      return proto.tfplugin5.ReadResource.Response.deserializeBinaryFromReader(msg, reader);
    };
    proto.tfplugin5.ReadResource.Response.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
          case 1:
            var value = new proto.tfplugin5.DynamicValue();
            reader.readMessage(value, proto.tfplugin5.DynamicValue.deserializeBinaryFromReader);
            msg.setNewState(value);
            break;
          case 2:
            var value = new proto.tfplugin5.Diagnostic();
            reader.readMessage(value, proto.tfplugin5.Diagnostic.deserializeBinaryFromReader);
            msg.addDiagnostics(value);
            break;
          case 3:
            var value = (
              /** @type {!Uint8Array} */
              reader.readBytes()
            );
            msg.setPrivate(value);
            break;
          default:
            reader.skipField();
            break;
        }
      }
      return msg;
    };
    proto.tfplugin5.ReadResource.Response.prototype.serializeBinary = function() {
      var writer = new jspb2.BinaryWriter();
      proto.tfplugin5.ReadResource.Response.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };
    proto.tfplugin5.ReadResource.Response.serializeBinaryToWriter = function(message, writer) {
      var f2 = void 0;
      f2 = message.getNewState();
      if (f2 != null) {
        writer.writeMessage(
          1,
          f2,
          proto.tfplugin5.DynamicValue.serializeBinaryToWriter
        );
      }
      f2 = message.getDiagnosticsList();
      if (f2.length > 0) {
        writer.writeRepeatedMessage(
          2,
          f2,
          proto.tfplugin5.Diagnostic.serializeBinaryToWriter
        );
      }
      f2 = message.getPrivate_asU8();
      if (f2.length > 0) {
        writer.writeBytes(
          3,
          f2
        );
      }
    };
    proto.tfplugin5.ReadResource.Response.prototype.getNewState = function() {
      return (
        /** @type{?proto.tfplugin5.DynamicValue} */
        jspb2.Message.getWrapperField(this, proto.tfplugin5.DynamicValue, 1)
      );
    };
    proto.tfplugin5.ReadResource.Response.prototype.setNewState = function(value) {
      return jspb2.Message.setWrapperField(this, 1, value);
    };
    proto.tfplugin5.ReadResource.Response.prototype.clearNewState = function() {
      return this.setNewState(void 0);
    };
    proto.tfplugin5.ReadResource.Response.prototype.hasNewState = function() {
      return jspb2.Message.getField(this, 1) != null;
    };
    proto.tfplugin5.ReadResource.Response.prototype.getDiagnosticsList = function() {
      return (
        /** @type{!Array<!proto.tfplugin5.Diagnostic>} */
        jspb2.Message.getRepeatedWrapperField(this, proto.tfplugin5.Diagnostic, 2)
      );
    };
    proto.tfplugin5.ReadResource.Response.prototype.setDiagnosticsList = function(value) {
      return jspb2.Message.setRepeatedWrapperField(this, 2, value);
    };
    proto.tfplugin5.ReadResource.Response.prototype.addDiagnostics = function(opt_value, opt_index) {
      return jspb2.Message.addToRepeatedWrapperField(this, 2, opt_value, proto.tfplugin5.Diagnostic, opt_index);
    };
    proto.tfplugin5.ReadResource.Response.prototype.clearDiagnosticsList = function() {
      return this.setDiagnosticsList([]);
    };
    proto.tfplugin5.ReadResource.Response.prototype.getPrivate = function() {
      return (
        /** @type {!(string|Uint8Array)} */
        jspb2.Message.getFieldWithDefault(this, 3, "")
      );
    };
    proto.tfplugin5.ReadResource.Response.prototype.getPrivate_asB64 = function() {
      return (
        /** @type {string} */
        jspb2.Message.bytesAsB64(
          this.getPrivate()
        )
      );
    };
    proto.tfplugin5.ReadResource.Response.prototype.getPrivate_asU8 = function() {
      return (
        /** @type {!Uint8Array} */
        jspb2.Message.bytesAsU8(
          this.getPrivate()
        )
      );
    };
    proto.tfplugin5.ReadResource.Response.prototype.setPrivate = function(value) {
      return jspb2.Message.setProto3BytesField(this, 3, value);
    };
    if (jspb2.Message.GENERATE_TO_OBJECT) {
      proto.tfplugin5.PlanResourceChange.prototype.toObject = function(opt_includeInstance) {
        return proto.tfplugin5.PlanResourceChange.toObject(opt_includeInstance, this);
      };
      proto.tfplugin5.PlanResourceChange.toObject = function(includeInstance, msg) {
        var f2, obj = {};
        if (includeInstance) {
          obj.$jspbMessageInstance = msg;
        }
        return obj;
      };
    }
    proto.tfplugin5.PlanResourceChange.deserializeBinary = function(bytes) {
      var reader = new jspb2.BinaryReader(bytes);
      var msg = new proto.tfplugin5.PlanResourceChange();
      return proto.tfplugin5.PlanResourceChange.deserializeBinaryFromReader(msg, reader);
    };
    proto.tfplugin5.PlanResourceChange.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
          default:
            reader.skipField();
            break;
        }
      }
      return msg;
    };
    proto.tfplugin5.PlanResourceChange.prototype.serializeBinary = function() {
      var writer = new jspb2.BinaryWriter();
      proto.tfplugin5.PlanResourceChange.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };
    proto.tfplugin5.PlanResourceChange.serializeBinaryToWriter = function(message, writer) {
      var f2 = void 0;
    };
    if (jspb2.Message.GENERATE_TO_OBJECT) {
      proto.tfplugin5.PlanResourceChange.Request.prototype.toObject = function(opt_includeInstance) {
        return proto.tfplugin5.PlanResourceChange.Request.toObject(opt_includeInstance, this);
      };
      proto.tfplugin5.PlanResourceChange.Request.toObject = function(includeInstance, msg) {
        var f2, obj = {
          typeName: jspb2.Message.getFieldWithDefault(msg, 1, ""),
          priorState: (f2 = msg.getPriorState()) && proto.tfplugin5.DynamicValue.toObject(includeInstance, f2),
          proposedNewState: (f2 = msg.getProposedNewState()) && proto.tfplugin5.DynamicValue.toObject(includeInstance, f2),
          config: (f2 = msg.getConfig()) && proto.tfplugin5.DynamicValue.toObject(includeInstance, f2),
          priorPrivate: msg.getPriorPrivate_asB64(),
          providerMeta: (f2 = msg.getProviderMeta()) && proto.tfplugin5.DynamicValue.toObject(includeInstance, f2)
        };
        if (includeInstance) {
          obj.$jspbMessageInstance = msg;
        }
        return obj;
      };
    }
    proto.tfplugin5.PlanResourceChange.Request.deserializeBinary = function(bytes) {
      var reader = new jspb2.BinaryReader(bytes);
      var msg = new proto.tfplugin5.PlanResourceChange.Request();
      return proto.tfplugin5.PlanResourceChange.Request.deserializeBinaryFromReader(msg, reader);
    };
    proto.tfplugin5.PlanResourceChange.Request.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
          case 1:
            var value = (
              /** @type {string} */
              reader.readString()
            );
            msg.setTypeName(value);
            break;
          case 2:
            var value = new proto.tfplugin5.DynamicValue();
            reader.readMessage(value, proto.tfplugin5.DynamicValue.deserializeBinaryFromReader);
            msg.setPriorState(value);
            break;
          case 3:
            var value = new proto.tfplugin5.DynamicValue();
            reader.readMessage(value, proto.tfplugin5.DynamicValue.deserializeBinaryFromReader);
            msg.setProposedNewState(value);
            break;
          case 4:
            var value = new proto.tfplugin5.DynamicValue();
            reader.readMessage(value, proto.tfplugin5.DynamicValue.deserializeBinaryFromReader);
            msg.setConfig(value);
            break;
          case 5:
            var value = (
              /** @type {!Uint8Array} */
              reader.readBytes()
            );
            msg.setPriorPrivate(value);
            break;
          case 6:
            var value = new proto.tfplugin5.DynamicValue();
            reader.readMessage(value, proto.tfplugin5.DynamicValue.deserializeBinaryFromReader);
            msg.setProviderMeta(value);
            break;
          default:
            reader.skipField();
            break;
        }
      }
      return msg;
    };
    proto.tfplugin5.PlanResourceChange.Request.prototype.serializeBinary = function() {
      var writer = new jspb2.BinaryWriter();
      proto.tfplugin5.PlanResourceChange.Request.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };
    proto.tfplugin5.PlanResourceChange.Request.serializeBinaryToWriter = function(message, writer) {
      var f2 = void 0;
      f2 = message.getTypeName();
      if (f2.length > 0) {
        writer.writeString(
          1,
          f2
        );
      }
      f2 = message.getPriorState();
      if (f2 != null) {
        writer.writeMessage(
          2,
          f2,
          proto.tfplugin5.DynamicValue.serializeBinaryToWriter
        );
      }
      f2 = message.getProposedNewState();
      if (f2 != null) {
        writer.writeMessage(
          3,
          f2,
          proto.tfplugin5.DynamicValue.serializeBinaryToWriter
        );
      }
      f2 = message.getConfig();
      if (f2 != null) {
        writer.writeMessage(
          4,
          f2,
          proto.tfplugin5.DynamicValue.serializeBinaryToWriter
        );
      }
      f2 = message.getPriorPrivate_asU8();
      if (f2.length > 0) {
        writer.writeBytes(
          5,
          f2
        );
      }
      f2 = message.getProviderMeta();
      if (f2 != null) {
        writer.writeMessage(
          6,
          f2,
          proto.tfplugin5.DynamicValue.serializeBinaryToWriter
        );
      }
    };
    proto.tfplugin5.PlanResourceChange.Request.prototype.getTypeName = function() {
      return (
        /** @type {string} */
        jspb2.Message.getFieldWithDefault(this, 1, "")
      );
    };
    proto.tfplugin5.PlanResourceChange.Request.prototype.setTypeName = function(value) {
      return jspb2.Message.setProto3StringField(this, 1, value);
    };
    proto.tfplugin5.PlanResourceChange.Request.prototype.getPriorState = function() {
      return (
        /** @type{?proto.tfplugin5.DynamicValue} */
        jspb2.Message.getWrapperField(this, proto.tfplugin5.DynamicValue, 2)
      );
    };
    proto.tfplugin5.PlanResourceChange.Request.prototype.setPriorState = function(value) {
      return jspb2.Message.setWrapperField(this, 2, value);
    };
    proto.tfplugin5.PlanResourceChange.Request.prototype.clearPriorState = function() {
      return this.setPriorState(void 0);
    };
    proto.tfplugin5.PlanResourceChange.Request.prototype.hasPriorState = function() {
      return jspb2.Message.getField(this, 2) != null;
    };
    proto.tfplugin5.PlanResourceChange.Request.prototype.getProposedNewState = function() {
      return (
        /** @type{?proto.tfplugin5.DynamicValue} */
        jspb2.Message.getWrapperField(this, proto.tfplugin5.DynamicValue, 3)
      );
    };
    proto.tfplugin5.PlanResourceChange.Request.prototype.setProposedNewState = function(value) {
      return jspb2.Message.setWrapperField(this, 3, value);
    };
    proto.tfplugin5.PlanResourceChange.Request.prototype.clearProposedNewState = function() {
      return this.setProposedNewState(void 0);
    };
    proto.tfplugin5.PlanResourceChange.Request.prototype.hasProposedNewState = function() {
      return jspb2.Message.getField(this, 3) != null;
    };
    proto.tfplugin5.PlanResourceChange.Request.prototype.getConfig = function() {
      return (
        /** @type{?proto.tfplugin5.DynamicValue} */
        jspb2.Message.getWrapperField(this, proto.tfplugin5.DynamicValue, 4)
      );
    };
    proto.tfplugin5.PlanResourceChange.Request.prototype.setConfig = function(value) {
      return jspb2.Message.setWrapperField(this, 4, value);
    };
    proto.tfplugin5.PlanResourceChange.Request.prototype.clearConfig = function() {
      return this.setConfig(void 0);
    };
    proto.tfplugin5.PlanResourceChange.Request.prototype.hasConfig = function() {
      return jspb2.Message.getField(this, 4) != null;
    };
    proto.tfplugin5.PlanResourceChange.Request.prototype.getPriorPrivate = function() {
      return (
        /** @type {!(string|Uint8Array)} */
        jspb2.Message.getFieldWithDefault(this, 5, "")
      );
    };
    proto.tfplugin5.PlanResourceChange.Request.prototype.getPriorPrivate_asB64 = function() {
      return (
        /** @type {string} */
        jspb2.Message.bytesAsB64(
          this.getPriorPrivate()
        )
      );
    };
    proto.tfplugin5.PlanResourceChange.Request.prototype.getPriorPrivate_asU8 = function() {
      return (
        /** @type {!Uint8Array} */
        jspb2.Message.bytesAsU8(
          this.getPriorPrivate()
        )
      );
    };
    proto.tfplugin5.PlanResourceChange.Request.prototype.setPriorPrivate = function(value) {
      return jspb2.Message.setProto3BytesField(this, 5, value);
    };
    proto.tfplugin5.PlanResourceChange.Request.prototype.getProviderMeta = function() {
      return (
        /** @type{?proto.tfplugin5.DynamicValue} */
        jspb2.Message.getWrapperField(this, proto.tfplugin5.DynamicValue, 6)
      );
    };
    proto.tfplugin5.PlanResourceChange.Request.prototype.setProviderMeta = function(value) {
      return jspb2.Message.setWrapperField(this, 6, value);
    };
    proto.tfplugin5.PlanResourceChange.Request.prototype.clearProviderMeta = function() {
      return this.setProviderMeta(void 0);
    };
    proto.tfplugin5.PlanResourceChange.Request.prototype.hasProviderMeta = function() {
      return jspb2.Message.getField(this, 6) != null;
    };
    proto.tfplugin5.PlanResourceChange.Response.repeatedFields_ = [2, 4];
    if (jspb2.Message.GENERATE_TO_OBJECT) {
      proto.tfplugin5.PlanResourceChange.Response.prototype.toObject = function(opt_includeInstance) {
        return proto.tfplugin5.PlanResourceChange.Response.toObject(opt_includeInstance, this);
      };
      proto.tfplugin5.PlanResourceChange.Response.toObject = function(includeInstance, msg) {
        var f2, obj = {
          plannedState: (f2 = msg.getPlannedState()) && proto.tfplugin5.DynamicValue.toObject(includeInstance, f2),
          requiresReplaceList: jspb2.Message.toObjectList(
            msg.getRequiresReplaceList(),
            proto.tfplugin5.AttributePath.toObject,
            includeInstance
          ),
          plannedPrivate: msg.getPlannedPrivate_asB64(),
          diagnosticsList: jspb2.Message.toObjectList(
            msg.getDiagnosticsList(),
            proto.tfplugin5.Diagnostic.toObject,
            includeInstance
          ),
          legacyTypeSystem: jspb2.Message.getBooleanFieldWithDefault(msg, 5, false)
        };
        if (includeInstance) {
          obj.$jspbMessageInstance = msg;
        }
        return obj;
      };
    }
    proto.tfplugin5.PlanResourceChange.Response.deserializeBinary = function(bytes) {
      var reader = new jspb2.BinaryReader(bytes);
      var msg = new proto.tfplugin5.PlanResourceChange.Response();
      return proto.tfplugin5.PlanResourceChange.Response.deserializeBinaryFromReader(msg, reader);
    };
    proto.tfplugin5.PlanResourceChange.Response.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
          case 1:
            var value = new proto.tfplugin5.DynamicValue();
            reader.readMessage(value, proto.tfplugin5.DynamicValue.deserializeBinaryFromReader);
            msg.setPlannedState(value);
            break;
          case 2:
            var value = new proto.tfplugin5.AttributePath();
            reader.readMessage(value, proto.tfplugin5.AttributePath.deserializeBinaryFromReader);
            msg.addRequiresReplace(value);
            break;
          case 3:
            var value = (
              /** @type {!Uint8Array} */
              reader.readBytes()
            );
            msg.setPlannedPrivate(value);
            break;
          case 4:
            var value = new proto.tfplugin5.Diagnostic();
            reader.readMessage(value, proto.tfplugin5.Diagnostic.deserializeBinaryFromReader);
            msg.addDiagnostics(value);
            break;
          case 5:
            var value = (
              /** @type {boolean} */
              reader.readBool()
            );
            msg.setLegacyTypeSystem(value);
            break;
          default:
            reader.skipField();
            break;
        }
      }
      return msg;
    };
    proto.tfplugin5.PlanResourceChange.Response.prototype.serializeBinary = function() {
      var writer = new jspb2.BinaryWriter();
      proto.tfplugin5.PlanResourceChange.Response.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };
    proto.tfplugin5.PlanResourceChange.Response.serializeBinaryToWriter = function(message, writer) {
      var f2 = void 0;
      f2 = message.getPlannedState();
      if (f2 != null) {
        writer.writeMessage(
          1,
          f2,
          proto.tfplugin5.DynamicValue.serializeBinaryToWriter
        );
      }
      f2 = message.getRequiresReplaceList();
      if (f2.length > 0) {
        writer.writeRepeatedMessage(
          2,
          f2,
          proto.tfplugin5.AttributePath.serializeBinaryToWriter
        );
      }
      f2 = message.getPlannedPrivate_asU8();
      if (f2.length > 0) {
        writer.writeBytes(
          3,
          f2
        );
      }
      f2 = message.getDiagnosticsList();
      if (f2.length > 0) {
        writer.writeRepeatedMessage(
          4,
          f2,
          proto.tfplugin5.Diagnostic.serializeBinaryToWriter
        );
      }
      f2 = message.getLegacyTypeSystem();
      if (f2) {
        writer.writeBool(
          5,
          f2
        );
      }
    };
    proto.tfplugin5.PlanResourceChange.Response.prototype.getPlannedState = function() {
      return (
        /** @type{?proto.tfplugin5.DynamicValue} */
        jspb2.Message.getWrapperField(this, proto.tfplugin5.DynamicValue, 1)
      );
    };
    proto.tfplugin5.PlanResourceChange.Response.prototype.setPlannedState = function(value) {
      return jspb2.Message.setWrapperField(this, 1, value);
    };
    proto.tfplugin5.PlanResourceChange.Response.prototype.clearPlannedState = function() {
      return this.setPlannedState(void 0);
    };
    proto.tfplugin5.PlanResourceChange.Response.prototype.hasPlannedState = function() {
      return jspb2.Message.getField(this, 1) != null;
    };
    proto.tfplugin5.PlanResourceChange.Response.prototype.getRequiresReplaceList = function() {
      return (
        /** @type{!Array<!proto.tfplugin5.AttributePath>} */
        jspb2.Message.getRepeatedWrapperField(this, proto.tfplugin5.AttributePath, 2)
      );
    };
    proto.tfplugin5.PlanResourceChange.Response.prototype.setRequiresReplaceList = function(value) {
      return jspb2.Message.setRepeatedWrapperField(this, 2, value);
    };
    proto.tfplugin5.PlanResourceChange.Response.prototype.addRequiresReplace = function(opt_value, opt_index) {
      return jspb2.Message.addToRepeatedWrapperField(this, 2, opt_value, proto.tfplugin5.AttributePath, opt_index);
    };
    proto.tfplugin5.PlanResourceChange.Response.prototype.clearRequiresReplaceList = function() {
      return this.setRequiresReplaceList([]);
    };
    proto.tfplugin5.PlanResourceChange.Response.prototype.getPlannedPrivate = function() {
      return (
        /** @type {!(string|Uint8Array)} */
        jspb2.Message.getFieldWithDefault(this, 3, "")
      );
    };
    proto.tfplugin5.PlanResourceChange.Response.prototype.getPlannedPrivate_asB64 = function() {
      return (
        /** @type {string} */
        jspb2.Message.bytesAsB64(
          this.getPlannedPrivate()
        )
      );
    };
    proto.tfplugin5.PlanResourceChange.Response.prototype.getPlannedPrivate_asU8 = function() {
      return (
        /** @type {!Uint8Array} */
        jspb2.Message.bytesAsU8(
          this.getPlannedPrivate()
        )
      );
    };
    proto.tfplugin5.PlanResourceChange.Response.prototype.setPlannedPrivate = function(value) {
      return jspb2.Message.setProto3BytesField(this, 3, value);
    };
    proto.tfplugin5.PlanResourceChange.Response.prototype.getDiagnosticsList = function() {
      return (
        /** @type{!Array<!proto.tfplugin5.Diagnostic>} */
        jspb2.Message.getRepeatedWrapperField(this, proto.tfplugin5.Diagnostic, 4)
      );
    };
    proto.tfplugin5.PlanResourceChange.Response.prototype.setDiagnosticsList = function(value) {
      return jspb2.Message.setRepeatedWrapperField(this, 4, value);
    };
    proto.tfplugin5.PlanResourceChange.Response.prototype.addDiagnostics = function(opt_value, opt_index) {
      return jspb2.Message.addToRepeatedWrapperField(this, 4, opt_value, proto.tfplugin5.Diagnostic, opt_index);
    };
    proto.tfplugin5.PlanResourceChange.Response.prototype.clearDiagnosticsList = function() {
      return this.setDiagnosticsList([]);
    };
    proto.tfplugin5.PlanResourceChange.Response.prototype.getLegacyTypeSystem = function() {
      return (
        /** @type {boolean} */
        jspb2.Message.getBooleanFieldWithDefault(this, 5, false)
      );
    };
    proto.tfplugin5.PlanResourceChange.Response.prototype.setLegacyTypeSystem = function(value) {
      return jspb2.Message.setProto3BooleanField(this, 5, value);
    };
    if (jspb2.Message.GENERATE_TO_OBJECT) {
      proto.tfplugin5.ApplyResourceChange.prototype.toObject = function(opt_includeInstance) {
        return proto.tfplugin5.ApplyResourceChange.toObject(opt_includeInstance, this);
      };
      proto.tfplugin5.ApplyResourceChange.toObject = function(includeInstance, msg) {
        var f2, obj = {};
        if (includeInstance) {
          obj.$jspbMessageInstance = msg;
        }
        return obj;
      };
    }
    proto.tfplugin5.ApplyResourceChange.deserializeBinary = function(bytes) {
      var reader = new jspb2.BinaryReader(bytes);
      var msg = new proto.tfplugin5.ApplyResourceChange();
      return proto.tfplugin5.ApplyResourceChange.deserializeBinaryFromReader(msg, reader);
    };
    proto.tfplugin5.ApplyResourceChange.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
          default:
            reader.skipField();
            break;
        }
      }
      return msg;
    };
    proto.tfplugin5.ApplyResourceChange.prototype.serializeBinary = function() {
      var writer = new jspb2.BinaryWriter();
      proto.tfplugin5.ApplyResourceChange.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };
    proto.tfplugin5.ApplyResourceChange.serializeBinaryToWriter = function(message, writer) {
      var f2 = void 0;
    };
    if (jspb2.Message.GENERATE_TO_OBJECT) {
      proto.tfplugin5.ApplyResourceChange.Request.prototype.toObject = function(opt_includeInstance) {
        return proto.tfplugin5.ApplyResourceChange.Request.toObject(opt_includeInstance, this);
      };
      proto.tfplugin5.ApplyResourceChange.Request.toObject = function(includeInstance, msg) {
        var f2, obj = {
          typeName: jspb2.Message.getFieldWithDefault(msg, 1, ""),
          priorState: (f2 = msg.getPriorState()) && proto.tfplugin5.DynamicValue.toObject(includeInstance, f2),
          plannedState: (f2 = msg.getPlannedState()) && proto.tfplugin5.DynamicValue.toObject(includeInstance, f2),
          config: (f2 = msg.getConfig()) && proto.tfplugin5.DynamicValue.toObject(includeInstance, f2),
          plannedPrivate: msg.getPlannedPrivate_asB64(),
          providerMeta: (f2 = msg.getProviderMeta()) && proto.tfplugin5.DynamicValue.toObject(includeInstance, f2)
        };
        if (includeInstance) {
          obj.$jspbMessageInstance = msg;
        }
        return obj;
      };
    }
    proto.tfplugin5.ApplyResourceChange.Request.deserializeBinary = function(bytes) {
      var reader = new jspb2.BinaryReader(bytes);
      var msg = new proto.tfplugin5.ApplyResourceChange.Request();
      return proto.tfplugin5.ApplyResourceChange.Request.deserializeBinaryFromReader(msg, reader);
    };
    proto.tfplugin5.ApplyResourceChange.Request.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
          case 1:
            var value = (
              /** @type {string} */
              reader.readString()
            );
            msg.setTypeName(value);
            break;
          case 2:
            var value = new proto.tfplugin5.DynamicValue();
            reader.readMessage(value, proto.tfplugin5.DynamicValue.deserializeBinaryFromReader);
            msg.setPriorState(value);
            break;
          case 3:
            var value = new proto.tfplugin5.DynamicValue();
            reader.readMessage(value, proto.tfplugin5.DynamicValue.deserializeBinaryFromReader);
            msg.setPlannedState(value);
            break;
          case 4:
            var value = new proto.tfplugin5.DynamicValue();
            reader.readMessage(value, proto.tfplugin5.DynamicValue.deserializeBinaryFromReader);
            msg.setConfig(value);
            break;
          case 5:
            var value = (
              /** @type {!Uint8Array} */
              reader.readBytes()
            );
            msg.setPlannedPrivate(value);
            break;
          case 6:
            var value = new proto.tfplugin5.DynamicValue();
            reader.readMessage(value, proto.tfplugin5.DynamicValue.deserializeBinaryFromReader);
            msg.setProviderMeta(value);
            break;
          default:
            reader.skipField();
            break;
        }
      }
      return msg;
    };
    proto.tfplugin5.ApplyResourceChange.Request.prototype.serializeBinary = function() {
      var writer = new jspb2.BinaryWriter();
      proto.tfplugin5.ApplyResourceChange.Request.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };
    proto.tfplugin5.ApplyResourceChange.Request.serializeBinaryToWriter = function(message, writer) {
      var f2 = void 0;
      f2 = message.getTypeName();
      if (f2.length > 0) {
        writer.writeString(
          1,
          f2
        );
      }
      f2 = message.getPriorState();
      if (f2 != null) {
        writer.writeMessage(
          2,
          f2,
          proto.tfplugin5.DynamicValue.serializeBinaryToWriter
        );
      }
      f2 = message.getPlannedState();
      if (f2 != null) {
        writer.writeMessage(
          3,
          f2,
          proto.tfplugin5.DynamicValue.serializeBinaryToWriter
        );
      }
      f2 = message.getConfig();
      if (f2 != null) {
        writer.writeMessage(
          4,
          f2,
          proto.tfplugin5.DynamicValue.serializeBinaryToWriter
        );
      }
      f2 = message.getPlannedPrivate_asU8();
      if (f2.length > 0) {
        writer.writeBytes(
          5,
          f2
        );
      }
      f2 = message.getProviderMeta();
      if (f2 != null) {
        writer.writeMessage(
          6,
          f2,
          proto.tfplugin5.DynamicValue.serializeBinaryToWriter
        );
      }
    };
    proto.tfplugin5.ApplyResourceChange.Request.prototype.getTypeName = function() {
      return (
        /** @type {string} */
        jspb2.Message.getFieldWithDefault(this, 1, "")
      );
    };
    proto.tfplugin5.ApplyResourceChange.Request.prototype.setTypeName = function(value) {
      return jspb2.Message.setProto3StringField(this, 1, value);
    };
    proto.tfplugin5.ApplyResourceChange.Request.prototype.getPriorState = function() {
      return (
        /** @type{?proto.tfplugin5.DynamicValue} */
        jspb2.Message.getWrapperField(this, proto.tfplugin5.DynamicValue, 2)
      );
    };
    proto.tfplugin5.ApplyResourceChange.Request.prototype.setPriorState = function(value) {
      return jspb2.Message.setWrapperField(this, 2, value);
    };
    proto.tfplugin5.ApplyResourceChange.Request.prototype.clearPriorState = function() {
      return this.setPriorState(void 0);
    };
    proto.tfplugin5.ApplyResourceChange.Request.prototype.hasPriorState = function() {
      return jspb2.Message.getField(this, 2) != null;
    };
    proto.tfplugin5.ApplyResourceChange.Request.prototype.getPlannedState = function() {
      return (
        /** @type{?proto.tfplugin5.DynamicValue} */
        jspb2.Message.getWrapperField(this, proto.tfplugin5.DynamicValue, 3)
      );
    };
    proto.tfplugin5.ApplyResourceChange.Request.prototype.setPlannedState = function(value) {
      return jspb2.Message.setWrapperField(this, 3, value);
    };
    proto.tfplugin5.ApplyResourceChange.Request.prototype.clearPlannedState = function() {
      return this.setPlannedState(void 0);
    };
    proto.tfplugin5.ApplyResourceChange.Request.prototype.hasPlannedState = function() {
      return jspb2.Message.getField(this, 3) != null;
    };
    proto.tfplugin5.ApplyResourceChange.Request.prototype.getConfig = function() {
      return (
        /** @type{?proto.tfplugin5.DynamicValue} */
        jspb2.Message.getWrapperField(this, proto.tfplugin5.DynamicValue, 4)
      );
    };
    proto.tfplugin5.ApplyResourceChange.Request.prototype.setConfig = function(value) {
      return jspb2.Message.setWrapperField(this, 4, value);
    };
    proto.tfplugin5.ApplyResourceChange.Request.prototype.clearConfig = function() {
      return this.setConfig(void 0);
    };
    proto.tfplugin5.ApplyResourceChange.Request.prototype.hasConfig = function() {
      return jspb2.Message.getField(this, 4) != null;
    };
    proto.tfplugin5.ApplyResourceChange.Request.prototype.getPlannedPrivate = function() {
      return (
        /** @type {!(string|Uint8Array)} */
        jspb2.Message.getFieldWithDefault(this, 5, "")
      );
    };
    proto.tfplugin5.ApplyResourceChange.Request.prototype.getPlannedPrivate_asB64 = function() {
      return (
        /** @type {string} */
        jspb2.Message.bytesAsB64(
          this.getPlannedPrivate()
        )
      );
    };
    proto.tfplugin5.ApplyResourceChange.Request.prototype.getPlannedPrivate_asU8 = function() {
      return (
        /** @type {!Uint8Array} */
        jspb2.Message.bytesAsU8(
          this.getPlannedPrivate()
        )
      );
    };
    proto.tfplugin5.ApplyResourceChange.Request.prototype.setPlannedPrivate = function(value) {
      return jspb2.Message.setProto3BytesField(this, 5, value);
    };
    proto.tfplugin5.ApplyResourceChange.Request.prototype.getProviderMeta = function() {
      return (
        /** @type{?proto.tfplugin5.DynamicValue} */
        jspb2.Message.getWrapperField(this, proto.tfplugin5.DynamicValue, 6)
      );
    };
    proto.tfplugin5.ApplyResourceChange.Request.prototype.setProviderMeta = function(value) {
      return jspb2.Message.setWrapperField(this, 6, value);
    };
    proto.tfplugin5.ApplyResourceChange.Request.prototype.clearProviderMeta = function() {
      return this.setProviderMeta(void 0);
    };
    proto.tfplugin5.ApplyResourceChange.Request.prototype.hasProviderMeta = function() {
      return jspb2.Message.getField(this, 6) != null;
    };
    proto.tfplugin5.ApplyResourceChange.Response.repeatedFields_ = [3];
    if (jspb2.Message.GENERATE_TO_OBJECT) {
      proto.tfplugin5.ApplyResourceChange.Response.prototype.toObject = function(opt_includeInstance) {
        return proto.tfplugin5.ApplyResourceChange.Response.toObject(opt_includeInstance, this);
      };
      proto.tfplugin5.ApplyResourceChange.Response.toObject = function(includeInstance, msg) {
        var f2, obj = {
          newState: (f2 = msg.getNewState()) && proto.tfplugin5.DynamicValue.toObject(includeInstance, f2),
          pb_private: msg.getPrivate_asB64(),
          diagnosticsList: jspb2.Message.toObjectList(
            msg.getDiagnosticsList(),
            proto.tfplugin5.Diagnostic.toObject,
            includeInstance
          ),
          legacyTypeSystem: jspb2.Message.getBooleanFieldWithDefault(msg, 4, false)
        };
        if (includeInstance) {
          obj.$jspbMessageInstance = msg;
        }
        return obj;
      };
    }
    proto.tfplugin5.ApplyResourceChange.Response.deserializeBinary = function(bytes) {
      var reader = new jspb2.BinaryReader(bytes);
      var msg = new proto.tfplugin5.ApplyResourceChange.Response();
      return proto.tfplugin5.ApplyResourceChange.Response.deserializeBinaryFromReader(msg, reader);
    };
    proto.tfplugin5.ApplyResourceChange.Response.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
          case 1:
            var value = new proto.tfplugin5.DynamicValue();
            reader.readMessage(value, proto.tfplugin5.DynamicValue.deserializeBinaryFromReader);
            msg.setNewState(value);
            break;
          case 2:
            var value = (
              /** @type {!Uint8Array} */
              reader.readBytes()
            );
            msg.setPrivate(value);
            break;
          case 3:
            var value = new proto.tfplugin5.Diagnostic();
            reader.readMessage(value, proto.tfplugin5.Diagnostic.deserializeBinaryFromReader);
            msg.addDiagnostics(value);
            break;
          case 4:
            var value = (
              /** @type {boolean} */
              reader.readBool()
            );
            msg.setLegacyTypeSystem(value);
            break;
          default:
            reader.skipField();
            break;
        }
      }
      return msg;
    };
    proto.tfplugin5.ApplyResourceChange.Response.prototype.serializeBinary = function() {
      var writer = new jspb2.BinaryWriter();
      proto.tfplugin5.ApplyResourceChange.Response.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };
    proto.tfplugin5.ApplyResourceChange.Response.serializeBinaryToWriter = function(message, writer) {
      var f2 = void 0;
      f2 = message.getNewState();
      if (f2 != null) {
        writer.writeMessage(
          1,
          f2,
          proto.tfplugin5.DynamicValue.serializeBinaryToWriter
        );
      }
      f2 = message.getPrivate_asU8();
      if (f2.length > 0) {
        writer.writeBytes(
          2,
          f2
        );
      }
      f2 = message.getDiagnosticsList();
      if (f2.length > 0) {
        writer.writeRepeatedMessage(
          3,
          f2,
          proto.tfplugin5.Diagnostic.serializeBinaryToWriter
        );
      }
      f2 = message.getLegacyTypeSystem();
      if (f2) {
        writer.writeBool(
          4,
          f2
        );
      }
    };
    proto.tfplugin5.ApplyResourceChange.Response.prototype.getNewState = function() {
      return (
        /** @type{?proto.tfplugin5.DynamicValue} */
        jspb2.Message.getWrapperField(this, proto.tfplugin5.DynamicValue, 1)
      );
    };
    proto.tfplugin5.ApplyResourceChange.Response.prototype.setNewState = function(value) {
      return jspb2.Message.setWrapperField(this, 1, value);
    };
    proto.tfplugin5.ApplyResourceChange.Response.prototype.clearNewState = function() {
      return this.setNewState(void 0);
    };
    proto.tfplugin5.ApplyResourceChange.Response.prototype.hasNewState = function() {
      return jspb2.Message.getField(this, 1) != null;
    };
    proto.tfplugin5.ApplyResourceChange.Response.prototype.getPrivate = function() {
      return (
        /** @type {!(string|Uint8Array)} */
        jspb2.Message.getFieldWithDefault(this, 2, "")
      );
    };
    proto.tfplugin5.ApplyResourceChange.Response.prototype.getPrivate_asB64 = function() {
      return (
        /** @type {string} */
        jspb2.Message.bytesAsB64(
          this.getPrivate()
        )
      );
    };
    proto.tfplugin5.ApplyResourceChange.Response.prototype.getPrivate_asU8 = function() {
      return (
        /** @type {!Uint8Array} */
        jspb2.Message.bytesAsU8(
          this.getPrivate()
        )
      );
    };
    proto.tfplugin5.ApplyResourceChange.Response.prototype.setPrivate = function(value) {
      return jspb2.Message.setProto3BytesField(this, 2, value);
    };
    proto.tfplugin5.ApplyResourceChange.Response.prototype.getDiagnosticsList = function() {
      return (
        /** @type{!Array<!proto.tfplugin5.Diagnostic>} */
        jspb2.Message.getRepeatedWrapperField(this, proto.tfplugin5.Diagnostic, 3)
      );
    };
    proto.tfplugin5.ApplyResourceChange.Response.prototype.setDiagnosticsList = function(value) {
      return jspb2.Message.setRepeatedWrapperField(this, 3, value);
    };
    proto.tfplugin5.ApplyResourceChange.Response.prototype.addDiagnostics = function(opt_value, opt_index) {
      return jspb2.Message.addToRepeatedWrapperField(this, 3, opt_value, proto.tfplugin5.Diagnostic, opt_index);
    };
    proto.tfplugin5.ApplyResourceChange.Response.prototype.clearDiagnosticsList = function() {
      return this.setDiagnosticsList([]);
    };
    proto.tfplugin5.ApplyResourceChange.Response.prototype.getLegacyTypeSystem = function() {
      return (
        /** @type {boolean} */
        jspb2.Message.getBooleanFieldWithDefault(this, 4, false)
      );
    };
    proto.tfplugin5.ApplyResourceChange.Response.prototype.setLegacyTypeSystem = function(value) {
      return jspb2.Message.setProto3BooleanField(this, 4, value);
    };
    if (jspb2.Message.GENERATE_TO_OBJECT) {
      proto.tfplugin5.ImportResourceState.prototype.toObject = function(opt_includeInstance) {
        return proto.tfplugin5.ImportResourceState.toObject(opt_includeInstance, this);
      };
      proto.tfplugin5.ImportResourceState.toObject = function(includeInstance, msg) {
        var f2, obj = {};
        if (includeInstance) {
          obj.$jspbMessageInstance = msg;
        }
        return obj;
      };
    }
    proto.tfplugin5.ImportResourceState.deserializeBinary = function(bytes) {
      var reader = new jspb2.BinaryReader(bytes);
      var msg = new proto.tfplugin5.ImportResourceState();
      return proto.tfplugin5.ImportResourceState.deserializeBinaryFromReader(msg, reader);
    };
    proto.tfplugin5.ImportResourceState.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
          default:
            reader.skipField();
            break;
        }
      }
      return msg;
    };
    proto.tfplugin5.ImportResourceState.prototype.serializeBinary = function() {
      var writer = new jspb2.BinaryWriter();
      proto.tfplugin5.ImportResourceState.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };
    proto.tfplugin5.ImportResourceState.serializeBinaryToWriter = function(message, writer) {
      var f2 = void 0;
    };
    if (jspb2.Message.GENERATE_TO_OBJECT) {
      proto.tfplugin5.ImportResourceState.Request.prototype.toObject = function(opt_includeInstance) {
        return proto.tfplugin5.ImportResourceState.Request.toObject(opt_includeInstance, this);
      };
      proto.tfplugin5.ImportResourceState.Request.toObject = function(includeInstance, msg) {
        var f2, obj = {
          typeName: jspb2.Message.getFieldWithDefault(msg, 1, ""),
          id: jspb2.Message.getFieldWithDefault(msg, 2, "")
        };
        if (includeInstance) {
          obj.$jspbMessageInstance = msg;
        }
        return obj;
      };
    }
    proto.tfplugin5.ImportResourceState.Request.deserializeBinary = function(bytes) {
      var reader = new jspb2.BinaryReader(bytes);
      var msg = new proto.tfplugin5.ImportResourceState.Request();
      return proto.tfplugin5.ImportResourceState.Request.deserializeBinaryFromReader(msg, reader);
    };
    proto.tfplugin5.ImportResourceState.Request.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
          case 1:
            var value = (
              /** @type {string} */
              reader.readString()
            );
            msg.setTypeName(value);
            break;
          case 2:
            var value = (
              /** @type {string} */
              reader.readString()
            );
            msg.setId(value);
            break;
          default:
            reader.skipField();
            break;
        }
      }
      return msg;
    };
    proto.tfplugin5.ImportResourceState.Request.prototype.serializeBinary = function() {
      var writer = new jspb2.BinaryWriter();
      proto.tfplugin5.ImportResourceState.Request.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };
    proto.tfplugin5.ImportResourceState.Request.serializeBinaryToWriter = function(message, writer) {
      var f2 = void 0;
      f2 = message.getTypeName();
      if (f2.length > 0) {
        writer.writeString(
          1,
          f2
        );
      }
      f2 = message.getId();
      if (f2.length > 0) {
        writer.writeString(
          2,
          f2
        );
      }
    };
    proto.tfplugin5.ImportResourceState.Request.prototype.getTypeName = function() {
      return (
        /** @type {string} */
        jspb2.Message.getFieldWithDefault(this, 1, "")
      );
    };
    proto.tfplugin5.ImportResourceState.Request.prototype.setTypeName = function(value) {
      return jspb2.Message.setProto3StringField(this, 1, value);
    };
    proto.tfplugin5.ImportResourceState.Request.prototype.getId = function() {
      return (
        /** @type {string} */
        jspb2.Message.getFieldWithDefault(this, 2, "")
      );
    };
    proto.tfplugin5.ImportResourceState.Request.prototype.setId = function(value) {
      return jspb2.Message.setProto3StringField(this, 2, value);
    };
    if (jspb2.Message.GENERATE_TO_OBJECT) {
      proto.tfplugin5.ImportResourceState.ImportedResource.prototype.toObject = function(opt_includeInstance) {
        return proto.tfplugin5.ImportResourceState.ImportedResource.toObject(opt_includeInstance, this);
      };
      proto.tfplugin5.ImportResourceState.ImportedResource.toObject = function(includeInstance, msg) {
        var f2, obj = {
          typeName: jspb2.Message.getFieldWithDefault(msg, 1, ""),
          state: (f2 = msg.getState()) && proto.tfplugin5.DynamicValue.toObject(includeInstance, f2),
          pb_private: msg.getPrivate_asB64()
        };
        if (includeInstance) {
          obj.$jspbMessageInstance = msg;
        }
        return obj;
      };
    }
    proto.tfplugin5.ImportResourceState.ImportedResource.deserializeBinary = function(bytes) {
      var reader = new jspb2.BinaryReader(bytes);
      var msg = new proto.tfplugin5.ImportResourceState.ImportedResource();
      return proto.tfplugin5.ImportResourceState.ImportedResource.deserializeBinaryFromReader(msg, reader);
    };
    proto.tfplugin5.ImportResourceState.ImportedResource.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
          case 1:
            var value = (
              /** @type {string} */
              reader.readString()
            );
            msg.setTypeName(value);
            break;
          case 2:
            var value = new proto.tfplugin5.DynamicValue();
            reader.readMessage(value, proto.tfplugin5.DynamicValue.deserializeBinaryFromReader);
            msg.setState(value);
            break;
          case 3:
            var value = (
              /** @type {!Uint8Array} */
              reader.readBytes()
            );
            msg.setPrivate(value);
            break;
          default:
            reader.skipField();
            break;
        }
      }
      return msg;
    };
    proto.tfplugin5.ImportResourceState.ImportedResource.prototype.serializeBinary = function() {
      var writer = new jspb2.BinaryWriter();
      proto.tfplugin5.ImportResourceState.ImportedResource.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };
    proto.tfplugin5.ImportResourceState.ImportedResource.serializeBinaryToWriter = function(message, writer) {
      var f2 = void 0;
      f2 = message.getTypeName();
      if (f2.length > 0) {
        writer.writeString(
          1,
          f2
        );
      }
      f2 = message.getState();
      if (f2 != null) {
        writer.writeMessage(
          2,
          f2,
          proto.tfplugin5.DynamicValue.serializeBinaryToWriter
        );
      }
      f2 = message.getPrivate_asU8();
      if (f2.length > 0) {
        writer.writeBytes(
          3,
          f2
        );
      }
    };
    proto.tfplugin5.ImportResourceState.ImportedResource.prototype.getTypeName = function() {
      return (
        /** @type {string} */
        jspb2.Message.getFieldWithDefault(this, 1, "")
      );
    };
    proto.tfplugin5.ImportResourceState.ImportedResource.prototype.setTypeName = function(value) {
      return jspb2.Message.setProto3StringField(this, 1, value);
    };
    proto.tfplugin5.ImportResourceState.ImportedResource.prototype.getState = function() {
      return (
        /** @type{?proto.tfplugin5.DynamicValue} */
        jspb2.Message.getWrapperField(this, proto.tfplugin5.DynamicValue, 2)
      );
    };
    proto.tfplugin5.ImportResourceState.ImportedResource.prototype.setState = function(value) {
      return jspb2.Message.setWrapperField(this, 2, value);
    };
    proto.tfplugin5.ImportResourceState.ImportedResource.prototype.clearState = function() {
      return this.setState(void 0);
    };
    proto.tfplugin5.ImportResourceState.ImportedResource.prototype.hasState = function() {
      return jspb2.Message.getField(this, 2) != null;
    };
    proto.tfplugin5.ImportResourceState.ImportedResource.prototype.getPrivate = function() {
      return (
        /** @type {!(string|Uint8Array)} */
        jspb2.Message.getFieldWithDefault(this, 3, "")
      );
    };
    proto.tfplugin5.ImportResourceState.ImportedResource.prototype.getPrivate_asB64 = function() {
      return (
        /** @type {string} */
        jspb2.Message.bytesAsB64(
          this.getPrivate()
        )
      );
    };
    proto.tfplugin5.ImportResourceState.ImportedResource.prototype.getPrivate_asU8 = function() {
      return (
        /** @type {!Uint8Array} */
        jspb2.Message.bytesAsU8(
          this.getPrivate()
        )
      );
    };
    proto.tfplugin5.ImportResourceState.ImportedResource.prototype.setPrivate = function(value) {
      return jspb2.Message.setProto3BytesField(this, 3, value);
    };
    proto.tfplugin5.ImportResourceState.Response.repeatedFields_ = [1, 2];
    if (jspb2.Message.GENERATE_TO_OBJECT) {
      proto.tfplugin5.ImportResourceState.Response.prototype.toObject = function(opt_includeInstance) {
        return proto.tfplugin5.ImportResourceState.Response.toObject(opt_includeInstance, this);
      };
      proto.tfplugin5.ImportResourceState.Response.toObject = function(includeInstance, msg) {
        var f2, obj = {
          importedResourcesList: jspb2.Message.toObjectList(
            msg.getImportedResourcesList(),
            proto.tfplugin5.ImportResourceState.ImportedResource.toObject,
            includeInstance
          ),
          diagnosticsList: jspb2.Message.toObjectList(
            msg.getDiagnosticsList(),
            proto.tfplugin5.Diagnostic.toObject,
            includeInstance
          )
        };
        if (includeInstance) {
          obj.$jspbMessageInstance = msg;
        }
        return obj;
      };
    }
    proto.tfplugin5.ImportResourceState.Response.deserializeBinary = function(bytes) {
      var reader = new jspb2.BinaryReader(bytes);
      var msg = new proto.tfplugin5.ImportResourceState.Response();
      return proto.tfplugin5.ImportResourceState.Response.deserializeBinaryFromReader(msg, reader);
    };
    proto.tfplugin5.ImportResourceState.Response.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
          case 1:
            var value = new proto.tfplugin5.ImportResourceState.ImportedResource();
            reader.readMessage(value, proto.tfplugin5.ImportResourceState.ImportedResource.deserializeBinaryFromReader);
            msg.addImportedResources(value);
            break;
          case 2:
            var value = new proto.tfplugin5.Diagnostic();
            reader.readMessage(value, proto.tfplugin5.Diagnostic.deserializeBinaryFromReader);
            msg.addDiagnostics(value);
            break;
          default:
            reader.skipField();
            break;
        }
      }
      return msg;
    };
    proto.tfplugin5.ImportResourceState.Response.prototype.serializeBinary = function() {
      var writer = new jspb2.BinaryWriter();
      proto.tfplugin5.ImportResourceState.Response.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };
    proto.tfplugin5.ImportResourceState.Response.serializeBinaryToWriter = function(message, writer) {
      var f2 = void 0;
      f2 = message.getImportedResourcesList();
      if (f2.length > 0) {
        writer.writeRepeatedMessage(
          1,
          f2,
          proto.tfplugin5.ImportResourceState.ImportedResource.serializeBinaryToWriter
        );
      }
      f2 = message.getDiagnosticsList();
      if (f2.length > 0) {
        writer.writeRepeatedMessage(
          2,
          f2,
          proto.tfplugin5.Diagnostic.serializeBinaryToWriter
        );
      }
    };
    proto.tfplugin5.ImportResourceState.Response.prototype.getImportedResourcesList = function() {
      return (
        /** @type{!Array<!proto.tfplugin5.ImportResourceState.ImportedResource>} */
        jspb2.Message.getRepeatedWrapperField(this, proto.tfplugin5.ImportResourceState.ImportedResource, 1)
      );
    };
    proto.tfplugin5.ImportResourceState.Response.prototype.setImportedResourcesList = function(value) {
      return jspb2.Message.setRepeatedWrapperField(this, 1, value);
    };
    proto.tfplugin5.ImportResourceState.Response.prototype.addImportedResources = function(opt_value, opt_index) {
      return jspb2.Message.addToRepeatedWrapperField(this, 1, opt_value, proto.tfplugin5.ImportResourceState.ImportedResource, opt_index);
    };
    proto.tfplugin5.ImportResourceState.Response.prototype.clearImportedResourcesList = function() {
      return this.setImportedResourcesList([]);
    };
    proto.tfplugin5.ImportResourceState.Response.prototype.getDiagnosticsList = function() {
      return (
        /** @type{!Array<!proto.tfplugin5.Diagnostic>} */
        jspb2.Message.getRepeatedWrapperField(this, proto.tfplugin5.Diagnostic, 2)
      );
    };
    proto.tfplugin5.ImportResourceState.Response.prototype.setDiagnosticsList = function(value) {
      return jspb2.Message.setRepeatedWrapperField(this, 2, value);
    };
    proto.tfplugin5.ImportResourceState.Response.prototype.addDiagnostics = function(opt_value, opt_index) {
      return jspb2.Message.addToRepeatedWrapperField(this, 2, opt_value, proto.tfplugin5.Diagnostic, opt_index);
    };
    proto.tfplugin5.ImportResourceState.Response.prototype.clearDiagnosticsList = function() {
      return this.setDiagnosticsList([]);
    };
    if (jspb2.Message.GENERATE_TO_OBJECT) {
      proto.tfplugin5.ReadDataSource.prototype.toObject = function(opt_includeInstance) {
        return proto.tfplugin5.ReadDataSource.toObject(opt_includeInstance, this);
      };
      proto.tfplugin5.ReadDataSource.toObject = function(includeInstance, msg) {
        var f2, obj = {};
        if (includeInstance) {
          obj.$jspbMessageInstance = msg;
        }
        return obj;
      };
    }
    proto.tfplugin5.ReadDataSource.deserializeBinary = function(bytes) {
      var reader = new jspb2.BinaryReader(bytes);
      var msg = new proto.tfplugin5.ReadDataSource();
      return proto.tfplugin5.ReadDataSource.deserializeBinaryFromReader(msg, reader);
    };
    proto.tfplugin5.ReadDataSource.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
          default:
            reader.skipField();
            break;
        }
      }
      return msg;
    };
    proto.tfplugin5.ReadDataSource.prototype.serializeBinary = function() {
      var writer = new jspb2.BinaryWriter();
      proto.tfplugin5.ReadDataSource.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };
    proto.tfplugin5.ReadDataSource.serializeBinaryToWriter = function(message, writer) {
      var f2 = void 0;
    };
    if (jspb2.Message.GENERATE_TO_OBJECT) {
      proto.tfplugin5.ReadDataSource.Request.prototype.toObject = function(opt_includeInstance) {
        return proto.tfplugin5.ReadDataSource.Request.toObject(opt_includeInstance, this);
      };
      proto.tfplugin5.ReadDataSource.Request.toObject = function(includeInstance, msg) {
        var f2, obj = {
          typeName: jspb2.Message.getFieldWithDefault(msg, 1, ""),
          config: (f2 = msg.getConfig()) && proto.tfplugin5.DynamicValue.toObject(includeInstance, f2),
          providerMeta: (f2 = msg.getProviderMeta()) && proto.tfplugin5.DynamicValue.toObject(includeInstance, f2)
        };
        if (includeInstance) {
          obj.$jspbMessageInstance = msg;
        }
        return obj;
      };
    }
    proto.tfplugin5.ReadDataSource.Request.deserializeBinary = function(bytes) {
      var reader = new jspb2.BinaryReader(bytes);
      var msg = new proto.tfplugin5.ReadDataSource.Request();
      return proto.tfplugin5.ReadDataSource.Request.deserializeBinaryFromReader(msg, reader);
    };
    proto.tfplugin5.ReadDataSource.Request.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
          case 1:
            var value = (
              /** @type {string} */
              reader.readString()
            );
            msg.setTypeName(value);
            break;
          case 2:
            var value = new proto.tfplugin5.DynamicValue();
            reader.readMessage(value, proto.tfplugin5.DynamicValue.deserializeBinaryFromReader);
            msg.setConfig(value);
            break;
          case 3:
            var value = new proto.tfplugin5.DynamicValue();
            reader.readMessage(value, proto.tfplugin5.DynamicValue.deserializeBinaryFromReader);
            msg.setProviderMeta(value);
            break;
          default:
            reader.skipField();
            break;
        }
      }
      return msg;
    };
    proto.tfplugin5.ReadDataSource.Request.prototype.serializeBinary = function() {
      var writer = new jspb2.BinaryWriter();
      proto.tfplugin5.ReadDataSource.Request.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };
    proto.tfplugin5.ReadDataSource.Request.serializeBinaryToWriter = function(message, writer) {
      var f2 = void 0;
      f2 = message.getTypeName();
      if (f2.length > 0) {
        writer.writeString(
          1,
          f2
        );
      }
      f2 = message.getConfig();
      if (f2 != null) {
        writer.writeMessage(
          2,
          f2,
          proto.tfplugin5.DynamicValue.serializeBinaryToWriter
        );
      }
      f2 = message.getProviderMeta();
      if (f2 != null) {
        writer.writeMessage(
          3,
          f2,
          proto.tfplugin5.DynamicValue.serializeBinaryToWriter
        );
      }
    };
    proto.tfplugin5.ReadDataSource.Request.prototype.getTypeName = function() {
      return (
        /** @type {string} */
        jspb2.Message.getFieldWithDefault(this, 1, "")
      );
    };
    proto.tfplugin5.ReadDataSource.Request.prototype.setTypeName = function(value) {
      return jspb2.Message.setProto3StringField(this, 1, value);
    };
    proto.tfplugin5.ReadDataSource.Request.prototype.getConfig = function() {
      return (
        /** @type{?proto.tfplugin5.DynamicValue} */
        jspb2.Message.getWrapperField(this, proto.tfplugin5.DynamicValue, 2)
      );
    };
    proto.tfplugin5.ReadDataSource.Request.prototype.setConfig = function(value) {
      return jspb2.Message.setWrapperField(this, 2, value);
    };
    proto.tfplugin5.ReadDataSource.Request.prototype.clearConfig = function() {
      return this.setConfig(void 0);
    };
    proto.tfplugin5.ReadDataSource.Request.prototype.hasConfig = function() {
      return jspb2.Message.getField(this, 2) != null;
    };
    proto.tfplugin5.ReadDataSource.Request.prototype.getProviderMeta = function() {
      return (
        /** @type{?proto.tfplugin5.DynamicValue} */
        jspb2.Message.getWrapperField(this, proto.tfplugin5.DynamicValue, 3)
      );
    };
    proto.tfplugin5.ReadDataSource.Request.prototype.setProviderMeta = function(value) {
      return jspb2.Message.setWrapperField(this, 3, value);
    };
    proto.tfplugin5.ReadDataSource.Request.prototype.clearProviderMeta = function() {
      return this.setProviderMeta(void 0);
    };
    proto.tfplugin5.ReadDataSource.Request.prototype.hasProviderMeta = function() {
      return jspb2.Message.getField(this, 3) != null;
    };
    proto.tfplugin5.ReadDataSource.Response.repeatedFields_ = [2];
    if (jspb2.Message.GENERATE_TO_OBJECT) {
      proto.tfplugin5.ReadDataSource.Response.prototype.toObject = function(opt_includeInstance) {
        return proto.tfplugin5.ReadDataSource.Response.toObject(opt_includeInstance, this);
      };
      proto.tfplugin5.ReadDataSource.Response.toObject = function(includeInstance, msg) {
        var f2, obj = {
          state: (f2 = msg.getState()) && proto.tfplugin5.DynamicValue.toObject(includeInstance, f2),
          diagnosticsList: jspb2.Message.toObjectList(
            msg.getDiagnosticsList(),
            proto.tfplugin5.Diagnostic.toObject,
            includeInstance
          )
        };
        if (includeInstance) {
          obj.$jspbMessageInstance = msg;
        }
        return obj;
      };
    }
    proto.tfplugin5.ReadDataSource.Response.deserializeBinary = function(bytes) {
      var reader = new jspb2.BinaryReader(bytes);
      var msg = new proto.tfplugin5.ReadDataSource.Response();
      return proto.tfplugin5.ReadDataSource.Response.deserializeBinaryFromReader(msg, reader);
    };
    proto.tfplugin5.ReadDataSource.Response.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
          case 1:
            var value = new proto.tfplugin5.DynamicValue();
            reader.readMessage(value, proto.tfplugin5.DynamicValue.deserializeBinaryFromReader);
            msg.setState(value);
            break;
          case 2:
            var value = new proto.tfplugin5.Diagnostic();
            reader.readMessage(value, proto.tfplugin5.Diagnostic.deserializeBinaryFromReader);
            msg.addDiagnostics(value);
            break;
          default:
            reader.skipField();
            break;
        }
      }
      return msg;
    };
    proto.tfplugin5.ReadDataSource.Response.prototype.serializeBinary = function() {
      var writer = new jspb2.BinaryWriter();
      proto.tfplugin5.ReadDataSource.Response.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };
    proto.tfplugin5.ReadDataSource.Response.serializeBinaryToWriter = function(message, writer) {
      var f2 = void 0;
      f2 = message.getState();
      if (f2 != null) {
        writer.writeMessage(
          1,
          f2,
          proto.tfplugin5.DynamicValue.serializeBinaryToWriter
        );
      }
      f2 = message.getDiagnosticsList();
      if (f2.length > 0) {
        writer.writeRepeatedMessage(
          2,
          f2,
          proto.tfplugin5.Diagnostic.serializeBinaryToWriter
        );
      }
    };
    proto.tfplugin5.ReadDataSource.Response.prototype.getState = function() {
      return (
        /** @type{?proto.tfplugin5.DynamicValue} */
        jspb2.Message.getWrapperField(this, proto.tfplugin5.DynamicValue, 1)
      );
    };
    proto.tfplugin5.ReadDataSource.Response.prototype.setState = function(value) {
      return jspb2.Message.setWrapperField(this, 1, value);
    };
    proto.tfplugin5.ReadDataSource.Response.prototype.clearState = function() {
      return this.setState(void 0);
    };
    proto.tfplugin5.ReadDataSource.Response.prototype.hasState = function() {
      return jspb2.Message.getField(this, 1) != null;
    };
    proto.tfplugin5.ReadDataSource.Response.prototype.getDiagnosticsList = function() {
      return (
        /** @type{!Array<!proto.tfplugin5.Diagnostic>} */
        jspb2.Message.getRepeatedWrapperField(this, proto.tfplugin5.Diagnostic, 2)
      );
    };
    proto.tfplugin5.ReadDataSource.Response.prototype.setDiagnosticsList = function(value) {
      return jspb2.Message.setRepeatedWrapperField(this, 2, value);
    };
    proto.tfplugin5.ReadDataSource.Response.prototype.addDiagnostics = function(opt_value, opt_index) {
      return jspb2.Message.addToRepeatedWrapperField(this, 2, opt_value, proto.tfplugin5.Diagnostic, opt_index);
    };
    proto.tfplugin5.ReadDataSource.Response.prototype.clearDiagnosticsList = function() {
      return this.setDiagnosticsList([]);
    };
    if (jspb2.Message.GENERATE_TO_OBJECT) {
      proto.tfplugin5.GetProvisionerSchema.prototype.toObject = function(opt_includeInstance) {
        return proto.tfplugin5.GetProvisionerSchema.toObject(opt_includeInstance, this);
      };
      proto.tfplugin5.GetProvisionerSchema.toObject = function(includeInstance, msg) {
        var f2, obj = {};
        if (includeInstance) {
          obj.$jspbMessageInstance = msg;
        }
        return obj;
      };
    }
    proto.tfplugin5.GetProvisionerSchema.deserializeBinary = function(bytes) {
      var reader = new jspb2.BinaryReader(bytes);
      var msg = new proto.tfplugin5.GetProvisionerSchema();
      return proto.tfplugin5.GetProvisionerSchema.deserializeBinaryFromReader(msg, reader);
    };
    proto.tfplugin5.GetProvisionerSchema.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
          default:
            reader.skipField();
            break;
        }
      }
      return msg;
    };
    proto.tfplugin5.GetProvisionerSchema.prototype.serializeBinary = function() {
      var writer = new jspb2.BinaryWriter();
      proto.tfplugin5.GetProvisionerSchema.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };
    proto.tfplugin5.GetProvisionerSchema.serializeBinaryToWriter = function(message, writer) {
      var f2 = void 0;
    };
    if (jspb2.Message.GENERATE_TO_OBJECT) {
      proto.tfplugin5.GetProvisionerSchema.Request.prototype.toObject = function(opt_includeInstance) {
        return proto.tfplugin5.GetProvisionerSchema.Request.toObject(opt_includeInstance, this);
      };
      proto.tfplugin5.GetProvisionerSchema.Request.toObject = function(includeInstance, msg) {
        var f2, obj = {};
        if (includeInstance) {
          obj.$jspbMessageInstance = msg;
        }
        return obj;
      };
    }
    proto.tfplugin5.GetProvisionerSchema.Request.deserializeBinary = function(bytes) {
      var reader = new jspb2.BinaryReader(bytes);
      var msg = new proto.tfplugin5.GetProvisionerSchema.Request();
      return proto.tfplugin5.GetProvisionerSchema.Request.deserializeBinaryFromReader(msg, reader);
    };
    proto.tfplugin5.GetProvisionerSchema.Request.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
          default:
            reader.skipField();
            break;
        }
      }
      return msg;
    };
    proto.tfplugin5.GetProvisionerSchema.Request.prototype.serializeBinary = function() {
      var writer = new jspb2.BinaryWriter();
      proto.tfplugin5.GetProvisionerSchema.Request.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };
    proto.tfplugin5.GetProvisionerSchema.Request.serializeBinaryToWriter = function(message, writer) {
      var f2 = void 0;
    };
    proto.tfplugin5.GetProvisionerSchema.Response.repeatedFields_ = [2];
    if (jspb2.Message.GENERATE_TO_OBJECT) {
      proto.tfplugin5.GetProvisionerSchema.Response.prototype.toObject = function(opt_includeInstance) {
        return proto.tfplugin5.GetProvisionerSchema.Response.toObject(opt_includeInstance, this);
      };
      proto.tfplugin5.GetProvisionerSchema.Response.toObject = function(includeInstance, msg) {
        var f2, obj = {
          provisioner: (f2 = msg.getProvisioner()) && proto.tfplugin5.Schema.toObject(includeInstance, f2),
          diagnosticsList: jspb2.Message.toObjectList(
            msg.getDiagnosticsList(),
            proto.tfplugin5.Diagnostic.toObject,
            includeInstance
          )
        };
        if (includeInstance) {
          obj.$jspbMessageInstance = msg;
        }
        return obj;
      };
    }
    proto.tfplugin5.GetProvisionerSchema.Response.deserializeBinary = function(bytes) {
      var reader = new jspb2.BinaryReader(bytes);
      var msg = new proto.tfplugin5.GetProvisionerSchema.Response();
      return proto.tfplugin5.GetProvisionerSchema.Response.deserializeBinaryFromReader(msg, reader);
    };
    proto.tfplugin5.GetProvisionerSchema.Response.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
          case 1:
            var value = new proto.tfplugin5.Schema();
            reader.readMessage(value, proto.tfplugin5.Schema.deserializeBinaryFromReader);
            msg.setProvisioner(value);
            break;
          case 2:
            var value = new proto.tfplugin5.Diagnostic();
            reader.readMessage(value, proto.tfplugin5.Diagnostic.deserializeBinaryFromReader);
            msg.addDiagnostics(value);
            break;
          default:
            reader.skipField();
            break;
        }
      }
      return msg;
    };
    proto.tfplugin5.GetProvisionerSchema.Response.prototype.serializeBinary = function() {
      var writer = new jspb2.BinaryWriter();
      proto.tfplugin5.GetProvisionerSchema.Response.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };
    proto.tfplugin5.GetProvisionerSchema.Response.serializeBinaryToWriter = function(message, writer) {
      var f2 = void 0;
      f2 = message.getProvisioner();
      if (f2 != null) {
        writer.writeMessage(
          1,
          f2,
          proto.tfplugin5.Schema.serializeBinaryToWriter
        );
      }
      f2 = message.getDiagnosticsList();
      if (f2.length > 0) {
        writer.writeRepeatedMessage(
          2,
          f2,
          proto.tfplugin5.Diagnostic.serializeBinaryToWriter
        );
      }
    };
    proto.tfplugin5.GetProvisionerSchema.Response.prototype.getProvisioner = function() {
      return (
        /** @type{?proto.tfplugin5.Schema} */
        jspb2.Message.getWrapperField(this, proto.tfplugin5.Schema, 1)
      );
    };
    proto.tfplugin5.GetProvisionerSchema.Response.prototype.setProvisioner = function(value) {
      return jspb2.Message.setWrapperField(this, 1, value);
    };
    proto.tfplugin5.GetProvisionerSchema.Response.prototype.clearProvisioner = function() {
      return this.setProvisioner(void 0);
    };
    proto.tfplugin5.GetProvisionerSchema.Response.prototype.hasProvisioner = function() {
      return jspb2.Message.getField(this, 1) != null;
    };
    proto.tfplugin5.GetProvisionerSchema.Response.prototype.getDiagnosticsList = function() {
      return (
        /** @type{!Array<!proto.tfplugin5.Diagnostic>} */
        jspb2.Message.getRepeatedWrapperField(this, proto.tfplugin5.Diagnostic, 2)
      );
    };
    proto.tfplugin5.GetProvisionerSchema.Response.prototype.setDiagnosticsList = function(value) {
      return jspb2.Message.setRepeatedWrapperField(this, 2, value);
    };
    proto.tfplugin5.GetProvisionerSchema.Response.prototype.addDiagnostics = function(opt_value, opt_index) {
      return jspb2.Message.addToRepeatedWrapperField(this, 2, opt_value, proto.tfplugin5.Diagnostic, opt_index);
    };
    proto.tfplugin5.GetProvisionerSchema.Response.prototype.clearDiagnosticsList = function() {
      return this.setDiagnosticsList([]);
    };
    if (jspb2.Message.GENERATE_TO_OBJECT) {
      proto.tfplugin5.ValidateProvisionerConfig.prototype.toObject = function(opt_includeInstance) {
        return proto.tfplugin5.ValidateProvisionerConfig.toObject(opt_includeInstance, this);
      };
      proto.tfplugin5.ValidateProvisionerConfig.toObject = function(includeInstance, msg) {
        var f2, obj = {};
        if (includeInstance) {
          obj.$jspbMessageInstance = msg;
        }
        return obj;
      };
    }
    proto.tfplugin5.ValidateProvisionerConfig.deserializeBinary = function(bytes) {
      var reader = new jspb2.BinaryReader(bytes);
      var msg = new proto.tfplugin5.ValidateProvisionerConfig();
      return proto.tfplugin5.ValidateProvisionerConfig.deserializeBinaryFromReader(msg, reader);
    };
    proto.tfplugin5.ValidateProvisionerConfig.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
          default:
            reader.skipField();
            break;
        }
      }
      return msg;
    };
    proto.tfplugin5.ValidateProvisionerConfig.prototype.serializeBinary = function() {
      var writer = new jspb2.BinaryWriter();
      proto.tfplugin5.ValidateProvisionerConfig.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };
    proto.tfplugin5.ValidateProvisionerConfig.serializeBinaryToWriter = function(message, writer) {
      var f2 = void 0;
    };
    if (jspb2.Message.GENERATE_TO_OBJECT) {
      proto.tfplugin5.ValidateProvisionerConfig.Request.prototype.toObject = function(opt_includeInstance) {
        return proto.tfplugin5.ValidateProvisionerConfig.Request.toObject(opt_includeInstance, this);
      };
      proto.tfplugin5.ValidateProvisionerConfig.Request.toObject = function(includeInstance, msg) {
        var f2, obj = {
          config: (f2 = msg.getConfig()) && proto.tfplugin5.DynamicValue.toObject(includeInstance, f2)
        };
        if (includeInstance) {
          obj.$jspbMessageInstance = msg;
        }
        return obj;
      };
    }
    proto.tfplugin5.ValidateProvisionerConfig.Request.deserializeBinary = function(bytes) {
      var reader = new jspb2.BinaryReader(bytes);
      var msg = new proto.tfplugin5.ValidateProvisionerConfig.Request();
      return proto.tfplugin5.ValidateProvisionerConfig.Request.deserializeBinaryFromReader(msg, reader);
    };
    proto.tfplugin5.ValidateProvisionerConfig.Request.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
          case 1:
            var value = new proto.tfplugin5.DynamicValue();
            reader.readMessage(value, proto.tfplugin5.DynamicValue.deserializeBinaryFromReader);
            msg.setConfig(value);
            break;
          default:
            reader.skipField();
            break;
        }
      }
      return msg;
    };
    proto.tfplugin5.ValidateProvisionerConfig.Request.prototype.serializeBinary = function() {
      var writer = new jspb2.BinaryWriter();
      proto.tfplugin5.ValidateProvisionerConfig.Request.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };
    proto.tfplugin5.ValidateProvisionerConfig.Request.serializeBinaryToWriter = function(message, writer) {
      var f2 = void 0;
      f2 = message.getConfig();
      if (f2 != null) {
        writer.writeMessage(
          1,
          f2,
          proto.tfplugin5.DynamicValue.serializeBinaryToWriter
        );
      }
    };
    proto.tfplugin5.ValidateProvisionerConfig.Request.prototype.getConfig = function() {
      return (
        /** @type{?proto.tfplugin5.DynamicValue} */
        jspb2.Message.getWrapperField(this, proto.tfplugin5.DynamicValue, 1)
      );
    };
    proto.tfplugin5.ValidateProvisionerConfig.Request.prototype.setConfig = function(value) {
      return jspb2.Message.setWrapperField(this, 1, value);
    };
    proto.tfplugin5.ValidateProvisionerConfig.Request.prototype.clearConfig = function() {
      return this.setConfig(void 0);
    };
    proto.tfplugin5.ValidateProvisionerConfig.Request.prototype.hasConfig = function() {
      return jspb2.Message.getField(this, 1) != null;
    };
    proto.tfplugin5.ValidateProvisionerConfig.Response.repeatedFields_ = [1];
    if (jspb2.Message.GENERATE_TO_OBJECT) {
      proto.tfplugin5.ValidateProvisionerConfig.Response.prototype.toObject = function(opt_includeInstance) {
        return proto.tfplugin5.ValidateProvisionerConfig.Response.toObject(opt_includeInstance, this);
      };
      proto.tfplugin5.ValidateProvisionerConfig.Response.toObject = function(includeInstance, msg) {
        var f2, obj = {
          diagnosticsList: jspb2.Message.toObjectList(
            msg.getDiagnosticsList(),
            proto.tfplugin5.Diagnostic.toObject,
            includeInstance
          )
        };
        if (includeInstance) {
          obj.$jspbMessageInstance = msg;
        }
        return obj;
      };
    }
    proto.tfplugin5.ValidateProvisionerConfig.Response.deserializeBinary = function(bytes) {
      var reader = new jspb2.BinaryReader(bytes);
      var msg = new proto.tfplugin5.ValidateProvisionerConfig.Response();
      return proto.tfplugin5.ValidateProvisionerConfig.Response.deserializeBinaryFromReader(msg, reader);
    };
    proto.tfplugin5.ValidateProvisionerConfig.Response.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
          case 1:
            var value = new proto.tfplugin5.Diagnostic();
            reader.readMessage(value, proto.tfplugin5.Diagnostic.deserializeBinaryFromReader);
            msg.addDiagnostics(value);
            break;
          default:
            reader.skipField();
            break;
        }
      }
      return msg;
    };
    proto.tfplugin5.ValidateProvisionerConfig.Response.prototype.serializeBinary = function() {
      var writer = new jspb2.BinaryWriter();
      proto.tfplugin5.ValidateProvisionerConfig.Response.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };
    proto.tfplugin5.ValidateProvisionerConfig.Response.serializeBinaryToWriter = function(message, writer) {
      var f2 = void 0;
      f2 = message.getDiagnosticsList();
      if (f2.length > 0) {
        writer.writeRepeatedMessage(
          1,
          f2,
          proto.tfplugin5.Diagnostic.serializeBinaryToWriter
        );
      }
    };
    proto.tfplugin5.ValidateProvisionerConfig.Response.prototype.getDiagnosticsList = function() {
      return (
        /** @type{!Array<!proto.tfplugin5.Diagnostic>} */
        jspb2.Message.getRepeatedWrapperField(this, proto.tfplugin5.Diagnostic, 1)
      );
    };
    proto.tfplugin5.ValidateProvisionerConfig.Response.prototype.setDiagnosticsList = function(value) {
      return jspb2.Message.setRepeatedWrapperField(this, 1, value);
    };
    proto.tfplugin5.ValidateProvisionerConfig.Response.prototype.addDiagnostics = function(opt_value, opt_index) {
      return jspb2.Message.addToRepeatedWrapperField(this, 1, opt_value, proto.tfplugin5.Diagnostic, opt_index);
    };
    proto.tfplugin5.ValidateProvisionerConfig.Response.prototype.clearDiagnosticsList = function() {
      return this.setDiagnosticsList([]);
    };
    if (jspb2.Message.GENERATE_TO_OBJECT) {
      proto.tfplugin5.ProvisionResource.prototype.toObject = function(opt_includeInstance) {
        return proto.tfplugin5.ProvisionResource.toObject(opt_includeInstance, this);
      };
      proto.tfplugin5.ProvisionResource.toObject = function(includeInstance, msg) {
        var f2, obj = {};
        if (includeInstance) {
          obj.$jspbMessageInstance = msg;
        }
        return obj;
      };
    }
    proto.tfplugin5.ProvisionResource.deserializeBinary = function(bytes) {
      var reader = new jspb2.BinaryReader(bytes);
      var msg = new proto.tfplugin5.ProvisionResource();
      return proto.tfplugin5.ProvisionResource.deserializeBinaryFromReader(msg, reader);
    };
    proto.tfplugin5.ProvisionResource.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
          default:
            reader.skipField();
            break;
        }
      }
      return msg;
    };
    proto.tfplugin5.ProvisionResource.prototype.serializeBinary = function() {
      var writer = new jspb2.BinaryWriter();
      proto.tfplugin5.ProvisionResource.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };
    proto.tfplugin5.ProvisionResource.serializeBinaryToWriter = function(message, writer) {
      var f2 = void 0;
    };
    if (jspb2.Message.GENERATE_TO_OBJECT) {
      proto.tfplugin5.ProvisionResource.Request.prototype.toObject = function(opt_includeInstance) {
        return proto.tfplugin5.ProvisionResource.Request.toObject(opt_includeInstance, this);
      };
      proto.tfplugin5.ProvisionResource.Request.toObject = function(includeInstance, msg) {
        var f2, obj = {
          config: (f2 = msg.getConfig()) && proto.tfplugin5.DynamicValue.toObject(includeInstance, f2),
          connection: (f2 = msg.getConnection()) && proto.tfplugin5.DynamicValue.toObject(includeInstance, f2)
        };
        if (includeInstance) {
          obj.$jspbMessageInstance = msg;
        }
        return obj;
      };
    }
    proto.tfplugin5.ProvisionResource.Request.deserializeBinary = function(bytes) {
      var reader = new jspb2.BinaryReader(bytes);
      var msg = new proto.tfplugin5.ProvisionResource.Request();
      return proto.tfplugin5.ProvisionResource.Request.deserializeBinaryFromReader(msg, reader);
    };
    proto.tfplugin5.ProvisionResource.Request.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
          case 1:
            var value = new proto.tfplugin5.DynamicValue();
            reader.readMessage(value, proto.tfplugin5.DynamicValue.deserializeBinaryFromReader);
            msg.setConfig(value);
            break;
          case 2:
            var value = new proto.tfplugin5.DynamicValue();
            reader.readMessage(value, proto.tfplugin5.DynamicValue.deserializeBinaryFromReader);
            msg.setConnection(value);
            break;
          default:
            reader.skipField();
            break;
        }
      }
      return msg;
    };
    proto.tfplugin5.ProvisionResource.Request.prototype.serializeBinary = function() {
      var writer = new jspb2.BinaryWriter();
      proto.tfplugin5.ProvisionResource.Request.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };
    proto.tfplugin5.ProvisionResource.Request.serializeBinaryToWriter = function(message, writer) {
      var f2 = void 0;
      f2 = message.getConfig();
      if (f2 != null) {
        writer.writeMessage(
          1,
          f2,
          proto.tfplugin5.DynamicValue.serializeBinaryToWriter
        );
      }
      f2 = message.getConnection();
      if (f2 != null) {
        writer.writeMessage(
          2,
          f2,
          proto.tfplugin5.DynamicValue.serializeBinaryToWriter
        );
      }
    };
    proto.tfplugin5.ProvisionResource.Request.prototype.getConfig = function() {
      return (
        /** @type{?proto.tfplugin5.DynamicValue} */
        jspb2.Message.getWrapperField(this, proto.tfplugin5.DynamicValue, 1)
      );
    };
    proto.tfplugin5.ProvisionResource.Request.prototype.setConfig = function(value) {
      return jspb2.Message.setWrapperField(this, 1, value);
    };
    proto.tfplugin5.ProvisionResource.Request.prototype.clearConfig = function() {
      return this.setConfig(void 0);
    };
    proto.tfplugin5.ProvisionResource.Request.prototype.hasConfig = function() {
      return jspb2.Message.getField(this, 1) != null;
    };
    proto.tfplugin5.ProvisionResource.Request.prototype.getConnection = function() {
      return (
        /** @type{?proto.tfplugin5.DynamicValue} */
        jspb2.Message.getWrapperField(this, proto.tfplugin5.DynamicValue, 2)
      );
    };
    proto.tfplugin5.ProvisionResource.Request.prototype.setConnection = function(value) {
      return jspb2.Message.setWrapperField(this, 2, value);
    };
    proto.tfplugin5.ProvisionResource.Request.prototype.clearConnection = function() {
      return this.setConnection(void 0);
    };
    proto.tfplugin5.ProvisionResource.Request.prototype.hasConnection = function() {
      return jspb2.Message.getField(this, 2) != null;
    };
    proto.tfplugin5.ProvisionResource.Response.repeatedFields_ = [2];
    if (jspb2.Message.GENERATE_TO_OBJECT) {
      proto.tfplugin5.ProvisionResource.Response.prototype.toObject = function(opt_includeInstance) {
        return proto.tfplugin5.ProvisionResource.Response.toObject(opt_includeInstance, this);
      };
      proto.tfplugin5.ProvisionResource.Response.toObject = function(includeInstance, msg) {
        var f2, obj = {
          output: jspb2.Message.getFieldWithDefault(msg, 1, ""),
          diagnosticsList: jspb2.Message.toObjectList(
            msg.getDiagnosticsList(),
            proto.tfplugin5.Diagnostic.toObject,
            includeInstance
          )
        };
        if (includeInstance) {
          obj.$jspbMessageInstance = msg;
        }
        return obj;
      };
    }
    proto.tfplugin5.ProvisionResource.Response.deserializeBinary = function(bytes) {
      var reader = new jspb2.BinaryReader(bytes);
      var msg = new proto.tfplugin5.ProvisionResource.Response();
      return proto.tfplugin5.ProvisionResource.Response.deserializeBinaryFromReader(msg, reader);
    };
    proto.tfplugin5.ProvisionResource.Response.deserializeBinaryFromReader = function(msg, reader) {
      while (reader.nextField()) {
        if (reader.isEndGroup()) {
          break;
        }
        var field = reader.getFieldNumber();
        switch (field) {
          case 1:
            var value = (
              /** @type {string} */
              reader.readString()
            );
            msg.setOutput(value);
            break;
          case 2:
            var value = new proto.tfplugin5.Diagnostic();
            reader.readMessage(value, proto.tfplugin5.Diagnostic.deserializeBinaryFromReader);
            msg.addDiagnostics(value);
            break;
          default:
            reader.skipField();
            break;
        }
      }
      return msg;
    };
    proto.tfplugin5.ProvisionResource.Response.prototype.serializeBinary = function() {
      var writer = new jspb2.BinaryWriter();
      proto.tfplugin5.ProvisionResource.Response.serializeBinaryToWriter(this, writer);
      return writer.getResultBuffer();
    };
    proto.tfplugin5.ProvisionResource.Response.serializeBinaryToWriter = function(message, writer) {
      var f2 = void 0;
      f2 = message.getOutput();
      if (f2.length > 0) {
        writer.writeString(
          1,
          f2
        );
      }
      f2 = message.getDiagnosticsList();
      if (f2.length > 0) {
        writer.writeRepeatedMessage(
          2,
          f2,
          proto.tfplugin5.Diagnostic.serializeBinaryToWriter
        );
      }
    };
    proto.tfplugin5.ProvisionResource.Response.prototype.getOutput = function() {
      return (
        /** @type {string} */
        jspb2.Message.getFieldWithDefault(this, 1, "")
      );
    };
    proto.tfplugin5.ProvisionResource.Response.prototype.setOutput = function(value) {
      return jspb2.Message.setProto3StringField(this, 1, value);
    };
    proto.tfplugin5.ProvisionResource.Response.prototype.getDiagnosticsList = function() {
      return (
        /** @type{!Array<!proto.tfplugin5.Diagnostic>} */
        jspb2.Message.getRepeatedWrapperField(this, proto.tfplugin5.Diagnostic, 2)
      );
    };
    proto.tfplugin5.ProvisionResource.Response.prototype.setDiagnosticsList = function(value) {
      return jspb2.Message.setRepeatedWrapperField(this, 2, value);
    };
    proto.tfplugin5.ProvisionResource.Response.prototype.addDiagnostics = function(opt_value, opt_index) {
      return jspb2.Message.addToRepeatedWrapperField(this, 2, opt_value, proto.tfplugin5.Diagnostic, opt_index);
    };
    proto.tfplugin5.ProvisionResource.Response.prototype.clearDiagnosticsList = function() {
      return this.setDiagnosticsList([]);
    };
    proto.tfplugin5.StringKind = {
      PLAIN: 0,
      MARKDOWN: 1
    };
    goog2.object.extend(exports2, proto.tfplugin5);
  }
});

// node_modules/@grpc/grpc-js/build/src/constants.js
var require_constants = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/constants.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DEFAULT_MAX_RECEIVE_MESSAGE_LENGTH = exports2.DEFAULT_MAX_SEND_MESSAGE_LENGTH = exports2.Propagate = exports2.LogVerbosity = exports2.Status = void 0;
    var Status;
    (function(Status2) {
      Status2[Status2["OK"] = 0] = "OK";
      Status2[Status2["CANCELLED"] = 1] = "CANCELLED";
      Status2[Status2["UNKNOWN"] = 2] = "UNKNOWN";
      Status2[Status2["INVALID_ARGUMENT"] = 3] = "INVALID_ARGUMENT";
      Status2[Status2["DEADLINE_EXCEEDED"] = 4] = "DEADLINE_EXCEEDED";
      Status2[Status2["NOT_FOUND"] = 5] = "NOT_FOUND";
      Status2[Status2["ALREADY_EXISTS"] = 6] = "ALREADY_EXISTS";
      Status2[Status2["PERMISSION_DENIED"] = 7] = "PERMISSION_DENIED";
      Status2[Status2["RESOURCE_EXHAUSTED"] = 8] = "RESOURCE_EXHAUSTED";
      Status2[Status2["FAILED_PRECONDITION"] = 9] = "FAILED_PRECONDITION";
      Status2[Status2["ABORTED"] = 10] = "ABORTED";
      Status2[Status2["OUT_OF_RANGE"] = 11] = "OUT_OF_RANGE";
      Status2[Status2["UNIMPLEMENTED"] = 12] = "UNIMPLEMENTED";
      Status2[Status2["INTERNAL"] = 13] = "INTERNAL";
      Status2[Status2["UNAVAILABLE"] = 14] = "UNAVAILABLE";
      Status2[Status2["DATA_LOSS"] = 15] = "DATA_LOSS";
      Status2[Status2["UNAUTHENTICATED"] = 16] = "UNAUTHENTICATED";
    })(Status = exports2.Status || (exports2.Status = {}));
    var LogVerbosity;
    (function(LogVerbosity2) {
      LogVerbosity2[LogVerbosity2["DEBUG"] = 0] = "DEBUG";
      LogVerbosity2[LogVerbosity2["INFO"] = 1] = "INFO";
      LogVerbosity2[LogVerbosity2["ERROR"] = 2] = "ERROR";
      LogVerbosity2[LogVerbosity2["NONE"] = 3] = "NONE";
    })(LogVerbosity = exports2.LogVerbosity || (exports2.LogVerbosity = {}));
    var Propagate;
    (function(Propagate2) {
      Propagate2[Propagate2["DEADLINE"] = 1] = "DEADLINE";
      Propagate2[Propagate2["CENSUS_STATS_CONTEXT"] = 2] = "CENSUS_STATS_CONTEXT";
      Propagate2[Propagate2["CENSUS_TRACING_CONTEXT"] = 4] = "CENSUS_TRACING_CONTEXT";
      Propagate2[Propagate2["CANCELLATION"] = 8] = "CANCELLATION";
      Propagate2[Propagate2["DEFAULTS"] = 65535] = "DEFAULTS";
    })(Propagate = exports2.Propagate || (exports2.Propagate = {}));
    exports2.DEFAULT_MAX_SEND_MESSAGE_LENGTH = -1;
    exports2.DEFAULT_MAX_RECEIVE_MESSAGE_LENGTH = 4 * 1024 * 1024;
  }
});

// node_modules/@grpc/grpc-js/build/src/logging.js
var require_logging = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/logging.js"(exports2) {
    "use strict";
    var _a;
    var _b;
    var _c;
    var _d;
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isTracerEnabled = exports2.trace = exports2.log = exports2.setLoggerVerbosity = exports2.setLogger = exports2.getLogger = void 0;
    var constants_1 = require_constants();
    var DEFAULT_LOGGER = {
      error: (message, ...optionalParams) => {
        console.error("E " + message, ...optionalParams);
      },
      info: (message, ...optionalParams) => {
        console.error("I " + message, ...optionalParams);
      },
      debug: (message, ...optionalParams) => {
        console.error("D " + message, ...optionalParams);
      }
    };
    var _logger = DEFAULT_LOGGER;
    var _logVerbosity = constants_1.LogVerbosity.ERROR;
    var verbosityString = (_b = (_a = process.env.GRPC_NODE_VERBOSITY) !== null && _a !== void 0 ? _a : process.env.GRPC_VERBOSITY) !== null && _b !== void 0 ? _b : "";
    switch (verbosityString.toUpperCase()) {
      case "DEBUG":
        _logVerbosity = constants_1.LogVerbosity.DEBUG;
        break;
      case "INFO":
        _logVerbosity = constants_1.LogVerbosity.INFO;
        break;
      case "ERROR":
        _logVerbosity = constants_1.LogVerbosity.ERROR;
        break;
      case "NONE":
        _logVerbosity = constants_1.LogVerbosity.NONE;
        break;
      default:
    }
    var getLogger = () => {
      return _logger;
    };
    exports2.getLogger = getLogger;
    var setLogger = (logger) => {
      _logger = logger;
    };
    exports2.setLogger = setLogger;
    var setLoggerVerbosity = (verbosity) => {
      _logVerbosity = verbosity;
    };
    exports2.setLoggerVerbosity = setLoggerVerbosity;
    var log = (severity, ...args) => {
      let logFunction;
      if (severity >= _logVerbosity) {
        switch (severity) {
          case constants_1.LogVerbosity.DEBUG:
            logFunction = _logger.debug;
            break;
          case constants_1.LogVerbosity.INFO:
            logFunction = _logger.info;
            break;
          case constants_1.LogVerbosity.ERROR:
            logFunction = _logger.error;
            break;
        }
        if (!logFunction) {
          logFunction = _logger.error;
        }
        if (logFunction) {
          logFunction.bind(_logger)(...args);
        }
      }
    };
    exports2.log = log;
    var tracersString = (_d = (_c = process.env.GRPC_NODE_TRACE) !== null && _c !== void 0 ? _c : process.env.GRPC_TRACE) !== null && _d !== void 0 ? _d : "";
    var enabledTracers = /* @__PURE__ */ new Set();
    var disabledTracers = /* @__PURE__ */ new Set();
    for (const tracerName of tracersString.split(",")) {
      if (tracerName.startsWith("-")) {
        disabledTracers.add(tracerName.substring(1));
      } else {
        enabledTracers.add(tracerName);
      }
    }
    var allEnabled = enabledTracers.has("all");
    function trace(severity, tracer, text) {
      if (isTracerEnabled(tracer)) {
        (0, exports2.log)(severity, new Date().toISOString() + " | " + tracer + " | " + text);
      }
    }
    exports2.trace = trace;
    function isTracerEnabled(tracer) {
      return !disabledTracers.has(tracer) && (allEnabled || enabledTracers.has(tracer));
    }
    exports2.isTracerEnabled = isTracerEnabled;
  }
});

// node_modules/@grpc/grpc-js/build/src/error.js
var require_error = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/error.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getErrorCode = exports2.getErrorMessage = void 0;
    function getErrorMessage(error) {
      if (error instanceof Error) {
        return error.message;
      } else {
        return String(error);
      }
    }
    exports2.getErrorMessage = getErrorMessage;
    function getErrorCode(error) {
      if (typeof error === "object" && error !== null && "code" in error && typeof error.code === "number") {
        return error.code;
      } else {
        return null;
      }
    }
    exports2.getErrorCode = getErrorCode;
  }
});

// node_modules/@grpc/grpc-js/build/src/metadata.js
var require_metadata = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/metadata.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Metadata = void 0;
    var logging_1 = require_logging();
    var constants_1 = require_constants();
    var error_1 = require_error();
    var LEGAL_KEY_REGEX = /^[0-9a-z_.-]+$/;
    var LEGAL_NON_BINARY_VALUE_REGEX = /^[ -~]*$/;
    function isLegalKey(key) {
      return LEGAL_KEY_REGEX.test(key);
    }
    function isLegalNonBinaryValue(value) {
      return LEGAL_NON_BINARY_VALUE_REGEX.test(value);
    }
    function isBinaryKey(key) {
      return key.endsWith("-bin");
    }
    function isCustomMetadata(key) {
      return !key.startsWith("grpc-");
    }
    function normalizeKey(key) {
      return key.toLowerCase();
    }
    function validate(key, value) {
      if (!isLegalKey(key)) {
        throw new Error('Metadata key "' + key + '" contains illegal characters');
      }
      if (value !== null && value !== void 0) {
        if (isBinaryKey(key)) {
          if (!Buffer.isBuffer(value)) {
            throw new Error("keys that end with '-bin' must have Buffer values");
          }
        } else {
          if (Buffer.isBuffer(value)) {
            throw new Error("keys that don't end with '-bin' must have String values");
          }
          if (!isLegalNonBinaryValue(value)) {
            throw new Error('Metadata string value "' + value + '" contains illegal characters');
          }
        }
      }
    }
    var Metadata = class {
      constructor(options = {}) {
        this.internalRepr = /* @__PURE__ */ new Map();
        this.options = options;
      }
      /**
       * Sets the given value for the given key by replacing any other values
       * associated with that key. Normalizes the key.
       * @param key The key to whose value should be set.
       * @param value The value to set. Must be a buffer if and only
       *   if the normalized key ends with '-bin'.
       */
      set(key, value) {
        key = normalizeKey(key);
        validate(key, value);
        this.internalRepr.set(key, [value]);
      }
      /**
       * Adds the given value for the given key by appending to a list of previous
       * values associated with that key. Normalizes the key.
       * @param key The key for which a new value should be appended.
       * @param value The value to add. Must be a buffer if and only
       *   if the normalized key ends with '-bin'.
       */
      add(key, value) {
        key = normalizeKey(key);
        validate(key, value);
        const existingValue = this.internalRepr.get(key);
        if (existingValue === void 0) {
          this.internalRepr.set(key, [value]);
        } else {
          existingValue.push(value);
        }
      }
      /**
       * Removes the given key and any associated values. Normalizes the key.
       * @param key The key whose values should be removed.
       */
      remove(key) {
        key = normalizeKey(key);
        this.internalRepr.delete(key);
      }
      /**
       * Gets a list of all values associated with the key. Normalizes the key.
       * @param key The key whose value should be retrieved.
       * @return A list of values associated with the given key.
       */
      get(key) {
        key = normalizeKey(key);
        return this.internalRepr.get(key) || [];
      }
      /**
       * Gets a plain object mapping each key to the first value associated with it.
       * This reflects the most common way that people will want to see metadata.
       * @return A key/value mapping of the metadata.
       */
      getMap() {
        const result = {};
        for (const [key, values] of this.internalRepr) {
          if (values.length > 0) {
            const v = values[0];
            result[key] = Buffer.isBuffer(v) ? Buffer.from(v) : v;
          }
        }
        return result;
      }
      /**
       * Clones the metadata object.
       * @return The newly cloned object.
       */
      clone() {
        const newMetadata = new Metadata(this.options);
        const newInternalRepr = newMetadata.internalRepr;
        for (const [key, value] of this.internalRepr) {
          const clonedValue = value.map((v) => {
            if (Buffer.isBuffer(v)) {
              return Buffer.from(v);
            } else {
              return v;
            }
          });
          newInternalRepr.set(key, clonedValue);
        }
        return newMetadata;
      }
      /**
       * Merges all key-value pairs from a given Metadata object into this one.
       * If both this object and the given object have values in the same key,
       * values from the other Metadata object will be appended to this object's
       * values.
       * @param other A Metadata object.
       */
      merge(other) {
        for (const [key, values] of other.internalRepr) {
          const mergedValue = (this.internalRepr.get(key) || []).concat(values);
          this.internalRepr.set(key, mergedValue);
        }
      }
      setOptions(options) {
        this.options = options;
      }
      getOptions() {
        return this.options;
      }
      /**
       * Creates an OutgoingHttpHeaders object that can be used with the http2 API.
       */
      toHttp2Headers() {
        const result = {};
        for (const [key, values] of this.internalRepr) {
          result[key] = values.map(bufToString);
        }
        return result;
      }
      // For compatibility with the other Metadata implementation
      _getCoreRepresentation() {
        return this.internalRepr;
      }
      /**
       * This modifies the behavior of JSON.stringify to show an object
       * representation of the metadata map.
       */
      toJSON() {
        const result = {};
        for (const [key, values] of this.internalRepr) {
          result[key] = values;
        }
        return result;
      }
      /**
       * Returns a new Metadata object based fields in a given IncomingHttpHeaders
       * object.
       * @param headers An IncomingHttpHeaders object.
       */
      static fromHttp2Headers(headers) {
        const result = new Metadata();
        for (const key of Object.keys(headers)) {
          if (key.charAt(0) === ":") {
            continue;
          }
          const values = headers[key];
          try {
            if (isBinaryKey(key)) {
              if (Array.isArray(values)) {
                values.forEach((value) => {
                  result.add(key, Buffer.from(value, "base64"));
                });
              } else if (values !== void 0) {
                if (isCustomMetadata(key)) {
                  values.split(",").forEach((v) => {
                    result.add(key, Buffer.from(v.trim(), "base64"));
                  });
                } else {
                  result.add(key, Buffer.from(values, "base64"));
                }
              }
            } else {
              if (Array.isArray(values)) {
                values.forEach((value) => {
                  result.add(key, value);
                });
              } else if (values !== void 0) {
                result.add(key, values);
              }
            }
          } catch (error) {
            const message = `Failed to add metadata entry ${key}: ${values}. ${(0, error_1.getErrorMessage)(error)}. For more information see https://github.com/grpc/grpc-node/issues/1173`;
            (0, logging_1.log)(constants_1.LogVerbosity.ERROR, message);
          }
        }
        return result;
      }
    };
    exports2.Metadata = Metadata;
    var bufToString = (val) => {
      return Buffer.isBuffer(val) ? val.toString("base64") : val;
    };
  }
});

// node_modules/@grpc/grpc-js/build/src/call-credentials.js
var require_call_credentials = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/call-credentials.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CallCredentials = void 0;
    var metadata_1 = require_metadata();
    function isCurrentOauth2Client(client) {
      return "getRequestHeaders" in client && typeof client.getRequestHeaders === "function";
    }
    var CallCredentials = class {
      /**
       * Creates a new CallCredentials object from a given function that generates
       * Metadata objects.
       * @param metadataGenerator A function that accepts a set of options, and
       * generates a Metadata object based on these options, which is passed back
       * to the caller via a supplied (err, metadata) callback.
       */
      static createFromMetadataGenerator(metadataGenerator) {
        return new SingleCallCredentials(metadataGenerator);
      }
      /**
       * Create a gRPC credential from a Google credential object.
       * @param googleCredentials The authentication client to use.
       * @return The resulting CallCredentials object.
       */
      static createFromGoogleCredential(googleCredentials) {
        return CallCredentials.createFromMetadataGenerator((options, callback) => {
          let getHeaders;
          if (isCurrentOauth2Client(googleCredentials)) {
            getHeaders = googleCredentials.getRequestHeaders(options.service_url);
          } else {
            getHeaders = new Promise((resolve, reject) => {
              googleCredentials.getRequestMetadata(options.service_url, (err, headers) => {
                if (err) {
                  reject(err);
                  return;
                }
                if (!headers) {
                  reject(new Error("Headers not set by metadata plugin"));
                  return;
                }
                resolve(headers);
              });
            });
          }
          getHeaders.then((headers) => {
            const metadata = new metadata_1.Metadata();
            for (const key of Object.keys(headers)) {
              metadata.add(key, headers[key]);
            }
            callback(null, metadata);
          }, (err) => {
            callback(err);
          });
        });
      }
      static createEmpty() {
        return new EmptyCallCredentials();
      }
    };
    exports2.CallCredentials = CallCredentials;
    var ComposedCallCredentials = class extends CallCredentials {
      constructor(creds) {
        super();
        this.creds = creds;
      }
      async generateMetadata(options) {
        const base = new metadata_1.Metadata();
        const generated = await Promise.all(this.creds.map((cred) => cred.generateMetadata(options)));
        for (const gen of generated) {
          base.merge(gen);
        }
        return base;
      }
      compose(other) {
        return new ComposedCallCredentials(this.creds.concat([other]));
      }
      _equals(other) {
        if (this === other) {
          return true;
        }
        if (other instanceof ComposedCallCredentials) {
          return this.creds.every((value, index) => value._equals(other.creds[index]));
        } else {
          return false;
        }
      }
    };
    var SingleCallCredentials = class extends CallCredentials {
      constructor(metadataGenerator) {
        super();
        this.metadataGenerator = metadataGenerator;
      }
      generateMetadata(options) {
        return new Promise((resolve, reject) => {
          this.metadataGenerator(options, (err, metadata) => {
            if (metadata !== void 0) {
              resolve(metadata);
            } else {
              reject(err);
            }
          });
        });
      }
      compose(other) {
        return new ComposedCallCredentials([this, other]);
      }
      _equals(other) {
        if (this === other) {
          return true;
        }
        if (other instanceof SingleCallCredentials) {
          return this.metadataGenerator === other.metadataGenerator;
        } else {
          return false;
        }
      }
    };
    var EmptyCallCredentials = class extends CallCredentials {
      generateMetadata(options) {
        return Promise.resolve(new metadata_1.Metadata());
      }
      compose(other) {
        return other;
      }
      _equals(other) {
        return other instanceof EmptyCallCredentials;
      }
    };
  }
});

// node_modules/@grpc/grpc-js/build/src/tls-helpers.js
var require_tls_helpers = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/tls-helpers.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getDefaultRootsData = exports2.CIPHER_SUITES = void 0;
    var fs2 = require("fs");
    exports2.CIPHER_SUITES = process.env.GRPC_SSL_CIPHER_SUITES;
    var DEFAULT_ROOTS_FILE_PATH = process.env.GRPC_DEFAULT_SSL_ROOTS_FILE_PATH;
    var defaultRootsData = null;
    function getDefaultRootsData() {
      if (DEFAULT_ROOTS_FILE_PATH) {
        if (defaultRootsData === null) {
          defaultRootsData = fs2.readFileSync(DEFAULT_ROOTS_FILE_PATH);
        }
        return defaultRootsData;
      }
      return null;
    }
    exports2.getDefaultRootsData = getDefaultRootsData;
  }
});

// node_modules/@grpc/grpc-js/build/src/channel-credentials.js
var require_channel_credentials = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/channel-credentials.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ChannelCredentials = void 0;
    var tls_1 = require("tls");
    var call_credentials_1 = require_call_credentials();
    var tls_helpers_1 = require_tls_helpers();
    function verifyIsBufferOrNull(obj, friendlyName) {
      if (obj && !(obj instanceof Buffer)) {
        throw new TypeError(`${friendlyName}, if provided, must be a Buffer.`);
      }
    }
    var ChannelCredentials = class {
      constructor(callCredentials) {
        this.callCredentials = callCredentials || call_credentials_1.CallCredentials.createEmpty();
      }
      /**
       * Gets the set of per-call credentials associated with this instance.
       */
      _getCallCredentials() {
        return this.callCredentials;
      }
      /**
       * Return a new ChannelCredentials instance with a given set of credentials.
       * The resulting instance can be used to construct a Channel that communicates
       * over TLS.
       * @param rootCerts The root certificate data.
       * @param privateKey The client certificate private key, if available.
       * @param certChain The client certificate key chain, if available.
       * @param verifyOptions Additional options to modify certificate verification
       */
      static createSsl(rootCerts, privateKey, certChain, verifyOptions) {
        var _a;
        verifyIsBufferOrNull(rootCerts, "Root certificate");
        verifyIsBufferOrNull(privateKey, "Private key");
        verifyIsBufferOrNull(certChain, "Certificate chain");
        if (privateKey && !certChain) {
          throw new Error("Private key must be given with accompanying certificate chain");
        }
        if (!privateKey && certChain) {
          throw new Error("Certificate chain must be given with accompanying private key");
        }
        const secureContext = (0, tls_1.createSecureContext)({
          ca: (_a = rootCerts !== null && rootCerts !== void 0 ? rootCerts : (0, tls_helpers_1.getDefaultRootsData)()) !== null && _a !== void 0 ? _a : void 0,
          key: privateKey !== null && privateKey !== void 0 ? privateKey : void 0,
          cert: certChain !== null && certChain !== void 0 ? certChain : void 0,
          ciphers: tls_helpers_1.CIPHER_SUITES
        });
        return new SecureChannelCredentialsImpl(secureContext, verifyOptions !== null && verifyOptions !== void 0 ? verifyOptions : {});
      }
      /**
       * Return a new ChannelCredentials instance with credentials created using
       * the provided secureContext. The resulting instances can be used to
       * construct a Channel that communicates over TLS. gRPC will not override
       * anything in the provided secureContext, so the environment variables
       * GRPC_SSL_CIPHER_SUITES and GRPC_DEFAULT_SSL_ROOTS_FILE_PATH will
       * not be applied.
       * @param secureContext The return value of tls.createSecureContext()
       * @param verifyOptions Additional options to modify certificate verification
       */
      static createFromSecureContext(secureContext, verifyOptions) {
        return new SecureChannelCredentialsImpl(secureContext, verifyOptions !== null && verifyOptions !== void 0 ? verifyOptions : {});
      }
      /**
       * Return a new ChannelCredentials instance with no credentials.
       */
      static createInsecure() {
        return new InsecureChannelCredentialsImpl();
      }
    };
    exports2.ChannelCredentials = ChannelCredentials;
    var InsecureChannelCredentialsImpl = class extends ChannelCredentials {
      constructor(callCredentials) {
        super(callCredentials);
      }
      compose(callCredentials) {
        throw new Error("Cannot compose insecure credentials");
      }
      _getConnectionOptions() {
        return null;
      }
      _isSecure() {
        return false;
      }
      _equals(other) {
        return other instanceof InsecureChannelCredentialsImpl;
      }
    };
    var SecureChannelCredentialsImpl = class extends ChannelCredentials {
      constructor(secureContext, verifyOptions) {
        super();
        this.secureContext = secureContext;
        this.verifyOptions = verifyOptions;
        this.connectionOptions = {
          secureContext
        };
        if (verifyOptions === null || verifyOptions === void 0 ? void 0 : verifyOptions.checkServerIdentity) {
          this.connectionOptions.checkServerIdentity = verifyOptions.checkServerIdentity;
        }
      }
      compose(callCredentials) {
        const combinedCallCredentials = this.callCredentials.compose(callCredentials);
        return new ComposedChannelCredentialsImpl(this, combinedCallCredentials);
      }
      _getConnectionOptions() {
        return Object.assign({}, this.connectionOptions);
      }
      _isSecure() {
        return true;
      }
      _equals(other) {
        if (this === other) {
          return true;
        }
        if (other instanceof SecureChannelCredentialsImpl) {
          return this.secureContext === other.secureContext && this.verifyOptions.checkServerIdentity === other.verifyOptions.checkServerIdentity;
        } else {
          return false;
        }
      }
    };
    var ComposedChannelCredentialsImpl = class extends ChannelCredentials {
      constructor(channelCredentials, callCreds) {
        super(callCreds);
        this.channelCredentials = channelCredentials;
      }
      compose(callCredentials) {
        const combinedCallCredentials = this.callCredentials.compose(callCredentials);
        return new ComposedChannelCredentialsImpl(this.channelCredentials, combinedCallCredentials);
      }
      _getConnectionOptions() {
        return this.channelCredentials._getConnectionOptions();
      }
      _isSecure() {
        return true;
      }
      _equals(other) {
        if (this === other) {
          return true;
        }
        if (other instanceof ComposedChannelCredentialsImpl) {
          return this.channelCredentials._equals(other.channelCredentials) && this.callCredentials._equals(other.callCredentials);
        } else {
          return false;
        }
      }
    };
  }
});

// node_modules/@grpc/grpc-js/build/src/load-balancer.js
var require_load_balancer = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/load-balancer.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.validateLoadBalancingConfig = exports2.getFirstUsableConfig = exports2.isLoadBalancerNameRegistered = exports2.createLoadBalancer = exports2.registerDefaultLoadBalancerType = exports2.registerLoadBalancerType = exports2.createChildChannelControlHelper = void 0;
    function createChildChannelControlHelper(parent, overrides) {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      return {
        createSubchannel: (_b = (_a = overrides.createSubchannel) === null || _a === void 0 ? void 0 : _a.bind(overrides)) !== null && _b !== void 0 ? _b : parent.createSubchannel.bind(parent),
        updateState: (_d = (_c = overrides.updateState) === null || _c === void 0 ? void 0 : _c.bind(overrides)) !== null && _d !== void 0 ? _d : parent.updateState.bind(parent),
        requestReresolution: (_f = (_e = overrides.requestReresolution) === null || _e === void 0 ? void 0 : _e.bind(overrides)) !== null && _f !== void 0 ? _f : parent.requestReresolution.bind(parent),
        addChannelzChild: (_h = (_g = overrides.addChannelzChild) === null || _g === void 0 ? void 0 : _g.bind(overrides)) !== null && _h !== void 0 ? _h : parent.addChannelzChild.bind(parent),
        removeChannelzChild: (_k = (_j = overrides.removeChannelzChild) === null || _j === void 0 ? void 0 : _j.bind(overrides)) !== null && _k !== void 0 ? _k : parent.removeChannelzChild.bind(parent)
      };
    }
    exports2.createChildChannelControlHelper = createChildChannelControlHelper;
    var registeredLoadBalancerTypes = {};
    var defaultLoadBalancerType = null;
    function registerLoadBalancerType(typeName, loadBalancerType, loadBalancingConfigType) {
      registeredLoadBalancerTypes[typeName] = {
        LoadBalancer: loadBalancerType,
        LoadBalancingConfig: loadBalancingConfigType
      };
    }
    exports2.registerLoadBalancerType = registerLoadBalancerType;
    function registerDefaultLoadBalancerType(typeName) {
      defaultLoadBalancerType = typeName;
    }
    exports2.registerDefaultLoadBalancerType = registerDefaultLoadBalancerType;
    function createLoadBalancer(config4, channelControlHelper) {
      const typeName = config4.getLoadBalancerName();
      if (typeName in registeredLoadBalancerTypes) {
        return new registeredLoadBalancerTypes[typeName].LoadBalancer(channelControlHelper);
      } else {
        return null;
      }
    }
    exports2.createLoadBalancer = createLoadBalancer;
    function isLoadBalancerNameRegistered(typeName) {
      return typeName in registeredLoadBalancerTypes;
    }
    exports2.isLoadBalancerNameRegistered = isLoadBalancerNameRegistered;
    function getFirstUsableConfig(configs, fallbackTodefault = false) {
      for (const config4 of configs) {
        if (config4.getLoadBalancerName() in registeredLoadBalancerTypes) {
          return config4;
        }
      }
      if (fallbackTodefault) {
        if (defaultLoadBalancerType) {
          return new registeredLoadBalancerTypes[defaultLoadBalancerType].LoadBalancingConfig();
        } else {
          return null;
        }
      } else {
        return null;
      }
    }
    exports2.getFirstUsableConfig = getFirstUsableConfig;
    function validateLoadBalancingConfig(obj) {
      if (!(obj !== null && typeof obj === "object")) {
        throw new Error("Load balancing config must be an object");
      }
      const keys = Object.keys(obj);
      if (keys.length !== 1) {
        throw new Error("Provided load balancing config has multiple conflicting entries");
      }
      const typeName = keys[0];
      if (typeName in registeredLoadBalancerTypes) {
        return registeredLoadBalancerTypes[typeName].LoadBalancingConfig.createFromJson(obj[typeName]);
      } else {
        throw new Error(`Unrecognized load balancing config name ${typeName}`);
      }
    }
    exports2.validateLoadBalancingConfig = validateLoadBalancingConfig;
  }
});

// node_modules/@grpc/grpc-js/build/src/service-config.js
var require_service_config = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/service-config.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.extractAndSelectServiceConfig = exports2.validateServiceConfig = exports2.validateRetryThrottling = void 0;
    var os = require("os");
    var constants_1 = require_constants();
    var load_balancer_1 = require_load_balancer();
    var DURATION_REGEX = /^\d+(\.\d{1,9})?s$/;
    var CLIENT_LANGUAGE_STRING = "node";
    function validateName(obj) {
      if (!("service" in obj) || typeof obj.service !== "string") {
        throw new Error("Invalid method config name: invalid service");
      }
      const result = {
        service: obj.service
      };
      if ("method" in obj) {
        if (typeof obj.method === "string") {
          result.method = obj.method;
        } else {
          throw new Error("Invalid method config name: invalid method");
        }
      }
      return result;
    }
    function validateRetryPolicy(obj) {
      if (!("maxAttempts" in obj) || !Number.isInteger(obj.maxAttempts) || obj.maxAttempts < 2) {
        throw new Error("Invalid method config retry policy: maxAttempts must be an integer at least 2");
      }
      if (!("initialBackoff" in obj) || typeof obj.initialBackoff !== "string" || !DURATION_REGEX.test(obj.initialBackoff)) {
        throw new Error("Invalid method config retry policy: initialBackoff must be a string consisting of a positive integer followed by s");
      }
      if (!("maxBackoff" in obj) || typeof obj.maxBackoff !== "string" || !DURATION_REGEX.test(obj.maxBackoff)) {
        throw new Error("Invalid method config retry policy: maxBackoff must be a string consisting of a positive integer followed by s");
      }
      if (!("backoffMultiplier" in obj) || typeof obj.backoffMultiplier !== "number" || obj.backoffMultiplier <= 0) {
        throw new Error("Invalid method config retry policy: backoffMultiplier must be a number greater than 0");
      }
      if (!("retryableStatusCodes" in obj && Array.isArray(obj.retryableStatusCodes))) {
        throw new Error("Invalid method config retry policy: retryableStatusCodes is required");
      }
      if (obj.retryableStatusCodes.length === 0) {
        throw new Error("Invalid method config retry policy: retryableStatusCodes must be non-empty");
      }
      for (const value of obj.retryableStatusCodes) {
        if (typeof value === "number") {
          if (!Object.values(constants_1.Status).includes(value)) {
            throw new Error("Invalid method config retry policy: retryableStatusCodes value not in status code range");
          }
        } else if (typeof value === "string") {
          if (!Object.values(constants_1.Status).includes(value.toUpperCase())) {
            throw new Error("Invalid method config retry policy: retryableStatusCodes value not a status code name");
          }
        } else {
          throw new Error("Invalid method config retry policy: retryableStatusCodes value must be a string or number");
        }
      }
      return {
        maxAttempts: obj.maxAttempts,
        initialBackoff: obj.initialBackoff,
        maxBackoff: obj.maxBackoff,
        backoffMultiplier: obj.backoffMultiplier,
        retryableStatusCodes: obj.retryableStatusCodes
      };
    }
    function validateHedgingPolicy(obj) {
      if (!("maxAttempts" in obj) || !Number.isInteger(obj.maxAttempts) || obj.maxAttempts < 2) {
        throw new Error("Invalid method config hedging policy: maxAttempts must be an integer at least 2");
      }
      if ("hedgingDelay" in obj && (typeof obj.hedgingDelay !== "string" || !DURATION_REGEX.test(obj.hedgingDelay))) {
        throw new Error("Invalid method config hedging policy: hedgingDelay must be a string consisting of a positive integer followed by s");
      }
      if ("nonFatalStatusCodes" in obj && Array.isArray(obj.nonFatalStatusCodes)) {
        for (const value of obj.nonFatalStatusCodes) {
          if (typeof value === "number") {
            if (!Object.values(constants_1.Status).includes(value)) {
              throw new Error("Invlid method config hedging policy: nonFatalStatusCodes value not in status code range");
            }
          } else if (typeof value === "string") {
            if (!Object.values(constants_1.Status).includes(value.toUpperCase())) {
              throw new Error("Invlid method config hedging policy: nonFatalStatusCodes value not a status code name");
            }
          } else {
            throw new Error("Invlid method config hedging policy: nonFatalStatusCodes value must be a string or number");
          }
        }
      }
      const result = {
        maxAttempts: obj.maxAttempts
      };
      if (obj.hedgingDelay) {
        result.hedgingDelay = obj.hedgingDelay;
      }
      if (obj.nonFatalStatusCodes) {
        result.nonFatalStatusCodes = obj.nonFatalStatusCodes;
      }
      return result;
    }
    function validateMethodConfig(obj) {
      var _a;
      const result = {
        name: []
      };
      if (!("name" in obj) || !Array.isArray(obj.name)) {
        throw new Error("Invalid method config: invalid name array");
      }
      for (const name of obj.name) {
        result.name.push(validateName(name));
      }
      if ("waitForReady" in obj) {
        if (typeof obj.waitForReady !== "boolean") {
          throw new Error("Invalid method config: invalid waitForReady");
        }
        result.waitForReady = obj.waitForReady;
      }
      if ("timeout" in obj) {
        if (typeof obj.timeout === "object") {
          if (!("seconds" in obj.timeout) || !(typeof obj.timeout.seconds === "number")) {
            throw new Error("Invalid method config: invalid timeout.seconds");
          }
          if (!("nanos" in obj.timeout) || !(typeof obj.timeout.nanos === "number")) {
            throw new Error("Invalid method config: invalid timeout.nanos");
          }
          result.timeout = obj.timeout;
        } else if (typeof obj.timeout === "string" && DURATION_REGEX.test(obj.timeout)) {
          const timeoutParts = obj.timeout.substring(0, obj.timeout.length - 1).split(".");
          result.timeout = {
            seconds: timeoutParts[0] | 0,
            nanos: ((_a = timeoutParts[1]) !== null && _a !== void 0 ? _a : 0) | 0
          };
        } else {
          throw new Error("Invalid method config: invalid timeout");
        }
      }
      if ("maxRequestBytes" in obj) {
        if (typeof obj.maxRequestBytes !== "number") {
          throw new Error("Invalid method config: invalid maxRequestBytes");
        }
        result.maxRequestBytes = obj.maxRequestBytes;
      }
      if ("maxResponseBytes" in obj) {
        if (typeof obj.maxResponseBytes !== "number") {
          throw new Error("Invalid method config: invalid maxRequestBytes");
        }
        result.maxResponseBytes = obj.maxResponseBytes;
      }
      if ("retryPolicy" in obj) {
        if ("hedgingPolicy" in obj) {
          throw new Error("Invalid method config: retryPolicy and hedgingPolicy cannot both be specified");
        } else {
          result.retryPolicy = validateRetryPolicy(obj.retryPolicy);
        }
      } else if ("hedgingPolicy" in obj) {
        result.hedgingPolicy = validateHedgingPolicy(obj.hedgingPolicy);
      }
      return result;
    }
    function validateRetryThrottling(obj) {
      if (!("maxTokens" in obj) || typeof obj.maxTokens !== "number" || obj.maxTokens <= 0 || obj.maxTokens > 1e3) {
        throw new Error("Invalid retryThrottling: maxTokens must be a number in (0, 1000]");
      }
      if (!("tokenRatio" in obj) || typeof obj.tokenRatio !== "number" || obj.tokenRatio <= 0) {
        throw new Error("Invalid retryThrottling: tokenRatio must be a number greater than 0");
      }
      return {
        maxTokens: +obj.maxTokens.toFixed(3),
        tokenRatio: +obj.tokenRatio.toFixed(3)
      };
    }
    exports2.validateRetryThrottling = validateRetryThrottling;
    function validateServiceConfig(obj) {
      const result = {
        loadBalancingConfig: [],
        methodConfig: []
      };
      if ("loadBalancingPolicy" in obj) {
        if (typeof obj.loadBalancingPolicy === "string") {
          result.loadBalancingPolicy = obj.loadBalancingPolicy;
        } else {
          throw new Error("Invalid service config: invalid loadBalancingPolicy");
        }
      }
      if ("loadBalancingConfig" in obj) {
        if (Array.isArray(obj.loadBalancingConfig)) {
          for (const config4 of obj.loadBalancingConfig) {
            result.loadBalancingConfig.push((0, load_balancer_1.validateLoadBalancingConfig)(config4));
          }
        } else {
          throw new Error("Invalid service config: invalid loadBalancingConfig");
        }
      }
      if ("methodConfig" in obj) {
        if (Array.isArray(obj.methodConfig)) {
          for (const methodConfig of obj.methodConfig) {
            result.methodConfig.push(validateMethodConfig(methodConfig));
          }
        }
      }
      if ("retryThrottling" in obj) {
        result.retryThrottling = validateRetryThrottling(obj.retryThrottling);
      }
      const seenMethodNames = [];
      for (const methodConfig of result.methodConfig) {
        for (const name of methodConfig.name) {
          for (const seenName of seenMethodNames) {
            if (name.service === seenName.service && name.method === seenName.method) {
              throw new Error(`Invalid service config: duplicate name ${name.service}/${name.method}`);
            }
          }
          seenMethodNames.push(name);
        }
      }
      return result;
    }
    exports2.validateServiceConfig = validateServiceConfig;
    function validateCanaryConfig(obj) {
      if (!("serviceConfig" in obj)) {
        throw new Error("Invalid service config choice: missing service config");
      }
      const result = {
        serviceConfig: validateServiceConfig(obj.serviceConfig)
      };
      if ("clientLanguage" in obj) {
        if (Array.isArray(obj.clientLanguage)) {
          result.clientLanguage = [];
          for (const lang of obj.clientLanguage) {
            if (typeof lang === "string") {
              result.clientLanguage.push(lang);
            } else {
              throw new Error("Invalid service config choice: invalid clientLanguage");
            }
          }
        } else {
          throw new Error("Invalid service config choice: invalid clientLanguage");
        }
      }
      if ("clientHostname" in obj) {
        if (Array.isArray(obj.clientHostname)) {
          result.clientHostname = [];
          for (const lang of obj.clientHostname) {
            if (typeof lang === "string") {
              result.clientHostname.push(lang);
            } else {
              throw new Error("Invalid service config choice: invalid clientHostname");
            }
          }
        } else {
          throw new Error("Invalid service config choice: invalid clientHostname");
        }
      }
      if ("percentage" in obj) {
        if (typeof obj.percentage === "number" && 0 <= obj.percentage && obj.percentage <= 100) {
          result.percentage = obj.percentage;
        } else {
          throw new Error("Invalid service config choice: invalid percentage");
        }
      }
      const allowedFields = [
        "clientLanguage",
        "percentage",
        "clientHostname",
        "serviceConfig"
      ];
      for (const field in obj) {
        if (!allowedFields.includes(field)) {
          throw new Error(`Invalid service config choice: unexpected field ${field}`);
        }
      }
      return result;
    }
    function validateAndSelectCanaryConfig(obj, percentage) {
      if (!Array.isArray(obj)) {
        throw new Error("Invalid service config list");
      }
      for (const config4 of obj) {
        const validatedConfig = validateCanaryConfig(config4);
        if (typeof validatedConfig.percentage === "number" && percentage > validatedConfig.percentage) {
          continue;
        }
        if (Array.isArray(validatedConfig.clientHostname)) {
          let hostnameMatched = false;
          for (const hostname of validatedConfig.clientHostname) {
            if (hostname === os.hostname()) {
              hostnameMatched = true;
            }
          }
          if (!hostnameMatched) {
            continue;
          }
        }
        if (Array.isArray(validatedConfig.clientLanguage)) {
          let languageMatched = false;
          for (const language of validatedConfig.clientLanguage) {
            if (language === CLIENT_LANGUAGE_STRING) {
              languageMatched = true;
            }
          }
          if (!languageMatched) {
            continue;
          }
        }
        return validatedConfig.serviceConfig;
      }
      throw new Error("No matching service config found");
    }
    function extractAndSelectServiceConfig(txtRecord, percentage) {
      for (const record of txtRecord) {
        if (record.length > 0 && record[0].startsWith("grpc_config=")) {
          const recordString = record.join("").substring("grpc_config=".length);
          const recordJson = JSON.parse(recordString);
          return validateAndSelectCanaryConfig(recordJson, percentage);
        }
      }
      return null;
    }
    exports2.extractAndSelectServiceConfig = extractAndSelectServiceConfig;
  }
});

// node_modules/@grpc/grpc-js/build/src/connectivity-state.js
var require_connectivity_state = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/connectivity-state.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ConnectivityState = void 0;
    var ConnectivityState;
    (function(ConnectivityState2) {
      ConnectivityState2[ConnectivityState2["IDLE"] = 0] = "IDLE";
      ConnectivityState2[ConnectivityState2["CONNECTING"] = 1] = "CONNECTING";
      ConnectivityState2[ConnectivityState2["READY"] = 2] = "READY";
      ConnectivityState2[ConnectivityState2["TRANSIENT_FAILURE"] = 3] = "TRANSIENT_FAILURE";
      ConnectivityState2[ConnectivityState2["SHUTDOWN"] = 4] = "SHUTDOWN";
    })(ConnectivityState = exports2.ConnectivityState || (exports2.ConnectivityState = {}));
  }
});

// node_modules/@grpc/grpc-js/build/src/uri-parser.js
var require_uri_parser = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/uri-parser.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.uriToString = exports2.splitHostPort = exports2.parseUri = void 0;
    var URI_REGEX = /^(?:([A-Za-z0-9+.-]+):)?(?:\/\/([^/]*)\/)?(.+)$/;
    function parseUri(uriString) {
      const parsedUri = URI_REGEX.exec(uriString);
      if (parsedUri === null) {
        return null;
      }
      return {
        scheme: parsedUri[1],
        authority: parsedUri[2],
        path: parsedUri[3]
      };
    }
    exports2.parseUri = parseUri;
    var NUMBER_REGEX = /^\d+$/;
    function splitHostPort(path2) {
      if (path2.startsWith("[")) {
        const hostEnd = path2.indexOf("]");
        if (hostEnd === -1) {
          return null;
        }
        const host = path2.substring(1, hostEnd);
        if (host.indexOf(":") === -1) {
          return null;
        }
        if (path2.length > hostEnd + 1) {
          if (path2[hostEnd + 1] === ":") {
            const portString = path2.substring(hostEnd + 2);
            if (NUMBER_REGEX.test(portString)) {
              return {
                host,
                port: +portString
              };
            } else {
              return null;
            }
          } else {
            return null;
          }
        } else {
          return {
            host
          };
        }
      } else {
        const splitPath = path2.split(":");
        if (splitPath.length === 2) {
          if (NUMBER_REGEX.test(splitPath[1])) {
            return {
              host: splitPath[0],
              port: +splitPath[1]
            };
          } else {
            return null;
          }
        } else {
          return {
            host: path2
          };
        }
      }
    }
    exports2.splitHostPort = splitHostPort;
    function uriToString(uri) {
      let result = "";
      if (uri.scheme !== void 0) {
        result += uri.scheme + ":";
      }
      if (uri.authority !== void 0) {
        result += "//" + uri.authority + "/";
      }
      result += uri.path;
      return result;
    }
    exports2.uriToString = uriToString;
  }
});

// node_modules/@grpc/grpc-js/build/src/resolver.js
var require_resolver = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/resolver.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.mapUriDefaultScheme = exports2.getDefaultAuthority = exports2.createResolver = exports2.registerDefaultScheme = exports2.registerResolver = void 0;
    var uri_parser_1 = require_uri_parser();
    var registeredResolvers = {};
    var defaultScheme = null;
    function registerResolver(scheme, resolverClass) {
      registeredResolvers[scheme] = resolverClass;
    }
    exports2.registerResolver = registerResolver;
    function registerDefaultScheme(scheme) {
      defaultScheme = scheme;
    }
    exports2.registerDefaultScheme = registerDefaultScheme;
    function createResolver(target, listener, options) {
      if (target.scheme !== void 0 && target.scheme in registeredResolvers) {
        return new registeredResolvers[target.scheme](target, listener, options);
      } else {
        throw new Error(`No resolver could be created for target ${(0, uri_parser_1.uriToString)(target)}`);
      }
    }
    exports2.createResolver = createResolver;
    function getDefaultAuthority(target) {
      if (target.scheme !== void 0 && target.scheme in registeredResolvers) {
        return registeredResolvers[target.scheme].getDefaultAuthority(target);
      } else {
        throw new Error(`Invalid target ${(0, uri_parser_1.uriToString)(target)}`);
      }
    }
    exports2.getDefaultAuthority = getDefaultAuthority;
    function mapUriDefaultScheme(target) {
      if (target.scheme === void 0 || !(target.scheme in registeredResolvers)) {
        if (defaultScheme !== null) {
          return {
            scheme: defaultScheme,
            authority: void 0,
            path: (0, uri_parser_1.uriToString)(target)
          };
        } else {
          return null;
        }
      }
      return target;
    }
    exports2.mapUriDefaultScheme = mapUriDefaultScheme;
  }
});

// node_modules/@grpc/grpc-js/build/src/picker.js
var require_picker = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/picker.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.QueuePicker = exports2.UnavailablePicker = exports2.PickResultType = void 0;
    var metadata_1 = require_metadata();
    var constants_1 = require_constants();
    var PickResultType;
    (function(PickResultType2) {
      PickResultType2[PickResultType2["COMPLETE"] = 0] = "COMPLETE";
      PickResultType2[PickResultType2["QUEUE"] = 1] = "QUEUE";
      PickResultType2[PickResultType2["TRANSIENT_FAILURE"] = 2] = "TRANSIENT_FAILURE";
      PickResultType2[PickResultType2["DROP"] = 3] = "DROP";
    })(PickResultType = exports2.PickResultType || (exports2.PickResultType = {}));
    var UnavailablePicker = class {
      constructor(status) {
        if (status !== void 0) {
          this.status = status;
        } else {
          this.status = {
            code: constants_1.Status.UNAVAILABLE,
            details: "No connection established",
            metadata: new metadata_1.Metadata()
          };
        }
      }
      pick(pickArgs) {
        return {
          pickResultType: PickResultType.TRANSIENT_FAILURE,
          subchannel: null,
          status: this.status,
          onCallStarted: null,
          onCallEnded: null
        };
      }
    };
    exports2.UnavailablePicker = UnavailablePicker;
    var QueuePicker = class {
      // Constructed with a load balancer. Calls exitIdle on it the first time pick is called
      constructor(loadBalancer) {
        this.loadBalancer = loadBalancer;
        this.calledExitIdle = false;
      }
      pick(pickArgs) {
        if (!this.calledExitIdle) {
          process.nextTick(() => {
            this.loadBalancer.exitIdle();
          });
          this.calledExitIdle = true;
        }
        return {
          pickResultType: PickResultType.QUEUE,
          subchannel: null,
          status: null,
          onCallStarted: null,
          onCallEnded: null
        };
      }
    };
    exports2.QueuePicker = QueuePicker;
  }
});

// node_modules/@grpc/grpc-js/build/src/backoff-timeout.js
var require_backoff_timeout = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/backoff-timeout.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.BackoffTimeout = void 0;
    var INITIAL_BACKOFF_MS = 1e3;
    var BACKOFF_MULTIPLIER = 1.6;
    var MAX_BACKOFF_MS = 12e4;
    var BACKOFF_JITTER = 0.2;
    function uniformRandom(min, max) {
      return Math.random() * (max - min) + min;
    }
    var BackoffTimeout = class {
      constructor(callback, options) {
        this.callback = callback;
        this.initialDelay = INITIAL_BACKOFF_MS;
        this.multiplier = BACKOFF_MULTIPLIER;
        this.maxDelay = MAX_BACKOFF_MS;
        this.jitter = BACKOFF_JITTER;
        this.running = false;
        this.hasRef = true;
        this.startTime = new Date();
        if (options) {
          if (options.initialDelay) {
            this.initialDelay = options.initialDelay;
          }
          if (options.multiplier) {
            this.multiplier = options.multiplier;
          }
          if (options.jitter) {
            this.jitter = options.jitter;
          }
          if (options.maxDelay) {
            this.maxDelay = options.maxDelay;
          }
        }
        this.nextDelay = this.initialDelay;
        this.timerId = setTimeout(() => {
        }, 0);
        clearTimeout(this.timerId);
      }
      runTimer(delay) {
        var _a, _b;
        clearTimeout(this.timerId);
        this.timerId = setTimeout(() => {
          this.callback();
          this.running = false;
        }, delay);
        if (!this.hasRef) {
          (_b = (_a = this.timerId).unref) === null || _b === void 0 ? void 0 : _b.call(_a);
        }
      }
      /**
       * Call the callback after the current amount of delay time
       */
      runOnce() {
        this.running = true;
        this.startTime = new Date();
        this.runTimer(this.nextDelay);
        const nextBackoff = Math.min(this.nextDelay * this.multiplier, this.maxDelay);
        const jitterMagnitude = nextBackoff * this.jitter;
        this.nextDelay = nextBackoff + uniformRandom(-jitterMagnitude, jitterMagnitude);
      }
      /**
       * Stop the timer. The callback will not be called until `runOnce` is called
       * again.
       */
      stop() {
        clearTimeout(this.timerId);
        this.running = false;
      }
      /**
       * Reset the delay time to its initial value. If the timer is still running,
       * retroactively apply that reset to the current timer.
       */
      reset() {
        this.nextDelay = this.initialDelay;
        if (this.running) {
          const now = new Date();
          const newEndTime = this.startTime;
          newEndTime.setMilliseconds(newEndTime.getMilliseconds() + this.nextDelay);
          clearTimeout(this.timerId);
          if (now < newEndTime) {
            this.runTimer(newEndTime.getTime() - now.getTime());
          } else {
            this.running = false;
          }
        }
      }
      /**
       * Check whether the timer is currently running.
       */
      isRunning() {
        return this.running;
      }
      /**
       * Set that while the timer is running, it should keep the Node process
       * running.
       */
      ref() {
        var _a, _b;
        this.hasRef = true;
        (_b = (_a = this.timerId).ref) === null || _b === void 0 ? void 0 : _b.call(_a);
      }
      /**
       * Set that while the timer is running, it should not keep the Node process
       * running.
       */
      unref() {
        var _a, _b;
        this.hasRef = false;
        (_b = (_a = this.timerId).unref) === null || _b === void 0 ? void 0 : _b.call(_a);
      }
    };
    exports2.BackoffTimeout = BackoffTimeout;
  }
});

// node_modules/@grpc/grpc-js/build/src/load-balancer-child-handler.js
var require_load_balancer_child_handler = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/load-balancer-child-handler.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ChildLoadBalancerHandler = void 0;
    var load_balancer_1 = require_load_balancer();
    var connectivity_state_1 = require_connectivity_state();
    var TYPE_NAME = "child_load_balancer_helper";
    var ChildLoadBalancerHandler = class {
      constructor(channelControlHelper) {
        this.channelControlHelper = channelControlHelper;
        this.currentChild = null;
        this.pendingChild = null;
        this.ChildPolicyHelper = class {
          constructor(parent) {
            this.parent = parent;
            this.child = null;
          }
          createSubchannel(subchannelAddress, subchannelArgs) {
            return this.parent.channelControlHelper.createSubchannel(subchannelAddress, subchannelArgs);
          }
          updateState(connectivityState, picker) {
            var _a;
            if (this.calledByPendingChild()) {
              if (connectivityState === connectivity_state_1.ConnectivityState.CONNECTING) {
                return;
              }
              (_a = this.parent.currentChild) === null || _a === void 0 ? void 0 : _a.destroy();
              this.parent.currentChild = this.parent.pendingChild;
              this.parent.pendingChild = null;
            } else if (!this.calledByCurrentChild()) {
              return;
            }
            this.parent.channelControlHelper.updateState(connectivityState, picker);
          }
          requestReresolution() {
            var _a;
            const latestChild = (_a = this.parent.pendingChild) !== null && _a !== void 0 ? _a : this.parent.currentChild;
            if (this.child === latestChild) {
              this.parent.channelControlHelper.requestReresolution();
            }
          }
          setChild(newChild) {
            this.child = newChild;
          }
          addChannelzChild(child) {
            this.parent.channelControlHelper.addChannelzChild(child);
          }
          removeChannelzChild(child) {
            this.parent.channelControlHelper.removeChannelzChild(child);
          }
          calledByPendingChild() {
            return this.child === this.parent.pendingChild;
          }
          calledByCurrentChild() {
            return this.child === this.parent.currentChild;
          }
        };
      }
      /**
       * Prerequisites: lbConfig !== null and lbConfig.name is registered
       * @param addressList
       * @param lbConfig
       * @param attributes
       */
      updateAddressList(addressList, lbConfig, attributes) {
        let childToUpdate;
        if (this.currentChild === null || this.currentChild.getTypeName() !== lbConfig.getLoadBalancerName()) {
          const newHelper = new this.ChildPolicyHelper(this);
          const newChild = (0, load_balancer_1.createLoadBalancer)(lbConfig, newHelper);
          newHelper.setChild(newChild);
          if (this.currentChild === null) {
            this.currentChild = newChild;
            childToUpdate = this.currentChild;
          } else {
            if (this.pendingChild) {
              this.pendingChild.destroy();
            }
            this.pendingChild = newChild;
            childToUpdate = this.pendingChild;
          }
        } else {
          if (this.pendingChild === null) {
            childToUpdate = this.currentChild;
          } else {
            childToUpdate = this.pendingChild;
          }
        }
        childToUpdate.updateAddressList(addressList, lbConfig, attributes);
      }
      exitIdle() {
        if (this.currentChild) {
          this.currentChild.exitIdle();
          if (this.pendingChild) {
            this.pendingChild.exitIdle();
          }
        }
      }
      resetBackoff() {
        if (this.currentChild) {
          this.currentChild.resetBackoff();
          if (this.pendingChild) {
            this.pendingChild.resetBackoff();
          }
        }
      }
      destroy() {
        if (this.currentChild) {
          this.currentChild.destroy();
          this.currentChild = null;
        }
        if (this.pendingChild) {
          this.pendingChild.destroy();
          this.pendingChild = null;
        }
      }
      getTypeName() {
        return TYPE_NAME;
      }
    };
    exports2.ChildLoadBalancerHandler = ChildLoadBalancerHandler;
  }
});

// node_modules/@grpc/grpc-js/build/src/resolving-load-balancer.js
var require_resolving_load_balancer = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/resolving-load-balancer.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ResolvingLoadBalancer = void 0;
    var load_balancer_1 = require_load_balancer();
    var service_config_1 = require_service_config();
    var connectivity_state_1 = require_connectivity_state();
    var resolver_1 = require_resolver();
    var picker_1 = require_picker();
    var backoff_timeout_1 = require_backoff_timeout();
    var constants_1 = require_constants();
    var metadata_1 = require_metadata();
    var logging = require_logging();
    var constants_2 = require_constants();
    var uri_parser_1 = require_uri_parser();
    var load_balancer_child_handler_1 = require_load_balancer_child_handler();
    var TRACER_NAME = "resolving_load_balancer";
    function trace(text) {
      logging.trace(constants_2.LogVerbosity.DEBUG, TRACER_NAME, text);
    }
    function getDefaultConfigSelector(serviceConfig) {
      return function defaultConfigSelector(methodName, metadata) {
        var _a, _b;
        const splitName = methodName.split("/").filter((x) => x.length > 0);
        const service = (_a = splitName[0]) !== null && _a !== void 0 ? _a : "";
        const method = (_b = splitName[1]) !== null && _b !== void 0 ? _b : "";
        if (serviceConfig && serviceConfig.methodConfig) {
          for (const methodConfig of serviceConfig.methodConfig) {
            for (const name of methodConfig.name) {
              if (name.service === service && (name.method === void 0 || name.method === method)) {
                return {
                  methodConfig,
                  pickInformation: {},
                  status: constants_1.Status.OK,
                  dynamicFilterFactories: []
                };
              }
            }
          }
        }
        return {
          methodConfig: { name: [] },
          pickInformation: {},
          status: constants_1.Status.OK,
          dynamicFilterFactories: []
        };
      };
    }
    var ResolvingLoadBalancer = class {
      /**
       * Wrapper class that behaves like a `LoadBalancer` and also handles name
       * resolution internally.
       * @param target The address of the backend to connect to.
       * @param channelControlHelper `ChannelControlHelper` instance provided by
       *     this load balancer's owner.
       * @param defaultServiceConfig The default service configuration to be used
       *     if none is provided by the name resolver. A `null` value indicates
       *     that the default behavior should be the default unconfigured behavior.
       *     In practice, that means using the "pick first" load balancer
       *     implmentation
       */
      constructor(target, channelControlHelper, channelOptions, onSuccessfulResolution, onFailedResolution) {
        this.target = target;
        this.channelControlHelper = channelControlHelper;
        this.channelOptions = channelOptions;
        this.onSuccessfulResolution = onSuccessfulResolution;
        this.onFailedResolution = onFailedResolution;
        this.latestChildState = connectivity_state_1.ConnectivityState.IDLE;
        this.latestChildPicker = new picker_1.QueuePicker(this);
        this.currentState = connectivity_state_1.ConnectivityState.IDLE;
        this.previousServiceConfig = null;
        this.continueResolving = false;
        if (channelOptions["grpc.service_config"]) {
          this.defaultServiceConfig = (0, service_config_1.validateServiceConfig)(JSON.parse(channelOptions["grpc.service_config"]));
        } else {
          this.defaultServiceConfig = {
            loadBalancingConfig: [],
            methodConfig: []
          };
        }
        this.updateState(connectivity_state_1.ConnectivityState.IDLE, new picker_1.QueuePicker(this));
        this.childLoadBalancer = new load_balancer_child_handler_1.ChildLoadBalancerHandler({
          createSubchannel: channelControlHelper.createSubchannel.bind(channelControlHelper),
          requestReresolution: () => {
            if (this.backoffTimeout.isRunning()) {
              this.continueResolving = true;
            } else {
              this.updateResolution();
            }
          },
          updateState: (newState, picker) => {
            this.latestChildState = newState;
            this.latestChildPicker = picker;
            this.updateState(newState, picker);
          },
          addChannelzChild: channelControlHelper.addChannelzChild.bind(channelControlHelper),
          removeChannelzChild: channelControlHelper.removeChannelzChild.bind(channelControlHelper)
        });
        this.innerResolver = (0, resolver_1.createResolver)(target, {
          onSuccessfulResolution: (addressList, serviceConfig, serviceConfigError, configSelector, attributes) => {
            var _a;
            let workingServiceConfig = null;
            if (serviceConfig === null) {
              if (serviceConfigError === null) {
                this.previousServiceConfig = null;
                workingServiceConfig = this.defaultServiceConfig;
              } else {
                if (this.previousServiceConfig === null) {
                  this.handleResolutionFailure(serviceConfigError);
                } else {
                  workingServiceConfig = this.previousServiceConfig;
                }
              }
            } else {
              workingServiceConfig = serviceConfig;
              this.previousServiceConfig = serviceConfig;
            }
            const workingConfigList = (_a = workingServiceConfig === null || workingServiceConfig === void 0 ? void 0 : workingServiceConfig.loadBalancingConfig) !== null && _a !== void 0 ? _a : [];
            const loadBalancingConfig = (0, load_balancer_1.getFirstUsableConfig)(workingConfigList, true);
            if (loadBalancingConfig === null) {
              this.handleResolutionFailure({
                code: constants_1.Status.UNAVAILABLE,
                details: "All load balancer options in service config are not compatible",
                metadata: new metadata_1.Metadata()
              });
              return;
            }
            this.childLoadBalancer.updateAddressList(addressList, loadBalancingConfig, attributes);
            const finalServiceConfig = workingServiceConfig !== null && workingServiceConfig !== void 0 ? workingServiceConfig : this.defaultServiceConfig;
            this.onSuccessfulResolution(finalServiceConfig, configSelector !== null && configSelector !== void 0 ? configSelector : getDefaultConfigSelector(finalServiceConfig));
          },
          onError: (error) => {
            this.handleResolutionFailure(error);
          }
        }, channelOptions);
        const backoffOptions = {
          initialDelay: channelOptions["grpc.initial_reconnect_backoff_ms"],
          maxDelay: channelOptions["grpc.max_reconnect_backoff_ms"]
        };
        this.backoffTimeout = new backoff_timeout_1.BackoffTimeout(() => {
          if (this.continueResolving) {
            this.updateResolution();
            this.continueResolving = false;
          } else {
            this.updateState(this.latestChildState, this.latestChildPicker);
          }
        }, backoffOptions);
        this.backoffTimeout.unref();
      }
      updateResolution() {
        this.innerResolver.updateResolution();
        if (this.currentState === connectivity_state_1.ConnectivityState.IDLE) {
          this.updateState(connectivity_state_1.ConnectivityState.CONNECTING, new picker_1.QueuePicker(this));
        }
        this.backoffTimeout.runOnce();
      }
      updateState(connectivityState, picker) {
        trace((0, uri_parser_1.uriToString)(this.target) + " " + connectivity_state_1.ConnectivityState[this.currentState] + " -> " + connectivity_state_1.ConnectivityState[connectivityState]);
        if (connectivityState === connectivity_state_1.ConnectivityState.IDLE) {
          picker = new picker_1.QueuePicker(this);
        }
        this.currentState = connectivityState;
        this.channelControlHelper.updateState(connectivityState, picker);
      }
      handleResolutionFailure(error) {
        if (this.latestChildState === connectivity_state_1.ConnectivityState.IDLE) {
          this.updateState(connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE, new picker_1.UnavailablePicker(error));
          this.onFailedResolution(error);
        }
      }
      exitIdle() {
        if (this.currentState === connectivity_state_1.ConnectivityState.IDLE || this.currentState === connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE) {
          if (this.backoffTimeout.isRunning()) {
            this.continueResolving = true;
          } else {
            this.updateResolution();
          }
        }
        this.childLoadBalancer.exitIdle();
      }
      updateAddressList(addressList, lbConfig) {
        throw new Error("updateAddressList not supported on ResolvingLoadBalancer");
      }
      resetBackoff() {
        this.backoffTimeout.reset();
        this.childLoadBalancer.resetBackoff();
      }
      destroy() {
        this.childLoadBalancer.destroy();
        this.innerResolver.destroy();
        this.updateState(connectivity_state_1.ConnectivityState.SHUTDOWN, new picker_1.UnavailablePicker());
      }
      getTypeName() {
        return "resolving_load_balancer";
      }
    };
    exports2.ResolvingLoadBalancer = ResolvingLoadBalancer;
  }
});

// node_modules/@grpc/grpc-js/build/src/channel-options.js
var require_channel_options = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/channel-options.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.channelOptionsEqual = exports2.recognizedOptions = void 0;
    exports2.recognizedOptions = {
      "grpc.ssl_target_name_override": true,
      "grpc.primary_user_agent": true,
      "grpc.secondary_user_agent": true,
      "grpc.default_authority": true,
      "grpc.keepalive_time_ms": true,
      "grpc.keepalive_timeout_ms": true,
      "grpc.keepalive_permit_without_calls": true,
      "grpc.service_config": true,
      "grpc.max_concurrent_streams": true,
      "grpc.initial_reconnect_backoff_ms": true,
      "grpc.max_reconnect_backoff_ms": true,
      "grpc.use_local_subchannel_pool": true,
      "grpc.max_send_message_length": true,
      "grpc.max_receive_message_length": true,
      "grpc.enable_http_proxy": true,
      "grpc.enable_channelz": true,
      "grpc.dns_min_time_between_resolutions_ms": true,
      "grpc.enable_retries": true,
      "grpc.per_rpc_retry_buffer_size": true,
      "grpc.retry_buffer_size": true,
      "grpc.max_connection_age_ms": true,
      "grpc.max_connection_age_grace_ms": true,
      "grpc-node.max_session_memory": true,
      "grpc.service_config_disable_resolution": true
    };
    function channelOptionsEqual(options1, options2) {
      const keys1 = Object.keys(options1).sort();
      const keys2 = Object.keys(options2).sort();
      if (keys1.length !== keys2.length) {
        return false;
      }
      for (let i = 0; i < keys1.length; i += 1) {
        if (keys1[i] !== keys2[i]) {
          return false;
        }
        if (options1[keys1[i]] !== options2[keys2[i]]) {
          return false;
        }
      }
      return true;
    }
    exports2.channelOptionsEqual = channelOptionsEqual;
  }
});

// node_modules/@grpc/grpc-js/build/src/subchannel-address.js
var require_subchannel_address = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/subchannel-address.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.stringToSubchannelAddress = exports2.subchannelAddressToString = exports2.subchannelAddressEqual = exports2.isTcpSubchannelAddress = void 0;
    var net_1 = require("net");
    function isTcpSubchannelAddress(address) {
      return "port" in address;
    }
    exports2.isTcpSubchannelAddress = isTcpSubchannelAddress;
    function subchannelAddressEqual(address1, address2) {
      if (isTcpSubchannelAddress(address1)) {
        return isTcpSubchannelAddress(address2) && address1.host === address2.host && address1.port === address2.port;
      } else {
        return !isTcpSubchannelAddress(address2) && address1.path === address2.path;
      }
    }
    exports2.subchannelAddressEqual = subchannelAddressEqual;
    function subchannelAddressToString(address) {
      if (isTcpSubchannelAddress(address)) {
        return address.host + ":" + address.port;
      } else {
        return address.path;
      }
    }
    exports2.subchannelAddressToString = subchannelAddressToString;
    var DEFAULT_PORT = 443;
    function stringToSubchannelAddress(addressString, port) {
      if ((0, net_1.isIP)(addressString)) {
        return {
          host: addressString,
          port: port !== null && port !== void 0 ? port : DEFAULT_PORT
        };
      } else {
        return {
          path: addressString
        };
      }
    }
    exports2.stringToSubchannelAddress = stringToSubchannelAddress;
  }
});

// node_modules/@grpc/grpc-js/build/src/admin.js
var require_admin = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/admin.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.addAdminServicesToServer = exports2.registerAdminService = void 0;
    var registeredAdminServices = [];
    function registerAdminService(getServiceDefinition, getHandlers) {
      registeredAdminServices.push({ getServiceDefinition, getHandlers });
    }
    exports2.registerAdminService = registerAdminService;
    function addAdminServicesToServer(server) {
      for (const { getServiceDefinition, getHandlers } of registeredAdminServices) {
        server.addService(getServiceDefinition(), getHandlers());
      }
    }
    exports2.addAdminServicesToServer = addAdminServicesToServer;
  }
});

// node_modules/@grpc/grpc-js/build/src/call.js
var require_call = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/call.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ClientDuplexStreamImpl = exports2.ClientWritableStreamImpl = exports2.ClientReadableStreamImpl = exports2.ClientUnaryCallImpl = exports2.callErrorFromStatus = void 0;
    var events_1 = require("events");
    var stream_1 = require("stream");
    var constants_1 = require_constants();
    function callErrorFromStatus(status, callerStack) {
      const message = `${status.code} ${constants_1.Status[status.code]}: ${status.details}`;
      const error = new Error(message);
      const stack = `${error.stack}
for call at
${callerStack}`;
      return Object.assign(new Error(message), status, { stack });
    }
    exports2.callErrorFromStatus = callErrorFromStatus;
    var ClientUnaryCallImpl = class extends events_1.EventEmitter {
      constructor() {
        super();
      }
      cancel() {
        var _a;
        (_a = this.call) === null || _a === void 0 ? void 0 : _a.cancelWithStatus(constants_1.Status.CANCELLED, "Cancelled on client");
      }
      getPeer() {
        var _a, _b;
        return (_b = (_a = this.call) === null || _a === void 0 ? void 0 : _a.getPeer()) !== null && _b !== void 0 ? _b : "unknown";
      }
    };
    exports2.ClientUnaryCallImpl = ClientUnaryCallImpl;
    var ClientReadableStreamImpl = class extends stream_1.Readable {
      constructor(deserialize) {
        super({ objectMode: true });
        this.deserialize = deserialize;
      }
      cancel() {
        var _a;
        (_a = this.call) === null || _a === void 0 ? void 0 : _a.cancelWithStatus(constants_1.Status.CANCELLED, "Cancelled on client");
      }
      getPeer() {
        var _a, _b;
        return (_b = (_a = this.call) === null || _a === void 0 ? void 0 : _a.getPeer()) !== null && _b !== void 0 ? _b : "unknown";
      }
      _read(_size) {
        var _a;
        (_a = this.call) === null || _a === void 0 ? void 0 : _a.startRead();
      }
    };
    exports2.ClientReadableStreamImpl = ClientReadableStreamImpl;
    var ClientWritableStreamImpl = class extends stream_1.Writable {
      constructor(serialize) {
        super({ objectMode: true });
        this.serialize = serialize;
      }
      cancel() {
        var _a;
        (_a = this.call) === null || _a === void 0 ? void 0 : _a.cancelWithStatus(constants_1.Status.CANCELLED, "Cancelled on client");
      }
      getPeer() {
        var _a, _b;
        return (_b = (_a = this.call) === null || _a === void 0 ? void 0 : _a.getPeer()) !== null && _b !== void 0 ? _b : "unknown";
      }
      _write(chunk, encoding, cb) {
        var _a;
        const context = {
          callback: cb
        };
        const flags = Number(encoding);
        if (!Number.isNaN(flags)) {
          context.flags = flags;
        }
        (_a = this.call) === null || _a === void 0 ? void 0 : _a.sendMessageWithContext(context, chunk);
      }
      _final(cb) {
        var _a;
        (_a = this.call) === null || _a === void 0 ? void 0 : _a.halfClose();
        cb();
      }
    };
    exports2.ClientWritableStreamImpl = ClientWritableStreamImpl;
    var ClientDuplexStreamImpl = class extends stream_1.Duplex {
      constructor(serialize, deserialize) {
        super({ objectMode: true });
        this.serialize = serialize;
        this.deserialize = deserialize;
      }
      cancel() {
        var _a;
        (_a = this.call) === null || _a === void 0 ? void 0 : _a.cancelWithStatus(constants_1.Status.CANCELLED, "Cancelled on client");
      }
      getPeer() {
        var _a, _b;
        return (_b = (_a = this.call) === null || _a === void 0 ? void 0 : _a.getPeer()) !== null && _b !== void 0 ? _b : "unknown";
      }
      _read(_size) {
        var _a;
        (_a = this.call) === null || _a === void 0 ? void 0 : _a.startRead();
      }
      _write(chunk, encoding, cb) {
        var _a;
        const context = {
          callback: cb
        };
        const flags = Number(encoding);
        if (!Number.isNaN(flags)) {
          context.flags = flags;
        }
        (_a = this.call) === null || _a === void 0 ? void 0 : _a.sendMessageWithContext(context, chunk);
      }
      _final(cb) {
        var _a;
        (_a = this.call) === null || _a === void 0 ? void 0 : _a.halfClose();
        cb();
      }
    };
    exports2.ClientDuplexStreamImpl = ClientDuplexStreamImpl;
  }
});

// node_modules/@grpc/grpc-js/build/src/call-interface.js
var require_call_interface = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/call-interface.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.InterceptingListenerImpl = exports2.isInterceptingListener = void 0;
    function isInterceptingListener(listener) {
      return listener.onReceiveMetadata !== void 0 && listener.onReceiveMetadata.length === 1;
    }
    exports2.isInterceptingListener = isInterceptingListener;
    var InterceptingListenerImpl = class {
      constructor(listener, nextListener) {
        this.listener = listener;
        this.nextListener = nextListener;
        this.processingMetadata = false;
        this.hasPendingMessage = false;
        this.processingMessage = false;
        this.pendingStatus = null;
      }
      processPendingMessage() {
        if (this.hasPendingMessage) {
          this.nextListener.onReceiveMessage(this.pendingMessage);
          this.pendingMessage = null;
          this.hasPendingMessage = false;
        }
      }
      processPendingStatus() {
        if (this.pendingStatus) {
          this.nextListener.onReceiveStatus(this.pendingStatus);
        }
      }
      onReceiveMetadata(metadata) {
        this.processingMetadata = true;
        this.listener.onReceiveMetadata(metadata, (metadata2) => {
          this.processingMetadata = false;
          this.nextListener.onReceiveMetadata(metadata2);
          this.processPendingMessage();
          this.processPendingStatus();
        });
      }
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      onReceiveMessage(message) {
        this.processingMessage = true;
        this.listener.onReceiveMessage(message, (msg) => {
          this.processingMessage = false;
          if (this.processingMetadata) {
            this.pendingMessage = msg;
            this.hasPendingMessage = true;
          } else {
            this.nextListener.onReceiveMessage(msg);
            this.processPendingStatus();
          }
        });
      }
      onReceiveStatus(status) {
        this.listener.onReceiveStatus(status, (processedStatus) => {
          if (this.processingMetadata || this.processingMessage) {
            this.pendingStatus = processedStatus;
          } else {
            this.nextListener.onReceiveStatus(processedStatus);
          }
        });
      }
    };
    exports2.InterceptingListenerImpl = InterceptingListenerImpl;
  }
});

// node_modules/@grpc/grpc-js/build/src/client-interceptors.js
var require_client_interceptors = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/client-interceptors.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getInterceptingCall = exports2.InterceptingCall = exports2.RequesterBuilder = exports2.ListenerBuilder = exports2.InterceptorConfigurationError = void 0;
    var metadata_1 = require_metadata();
    var call_interface_1 = require_call_interface();
    var constants_1 = require_constants();
    var error_1 = require_error();
    var InterceptorConfigurationError = class extends Error {
      constructor(message) {
        super(message);
        this.name = "InterceptorConfigurationError";
        Error.captureStackTrace(this, InterceptorConfigurationError);
      }
    };
    exports2.InterceptorConfigurationError = InterceptorConfigurationError;
    var ListenerBuilder = class {
      constructor() {
        this.metadata = void 0;
        this.message = void 0;
        this.status = void 0;
      }
      withOnReceiveMetadata(onReceiveMetadata) {
        this.metadata = onReceiveMetadata;
        return this;
      }
      withOnReceiveMessage(onReceiveMessage) {
        this.message = onReceiveMessage;
        return this;
      }
      withOnReceiveStatus(onReceiveStatus) {
        this.status = onReceiveStatus;
        return this;
      }
      build() {
        return {
          onReceiveMetadata: this.metadata,
          onReceiveMessage: this.message,
          onReceiveStatus: this.status
        };
      }
    };
    exports2.ListenerBuilder = ListenerBuilder;
    var RequesterBuilder = class {
      constructor() {
        this.start = void 0;
        this.message = void 0;
        this.halfClose = void 0;
        this.cancel = void 0;
      }
      withStart(start) {
        this.start = start;
        return this;
      }
      withSendMessage(sendMessage) {
        this.message = sendMessage;
        return this;
      }
      withHalfClose(halfClose) {
        this.halfClose = halfClose;
        return this;
      }
      withCancel(cancel) {
        this.cancel = cancel;
        return this;
      }
      build() {
        return {
          start: this.start,
          sendMessage: this.message,
          halfClose: this.halfClose,
          cancel: this.cancel
        };
      }
    };
    exports2.RequesterBuilder = RequesterBuilder;
    var defaultListener = {
      onReceiveMetadata: (metadata, next) => {
        next(metadata);
      },
      onReceiveMessage: (message, next) => {
        next(message);
      },
      onReceiveStatus: (status, next) => {
        next(status);
      }
    };
    var defaultRequester = {
      start: (metadata, listener, next) => {
        next(metadata, listener);
      },
      sendMessage: (message, next) => {
        next(message);
      },
      halfClose: (next) => {
        next();
      },
      cancel: (next) => {
        next();
      }
    };
    var InterceptingCall = class {
      constructor(nextCall, requester) {
        var _a, _b, _c, _d;
        this.nextCall = nextCall;
        this.processingMetadata = false;
        this.pendingMessageContext = null;
        this.processingMessage = false;
        this.pendingHalfClose = false;
        if (requester) {
          this.requester = {
            start: (_a = requester.start) !== null && _a !== void 0 ? _a : defaultRequester.start,
            sendMessage: (_b = requester.sendMessage) !== null && _b !== void 0 ? _b : defaultRequester.sendMessage,
            halfClose: (_c = requester.halfClose) !== null && _c !== void 0 ? _c : defaultRequester.halfClose,
            cancel: (_d = requester.cancel) !== null && _d !== void 0 ? _d : defaultRequester.cancel
          };
        } else {
          this.requester = defaultRequester;
        }
      }
      cancelWithStatus(status, details) {
        this.requester.cancel(() => {
          this.nextCall.cancelWithStatus(status, details);
        });
      }
      getPeer() {
        return this.nextCall.getPeer();
      }
      processPendingMessage() {
        if (this.pendingMessageContext) {
          this.nextCall.sendMessageWithContext(this.pendingMessageContext, this.pendingMessage);
          this.pendingMessageContext = null;
          this.pendingMessage = null;
        }
      }
      processPendingHalfClose() {
        if (this.pendingHalfClose) {
          this.nextCall.halfClose();
        }
      }
      start(metadata, interceptingListener) {
        var _a, _b, _c, _d, _e, _f;
        const fullInterceptingListener = {
          onReceiveMetadata: (_b = (_a = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveMetadata) === null || _a === void 0 ? void 0 : _a.bind(interceptingListener)) !== null && _b !== void 0 ? _b : (metadata2) => {
          },
          onReceiveMessage: (_d = (_c = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveMessage) === null || _c === void 0 ? void 0 : _c.bind(interceptingListener)) !== null && _d !== void 0 ? _d : (message) => {
          },
          onReceiveStatus: (_f = (_e = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveStatus) === null || _e === void 0 ? void 0 : _e.bind(interceptingListener)) !== null && _f !== void 0 ? _f : (status) => {
          }
        };
        this.processingMetadata = true;
        this.requester.start(metadata, fullInterceptingListener, (md, listener) => {
          var _a2, _b2, _c2;
          this.processingMetadata = false;
          let finalInterceptingListener;
          if ((0, call_interface_1.isInterceptingListener)(listener)) {
            finalInterceptingListener = listener;
          } else {
            const fullListener = {
              onReceiveMetadata: (_a2 = listener.onReceiveMetadata) !== null && _a2 !== void 0 ? _a2 : defaultListener.onReceiveMetadata,
              onReceiveMessage: (_b2 = listener.onReceiveMessage) !== null && _b2 !== void 0 ? _b2 : defaultListener.onReceiveMessage,
              onReceiveStatus: (_c2 = listener.onReceiveStatus) !== null && _c2 !== void 0 ? _c2 : defaultListener.onReceiveStatus
            };
            finalInterceptingListener = new call_interface_1.InterceptingListenerImpl(fullListener, fullInterceptingListener);
          }
          this.nextCall.start(md, finalInterceptingListener);
          this.processPendingMessage();
          this.processPendingHalfClose();
        });
      }
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      sendMessageWithContext(context, message) {
        this.processingMessage = true;
        this.requester.sendMessage(message, (finalMessage) => {
          this.processingMessage = false;
          if (this.processingMetadata) {
            this.pendingMessageContext = context;
            this.pendingMessage = message;
          } else {
            this.nextCall.sendMessageWithContext(context, finalMessage);
            this.processPendingHalfClose();
          }
        });
      }
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      sendMessage(message) {
        this.sendMessageWithContext({}, message);
      }
      startRead() {
        this.nextCall.startRead();
      }
      halfClose() {
        this.requester.halfClose(() => {
          if (this.processingMetadata || this.processingMessage) {
            this.pendingHalfClose = true;
          } else {
            this.nextCall.halfClose();
          }
        });
      }
    };
    exports2.InterceptingCall = InterceptingCall;
    function getCall(channel, path2, options) {
      var _a, _b;
      const deadline = (_a = options.deadline) !== null && _a !== void 0 ? _a : Infinity;
      const host = options.host;
      const parent = (_b = options.parent) !== null && _b !== void 0 ? _b : null;
      const propagateFlags = options.propagate_flags;
      const credentials2 = options.credentials;
      const call = channel.createCall(path2, deadline, host, parent, propagateFlags);
      if (credentials2) {
        call.setCredentials(credentials2);
      }
      return call;
    }
    var BaseInterceptingCall = class {
      constructor(call, methodDefinition) {
        this.call = call;
        this.methodDefinition = methodDefinition;
      }
      cancelWithStatus(status, details) {
        this.call.cancelWithStatus(status, details);
      }
      getPeer() {
        return this.call.getPeer();
      }
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      sendMessageWithContext(context, message) {
        let serialized;
        try {
          serialized = this.methodDefinition.requestSerialize(message);
        } catch (e2) {
          this.call.cancelWithStatus(constants_1.Status.INTERNAL, `Request message serialization failure: ${(0, error_1.getErrorMessage)(e2)}`);
          return;
        }
        this.call.sendMessageWithContext(context, serialized);
      }
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      sendMessage(message) {
        this.sendMessageWithContext({}, message);
      }
      start(metadata, interceptingListener) {
        let readError = null;
        this.call.start(metadata, {
          onReceiveMetadata: (metadata2) => {
            var _a;
            (_a = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveMetadata) === null || _a === void 0 ? void 0 : _a.call(interceptingListener, metadata2);
          },
          onReceiveMessage: (message) => {
            var _a;
            let deserialized;
            try {
              deserialized = this.methodDefinition.responseDeserialize(message);
            } catch (e2) {
              readError = {
                code: constants_1.Status.INTERNAL,
                details: `Response message parsing error: ${(0, error_1.getErrorMessage)(e2)}`,
                metadata: new metadata_1.Metadata()
              };
              this.call.cancelWithStatus(readError.code, readError.details);
              return;
            }
            (_a = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveMessage) === null || _a === void 0 ? void 0 : _a.call(interceptingListener, deserialized);
          },
          onReceiveStatus: (status) => {
            var _a, _b;
            if (readError) {
              (_a = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveStatus) === null || _a === void 0 ? void 0 : _a.call(interceptingListener, readError);
            } else {
              (_b = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveStatus) === null || _b === void 0 ? void 0 : _b.call(interceptingListener, status);
            }
          }
        });
      }
      startRead() {
        this.call.startRead();
      }
      halfClose() {
        this.call.halfClose();
      }
    };
    var BaseUnaryInterceptingCall = class extends BaseInterceptingCall {
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      constructor(call, methodDefinition) {
        super(call, methodDefinition);
      }
      start(metadata, listener) {
        var _a, _b;
        let receivedMessage = false;
        const wrapperListener = {
          onReceiveMetadata: (_b = (_a = listener === null || listener === void 0 ? void 0 : listener.onReceiveMetadata) === null || _a === void 0 ? void 0 : _a.bind(listener)) !== null && _b !== void 0 ? _b : (metadata2) => {
          },
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          onReceiveMessage: (message) => {
            var _a2;
            receivedMessage = true;
            (_a2 = listener === null || listener === void 0 ? void 0 : listener.onReceiveMessage) === null || _a2 === void 0 ? void 0 : _a2.call(listener, message);
          },
          onReceiveStatus: (status) => {
            var _a2, _b2;
            if (!receivedMessage) {
              (_a2 = listener === null || listener === void 0 ? void 0 : listener.onReceiveMessage) === null || _a2 === void 0 ? void 0 : _a2.call(listener, null);
            }
            (_b2 = listener === null || listener === void 0 ? void 0 : listener.onReceiveStatus) === null || _b2 === void 0 ? void 0 : _b2.call(listener, status);
          }
        };
        super.start(metadata, wrapperListener);
        this.call.startRead();
      }
    };
    var BaseStreamingInterceptingCall = class extends BaseInterceptingCall {
    };
    function getBottomInterceptingCall(channel, options, methodDefinition) {
      const call = getCall(channel, methodDefinition.path, options);
      if (methodDefinition.responseStream) {
        return new BaseStreamingInterceptingCall(call, methodDefinition);
      } else {
        return new BaseUnaryInterceptingCall(call, methodDefinition);
      }
    }
    function getInterceptingCall(interceptorArgs, methodDefinition, options, channel) {
      if (interceptorArgs.clientInterceptors.length > 0 && interceptorArgs.clientInterceptorProviders.length > 0) {
        throw new InterceptorConfigurationError("Both interceptors and interceptor_providers were passed as options to the client constructor. Only one of these is allowed.");
      }
      if (interceptorArgs.callInterceptors.length > 0 && interceptorArgs.callInterceptorProviders.length > 0) {
        throw new InterceptorConfigurationError("Both interceptors and interceptor_providers were passed as call options. Only one of these is allowed.");
      }
      let interceptors = [];
      if (interceptorArgs.callInterceptors.length > 0 || interceptorArgs.callInterceptorProviders.length > 0) {
        interceptors = [].concat(interceptorArgs.callInterceptors, interceptorArgs.callInterceptorProviders.map((provider) => provider(methodDefinition))).filter((interceptor) => interceptor);
      } else {
        interceptors = [].concat(interceptorArgs.clientInterceptors, interceptorArgs.clientInterceptorProviders.map((provider) => provider(methodDefinition))).filter((interceptor) => interceptor);
      }
      const interceptorOptions = Object.assign({}, options, {
        method_definition: methodDefinition
      });
      const getCall2 = interceptors.reduceRight((nextCall, nextInterceptor) => {
        return (currentOptions) => nextInterceptor(currentOptions, nextCall);
      }, (finalOptions) => getBottomInterceptingCall(channel, finalOptions, methodDefinition));
      return getCall2(interceptorOptions);
    }
    exports2.getInterceptingCall = getInterceptingCall;
  }
});

// node_modules/@grpc/grpc-js/build/src/client.js
var require_client = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/client.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Client = void 0;
    var call_1 = require_call();
    var channel_1 = require_channel();
    var connectivity_state_1 = require_connectivity_state();
    var constants_1 = require_constants();
    var metadata_1 = require_metadata();
    var client_interceptors_1 = require_client_interceptors();
    var CHANNEL_SYMBOL = Symbol();
    var INTERCEPTOR_SYMBOL = Symbol();
    var INTERCEPTOR_PROVIDER_SYMBOL = Symbol();
    var CALL_INVOCATION_TRANSFORMER_SYMBOL = Symbol();
    function isFunction(arg) {
      return typeof arg === "function";
    }
    function getErrorStackString(error) {
      return error.stack.split("\n").slice(1).join("\n");
    }
    var Client = class {
      constructor(address, credentials2, options = {}) {
        var _a, _b;
        options = Object.assign({}, options);
        this[INTERCEPTOR_SYMBOL] = (_a = options.interceptors) !== null && _a !== void 0 ? _a : [];
        delete options.interceptors;
        this[INTERCEPTOR_PROVIDER_SYMBOL] = (_b = options.interceptor_providers) !== null && _b !== void 0 ? _b : [];
        delete options.interceptor_providers;
        if (this[INTERCEPTOR_SYMBOL].length > 0 && this[INTERCEPTOR_PROVIDER_SYMBOL].length > 0) {
          throw new Error("Both interceptors and interceptor_providers were passed as options to the client constructor. Only one of these is allowed.");
        }
        this[CALL_INVOCATION_TRANSFORMER_SYMBOL] = options.callInvocationTransformer;
        delete options.callInvocationTransformer;
        if (options.channelOverride) {
          this[CHANNEL_SYMBOL] = options.channelOverride;
        } else if (options.channelFactoryOverride) {
          const channelFactoryOverride = options.channelFactoryOverride;
          delete options.channelFactoryOverride;
          this[CHANNEL_SYMBOL] = channelFactoryOverride(address, credentials2, options);
        } else {
          this[CHANNEL_SYMBOL] = new channel_1.ChannelImplementation(address, credentials2, options);
        }
      }
      close() {
        this[CHANNEL_SYMBOL].close();
      }
      getChannel() {
        return this[CHANNEL_SYMBOL];
      }
      waitForReady(deadline, callback) {
        const checkState = (err) => {
          if (err) {
            callback(new Error("Failed to connect before the deadline"));
            return;
          }
          let newState;
          try {
            newState = this[CHANNEL_SYMBOL].getConnectivityState(true);
          } catch (e2) {
            callback(new Error("The channel has been closed"));
            return;
          }
          if (newState === connectivity_state_1.ConnectivityState.READY) {
            callback();
          } else {
            try {
              this[CHANNEL_SYMBOL].watchConnectivityState(newState, deadline, checkState);
            } catch (e2) {
              callback(new Error("The channel has been closed"));
            }
          }
        };
        setImmediate(checkState);
      }
      checkOptionalUnaryResponseArguments(arg1, arg2, arg3) {
        if (isFunction(arg1)) {
          return { metadata: new metadata_1.Metadata(), options: {}, callback: arg1 };
        } else if (isFunction(arg2)) {
          if (arg1 instanceof metadata_1.Metadata) {
            return { metadata: arg1, options: {}, callback: arg2 };
          } else {
            return { metadata: new metadata_1.Metadata(), options: arg1, callback: arg2 };
          }
        } else {
          if (!(arg1 instanceof metadata_1.Metadata && arg2 instanceof Object && isFunction(arg3))) {
            throw new Error("Incorrect arguments passed");
          }
          return { metadata: arg1, options: arg2, callback: arg3 };
        }
      }
      makeUnaryRequest(method, serialize, deserialize, argument, metadata, options, callback) {
        var _a, _b;
        const checkedArguments = this.checkOptionalUnaryResponseArguments(metadata, options, callback);
        const methodDefinition = {
          path: method,
          requestStream: false,
          responseStream: false,
          requestSerialize: serialize,
          responseDeserialize: deserialize
        };
        let callProperties = {
          argument,
          metadata: checkedArguments.metadata,
          call: new call_1.ClientUnaryCallImpl(),
          channel: this[CHANNEL_SYMBOL],
          methodDefinition,
          callOptions: checkedArguments.options,
          callback: checkedArguments.callback
        };
        if (this[CALL_INVOCATION_TRANSFORMER_SYMBOL]) {
          callProperties = this[CALL_INVOCATION_TRANSFORMER_SYMBOL](callProperties);
        }
        const emitter = callProperties.call;
        const interceptorArgs = {
          clientInterceptors: this[INTERCEPTOR_SYMBOL],
          clientInterceptorProviders: this[INTERCEPTOR_PROVIDER_SYMBOL],
          callInterceptors: (_a = callProperties.callOptions.interceptors) !== null && _a !== void 0 ? _a : [],
          callInterceptorProviders: (_b = callProperties.callOptions.interceptor_providers) !== null && _b !== void 0 ? _b : []
        };
        const call = (0, client_interceptors_1.getInterceptingCall)(interceptorArgs, callProperties.methodDefinition, callProperties.callOptions, callProperties.channel);
        emitter.call = call;
        let responseMessage = null;
        let receivedStatus = false;
        const callerStackError = new Error();
        call.start(callProperties.metadata, {
          onReceiveMetadata: (metadata2) => {
            emitter.emit("metadata", metadata2);
          },
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          onReceiveMessage(message) {
            if (responseMessage !== null) {
              call.cancelWithStatus(constants_1.Status.INTERNAL, "Too many responses received");
            }
            responseMessage = message;
          },
          onReceiveStatus(status) {
            if (receivedStatus) {
              return;
            }
            receivedStatus = true;
            if (status.code === constants_1.Status.OK) {
              if (responseMessage === null) {
                const callerStack = getErrorStackString(callerStackError);
                callProperties.callback((0, call_1.callErrorFromStatus)({
                  code: constants_1.Status.INTERNAL,
                  details: "No message received",
                  metadata: status.metadata
                }, callerStack));
              } else {
                callProperties.callback(null, responseMessage);
              }
            } else {
              const callerStack = getErrorStackString(callerStackError);
              callProperties.callback((0, call_1.callErrorFromStatus)(status, callerStack));
            }
            emitter.emit("status", status);
          }
        });
        call.sendMessage(argument);
        call.halfClose();
        return emitter;
      }
      makeClientStreamRequest(method, serialize, deserialize, metadata, options, callback) {
        var _a, _b;
        const checkedArguments = this.checkOptionalUnaryResponseArguments(metadata, options, callback);
        const methodDefinition = {
          path: method,
          requestStream: true,
          responseStream: false,
          requestSerialize: serialize,
          responseDeserialize: deserialize
        };
        let callProperties = {
          metadata: checkedArguments.metadata,
          call: new call_1.ClientWritableStreamImpl(serialize),
          channel: this[CHANNEL_SYMBOL],
          methodDefinition,
          callOptions: checkedArguments.options,
          callback: checkedArguments.callback
        };
        if (this[CALL_INVOCATION_TRANSFORMER_SYMBOL]) {
          callProperties = this[CALL_INVOCATION_TRANSFORMER_SYMBOL](callProperties);
        }
        const emitter = callProperties.call;
        const interceptorArgs = {
          clientInterceptors: this[INTERCEPTOR_SYMBOL],
          clientInterceptorProviders: this[INTERCEPTOR_PROVIDER_SYMBOL],
          callInterceptors: (_a = callProperties.callOptions.interceptors) !== null && _a !== void 0 ? _a : [],
          callInterceptorProviders: (_b = callProperties.callOptions.interceptor_providers) !== null && _b !== void 0 ? _b : []
        };
        const call = (0, client_interceptors_1.getInterceptingCall)(interceptorArgs, callProperties.methodDefinition, callProperties.callOptions, callProperties.channel);
        emitter.call = call;
        let responseMessage = null;
        let receivedStatus = false;
        const callerStackError = new Error();
        call.start(callProperties.metadata, {
          onReceiveMetadata: (metadata2) => {
            emitter.emit("metadata", metadata2);
          },
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          onReceiveMessage(message) {
            if (responseMessage !== null) {
              call.cancelWithStatus(constants_1.Status.INTERNAL, "Too many responses received");
            }
            responseMessage = message;
          },
          onReceiveStatus(status) {
            if (receivedStatus) {
              return;
            }
            receivedStatus = true;
            if (status.code === constants_1.Status.OK) {
              if (responseMessage === null) {
                const callerStack = getErrorStackString(callerStackError);
                callProperties.callback((0, call_1.callErrorFromStatus)({
                  code: constants_1.Status.INTERNAL,
                  details: "No message received",
                  metadata: status.metadata
                }, callerStack));
              } else {
                callProperties.callback(null, responseMessage);
              }
            } else {
              const callerStack = getErrorStackString(callerStackError);
              callProperties.callback((0, call_1.callErrorFromStatus)(status, callerStack));
            }
            emitter.emit("status", status);
          }
        });
        return emitter;
      }
      checkMetadataAndOptions(arg1, arg2) {
        let metadata;
        let options;
        if (arg1 instanceof metadata_1.Metadata) {
          metadata = arg1;
          if (arg2) {
            options = arg2;
          } else {
            options = {};
          }
        } else {
          if (arg1) {
            options = arg1;
          } else {
            options = {};
          }
          metadata = new metadata_1.Metadata();
        }
        return { metadata, options };
      }
      makeServerStreamRequest(method, serialize, deserialize, argument, metadata, options) {
        var _a, _b;
        const checkedArguments = this.checkMetadataAndOptions(metadata, options);
        const methodDefinition = {
          path: method,
          requestStream: false,
          responseStream: true,
          requestSerialize: serialize,
          responseDeserialize: deserialize
        };
        let callProperties = {
          argument,
          metadata: checkedArguments.metadata,
          call: new call_1.ClientReadableStreamImpl(deserialize),
          channel: this[CHANNEL_SYMBOL],
          methodDefinition,
          callOptions: checkedArguments.options
        };
        if (this[CALL_INVOCATION_TRANSFORMER_SYMBOL]) {
          callProperties = this[CALL_INVOCATION_TRANSFORMER_SYMBOL](callProperties);
        }
        const stream = callProperties.call;
        const interceptorArgs = {
          clientInterceptors: this[INTERCEPTOR_SYMBOL],
          clientInterceptorProviders: this[INTERCEPTOR_PROVIDER_SYMBOL],
          callInterceptors: (_a = callProperties.callOptions.interceptors) !== null && _a !== void 0 ? _a : [],
          callInterceptorProviders: (_b = callProperties.callOptions.interceptor_providers) !== null && _b !== void 0 ? _b : []
        };
        const call = (0, client_interceptors_1.getInterceptingCall)(interceptorArgs, callProperties.methodDefinition, callProperties.callOptions, callProperties.channel);
        stream.call = call;
        let receivedStatus = false;
        const callerStackError = new Error();
        call.start(callProperties.metadata, {
          onReceiveMetadata(metadata2) {
            stream.emit("metadata", metadata2);
          },
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          onReceiveMessage(message) {
            stream.push(message);
          },
          onReceiveStatus(status) {
            if (receivedStatus) {
              return;
            }
            receivedStatus = true;
            stream.push(null);
            if (status.code !== constants_1.Status.OK) {
              const callerStack = getErrorStackString(callerStackError);
              stream.emit("error", (0, call_1.callErrorFromStatus)(status, callerStack));
            }
            stream.emit("status", status);
          }
        });
        call.sendMessage(argument);
        call.halfClose();
        return stream;
      }
      makeBidiStreamRequest(method, serialize, deserialize, metadata, options) {
        var _a, _b;
        const checkedArguments = this.checkMetadataAndOptions(metadata, options);
        const methodDefinition = {
          path: method,
          requestStream: true,
          responseStream: true,
          requestSerialize: serialize,
          responseDeserialize: deserialize
        };
        let callProperties = {
          metadata: checkedArguments.metadata,
          call: new call_1.ClientDuplexStreamImpl(serialize, deserialize),
          channel: this[CHANNEL_SYMBOL],
          methodDefinition,
          callOptions: checkedArguments.options
        };
        if (this[CALL_INVOCATION_TRANSFORMER_SYMBOL]) {
          callProperties = this[CALL_INVOCATION_TRANSFORMER_SYMBOL](callProperties);
        }
        const stream = callProperties.call;
        const interceptorArgs = {
          clientInterceptors: this[INTERCEPTOR_SYMBOL],
          clientInterceptorProviders: this[INTERCEPTOR_PROVIDER_SYMBOL],
          callInterceptors: (_a = callProperties.callOptions.interceptors) !== null && _a !== void 0 ? _a : [],
          callInterceptorProviders: (_b = callProperties.callOptions.interceptor_providers) !== null && _b !== void 0 ? _b : []
        };
        const call = (0, client_interceptors_1.getInterceptingCall)(interceptorArgs, callProperties.methodDefinition, callProperties.callOptions, callProperties.channel);
        stream.call = call;
        let receivedStatus = false;
        const callerStackError = new Error();
        call.start(callProperties.metadata, {
          onReceiveMetadata(metadata2) {
            stream.emit("metadata", metadata2);
          },
          onReceiveMessage(message) {
            stream.push(message);
          },
          onReceiveStatus(status) {
            if (receivedStatus) {
              return;
            }
            receivedStatus = true;
            stream.push(null);
            if (status.code !== constants_1.Status.OK) {
              const callerStack = getErrorStackString(callerStackError);
              stream.emit("error", (0, call_1.callErrorFromStatus)(status, callerStack));
            }
            stream.emit("status", status);
          }
        });
        return stream;
      }
    };
    exports2.Client = Client;
  }
});

// node_modules/@grpc/grpc-js/build/src/make-client.js
var require_make_client = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/make-client.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.loadPackageDefinition = exports2.makeClientConstructor = void 0;
    var client_1 = require_client();
    var requesterFuncs = {
      unary: client_1.Client.prototype.makeUnaryRequest,
      server_stream: client_1.Client.prototype.makeServerStreamRequest,
      client_stream: client_1.Client.prototype.makeClientStreamRequest,
      bidi: client_1.Client.prototype.makeBidiStreamRequest
    };
    function isPrototypePolluted(key) {
      return ["__proto__", "prototype", "constructor"].includes(key);
    }
    function makeClientConstructor(methods, serviceName, classOptions) {
      if (!classOptions) {
        classOptions = {};
      }
      class ServiceClientImpl extends client_1.Client {
      }
      Object.keys(methods).forEach((name) => {
        if (isPrototypePolluted(name)) {
          return;
        }
        const attrs = methods[name];
        let methodType;
        if (typeof name === "string" && name.charAt(0) === "$") {
          throw new Error("Method names cannot start with $");
        }
        if (attrs.requestStream) {
          if (attrs.responseStream) {
            methodType = "bidi";
          } else {
            methodType = "client_stream";
          }
        } else {
          if (attrs.responseStream) {
            methodType = "server_stream";
          } else {
            methodType = "unary";
          }
        }
        const serialize = attrs.requestSerialize;
        const deserialize = attrs.responseDeserialize;
        const methodFunc = partial(requesterFuncs[methodType], attrs.path, serialize, deserialize);
        ServiceClientImpl.prototype[name] = methodFunc;
        Object.assign(ServiceClientImpl.prototype[name], attrs);
        if (attrs.originalName && !isPrototypePolluted(attrs.originalName)) {
          ServiceClientImpl.prototype[attrs.originalName] = ServiceClientImpl.prototype[name];
        }
      });
      ServiceClientImpl.service = methods;
      ServiceClientImpl.serviceName = serviceName;
      return ServiceClientImpl;
    }
    exports2.makeClientConstructor = makeClientConstructor;
    function partial(fn, path2, serialize, deserialize) {
      return function(...args) {
        return fn.call(this, path2, serialize, deserialize, ...args);
      };
    }
    function isProtobufTypeDefinition(obj) {
      return "format" in obj;
    }
    function loadPackageDefinition(packageDef) {
      const result = {};
      for (const serviceFqn in packageDef) {
        if (Object.prototype.hasOwnProperty.call(packageDef, serviceFqn)) {
          const service = packageDef[serviceFqn];
          const nameComponents = serviceFqn.split(".");
          if (nameComponents.some((comp) => isPrototypePolluted(comp))) {
            continue;
          }
          const serviceName = nameComponents[nameComponents.length - 1];
          let current = result;
          for (const packageName of nameComponents.slice(0, -1)) {
            if (!current[packageName]) {
              current[packageName] = {};
            }
            current = current[packageName];
          }
          if (isProtobufTypeDefinition(service)) {
            current[serviceName] = service;
          } else {
            current[serviceName] = makeClientConstructor(service, serviceName, {});
          }
        }
      }
      return result;
    }
    exports2.loadPackageDefinition = loadPackageDefinition;
  }
});

// node_modules/lodash.camelcase/index.js
var require_lodash = __commonJS({
  "node_modules/lodash.camelcase/index.js"(exports2, module2) {
    var INFINITY = 1 / 0;
    var symbolTag = "[object Symbol]";
    var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
    var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
    var rsAstralRange = "\\ud800-\\udfff";
    var rsComboMarksRange = "\\u0300-\\u036f\\ufe20-\\ufe23";
    var rsComboSymbolsRange = "\\u20d0-\\u20f0";
    var rsDingbatRange = "\\u2700-\\u27bf";
    var rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff";
    var rsMathOpRange = "\\xac\\xb1\\xd7\\xf7";
    var rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf";
    var rsPunctuationRange = "\\u2000-\\u206f";
    var rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000";
    var rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde";
    var rsVarRange = "\\ufe0e\\ufe0f";
    var rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
    var rsApos = "['\u2019]";
    var rsAstral = "[" + rsAstralRange + "]";
    var rsBreak = "[" + rsBreakRange + "]";
    var rsCombo = "[" + rsComboMarksRange + rsComboSymbolsRange + "]";
    var rsDigits = "\\d+";
    var rsDingbat = "[" + rsDingbatRange + "]";
    var rsLower = "[" + rsLowerRange + "]";
    var rsMisc = "[^" + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]";
    var rsFitz = "\\ud83c[\\udffb-\\udfff]";
    var rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")";
    var rsNonAstral = "[^" + rsAstralRange + "]";
    var rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}";
    var rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]";
    var rsUpper = "[" + rsUpperRange + "]";
    var rsZWJ = "\\u200d";
    var rsLowerMisc = "(?:" + rsLower + "|" + rsMisc + ")";
    var rsUpperMisc = "(?:" + rsUpper + "|" + rsMisc + ")";
    var rsOptLowerContr = "(?:" + rsApos + "(?:d|ll|m|re|s|t|ve))?";
    var rsOptUpperContr = "(?:" + rsApos + "(?:D|LL|M|RE|S|T|VE))?";
    var reOptMod = rsModifier + "?";
    var rsOptVar = "[" + rsVarRange + "]?";
    var rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*";
    var rsSeq = rsOptVar + reOptMod + rsOptJoin;
    var rsEmoji = "(?:" + [rsDingbat, rsRegional, rsSurrPair].join("|") + ")" + rsSeq;
    var rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
    var reApos = RegExp(rsApos, "g");
    var reComboMark = RegExp(rsCombo, "g");
    var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
    var reUnicodeWord = RegExp([
      rsUpper + "?" + rsLower + "+" + rsOptLowerContr + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")",
      rsUpperMisc + "+" + rsOptUpperContr + "(?=" + [rsBreak, rsUpper + rsLowerMisc, "$"].join("|") + ")",
      rsUpper + "?" + rsLowerMisc + "+" + rsOptLowerContr,
      rsUpper + "+" + rsOptUpperContr,
      rsDigits,
      rsEmoji
    ].join("|"), "g");
    var reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboMarksRange + rsComboSymbolsRange + rsVarRange + "]");
    var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2,}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
    var deburredLetters = {
      // Latin-1 Supplement block.
      "\xC0": "A",
      "\xC1": "A",
      "\xC2": "A",
      "\xC3": "A",
      "\xC4": "A",
      "\xC5": "A",
      "\xE0": "a",
      "\xE1": "a",
      "\xE2": "a",
      "\xE3": "a",
      "\xE4": "a",
      "\xE5": "a",
      "\xC7": "C",
      "\xE7": "c",
      "\xD0": "D",
      "\xF0": "d",
      "\xC8": "E",
      "\xC9": "E",
      "\xCA": "E",
      "\xCB": "E",
      "\xE8": "e",
      "\xE9": "e",
      "\xEA": "e",
      "\xEB": "e",
      "\xCC": "I",
      "\xCD": "I",
      "\xCE": "I",
      "\xCF": "I",
      "\xEC": "i",
      "\xED": "i",
      "\xEE": "i",
      "\xEF": "i",
      "\xD1": "N",
      "\xF1": "n",
      "\xD2": "O",
      "\xD3": "O",
      "\xD4": "O",
      "\xD5": "O",
      "\xD6": "O",
      "\xD8": "O",
      "\xF2": "o",
      "\xF3": "o",
      "\xF4": "o",
      "\xF5": "o",
      "\xF6": "o",
      "\xF8": "o",
      "\xD9": "U",
      "\xDA": "U",
      "\xDB": "U",
      "\xDC": "U",
      "\xF9": "u",
      "\xFA": "u",
      "\xFB": "u",
      "\xFC": "u",
      "\xDD": "Y",
      "\xFD": "y",
      "\xFF": "y",
      "\xC6": "Ae",
      "\xE6": "ae",
      "\xDE": "Th",
      "\xFE": "th",
      "\xDF": "ss",
      // Latin Extended-A block.
      "\u0100": "A",
      "\u0102": "A",
      "\u0104": "A",
      "\u0101": "a",
      "\u0103": "a",
      "\u0105": "a",
      "\u0106": "C",
      "\u0108": "C",
      "\u010A": "C",
      "\u010C": "C",
      "\u0107": "c",
      "\u0109": "c",
      "\u010B": "c",
      "\u010D": "c",
      "\u010E": "D",
      "\u0110": "D",
      "\u010F": "d",
      "\u0111": "d",
      "\u0112": "E",
      "\u0114": "E",
      "\u0116": "E",
      "\u0118": "E",
      "\u011A": "E",
      "\u0113": "e",
      "\u0115": "e",
      "\u0117": "e",
      "\u0119": "e",
      "\u011B": "e",
      "\u011C": "G",
      "\u011E": "G",
      "\u0120": "G",
      "\u0122": "G",
      "\u011D": "g",
      "\u011F": "g",
      "\u0121": "g",
      "\u0123": "g",
      "\u0124": "H",
      "\u0126": "H",
      "\u0125": "h",
      "\u0127": "h",
      "\u0128": "I",
      "\u012A": "I",
      "\u012C": "I",
      "\u012E": "I",
      "\u0130": "I",
      "\u0129": "i",
      "\u012B": "i",
      "\u012D": "i",
      "\u012F": "i",
      "\u0131": "i",
      "\u0134": "J",
      "\u0135": "j",
      "\u0136": "K",
      "\u0137": "k",
      "\u0138": "k",
      "\u0139": "L",
      "\u013B": "L",
      "\u013D": "L",
      "\u013F": "L",
      "\u0141": "L",
      "\u013A": "l",
      "\u013C": "l",
      "\u013E": "l",
      "\u0140": "l",
      "\u0142": "l",
      "\u0143": "N",
      "\u0145": "N",
      "\u0147": "N",
      "\u014A": "N",
      "\u0144": "n",
      "\u0146": "n",
      "\u0148": "n",
      "\u014B": "n",
      "\u014C": "O",
      "\u014E": "O",
      "\u0150": "O",
      "\u014D": "o",
      "\u014F": "o",
      "\u0151": "o",
      "\u0154": "R",
      "\u0156": "R",
      "\u0158": "R",
      "\u0155": "r",
      "\u0157": "r",
      "\u0159": "r",
      "\u015A": "S",
      "\u015C": "S",
      "\u015E": "S",
      "\u0160": "S",
      "\u015B": "s",
      "\u015D": "s",
      "\u015F": "s",
      "\u0161": "s",
      "\u0162": "T",
      "\u0164": "T",
      "\u0166": "T",
      "\u0163": "t",
      "\u0165": "t",
      "\u0167": "t",
      "\u0168": "U",
      "\u016A": "U",
      "\u016C": "U",
      "\u016E": "U",
      "\u0170": "U",
      "\u0172": "U",
      "\u0169": "u",
      "\u016B": "u",
      "\u016D": "u",
      "\u016F": "u",
      "\u0171": "u",
      "\u0173": "u",
      "\u0174": "W",
      "\u0175": "w",
      "\u0176": "Y",
      "\u0177": "y",
      "\u0178": "Y",
      "\u0179": "Z",
      "\u017B": "Z",
      "\u017D": "Z",
      "\u017A": "z",
      "\u017C": "z",
      "\u017E": "z",
      "\u0132": "IJ",
      "\u0133": "ij",
      "\u0152": "Oe",
      "\u0153": "oe",
      "\u0149": "'n",
      "\u017F": "ss"
    };
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    function arrayReduce(array, iteratee, accumulator, initAccum) {
      var index = -1, length = array ? array.length : 0;
      if (initAccum && length) {
        accumulator = array[++index];
      }
      while (++index < length) {
        accumulator = iteratee(accumulator, array[index], index, array);
      }
      return accumulator;
    }
    function asciiToArray(string) {
      return string.split("");
    }
    function asciiWords(string) {
      return string.match(reAsciiWord) || [];
    }
    function basePropertyOf(object) {
      return function(key) {
        return object == null ? void 0 : object[key];
      };
    }
    var deburrLetter = basePropertyOf(deburredLetters);
    function hasUnicode(string) {
      return reHasUnicode.test(string);
    }
    function hasUnicodeWord(string) {
      return reHasUnicodeWord.test(string);
    }
    function stringToArray(string) {
      return hasUnicode(string) ? unicodeToArray(string) : asciiToArray(string);
    }
    function unicodeToArray(string) {
      return string.match(reUnicode) || [];
    }
    function unicodeWords(string) {
      return string.match(reUnicodeWord) || [];
    }
    var objectProto = Object.prototype;
    var objectToString = objectProto.toString;
    var Symbol2 = root.Symbol;
    var symbolProto = Symbol2 ? Symbol2.prototype : void 0;
    var symbolToString = symbolProto ? symbolProto.toString : void 0;
    function baseSlice(array, start, end) {
      var index = -1, length = array.length;
      if (start < 0) {
        start = -start > length ? 0 : length + start;
      }
      end = end > length ? length : end;
      if (end < 0) {
        end += length;
      }
      length = start > end ? 0 : end - start >>> 0;
      start >>>= 0;
      var result = Array(length);
      while (++index < length) {
        result[index] = array[index + start];
      }
      return result;
    }
    function baseToString(value) {
      if (typeof value == "string") {
        return value;
      }
      if (isSymbol(value)) {
        return symbolToString ? symbolToString.call(value) : "";
      }
      var result = value + "";
      return result == "0" && 1 / value == -INFINITY ? "-0" : result;
    }
    function castSlice(array, start, end) {
      var length = array.length;
      end = end === void 0 ? length : end;
      return !start && end >= length ? array : baseSlice(array, start, end);
    }
    function createCaseFirst(methodName) {
      return function(string) {
        string = toString(string);
        var strSymbols = hasUnicode(string) ? stringToArray(string) : void 0;
        var chr = strSymbols ? strSymbols[0] : string.charAt(0);
        var trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string.slice(1);
        return chr[methodName]() + trailing;
      };
    }
    function createCompounder(callback) {
      return function(string) {
        return arrayReduce(words(deburr(string).replace(reApos, "")), callback, "");
      };
    }
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function isSymbol(value) {
      return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
    }
    function toString(value) {
      return value == null ? "" : baseToString(value);
    }
    var camelCase = createCompounder(function(result, word, index) {
      word = word.toLowerCase();
      return result + (index ? capitalize(word) : word);
    });
    function capitalize(string) {
      return upperFirst(toString(string).toLowerCase());
    }
    function deburr(string) {
      string = toString(string);
      return string && string.replace(reLatin, deburrLetter).replace(reComboMark, "");
    }
    var upperFirst = createCaseFirst("toUpperCase");
    function words(string, pattern, guard) {
      string = toString(string);
      pattern = guard ? void 0 : pattern;
      if (pattern === void 0) {
        return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
      }
      return string.match(pattern) || [];
    }
    module2.exports = camelCase;
  }
});

// node_modules/@protobufjs/aspromise/index.js
var require_aspromise = __commonJS({
  "node_modules/@protobufjs/aspromise/index.js"(exports2, module2) {
    "use strict";
    module2.exports = asPromise;
    function asPromise(fn, ctx) {
      var params = new Array(arguments.length - 1), offset = 0, index = 2, pending = true;
      while (index < arguments.length)
        params[offset++] = arguments[index++];
      return new Promise(function executor(resolve, reject) {
        params[offset] = function callback(err) {
          if (pending) {
            pending = false;
            if (err)
              reject(err);
            else {
              var params2 = new Array(arguments.length - 1), offset2 = 0;
              while (offset2 < params2.length)
                params2[offset2++] = arguments[offset2];
              resolve.apply(null, params2);
            }
          }
        };
        try {
          fn.apply(ctx || null, params);
        } catch (err) {
          if (pending) {
            pending = false;
            reject(err);
          }
        }
      });
    }
  }
});

// node_modules/@protobufjs/base64/index.js
var require_base64 = __commonJS({
  "node_modules/@protobufjs/base64/index.js"(exports2) {
    "use strict";
    var base64 = exports2;
    base64.length = function length(string) {
      var p = string.length;
      if (!p)
        return 0;
      var n = 0;
      while (--p % 4 > 1 && string.charAt(p) === "=")
        ++n;
      return Math.ceil(string.length * 3) / 4 - n;
    };
    var b64 = new Array(64);
    var s64 = new Array(123);
    for (i = 0; i < 64; )
      s64[b64[i] = i < 26 ? i + 65 : i < 52 ? i + 71 : i < 62 ? i - 4 : i - 59 | 43] = i++;
    var i;
    base64.encode = function encode3(buffer, start, end) {
      var parts = null, chunk = [];
      var i2 = 0, j = 0, t;
      while (start < end) {
        var b2 = buffer[start++];
        switch (j) {
          case 0:
            chunk[i2++] = b64[b2 >> 2];
            t = (b2 & 3) << 4;
            j = 1;
            break;
          case 1:
            chunk[i2++] = b64[t | b2 >> 4];
            t = (b2 & 15) << 2;
            j = 2;
            break;
          case 2:
            chunk[i2++] = b64[t | b2 >> 6];
            chunk[i2++] = b64[b2 & 63];
            j = 0;
            break;
        }
        if (i2 > 8191) {
          (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
          i2 = 0;
        }
      }
      if (j) {
        chunk[i2++] = b64[t];
        chunk[i2++] = 61;
        if (j === 1)
          chunk[i2++] = 61;
      }
      if (parts) {
        if (i2)
          parts.push(String.fromCharCode.apply(String, chunk.slice(0, i2)));
        return parts.join("");
      }
      return String.fromCharCode.apply(String, chunk.slice(0, i2));
    };
    var invalidEncoding = "invalid encoding";
    base64.decode = function decode2(string, buffer, offset) {
      var start = offset;
      var j = 0, t;
      for (var i2 = 0; i2 < string.length; ) {
        var c2 = string.charCodeAt(i2++);
        if (c2 === 61 && j > 1)
          break;
        if ((c2 = s64[c2]) === void 0)
          throw Error(invalidEncoding);
        switch (j) {
          case 0:
            t = c2;
            j = 1;
            break;
          case 1:
            buffer[offset++] = t << 2 | (c2 & 48) >> 4;
            t = c2;
            j = 2;
            break;
          case 2:
            buffer[offset++] = (t & 15) << 4 | (c2 & 60) >> 2;
            t = c2;
            j = 3;
            break;
          case 3:
            buffer[offset++] = (t & 3) << 6 | c2;
            j = 0;
            break;
        }
      }
      if (j === 1)
        throw Error(invalidEncoding);
      return offset - start;
    };
    base64.test = function test(string) {
      return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(string);
    };
  }
});

// node_modules/@protobufjs/eventemitter/index.js
var require_eventemitter = __commonJS({
  "node_modules/@protobufjs/eventemitter/index.js"(exports2, module2) {
    "use strict";
    module2.exports = EventEmitter;
    function EventEmitter() {
      this._listeners = {};
    }
    EventEmitter.prototype.on = function on(evt, fn, ctx) {
      (this._listeners[evt] || (this._listeners[evt] = [])).push({
        fn,
        ctx: ctx || this
      });
      return this;
    };
    EventEmitter.prototype.off = function off(evt, fn) {
      if (evt === void 0)
        this._listeners = {};
      else {
        if (fn === void 0)
          this._listeners[evt] = [];
        else {
          var listeners = this._listeners[evt];
          for (var i = 0; i < listeners.length; )
            if (listeners[i].fn === fn)
              listeners.splice(i, 1);
            else
              ++i;
        }
      }
      return this;
    };
    EventEmitter.prototype.emit = function emit(evt) {
      var listeners = this._listeners[evt];
      if (listeners) {
        var args = [], i = 1;
        for (; i < arguments.length; )
          args.push(arguments[i++]);
        for (i = 0; i < listeners.length; )
          listeners[i].fn.apply(listeners[i++].ctx, args);
      }
      return this;
    };
  }
});

// node_modules/@protobufjs/float/index.js
var require_float = __commonJS({
  "node_modules/@protobufjs/float/index.js"(exports2, module2) {
    "use strict";
    module2.exports = factory(factory);
    function factory(exports3) {
      if (typeof Float32Array !== "undefined")
        (function() {
          var f32 = new Float32Array([-0]), f8b = new Uint8Array(f32.buffer), le = f8b[3] === 128;
          function writeFloat_f32_cpy(val, buf, pos) {
            f32[0] = val;
            buf[pos] = f8b[0];
            buf[pos + 1] = f8b[1];
            buf[pos + 2] = f8b[2];
            buf[pos + 3] = f8b[3];
          }
          function writeFloat_f32_rev(val, buf, pos) {
            f32[0] = val;
            buf[pos] = f8b[3];
            buf[pos + 1] = f8b[2];
            buf[pos + 2] = f8b[1];
            buf[pos + 3] = f8b[0];
          }
          exports3.writeFloatLE = le ? writeFloat_f32_cpy : writeFloat_f32_rev;
          exports3.writeFloatBE = le ? writeFloat_f32_rev : writeFloat_f32_cpy;
          function readFloat_f32_cpy(buf, pos) {
            f8b[0] = buf[pos];
            f8b[1] = buf[pos + 1];
            f8b[2] = buf[pos + 2];
            f8b[3] = buf[pos + 3];
            return f32[0];
          }
          function readFloat_f32_rev(buf, pos) {
            f8b[3] = buf[pos];
            f8b[2] = buf[pos + 1];
            f8b[1] = buf[pos + 2];
            f8b[0] = buf[pos + 3];
            return f32[0];
          }
          exports3.readFloatLE = le ? readFloat_f32_cpy : readFloat_f32_rev;
          exports3.readFloatBE = le ? readFloat_f32_rev : readFloat_f32_cpy;
        })();
      else
        (function() {
          function writeFloat_ieee754(writeUint, val, buf, pos) {
            var sign = val < 0 ? 1 : 0;
            if (sign)
              val = -val;
            if (val === 0)
              writeUint(1 / val > 0 ? (
                /* positive */
                0
              ) : (
                /* negative 0 */
                2147483648
              ), buf, pos);
            else if (isNaN(val))
              writeUint(2143289344, buf, pos);
            else if (val > 34028234663852886e22)
              writeUint((sign << 31 | 2139095040) >>> 0, buf, pos);
            else if (val < 11754943508222875e-54)
              writeUint((sign << 31 | Math.round(val / 1401298464324817e-60)) >>> 0, buf, pos);
            else {
              var exponent = Math.floor(Math.log(val) / Math.LN2), mantissa = Math.round(val * Math.pow(2, -exponent) * 8388608) & 8388607;
              writeUint((sign << 31 | exponent + 127 << 23 | mantissa) >>> 0, buf, pos);
            }
          }
          exports3.writeFloatLE = writeFloat_ieee754.bind(null, writeUintLE);
          exports3.writeFloatBE = writeFloat_ieee754.bind(null, writeUintBE);
          function readFloat_ieee754(readUint, buf, pos) {
            var uint = readUint(buf, pos), sign = (uint >> 31) * 2 + 1, exponent = uint >>> 23 & 255, mantissa = uint & 8388607;
            return exponent === 255 ? mantissa ? NaN : sign * Infinity : exponent === 0 ? sign * 1401298464324817e-60 * mantissa : sign * Math.pow(2, exponent - 150) * (mantissa + 8388608);
          }
          exports3.readFloatLE = readFloat_ieee754.bind(null, readUintLE);
          exports3.readFloatBE = readFloat_ieee754.bind(null, readUintBE);
        })();
      if (typeof Float64Array !== "undefined")
        (function() {
          var f64 = new Float64Array([-0]), f8b = new Uint8Array(f64.buffer), le = f8b[7] === 128;
          function writeDouble_f64_cpy(val, buf, pos) {
            f64[0] = val;
            buf[pos] = f8b[0];
            buf[pos + 1] = f8b[1];
            buf[pos + 2] = f8b[2];
            buf[pos + 3] = f8b[3];
            buf[pos + 4] = f8b[4];
            buf[pos + 5] = f8b[5];
            buf[pos + 6] = f8b[6];
            buf[pos + 7] = f8b[7];
          }
          function writeDouble_f64_rev(val, buf, pos) {
            f64[0] = val;
            buf[pos] = f8b[7];
            buf[pos + 1] = f8b[6];
            buf[pos + 2] = f8b[5];
            buf[pos + 3] = f8b[4];
            buf[pos + 4] = f8b[3];
            buf[pos + 5] = f8b[2];
            buf[pos + 6] = f8b[1];
            buf[pos + 7] = f8b[0];
          }
          exports3.writeDoubleLE = le ? writeDouble_f64_cpy : writeDouble_f64_rev;
          exports3.writeDoubleBE = le ? writeDouble_f64_rev : writeDouble_f64_cpy;
          function readDouble_f64_cpy(buf, pos) {
            f8b[0] = buf[pos];
            f8b[1] = buf[pos + 1];
            f8b[2] = buf[pos + 2];
            f8b[3] = buf[pos + 3];
            f8b[4] = buf[pos + 4];
            f8b[5] = buf[pos + 5];
            f8b[6] = buf[pos + 6];
            f8b[7] = buf[pos + 7];
            return f64[0];
          }
          function readDouble_f64_rev(buf, pos) {
            f8b[7] = buf[pos];
            f8b[6] = buf[pos + 1];
            f8b[5] = buf[pos + 2];
            f8b[4] = buf[pos + 3];
            f8b[3] = buf[pos + 4];
            f8b[2] = buf[pos + 5];
            f8b[1] = buf[pos + 6];
            f8b[0] = buf[pos + 7];
            return f64[0];
          }
          exports3.readDoubleLE = le ? readDouble_f64_cpy : readDouble_f64_rev;
          exports3.readDoubleBE = le ? readDouble_f64_rev : readDouble_f64_cpy;
        })();
      else
        (function() {
          function writeDouble_ieee754(writeUint, off0, off1, val, buf, pos) {
            var sign = val < 0 ? 1 : 0;
            if (sign)
              val = -val;
            if (val === 0) {
              writeUint(0, buf, pos + off0);
              writeUint(1 / val > 0 ? (
                /* positive */
                0
              ) : (
                /* negative 0 */
                2147483648
              ), buf, pos + off1);
            } else if (isNaN(val)) {
              writeUint(0, buf, pos + off0);
              writeUint(2146959360, buf, pos + off1);
            } else if (val > 17976931348623157e292) {
              writeUint(0, buf, pos + off0);
              writeUint((sign << 31 | 2146435072) >>> 0, buf, pos + off1);
            } else {
              var mantissa;
              if (val < 22250738585072014e-324) {
                mantissa = val / 5e-324;
                writeUint(mantissa >>> 0, buf, pos + off0);
                writeUint((sign << 31 | mantissa / 4294967296) >>> 0, buf, pos + off1);
              } else {
                var exponent = Math.floor(Math.log(val) / Math.LN2);
                if (exponent === 1024)
                  exponent = 1023;
                mantissa = val * Math.pow(2, -exponent);
                writeUint(mantissa * 4503599627370496 >>> 0, buf, pos + off0);
                writeUint((sign << 31 | exponent + 1023 << 20 | mantissa * 1048576 & 1048575) >>> 0, buf, pos + off1);
              }
            }
          }
          exports3.writeDoubleLE = writeDouble_ieee754.bind(null, writeUintLE, 0, 4);
          exports3.writeDoubleBE = writeDouble_ieee754.bind(null, writeUintBE, 4, 0);
          function readDouble_ieee754(readUint, off0, off1, buf, pos) {
            var lo = readUint(buf, pos + off0), hi = readUint(buf, pos + off1);
            var sign = (hi >> 31) * 2 + 1, exponent = hi >>> 20 & 2047, mantissa = 4294967296 * (hi & 1048575) + lo;
            return exponent === 2047 ? mantissa ? NaN : sign * Infinity : exponent === 0 ? sign * 5e-324 * mantissa : sign * Math.pow(2, exponent - 1075) * (mantissa + 4503599627370496);
          }
          exports3.readDoubleLE = readDouble_ieee754.bind(null, readUintLE, 0, 4);
          exports3.readDoubleBE = readDouble_ieee754.bind(null, readUintBE, 4, 0);
        })();
      return exports3;
    }
    function writeUintLE(val, buf, pos) {
      buf[pos] = val & 255;
      buf[pos + 1] = val >>> 8 & 255;
      buf[pos + 2] = val >>> 16 & 255;
      buf[pos + 3] = val >>> 24;
    }
    function writeUintBE(val, buf, pos) {
      buf[pos] = val >>> 24;
      buf[pos + 1] = val >>> 16 & 255;
      buf[pos + 2] = val >>> 8 & 255;
      buf[pos + 3] = val & 255;
    }
    function readUintLE(buf, pos) {
      return (buf[pos] | buf[pos + 1] << 8 | buf[pos + 2] << 16 | buf[pos + 3] << 24) >>> 0;
    }
    function readUintBE(buf, pos) {
      return (buf[pos] << 24 | buf[pos + 1] << 16 | buf[pos + 2] << 8 | buf[pos + 3]) >>> 0;
    }
  }
});

// node_modules/@protobufjs/inquire/index.js
var require_inquire = __commonJS({
  "node_modules/@protobufjs/inquire/index.js"(exports, module) {
    "use strict";
    module.exports = inquire;
    function inquire(moduleName) {
      try {
        var mod = eval("quire".replace(/^/, "re"))(moduleName);
        if (mod && (mod.length || Object.keys(mod).length))
          return mod;
      } catch (e2) {
      }
      return null;
    }
  }
});

// node_modules/@protobufjs/utf8/index.js
var require_utf8 = __commonJS({
  "node_modules/@protobufjs/utf8/index.js"(exports2) {
    "use strict";
    var utf8 = exports2;
    utf8.length = function utf8_length(string) {
      var len = 0, c2 = 0;
      for (var i = 0; i < string.length; ++i) {
        c2 = string.charCodeAt(i);
        if (c2 < 128)
          len += 1;
        else if (c2 < 2048)
          len += 2;
        else if ((c2 & 64512) === 55296 && (string.charCodeAt(i + 1) & 64512) === 56320) {
          ++i;
          len += 4;
        } else
          len += 3;
      }
      return len;
    };
    utf8.read = function utf8_read(buffer, start, end) {
      var len = end - start;
      if (len < 1)
        return "";
      var parts = null, chunk = [], i = 0, t;
      while (start < end) {
        t = buffer[start++];
        if (t < 128)
          chunk[i++] = t;
        else if (t > 191 && t < 224)
          chunk[i++] = (t & 31) << 6 | buffer[start++] & 63;
        else if (t > 239 && t < 365) {
          t = ((t & 7) << 18 | (buffer[start++] & 63) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63) - 65536;
          chunk[i++] = 55296 + (t >> 10);
          chunk[i++] = 56320 + (t & 1023);
        } else
          chunk[i++] = (t & 15) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63;
        if (i > 8191) {
          (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
          i = 0;
        }
      }
      if (parts) {
        if (i)
          parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));
        return parts.join("");
      }
      return String.fromCharCode.apply(String, chunk.slice(0, i));
    };
    utf8.write = function utf8_write(string, buffer, offset) {
      var start = offset, c1, c2;
      for (var i = 0; i < string.length; ++i) {
        c1 = string.charCodeAt(i);
        if (c1 < 128) {
          buffer[offset++] = c1;
        } else if (c1 < 2048) {
          buffer[offset++] = c1 >> 6 | 192;
          buffer[offset++] = c1 & 63 | 128;
        } else if ((c1 & 64512) === 55296 && ((c2 = string.charCodeAt(i + 1)) & 64512) === 56320) {
          c1 = 65536 + ((c1 & 1023) << 10) + (c2 & 1023);
          ++i;
          buffer[offset++] = c1 >> 18 | 240;
          buffer[offset++] = c1 >> 12 & 63 | 128;
          buffer[offset++] = c1 >> 6 & 63 | 128;
          buffer[offset++] = c1 & 63 | 128;
        } else {
          buffer[offset++] = c1 >> 12 | 224;
          buffer[offset++] = c1 >> 6 & 63 | 128;
          buffer[offset++] = c1 & 63 | 128;
        }
      }
      return offset - start;
    };
  }
});

// node_modules/@protobufjs/pool/index.js
var require_pool = __commonJS({
  "node_modules/@protobufjs/pool/index.js"(exports2, module2) {
    "use strict";
    module2.exports = pool;
    function pool(alloc, slice, size) {
      var SIZE = size || 8192;
      var MAX = SIZE >>> 1;
      var slab = null;
      var offset = SIZE;
      return function pool_alloc(size2) {
        if (size2 < 1 || size2 > MAX)
          return alloc(size2);
        if (offset + size2 > SIZE) {
          slab = alloc(SIZE);
          offset = 0;
        }
        var buf = slice.call(slab, offset, offset += size2);
        if (offset & 7)
          offset = (offset | 7) + 1;
        return buf;
      };
    }
  }
});

// node_modules/protobufjs/src/util/longbits.js
var require_longbits = __commonJS({
  "node_modules/protobufjs/src/util/longbits.js"(exports2, module2) {
    "use strict";
    module2.exports = LongBits;
    var util = require_minimal();
    function LongBits(lo, hi) {
      this.lo = lo >>> 0;
      this.hi = hi >>> 0;
    }
    var zero = LongBits.zero = new LongBits(0, 0);
    zero.toNumber = function() {
      return 0;
    };
    zero.zzEncode = zero.zzDecode = function() {
      return this;
    };
    zero.length = function() {
      return 1;
    };
    var zeroHash = LongBits.zeroHash = "\0\0\0\0\0\0\0\0";
    LongBits.fromNumber = function fromNumber(value) {
      if (value === 0)
        return zero;
      var sign = value < 0;
      if (sign)
        value = -value;
      var lo = value >>> 0, hi = (value - lo) / 4294967296 >>> 0;
      if (sign) {
        hi = ~hi >>> 0;
        lo = ~lo >>> 0;
        if (++lo > 4294967295) {
          lo = 0;
          if (++hi > 4294967295)
            hi = 0;
        }
      }
      return new LongBits(lo, hi);
    };
    LongBits.from = function from(value) {
      if (typeof value === "number")
        return LongBits.fromNumber(value);
      if (util.isString(value)) {
        if (util.Long)
          value = util.Long.fromString(value);
        else
          return LongBits.fromNumber(parseInt(value, 10));
      }
      return value.low || value.high ? new LongBits(value.low >>> 0, value.high >>> 0) : zero;
    };
    LongBits.prototype.toNumber = function toNumber(unsigned) {
      if (!unsigned && this.hi >>> 31) {
        var lo = ~this.lo + 1 >>> 0, hi = ~this.hi >>> 0;
        if (!lo)
          hi = hi + 1 >>> 0;
        return -(lo + hi * 4294967296);
      }
      return this.lo + this.hi * 4294967296;
    };
    LongBits.prototype.toLong = function toLong(unsigned) {
      return util.Long ? new util.Long(this.lo | 0, this.hi | 0, Boolean(unsigned)) : { low: this.lo | 0, high: this.hi | 0, unsigned: Boolean(unsigned) };
    };
    var charCodeAt = String.prototype.charCodeAt;
    LongBits.fromHash = function fromHash(hash) {
      if (hash === zeroHash)
        return zero;
      return new LongBits(
        (charCodeAt.call(hash, 0) | charCodeAt.call(hash, 1) << 8 | charCodeAt.call(hash, 2) << 16 | charCodeAt.call(hash, 3) << 24) >>> 0,
        (charCodeAt.call(hash, 4) | charCodeAt.call(hash, 5) << 8 | charCodeAt.call(hash, 6) << 16 | charCodeAt.call(hash, 7) << 24) >>> 0
      );
    };
    LongBits.prototype.toHash = function toHash() {
      return String.fromCharCode(
        this.lo & 255,
        this.lo >>> 8 & 255,
        this.lo >>> 16 & 255,
        this.lo >>> 24,
        this.hi & 255,
        this.hi >>> 8 & 255,
        this.hi >>> 16 & 255,
        this.hi >>> 24
      );
    };
    LongBits.prototype.zzEncode = function zzEncode() {
      var mask = this.hi >> 31;
      this.hi = ((this.hi << 1 | this.lo >>> 31) ^ mask) >>> 0;
      this.lo = (this.lo << 1 ^ mask) >>> 0;
      return this;
    };
    LongBits.prototype.zzDecode = function zzDecode() {
      var mask = -(this.lo & 1);
      this.lo = ((this.lo >>> 1 | this.hi << 31) ^ mask) >>> 0;
      this.hi = (this.hi >>> 1 ^ mask) >>> 0;
      return this;
    };
    LongBits.prototype.length = function length() {
      var part0 = this.lo, part1 = (this.lo >>> 28 | this.hi << 4) >>> 0, part2 = this.hi >>> 24;
      return part2 === 0 ? part1 === 0 ? part0 < 16384 ? part0 < 128 ? 1 : 2 : part0 < 2097152 ? 3 : 4 : part1 < 16384 ? part1 < 128 ? 5 : 6 : part1 < 2097152 ? 7 : 8 : part2 < 128 ? 9 : 10;
    };
  }
});

// node_modules/protobufjs/src/util/minimal.js
var require_minimal = __commonJS({
  "node_modules/protobufjs/src/util/minimal.js"(exports2) {
    "use strict";
    var util = exports2;
    util.asPromise = require_aspromise();
    util.base64 = require_base64();
    util.EventEmitter = require_eventemitter();
    util.float = require_float();
    util.inquire = require_inquire();
    util.utf8 = require_utf8();
    util.pool = require_pool();
    util.LongBits = require_longbits();
    util.isNode = Boolean(typeof global !== "undefined" && global && global.process && global.process.versions && global.process.versions.node);
    util.global = util.isNode && global || typeof window !== "undefined" && window || typeof self !== "undefined" && self || exports2;
    util.emptyArray = Object.freeze ? Object.freeze([]) : (
      /* istanbul ignore next */
      []
    );
    util.emptyObject = Object.freeze ? Object.freeze({}) : (
      /* istanbul ignore next */
      {}
    );
    util.isInteger = Number.isInteger || /* istanbul ignore next */
    function isInteger(value) {
      return typeof value === "number" && isFinite(value) && Math.floor(value) === value;
    };
    util.isString = function isString(value) {
      return typeof value === "string" || value instanceof String;
    };
    util.isObject = function isObject(value) {
      return value && typeof value === "object";
    };
    util.isset = /**
     * Checks if a property on a message is considered to be present.
     * @param {Object} obj Plain object or message instance
     * @param {string} prop Property name
     * @returns {boolean} `true` if considered to be present, otherwise `false`
     */
    util.isSet = function isSet(obj, prop) {
      var value = obj[prop];
      if (value != null && obj.hasOwnProperty(prop))
        return typeof value !== "object" || (Array.isArray(value) ? value.length : Object.keys(value).length) > 0;
      return false;
    };
    util.Buffer = function() {
      try {
        var Buffer2 = util.inquire("buffer").Buffer;
        return Buffer2.prototype.utf8Write ? Buffer2 : (
          /* istanbul ignore next */
          null
        );
      } catch (e2) {
        return null;
      }
    }();
    util._Buffer_from = null;
    util._Buffer_allocUnsafe = null;
    util.newBuffer = function newBuffer(sizeOrArray) {
      return typeof sizeOrArray === "number" ? util.Buffer ? util._Buffer_allocUnsafe(sizeOrArray) : new util.Array(sizeOrArray) : util.Buffer ? util._Buffer_from(sizeOrArray) : typeof Uint8Array === "undefined" ? sizeOrArray : new Uint8Array(sizeOrArray);
    };
    util.Array = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
    util.Long = /* istanbul ignore next */
    util.global.dcodeIO && /* istanbul ignore next */
    util.global.dcodeIO.Long || /* istanbul ignore next */
    util.global.Long || util.inquire("long");
    util.key2Re = /^true|false|0|1$/;
    util.key32Re = /^-?(?:0|[1-9][0-9]*)$/;
    util.key64Re = /^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/;
    util.longToHash = function longToHash(value) {
      return value ? util.LongBits.from(value).toHash() : util.LongBits.zeroHash;
    };
    util.longFromHash = function longFromHash(hash, unsigned) {
      var bits = util.LongBits.fromHash(hash);
      if (util.Long)
        return util.Long.fromBits(bits.lo, bits.hi, unsigned);
      return bits.toNumber(Boolean(unsigned));
    };
    function merge(dst, src, ifNotSet) {
      for (var keys = Object.keys(src), i = 0; i < keys.length; ++i)
        if (dst[keys[i]] === void 0 || !ifNotSet)
          dst[keys[i]] = src[keys[i]];
      return dst;
    }
    util.merge = merge;
    util.lcFirst = function lcFirst(str) {
      return str.charAt(0).toLowerCase() + str.substring(1);
    };
    function newError(name) {
      function CustomError(message, properties) {
        if (!(this instanceof CustomError))
          return new CustomError(message, properties);
        Object.defineProperty(this, "message", { get: function() {
          return message;
        } });
        if (Error.captureStackTrace)
          Error.captureStackTrace(this, CustomError);
        else
          Object.defineProperty(this, "stack", { value: new Error().stack || "" });
        if (properties)
          merge(this, properties);
      }
      CustomError.prototype = Object.create(Error.prototype, {
        constructor: {
          value: CustomError,
          writable: true,
          enumerable: false,
          configurable: true
        },
        name: {
          get() {
            return name;
          },
          set: void 0,
          enumerable: false,
          // configurable: false would accurately preserve the behavior of
          // the original, but I'm guessing that was not intentional.
          // For an actual error subclass, this property would
          // be configurable.
          configurable: true
        },
        toString: {
          value() {
            return this.name + ": " + this.message;
          },
          writable: true,
          enumerable: false,
          configurable: true
        }
      });
      return CustomError;
    }
    util.newError = newError;
    util.ProtocolError = newError("ProtocolError");
    util.oneOfGetter = function getOneOf(fieldNames) {
      var fieldMap = {};
      for (var i = 0; i < fieldNames.length; ++i)
        fieldMap[fieldNames[i]] = 1;
      return function() {
        for (var keys = Object.keys(this), i2 = keys.length - 1; i2 > -1; --i2)
          if (fieldMap[keys[i2]] === 1 && this[keys[i2]] !== void 0 && this[keys[i2]] !== null)
            return keys[i2];
      };
    };
    util.oneOfSetter = function setOneOf(fieldNames) {
      return function(name) {
        for (var i = 0; i < fieldNames.length; ++i)
          if (fieldNames[i] !== name)
            delete this[fieldNames[i]];
      };
    };
    util.toJSONOptions = {
      longs: String,
      enums: String,
      bytes: String,
      json: true
    };
    util._configure = function() {
      var Buffer2 = util.Buffer;
      if (!Buffer2) {
        util._Buffer_from = util._Buffer_allocUnsafe = null;
        return;
      }
      util._Buffer_from = Buffer2.from !== Uint8Array.from && Buffer2.from || /* istanbul ignore next */
      function Buffer_from(value, encoding) {
        return new Buffer2(value, encoding);
      };
      util._Buffer_allocUnsafe = Buffer2.allocUnsafe || /* istanbul ignore next */
      function Buffer_allocUnsafe(size) {
        return new Buffer2(size);
      };
    };
  }
});

// node_modules/protobufjs/src/writer.js
var require_writer = __commonJS({
  "node_modules/protobufjs/src/writer.js"(exports2, module2) {
    "use strict";
    module2.exports = Writer;
    var util = require_minimal();
    var BufferWriter;
    var LongBits = util.LongBits;
    var base64 = util.base64;
    var utf8 = util.utf8;
    function Op(fn, len, val) {
      this.fn = fn;
      this.len = len;
      this.next = void 0;
      this.val = val;
    }
    function noop() {
    }
    function State(writer) {
      this.head = writer.head;
      this.tail = writer.tail;
      this.len = writer.len;
      this.next = writer.states;
    }
    function Writer() {
      this.len = 0;
      this.head = new Op(noop, 0, 0);
      this.tail = this.head;
      this.states = null;
    }
    var create = function create2() {
      return util.Buffer ? function create_buffer_setup() {
        return (Writer.create = function create_buffer() {
          return new BufferWriter();
        })();
      } : function create_array() {
        return new Writer();
      };
    };
    Writer.create = create();
    Writer.alloc = function alloc(size) {
      return new util.Array(size);
    };
    if (util.Array !== Array)
      Writer.alloc = util.pool(Writer.alloc, util.Array.prototype.subarray);
    Writer.prototype._push = function push(fn, len, val) {
      this.tail = this.tail.next = new Op(fn, len, val);
      this.len += len;
      return this;
    };
    function writeByte(val, buf, pos) {
      buf[pos] = val & 255;
    }
    function writeVarint32(val, buf, pos) {
      while (val > 127) {
        buf[pos++] = val & 127 | 128;
        val >>>= 7;
      }
      buf[pos] = val;
    }
    function VarintOp(len, val) {
      this.len = len;
      this.next = void 0;
      this.val = val;
    }
    VarintOp.prototype = Object.create(Op.prototype);
    VarintOp.prototype.fn = writeVarint32;
    Writer.prototype.uint32 = function write_uint32(value) {
      this.len += (this.tail = this.tail.next = new VarintOp(
        (value = value >>> 0) < 128 ? 1 : value < 16384 ? 2 : value < 2097152 ? 3 : value < 268435456 ? 4 : 5,
        value
      )).len;
      return this;
    };
    Writer.prototype.int32 = function write_int32(value) {
      return value < 0 ? this._push(writeVarint64, 10, LongBits.fromNumber(value)) : this.uint32(value);
    };
    Writer.prototype.sint32 = function write_sint32(value) {
      return this.uint32((value << 1 ^ value >> 31) >>> 0);
    };
    function writeVarint64(val, buf, pos) {
      while (val.hi) {
        buf[pos++] = val.lo & 127 | 128;
        val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;
        val.hi >>>= 7;
      }
      while (val.lo > 127) {
        buf[pos++] = val.lo & 127 | 128;
        val.lo = val.lo >>> 7;
      }
      buf[pos++] = val.lo;
    }
    Writer.prototype.uint64 = function write_uint64(value) {
      var bits = LongBits.from(value);
      return this._push(writeVarint64, bits.length(), bits);
    };
    Writer.prototype.int64 = Writer.prototype.uint64;
    Writer.prototype.sint64 = function write_sint64(value) {
      var bits = LongBits.from(value).zzEncode();
      return this._push(writeVarint64, bits.length(), bits);
    };
    Writer.prototype.bool = function write_bool(value) {
      return this._push(writeByte, 1, value ? 1 : 0);
    };
    function writeFixed32(val, buf, pos) {
      buf[pos] = val & 255;
      buf[pos + 1] = val >>> 8 & 255;
      buf[pos + 2] = val >>> 16 & 255;
      buf[pos + 3] = val >>> 24;
    }
    Writer.prototype.fixed32 = function write_fixed32(value) {
      return this._push(writeFixed32, 4, value >>> 0);
    };
    Writer.prototype.sfixed32 = Writer.prototype.fixed32;
    Writer.prototype.fixed64 = function write_fixed64(value) {
      var bits = LongBits.from(value);
      return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi);
    };
    Writer.prototype.sfixed64 = Writer.prototype.fixed64;
    Writer.prototype.float = function write_float(value) {
      return this._push(util.float.writeFloatLE, 4, value);
    };
    Writer.prototype.double = function write_double(value) {
      return this._push(util.float.writeDoubleLE, 8, value);
    };
    var writeBytes = util.Array.prototype.set ? function writeBytes_set(val, buf, pos) {
      buf.set(val, pos);
    } : function writeBytes_for(val, buf, pos) {
      for (var i = 0; i < val.length; ++i)
        buf[pos + i] = val[i];
    };
    Writer.prototype.bytes = function write_bytes(value) {
      var len = value.length >>> 0;
      if (!len)
        return this._push(writeByte, 1, 0);
      if (util.isString(value)) {
        var buf = Writer.alloc(len = base64.length(value));
        base64.decode(value, buf, 0);
        value = buf;
      }
      return this.uint32(len)._push(writeBytes, len, value);
    };
    Writer.prototype.string = function write_string(value) {
      var len = utf8.length(value);
      return len ? this.uint32(len)._push(utf8.write, len, value) : this._push(writeByte, 1, 0);
    };
    Writer.prototype.fork = function fork() {
      this.states = new State(this);
      this.head = this.tail = new Op(noop, 0, 0);
      this.len = 0;
      return this;
    };
    Writer.prototype.reset = function reset() {
      if (this.states) {
        this.head = this.states.head;
        this.tail = this.states.tail;
        this.len = this.states.len;
        this.states = this.states.next;
      } else {
        this.head = this.tail = new Op(noop, 0, 0);
        this.len = 0;
      }
      return this;
    };
    Writer.prototype.ldelim = function ldelim() {
      var head = this.head, tail = this.tail, len = this.len;
      this.reset().uint32(len);
      if (len) {
        this.tail.next = head.next;
        this.tail = tail;
        this.len += len;
      }
      return this;
    };
    Writer.prototype.finish = function finish() {
      var head = this.head.next, buf = this.constructor.alloc(this.len), pos = 0;
      while (head) {
        head.fn(head.val, buf, pos);
        pos += head.len;
        head = head.next;
      }
      return buf;
    };
    Writer._configure = function(BufferWriter_) {
      BufferWriter = BufferWriter_;
      Writer.create = create();
      BufferWriter._configure();
    };
  }
});

// node_modules/protobufjs/src/writer_buffer.js
var require_writer_buffer = __commonJS({
  "node_modules/protobufjs/src/writer_buffer.js"(exports2, module2) {
    "use strict";
    module2.exports = BufferWriter;
    var Writer = require_writer();
    (BufferWriter.prototype = Object.create(Writer.prototype)).constructor = BufferWriter;
    var util = require_minimal();
    function BufferWriter() {
      Writer.call(this);
    }
    BufferWriter._configure = function() {
      BufferWriter.alloc = util._Buffer_allocUnsafe;
      BufferWriter.writeBytesBuffer = util.Buffer && util.Buffer.prototype instanceof Uint8Array && util.Buffer.prototype.set.name === "set" ? function writeBytesBuffer_set(val, buf, pos) {
        buf.set(val, pos);
      } : function writeBytesBuffer_copy(val, buf, pos) {
        if (val.copy)
          val.copy(buf, pos, 0, val.length);
        else
          for (var i = 0; i < val.length; )
            buf[pos++] = val[i++];
      };
    };
    BufferWriter.prototype.bytes = function write_bytes_buffer(value) {
      if (util.isString(value))
        value = util._Buffer_from(value, "base64");
      var len = value.length >>> 0;
      this.uint32(len);
      if (len)
        this._push(BufferWriter.writeBytesBuffer, len, value);
      return this;
    };
    function writeStringBuffer(val, buf, pos) {
      if (val.length < 40)
        util.utf8.write(val, buf, pos);
      else if (buf.utf8Write)
        buf.utf8Write(val, pos);
      else
        buf.write(val, pos);
    }
    BufferWriter.prototype.string = function write_string_buffer(value) {
      var len = util.Buffer.byteLength(value);
      this.uint32(len);
      if (len)
        this._push(writeStringBuffer, len, value);
      return this;
    };
    BufferWriter._configure();
  }
});

// node_modules/protobufjs/src/reader.js
var require_reader = __commonJS({
  "node_modules/protobufjs/src/reader.js"(exports2, module2) {
    "use strict";
    module2.exports = Reader;
    var util = require_minimal();
    var BufferReader;
    var LongBits = util.LongBits;
    var utf8 = util.utf8;
    function indexOutOfRange(reader, writeLength) {
      return RangeError("index out of range: " + reader.pos + " + " + (writeLength || 1) + " > " + reader.len);
    }
    function Reader(buffer) {
      this.buf = buffer;
      this.pos = 0;
      this.len = buffer.length;
    }
    var create_array = typeof Uint8Array !== "undefined" ? function create_typed_array(buffer) {
      if (buffer instanceof Uint8Array || Array.isArray(buffer))
        return new Reader(buffer);
      throw Error("illegal buffer");
    } : function create_array2(buffer) {
      if (Array.isArray(buffer))
        return new Reader(buffer);
      throw Error("illegal buffer");
    };
    var create = function create2() {
      return util.Buffer ? function create_buffer_setup(buffer) {
        return (Reader.create = function create_buffer(buffer2) {
          return util.Buffer.isBuffer(buffer2) ? new BufferReader(buffer2) : create_array(buffer2);
        })(buffer);
      } : create_array;
    };
    Reader.create = create();
    Reader.prototype._slice = util.Array.prototype.subarray || /* istanbul ignore next */
    util.Array.prototype.slice;
    Reader.prototype.uint32 = function read_uint32_setup() {
      var value = 4294967295;
      return function read_uint32() {
        value = (this.buf[this.pos] & 127) >>> 0;
        if (this.buf[this.pos++] < 128)
          return value;
        value = (value | (this.buf[this.pos] & 127) << 7) >>> 0;
        if (this.buf[this.pos++] < 128)
          return value;
        value = (value | (this.buf[this.pos] & 127) << 14) >>> 0;
        if (this.buf[this.pos++] < 128)
          return value;
        value = (value | (this.buf[this.pos] & 127) << 21) >>> 0;
        if (this.buf[this.pos++] < 128)
          return value;
        value = (value | (this.buf[this.pos] & 15) << 28) >>> 0;
        if (this.buf[this.pos++] < 128)
          return value;
        if ((this.pos += 5) > this.len) {
          this.pos = this.len;
          throw indexOutOfRange(this, 10);
        }
        return value;
      };
    }();
    Reader.prototype.int32 = function read_int32() {
      return this.uint32() | 0;
    };
    Reader.prototype.sint32 = function read_sint32() {
      var value = this.uint32();
      return value >>> 1 ^ -(value & 1) | 0;
    };
    function readLongVarint() {
      var bits = new LongBits(0, 0);
      var i = 0;
      if (this.len - this.pos > 4) {
        for (; i < 4; ++i) {
          bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits;
        }
        bits.lo = (bits.lo | (this.buf[this.pos] & 127) << 28) >>> 0;
        bits.hi = (bits.hi | (this.buf[this.pos] & 127) >> 4) >>> 0;
        if (this.buf[this.pos++] < 128)
          return bits;
        i = 0;
      } else {
        for (; i < 3; ++i) {
          if (this.pos >= this.len)
            throw indexOutOfRange(this);
          bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits;
        }
        bits.lo = (bits.lo | (this.buf[this.pos++] & 127) << i * 7) >>> 0;
        return bits;
      }
      if (this.len - this.pos > 4) {
        for (; i < 5; ++i) {
          bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits;
        }
      } else {
        for (; i < 5; ++i) {
          if (this.pos >= this.len)
            throw indexOutOfRange(this);
          bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits;
        }
      }
      throw Error("invalid varint encoding");
    }
    Reader.prototype.bool = function read_bool() {
      return this.uint32() !== 0;
    };
    function readFixed32_end(buf, end) {
      return (buf[end - 4] | buf[end - 3] << 8 | buf[end - 2] << 16 | buf[end - 1] << 24) >>> 0;
    }
    Reader.prototype.fixed32 = function read_fixed32() {
      if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);
      return readFixed32_end(this.buf, this.pos += 4);
    };
    Reader.prototype.sfixed32 = function read_sfixed32() {
      if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);
      return readFixed32_end(this.buf, this.pos += 4) | 0;
    };
    function readFixed64() {
      if (this.pos + 8 > this.len)
        throw indexOutOfRange(this, 8);
      return new LongBits(readFixed32_end(this.buf, this.pos += 4), readFixed32_end(this.buf, this.pos += 4));
    }
    Reader.prototype.float = function read_float() {
      if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);
      var value = util.float.readFloatLE(this.buf, this.pos);
      this.pos += 4;
      return value;
    };
    Reader.prototype.double = function read_double() {
      if (this.pos + 8 > this.len)
        throw indexOutOfRange(this, 4);
      var value = util.float.readDoubleLE(this.buf, this.pos);
      this.pos += 8;
      return value;
    };
    Reader.prototype.bytes = function read_bytes() {
      var length = this.uint32(), start = this.pos, end = this.pos + length;
      if (end > this.len)
        throw indexOutOfRange(this, length);
      this.pos += length;
      if (Array.isArray(this.buf))
        return this.buf.slice(start, end);
      return start === end ? new this.buf.constructor(0) : this._slice.call(this.buf, start, end);
    };
    Reader.prototype.string = function read_string() {
      var bytes = this.bytes();
      return utf8.read(bytes, 0, bytes.length);
    };
    Reader.prototype.skip = function skip(length) {
      if (typeof length === "number") {
        if (this.pos + length > this.len)
          throw indexOutOfRange(this, length);
        this.pos += length;
      } else {
        do {
          if (this.pos >= this.len)
            throw indexOutOfRange(this);
        } while (this.buf[this.pos++] & 128);
      }
      return this;
    };
    Reader.prototype.skipType = function(wireType) {
      switch (wireType) {
        case 0:
          this.skip();
          break;
        case 1:
          this.skip(8);
          break;
        case 2:
          this.skip(this.uint32());
          break;
        case 3:
          while ((wireType = this.uint32() & 7) !== 4) {
            this.skipType(wireType);
          }
          break;
        case 5:
          this.skip(4);
          break;
        default:
          throw Error("invalid wire type " + wireType + " at offset " + this.pos);
      }
      return this;
    };
    Reader._configure = function(BufferReader_) {
      BufferReader = BufferReader_;
      Reader.create = create();
      BufferReader._configure();
      var fn = util.Long ? "toLong" : (
        /* istanbul ignore next */
        "toNumber"
      );
      util.merge(Reader.prototype, {
        int64: function read_int64() {
          return readLongVarint.call(this)[fn](false);
        },
        uint64: function read_uint64() {
          return readLongVarint.call(this)[fn](true);
        },
        sint64: function read_sint64() {
          return readLongVarint.call(this).zzDecode()[fn](false);
        },
        fixed64: function read_fixed64() {
          return readFixed64.call(this)[fn](true);
        },
        sfixed64: function read_sfixed64() {
          return readFixed64.call(this)[fn](false);
        }
      });
    };
  }
});

// node_modules/protobufjs/src/reader_buffer.js
var require_reader_buffer = __commonJS({
  "node_modules/protobufjs/src/reader_buffer.js"(exports2, module2) {
    "use strict";
    module2.exports = BufferReader;
    var Reader = require_reader();
    (BufferReader.prototype = Object.create(Reader.prototype)).constructor = BufferReader;
    var util = require_minimal();
    function BufferReader(buffer) {
      Reader.call(this, buffer);
    }
    BufferReader._configure = function() {
      if (util.Buffer)
        BufferReader.prototype._slice = util.Buffer.prototype.slice;
    };
    BufferReader.prototype.string = function read_string_buffer() {
      var len = this.uint32();
      return this.buf.utf8Slice ? this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + len, this.len)) : this.buf.toString("utf-8", this.pos, this.pos = Math.min(this.pos + len, this.len));
    };
    BufferReader._configure();
  }
});

// node_modules/protobufjs/src/rpc/service.js
var require_service = __commonJS({
  "node_modules/protobufjs/src/rpc/service.js"(exports2, module2) {
    "use strict";
    module2.exports = Service;
    var util = require_minimal();
    (Service.prototype = Object.create(util.EventEmitter.prototype)).constructor = Service;
    function Service(rpcImpl, requestDelimited, responseDelimited) {
      if (typeof rpcImpl !== "function")
        throw TypeError("rpcImpl must be a function");
      util.EventEmitter.call(this);
      this.rpcImpl = rpcImpl;
      this.requestDelimited = Boolean(requestDelimited);
      this.responseDelimited = Boolean(responseDelimited);
    }
    Service.prototype.rpcCall = function rpcCall(method, requestCtor, responseCtor, request, callback) {
      if (!request)
        throw TypeError("request must be specified");
      var self2 = this;
      if (!callback)
        return util.asPromise(rpcCall, self2, method, requestCtor, responseCtor, request);
      if (!self2.rpcImpl) {
        setTimeout(function() {
          callback(Error("already ended"));
        }, 0);
        return void 0;
      }
      try {
        return self2.rpcImpl(
          method,
          requestCtor[self2.requestDelimited ? "encodeDelimited" : "encode"](request).finish(),
          function rpcCallback(err, response) {
            if (err) {
              self2.emit("error", err, method);
              return callback(err);
            }
            if (response === null) {
              self2.end(
                /* endedByRPC */
                true
              );
              return void 0;
            }
            if (!(response instanceof responseCtor)) {
              try {
                response = responseCtor[self2.responseDelimited ? "decodeDelimited" : "decode"](response);
              } catch (err2) {
                self2.emit("error", err2, method);
                return callback(err2);
              }
            }
            self2.emit("data", response, method);
            return callback(null, response);
          }
        );
      } catch (err) {
        self2.emit("error", err, method);
        setTimeout(function() {
          callback(err);
        }, 0);
        return void 0;
      }
    };
    Service.prototype.end = function end(endedByRPC) {
      if (this.rpcImpl) {
        if (!endedByRPC)
          this.rpcImpl(null, null, null);
        this.rpcImpl = null;
        this.emit("end").off();
      }
      return this;
    };
  }
});

// node_modules/protobufjs/src/rpc.js
var require_rpc = __commonJS({
  "node_modules/protobufjs/src/rpc.js"(exports2) {
    "use strict";
    var rpc = exports2;
    rpc.Service = require_service();
  }
});

// node_modules/protobufjs/src/roots.js
var require_roots = __commonJS({
  "node_modules/protobufjs/src/roots.js"(exports2, module2) {
    "use strict";
    module2.exports = {};
  }
});

// node_modules/protobufjs/src/index-minimal.js
var require_index_minimal = __commonJS({
  "node_modules/protobufjs/src/index-minimal.js"(exports2) {
    "use strict";
    var protobuf = exports2;
    protobuf.build = "minimal";
    protobuf.Writer = require_writer();
    protobuf.BufferWriter = require_writer_buffer();
    protobuf.Reader = require_reader();
    protobuf.BufferReader = require_reader_buffer();
    protobuf.util = require_minimal();
    protobuf.rpc = require_rpc();
    protobuf.roots = require_roots();
    protobuf.configure = configure;
    function configure() {
      protobuf.util._configure();
      protobuf.Writer._configure(protobuf.BufferWriter);
      protobuf.Reader._configure(protobuf.BufferReader);
    }
    configure();
  }
});

// node_modules/@protobufjs/codegen/index.js
var require_codegen = __commonJS({
  "node_modules/@protobufjs/codegen/index.js"(exports2, module2) {
    "use strict";
    module2.exports = codegen;
    function codegen(functionParams, functionName) {
      if (typeof functionParams === "string") {
        functionName = functionParams;
        functionParams = void 0;
      }
      var body = [];
      function Codegen(formatStringOrScope) {
        if (typeof formatStringOrScope !== "string") {
          var source = toString();
          if (codegen.verbose)
            console.log("codegen: " + source);
          source = "return " + source;
          if (formatStringOrScope) {
            var scopeKeys = Object.keys(formatStringOrScope), scopeParams = new Array(scopeKeys.length + 1), scopeValues = new Array(scopeKeys.length), scopeOffset = 0;
            while (scopeOffset < scopeKeys.length) {
              scopeParams[scopeOffset] = scopeKeys[scopeOffset];
              scopeValues[scopeOffset] = formatStringOrScope[scopeKeys[scopeOffset++]];
            }
            scopeParams[scopeOffset] = source;
            return Function.apply(null, scopeParams).apply(null, scopeValues);
          }
          return Function(source)();
        }
        var formatParams = new Array(arguments.length - 1), formatOffset = 0;
        while (formatOffset < formatParams.length)
          formatParams[formatOffset] = arguments[++formatOffset];
        formatOffset = 0;
        formatStringOrScope = formatStringOrScope.replace(/%([%dfijs])/g, function replace($0, $1) {
          var value = formatParams[formatOffset++];
          switch ($1) {
            case "d":
            case "f":
              return String(Number(value));
            case "i":
              return String(Math.floor(value));
            case "j":
              return JSON.stringify(value);
            case "s":
              return String(value);
          }
          return "%";
        });
        if (formatOffset !== formatParams.length)
          throw Error("parameter count mismatch");
        body.push(formatStringOrScope);
        return Codegen;
      }
      function toString(functionNameOverride) {
        return "function " + (functionNameOverride || functionName || "") + "(" + (functionParams && functionParams.join(",") || "") + "){\n  " + body.join("\n  ") + "\n}";
      }
      Codegen.toString = toString;
      return Codegen;
    }
    codegen.verbose = false;
  }
});

// node_modules/@protobufjs/fetch/index.js
var require_fetch = __commonJS({
  "node_modules/@protobufjs/fetch/index.js"(exports2, module2) {
    "use strict";
    module2.exports = fetch;
    var asPromise = require_aspromise();
    var inquire2 = require_inquire();
    var fs2 = inquire2("fs");
    function fetch(filename, options, callback) {
      if (typeof options === "function") {
        callback = options;
        options = {};
      } else if (!options)
        options = {};
      if (!callback)
        return asPromise(fetch, this, filename, options);
      if (!options.xhr && fs2 && fs2.readFile)
        return fs2.readFile(filename, function fetchReadFileCallback(err, contents) {
          return err && typeof XMLHttpRequest !== "undefined" ? fetch.xhr(filename, options, callback) : err ? callback(err) : callback(null, options.binary ? contents : contents.toString("utf8"));
        });
      return fetch.xhr(filename, options, callback);
    }
    fetch.xhr = function fetch_xhr(filename, options, callback) {
      var xhr = new XMLHttpRequest();
      xhr.onreadystatechange = function fetchOnReadyStateChange() {
        if (xhr.readyState !== 4)
          return void 0;
        if (xhr.status !== 0 && xhr.status !== 200)
          return callback(Error("status " + xhr.status));
        if (options.binary) {
          var buffer = xhr.response;
          if (!buffer) {
            buffer = [];
            for (var i = 0; i < xhr.responseText.length; ++i)
              buffer.push(xhr.responseText.charCodeAt(i) & 255);
          }
          return callback(null, typeof Uint8Array !== "undefined" ? new Uint8Array(buffer) : buffer);
        }
        return callback(null, xhr.responseText);
      };
      if (options.binary) {
        if ("overrideMimeType" in xhr)
          xhr.overrideMimeType("text/plain; charset=x-user-defined");
        xhr.responseType = "arraybuffer";
      }
      xhr.open("GET", filename);
      xhr.send();
    };
  }
});

// node_modules/@protobufjs/path/index.js
var require_path = __commonJS({
  "node_modules/@protobufjs/path/index.js"(exports2) {
    "use strict";
    var path2 = exports2;
    var isAbsolute = (
      /**
       * Tests if the specified path is absolute.
       * @param {string} path Path to test
       * @returns {boolean} `true` if path is absolute
       */
      path2.isAbsolute = function isAbsolute2(path3) {
        return /^(?:\/|\w+:)/.test(path3);
      }
    );
    var normalize = (
      /**
       * Normalizes the specified path.
       * @param {string} path Path to normalize
       * @returns {string} Normalized path
       */
      path2.normalize = function normalize2(path3) {
        path3 = path3.replace(/\\/g, "/").replace(/\/{2,}/g, "/");
        var parts = path3.split("/"), absolute = isAbsolute(path3), prefix = "";
        if (absolute)
          prefix = parts.shift() + "/";
        for (var i = 0; i < parts.length; ) {
          if (parts[i] === "..") {
            if (i > 0 && parts[i - 1] !== "..")
              parts.splice(--i, 2);
            else if (absolute)
              parts.splice(i, 1);
            else
              ++i;
          } else if (parts[i] === ".")
            parts.splice(i, 1);
          else
            ++i;
        }
        return prefix + parts.join("/");
      }
    );
    path2.resolve = function resolve(originPath, includePath, alreadyNormalized) {
      if (!alreadyNormalized)
        includePath = normalize(includePath);
      if (isAbsolute(includePath))
        return includePath;
      if (!alreadyNormalized)
        originPath = normalize(originPath);
      return (originPath = originPath.replace(/(?:\/|^)[^/]+$/, "")).length ? normalize(originPath + "/" + includePath) : includePath;
    };
  }
});

// node_modules/protobufjs/src/types.js
var require_types = __commonJS({
  "node_modules/protobufjs/src/types.js"(exports2) {
    "use strict";
    var types = exports2;
    var util = require_util();
    var s = [
      "double",
      // 0
      "float",
      // 1
      "int32",
      // 2
      "uint32",
      // 3
      "sint32",
      // 4
      "fixed32",
      // 5
      "sfixed32",
      // 6
      "int64",
      // 7
      "uint64",
      // 8
      "sint64",
      // 9
      "fixed64",
      // 10
      "sfixed64",
      // 11
      "bool",
      // 12
      "string",
      // 13
      "bytes"
      // 14
    ];
    function bake(values, offset) {
      var i = 0, o = {};
      offset |= 0;
      while (i < values.length)
        o[s[i + offset]] = values[i++];
      return o;
    }
    types.basic = bake([
      /* double   */
      1,
      /* float    */
      5,
      /* int32    */
      0,
      /* uint32   */
      0,
      /* sint32   */
      0,
      /* fixed32  */
      5,
      /* sfixed32 */
      5,
      /* int64    */
      0,
      /* uint64   */
      0,
      /* sint64   */
      0,
      /* fixed64  */
      1,
      /* sfixed64 */
      1,
      /* bool     */
      0,
      /* string   */
      2,
      /* bytes    */
      2
    ]);
    types.defaults = bake([
      /* double   */
      0,
      /* float    */
      0,
      /* int32    */
      0,
      /* uint32   */
      0,
      /* sint32   */
      0,
      /* fixed32  */
      0,
      /* sfixed32 */
      0,
      /* int64    */
      0,
      /* uint64   */
      0,
      /* sint64   */
      0,
      /* fixed64  */
      0,
      /* sfixed64 */
      0,
      /* bool     */
      false,
      /* string   */
      "",
      /* bytes    */
      util.emptyArray,
      /* message  */
      null
    ]);
    types.long = bake([
      /* int64    */
      0,
      /* uint64   */
      0,
      /* sint64   */
      0,
      /* fixed64  */
      1,
      /* sfixed64 */
      1
    ], 7);
    types.mapKey = bake([
      /* int32    */
      0,
      /* uint32   */
      0,
      /* sint32   */
      0,
      /* fixed32  */
      5,
      /* sfixed32 */
      5,
      /* int64    */
      0,
      /* uint64   */
      0,
      /* sint64   */
      0,
      /* fixed64  */
      1,
      /* sfixed64 */
      1,
      /* bool     */
      0,
      /* string   */
      2
    ], 2);
    types.packed = bake([
      /* double   */
      1,
      /* float    */
      5,
      /* int32    */
      0,
      /* uint32   */
      0,
      /* sint32   */
      0,
      /* fixed32  */
      5,
      /* sfixed32 */
      5,
      /* int64    */
      0,
      /* uint64   */
      0,
      /* sint64   */
      0,
      /* fixed64  */
      1,
      /* sfixed64 */
      1,
      /* bool     */
      0
    ]);
  }
});

// node_modules/protobufjs/src/field.js
var require_field = __commonJS({
  "node_modules/protobufjs/src/field.js"(exports2, module2) {
    "use strict";
    module2.exports = Field;
    var ReflectionObject = require_object();
    ((Field.prototype = Object.create(ReflectionObject.prototype)).constructor = Field).className = "Field";
    var Enum = require_enum();
    var types = require_types();
    var util = require_util();
    var Type;
    var ruleRe = /^required|optional|repeated$/;
    Field.fromJSON = function fromJSON(name, json) {
      return new Field(name, json.id, json.type, json.rule, json.extend, json.options, json.comment);
    };
    function Field(name, id, type, rule, extend, options, comment) {
      if (util.isObject(rule)) {
        comment = extend;
        options = rule;
        rule = extend = void 0;
      } else if (util.isObject(extend)) {
        comment = options;
        options = extend;
        extend = void 0;
      }
      ReflectionObject.call(this, name, options);
      if (!util.isInteger(id) || id < 0)
        throw TypeError("id must be a non-negative integer");
      if (!util.isString(type))
        throw TypeError("type must be a string");
      if (rule !== void 0 && !ruleRe.test(rule = rule.toString().toLowerCase()))
        throw TypeError("rule must be a string rule");
      if (extend !== void 0 && !util.isString(extend))
        throw TypeError("extend must be a string");
      if (rule === "proto3_optional") {
        rule = "optional";
      }
      this.rule = rule && rule !== "optional" ? rule : void 0;
      this.type = type;
      this.id = id;
      this.extend = extend || void 0;
      this.required = rule === "required";
      this.optional = !this.required;
      this.repeated = rule === "repeated";
      this.map = false;
      this.message = null;
      this.partOf = null;
      this.typeDefault = null;
      this.defaultValue = null;
      this.long = util.Long ? types.long[type] !== void 0 : (
        /* istanbul ignore next */
        false
      );
      this.bytes = type === "bytes";
      this.resolvedType = null;
      this.extensionField = null;
      this.declaringField = null;
      this._packed = null;
      this.comment = comment;
    }
    Object.defineProperty(Field.prototype, "packed", {
      get: function() {
        if (this._packed === null)
          this._packed = this.getOption("packed") !== false;
        return this._packed;
      }
    });
    Field.prototype.setOption = function setOption(name, value, ifNotSet) {
      if (name === "packed")
        this._packed = null;
      return ReflectionObject.prototype.setOption.call(this, name, value, ifNotSet);
    };
    Field.prototype.toJSON = function toJSON(toJSONOptions) {
      var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
      return util.toObject([
        "rule",
        this.rule !== "optional" && this.rule || void 0,
        "type",
        this.type,
        "id",
        this.id,
        "extend",
        this.extend,
        "options",
        this.options,
        "comment",
        keepComments ? this.comment : void 0
      ]);
    };
    Field.prototype.resolve = function resolve() {
      if (this.resolved)
        return this;
      if ((this.typeDefault = types.defaults[this.type]) === void 0) {
        this.resolvedType = (this.declaringField ? this.declaringField.parent : this.parent).lookupTypeOrEnum(this.type);
        if (this.resolvedType instanceof Type)
          this.typeDefault = null;
        else
          this.typeDefault = this.resolvedType.values[Object.keys(this.resolvedType.values)[0]];
      } else if (this.options && this.options.proto3_optional) {
        this.typeDefault = null;
      }
      if (this.options && this.options["default"] != null) {
        this.typeDefault = this.options["default"];
        if (this.resolvedType instanceof Enum && typeof this.typeDefault === "string")
          this.typeDefault = this.resolvedType.values[this.typeDefault];
      }
      if (this.options) {
        if (this.options.packed === true || this.options.packed !== void 0 && this.resolvedType && !(this.resolvedType instanceof Enum))
          delete this.options.packed;
        if (!Object.keys(this.options).length)
          this.options = void 0;
      }
      if (this.long) {
        this.typeDefault = util.Long.fromNumber(this.typeDefault, this.type.charAt(0) === "u");
        if (Object.freeze)
          Object.freeze(this.typeDefault);
      } else if (this.bytes && typeof this.typeDefault === "string") {
        var buf;
        if (util.base64.test(this.typeDefault))
          util.base64.decode(this.typeDefault, buf = util.newBuffer(util.base64.length(this.typeDefault)), 0);
        else
          util.utf8.write(this.typeDefault, buf = util.newBuffer(util.utf8.length(this.typeDefault)), 0);
        this.typeDefault = buf;
      }
      if (this.map)
        this.defaultValue = util.emptyObject;
      else if (this.repeated)
        this.defaultValue = util.emptyArray;
      else
        this.defaultValue = this.typeDefault;
      if (this.parent instanceof Type)
        this.parent.ctor.prototype[this.name] = this.defaultValue;
      return ReflectionObject.prototype.resolve.call(this);
    };
    Field.d = function decorateField(fieldId, fieldType, fieldRule, defaultValue) {
      if (typeof fieldType === "function")
        fieldType = util.decorateType(fieldType).name;
      else if (fieldType && typeof fieldType === "object")
        fieldType = util.decorateEnum(fieldType).name;
      return function fieldDecorator(prototype, fieldName) {
        util.decorateType(prototype.constructor).add(new Field(fieldName, fieldId, fieldType, fieldRule, { "default": defaultValue }));
      };
    };
    Field._configure = function configure(Type_) {
      Type = Type_;
    };
  }
});

// node_modules/protobufjs/src/oneof.js
var require_oneof = __commonJS({
  "node_modules/protobufjs/src/oneof.js"(exports2, module2) {
    "use strict";
    module2.exports = OneOf;
    var ReflectionObject = require_object();
    ((OneOf.prototype = Object.create(ReflectionObject.prototype)).constructor = OneOf).className = "OneOf";
    var Field = require_field();
    var util = require_util();
    function OneOf(name, fieldNames, options, comment) {
      if (!Array.isArray(fieldNames)) {
        options = fieldNames;
        fieldNames = void 0;
      }
      ReflectionObject.call(this, name, options);
      if (!(fieldNames === void 0 || Array.isArray(fieldNames)))
        throw TypeError("fieldNames must be an Array");
      this.oneof = fieldNames || [];
      this.fieldsArray = [];
      this.comment = comment;
    }
    OneOf.fromJSON = function fromJSON(name, json) {
      return new OneOf(name, json.oneof, json.options, json.comment);
    };
    OneOf.prototype.toJSON = function toJSON(toJSONOptions) {
      var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
      return util.toObject([
        "options",
        this.options,
        "oneof",
        this.oneof,
        "comment",
        keepComments ? this.comment : void 0
      ]);
    };
    function addFieldsToParent(oneof) {
      if (oneof.parent) {
        for (var i = 0; i < oneof.fieldsArray.length; ++i)
          if (!oneof.fieldsArray[i].parent)
            oneof.parent.add(oneof.fieldsArray[i]);
      }
    }
    OneOf.prototype.add = function add(field) {
      if (!(field instanceof Field))
        throw TypeError("field must be a Field");
      if (field.parent && field.parent !== this.parent)
        field.parent.remove(field);
      this.oneof.push(field.name);
      this.fieldsArray.push(field);
      field.partOf = this;
      addFieldsToParent(this);
      return this;
    };
    OneOf.prototype.remove = function remove(field) {
      if (!(field instanceof Field))
        throw TypeError("field must be a Field");
      var index = this.fieldsArray.indexOf(field);
      if (index < 0)
        throw Error(field + " is not a member of " + this);
      this.fieldsArray.splice(index, 1);
      index = this.oneof.indexOf(field.name);
      if (index > -1)
        this.oneof.splice(index, 1);
      field.partOf = null;
      return this;
    };
    OneOf.prototype.onAdd = function onAdd(parent) {
      ReflectionObject.prototype.onAdd.call(this, parent);
      var self2 = this;
      for (var i = 0; i < this.oneof.length; ++i) {
        var field = parent.get(this.oneof[i]);
        if (field && !field.partOf) {
          field.partOf = self2;
          self2.fieldsArray.push(field);
        }
      }
      addFieldsToParent(this);
    };
    OneOf.prototype.onRemove = function onRemove(parent) {
      for (var i = 0, field; i < this.fieldsArray.length; ++i)
        if ((field = this.fieldsArray[i]).parent)
          field.parent.remove(field);
      ReflectionObject.prototype.onRemove.call(this, parent);
    };
    OneOf.d = function decorateOneOf() {
      var fieldNames = new Array(arguments.length), index = 0;
      while (index < arguments.length)
        fieldNames[index] = arguments[index++];
      return function oneOfDecorator(prototype, oneofName) {
        util.decorateType(prototype.constructor).add(new OneOf(oneofName, fieldNames));
        Object.defineProperty(prototype, oneofName, {
          get: util.oneOfGetter(fieldNames),
          set: util.oneOfSetter(fieldNames)
        });
      };
    };
  }
});

// node_modules/protobufjs/src/namespace.js
var require_namespace = __commonJS({
  "node_modules/protobufjs/src/namespace.js"(exports2, module2) {
    "use strict";
    module2.exports = Namespace;
    var ReflectionObject = require_object();
    ((Namespace.prototype = Object.create(ReflectionObject.prototype)).constructor = Namespace).className = "Namespace";
    var Field = require_field();
    var util = require_util();
    var OneOf = require_oneof();
    var Type;
    var Service;
    var Enum;
    Namespace.fromJSON = function fromJSON(name, json) {
      return new Namespace(name, json.options).addJSON(json.nested);
    };
    function arrayToJSON(array, toJSONOptions) {
      if (!(array && array.length))
        return void 0;
      var obj = {};
      for (var i = 0; i < array.length; ++i)
        obj[array[i].name] = array[i].toJSON(toJSONOptions);
      return obj;
    }
    Namespace.arrayToJSON = arrayToJSON;
    Namespace.isReservedId = function isReservedId(reserved, id) {
      if (reserved) {
        for (var i = 0; i < reserved.length; ++i)
          if (typeof reserved[i] !== "string" && reserved[i][0] <= id && reserved[i][1] > id)
            return true;
      }
      return false;
    };
    Namespace.isReservedName = function isReservedName(reserved, name) {
      if (reserved) {
        for (var i = 0; i < reserved.length; ++i)
          if (reserved[i] === name)
            return true;
      }
      return false;
    };
    function Namespace(name, options) {
      ReflectionObject.call(this, name, options);
      this.nested = void 0;
      this._nestedArray = null;
    }
    function clearCache(namespace) {
      namespace._nestedArray = null;
      return namespace;
    }
    Object.defineProperty(Namespace.prototype, "nestedArray", {
      get: function() {
        return this._nestedArray || (this._nestedArray = util.toArray(this.nested));
      }
    });
    Namespace.prototype.toJSON = function toJSON(toJSONOptions) {
      return util.toObject([
        "options",
        this.options,
        "nested",
        arrayToJSON(this.nestedArray, toJSONOptions)
      ]);
    };
    Namespace.prototype.addJSON = function addJSON(nestedJson) {
      var ns = this;
      if (nestedJson) {
        for (var names = Object.keys(nestedJson), i = 0, nested; i < names.length; ++i) {
          nested = nestedJson[names[i]];
          ns.add(
            // most to least likely
            (nested.fields !== void 0 ? Type.fromJSON : nested.values !== void 0 ? Enum.fromJSON : nested.methods !== void 0 ? Service.fromJSON : nested.id !== void 0 ? Field.fromJSON : Namespace.fromJSON)(names[i], nested)
          );
        }
      }
      return this;
    };
    Namespace.prototype.get = function get(name) {
      return this.nested && this.nested[name] || null;
    };
    Namespace.prototype.getEnum = function getEnum(name) {
      if (this.nested && this.nested[name] instanceof Enum)
        return this.nested[name].values;
      throw Error("no such enum: " + name);
    };
    Namespace.prototype.add = function add(object) {
      if (!(object instanceof Field && object.extend !== void 0 || object instanceof Type || object instanceof OneOf || object instanceof Enum || object instanceof Service || object instanceof Namespace))
        throw TypeError("object must be a valid nested object");
      if (!this.nested)
        this.nested = {};
      else {
        var prev = this.get(object.name);
        if (prev) {
          if (prev instanceof Namespace && object instanceof Namespace && !(prev instanceof Type || prev instanceof Service)) {
            var nested = prev.nestedArray;
            for (var i = 0; i < nested.length; ++i)
              object.add(nested[i]);
            this.remove(prev);
            if (!this.nested)
              this.nested = {};
            object.setOptions(prev.options, true);
          } else
            throw Error("duplicate name '" + object.name + "' in " + this);
        }
      }
      this.nested[object.name] = object;
      object.onAdd(this);
      return clearCache(this);
    };
    Namespace.prototype.remove = function remove(object) {
      if (!(object instanceof ReflectionObject))
        throw TypeError("object must be a ReflectionObject");
      if (object.parent !== this)
        throw Error(object + " is not a member of " + this);
      delete this.nested[object.name];
      if (!Object.keys(this.nested).length)
        this.nested = void 0;
      object.onRemove(this);
      return clearCache(this);
    };
    Namespace.prototype.define = function define(path2, json) {
      if (util.isString(path2))
        path2 = path2.split(".");
      else if (!Array.isArray(path2))
        throw TypeError("illegal path");
      if (path2 && path2.length && path2[0] === "")
        throw Error("path must be relative");
      var ptr = this;
      while (path2.length > 0) {
        var part = path2.shift();
        if (ptr.nested && ptr.nested[part]) {
          ptr = ptr.nested[part];
          if (!(ptr instanceof Namespace))
            throw Error("path conflicts with non-namespace objects");
        } else
          ptr.add(ptr = new Namespace(part));
      }
      if (json)
        ptr.addJSON(json);
      return ptr;
    };
    Namespace.prototype.resolveAll = function resolveAll() {
      var nested = this.nestedArray, i = 0;
      while (i < nested.length)
        if (nested[i] instanceof Namespace)
          nested[i++].resolveAll();
        else
          nested[i++].resolve();
      return this.resolve();
    };
    Namespace.prototype.lookup = function lookup(path2, filterTypes, parentAlreadyChecked) {
      if (typeof filterTypes === "boolean") {
        parentAlreadyChecked = filterTypes;
        filterTypes = void 0;
      } else if (filterTypes && !Array.isArray(filterTypes))
        filterTypes = [filterTypes];
      if (util.isString(path2) && path2.length) {
        if (path2 === ".")
          return this.root;
        path2 = path2.split(".");
      } else if (!path2.length)
        return this;
      if (path2[0] === "")
        return this.root.lookup(path2.slice(1), filterTypes);
      var found = this.get(path2[0]);
      if (found) {
        if (path2.length === 1) {
          if (!filterTypes || filterTypes.indexOf(found.constructor) > -1)
            return found;
        } else if (found instanceof Namespace && (found = found.lookup(path2.slice(1), filterTypes, true)))
          return found;
      } else
        for (var i = 0; i < this.nestedArray.length; ++i)
          if (this._nestedArray[i] instanceof Namespace && (found = this._nestedArray[i].lookup(path2, filterTypes, true)))
            return found;
      if (this.parent === null || parentAlreadyChecked)
        return null;
      return this.parent.lookup(path2, filterTypes);
    };
    Namespace.prototype.lookupType = function lookupType(path2) {
      var found = this.lookup(path2, [Type]);
      if (!found)
        throw Error("no such type: " + path2);
      return found;
    };
    Namespace.prototype.lookupEnum = function lookupEnum(path2) {
      var found = this.lookup(path2, [Enum]);
      if (!found)
        throw Error("no such Enum '" + path2 + "' in " + this);
      return found;
    };
    Namespace.prototype.lookupTypeOrEnum = function lookupTypeOrEnum(path2) {
      var found = this.lookup(path2, [Type, Enum]);
      if (!found)
        throw Error("no such Type or Enum '" + path2 + "' in " + this);
      return found;
    };
    Namespace.prototype.lookupService = function lookupService(path2) {
      var found = this.lookup(path2, [Service]);
      if (!found)
        throw Error("no such Service '" + path2 + "' in " + this);
      return found;
    };
    Namespace._configure = function(Type_, Service_, Enum_) {
      Type = Type_;
      Service = Service_;
      Enum = Enum_;
    };
  }
});

// node_modules/protobufjs/src/mapfield.js
var require_mapfield = __commonJS({
  "node_modules/protobufjs/src/mapfield.js"(exports2, module2) {
    "use strict";
    module2.exports = MapField;
    var Field = require_field();
    ((MapField.prototype = Object.create(Field.prototype)).constructor = MapField).className = "MapField";
    var types = require_types();
    var util = require_util();
    function MapField(name, id, keyType, type, options, comment) {
      Field.call(this, name, id, type, void 0, void 0, options, comment);
      if (!util.isString(keyType))
        throw TypeError("keyType must be a string");
      this.keyType = keyType;
      this.resolvedKeyType = null;
      this.map = true;
    }
    MapField.fromJSON = function fromJSON(name, json) {
      return new MapField(name, json.id, json.keyType, json.type, json.options, json.comment);
    };
    MapField.prototype.toJSON = function toJSON(toJSONOptions) {
      var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
      return util.toObject([
        "keyType",
        this.keyType,
        "type",
        this.type,
        "id",
        this.id,
        "extend",
        this.extend,
        "options",
        this.options,
        "comment",
        keepComments ? this.comment : void 0
      ]);
    };
    MapField.prototype.resolve = function resolve() {
      if (this.resolved)
        return this;
      if (types.mapKey[this.keyType] === void 0)
        throw Error("invalid key type: " + this.keyType);
      return Field.prototype.resolve.call(this);
    };
    MapField.d = function decorateMapField(fieldId, fieldKeyType, fieldValueType) {
      if (typeof fieldValueType === "function")
        fieldValueType = util.decorateType(fieldValueType).name;
      else if (fieldValueType && typeof fieldValueType === "object")
        fieldValueType = util.decorateEnum(fieldValueType).name;
      return function mapFieldDecorator(prototype, fieldName) {
        util.decorateType(prototype.constructor).add(new MapField(fieldName, fieldId, fieldKeyType, fieldValueType));
      };
    };
  }
});

// node_modules/protobufjs/src/method.js
var require_method = __commonJS({
  "node_modules/protobufjs/src/method.js"(exports2, module2) {
    "use strict";
    module2.exports = Method;
    var ReflectionObject = require_object();
    ((Method.prototype = Object.create(ReflectionObject.prototype)).constructor = Method).className = "Method";
    var util = require_util();
    function Method(name, type, requestType, responseType, requestStream, responseStream, options, comment, parsedOptions) {
      if (util.isObject(requestStream)) {
        options = requestStream;
        requestStream = responseStream = void 0;
      } else if (util.isObject(responseStream)) {
        options = responseStream;
        responseStream = void 0;
      }
      if (!(type === void 0 || util.isString(type)))
        throw TypeError("type must be a string");
      if (!util.isString(requestType))
        throw TypeError("requestType must be a string");
      if (!util.isString(responseType))
        throw TypeError("responseType must be a string");
      ReflectionObject.call(this, name, options);
      this.type = type || "rpc";
      this.requestType = requestType;
      this.requestStream = requestStream ? true : void 0;
      this.responseType = responseType;
      this.responseStream = responseStream ? true : void 0;
      this.resolvedRequestType = null;
      this.resolvedResponseType = null;
      this.comment = comment;
      this.parsedOptions = parsedOptions;
    }
    Method.fromJSON = function fromJSON(name, json) {
      return new Method(name, json.type, json.requestType, json.responseType, json.requestStream, json.responseStream, json.options, json.comment, json.parsedOptions);
    };
    Method.prototype.toJSON = function toJSON(toJSONOptions) {
      var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
      return util.toObject([
        "type",
        this.type !== "rpc" && /* istanbul ignore next */
        this.type || void 0,
        "requestType",
        this.requestType,
        "requestStream",
        this.requestStream,
        "responseType",
        this.responseType,
        "responseStream",
        this.responseStream,
        "options",
        this.options,
        "comment",
        keepComments ? this.comment : void 0,
        "parsedOptions",
        this.parsedOptions
      ]);
    };
    Method.prototype.resolve = function resolve() {
      if (this.resolved)
        return this;
      this.resolvedRequestType = this.parent.lookupType(this.requestType);
      this.resolvedResponseType = this.parent.lookupType(this.responseType);
      return ReflectionObject.prototype.resolve.call(this);
    };
  }
});

// node_modules/protobufjs/src/service.js
var require_service2 = __commonJS({
  "node_modules/protobufjs/src/service.js"(exports2, module2) {
    "use strict";
    module2.exports = Service;
    var Namespace = require_namespace();
    ((Service.prototype = Object.create(Namespace.prototype)).constructor = Service).className = "Service";
    var Method = require_method();
    var util = require_util();
    var rpc = require_rpc();
    function Service(name, options) {
      Namespace.call(this, name, options);
      this.methods = {};
      this._methodsArray = null;
    }
    Service.fromJSON = function fromJSON(name, json) {
      var service = new Service(name, json.options);
      if (json.methods)
        for (var names = Object.keys(json.methods), i = 0; i < names.length; ++i)
          service.add(Method.fromJSON(names[i], json.methods[names[i]]));
      if (json.nested)
        service.addJSON(json.nested);
      service.comment = json.comment;
      return service;
    };
    Service.prototype.toJSON = function toJSON(toJSONOptions) {
      var inherited = Namespace.prototype.toJSON.call(this, toJSONOptions);
      var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
      return util.toObject([
        "options",
        inherited && inherited.options || void 0,
        "methods",
        Namespace.arrayToJSON(this.methodsArray, toJSONOptions) || /* istanbul ignore next */
        {},
        "nested",
        inherited && inherited.nested || void 0,
        "comment",
        keepComments ? this.comment : void 0
      ]);
    };
    Object.defineProperty(Service.prototype, "methodsArray", {
      get: function() {
        return this._methodsArray || (this._methodsArray = util.toArray(this.methods));
      }
    });
    function clearCache(service) {
      service._methodsArray = null;
      return service;
    }
    Service.prototype.get = function get(name) {
      return this.methods[name] || Namespace.prototype.get.call(this, name);
    };
    Service.prototype.resolveAll = function resolveAll() {
      var methods = this.methodsArray;
      for (var i = 0; i < methods.length; ++i)
        methods[i].resolve();
      return Namespace.prototype.resolve.call(this);
    };
    Service.prototype.add = function add(object) {
      if (this.get(object.name))
        throw Error("duplicate name '" + object.name + "' in " + this);
      if (object instanceof Method) {
        this.methods[object.name] = object;
        object.parent = this;
        return clearCache(this);
      }
      return Namespace.prototype.add.call(this, object);
    };
    Service.prototype.remove = function remove(object) {
      if (object instanceof Method) {
        if (this.methods[object.name] !== object)
          throw Error(object + " is not a member of " + this);
        delete this.methods[object.name];
        object.parent = null;
        return clearCache(this);
      }
      return Namespace.prototype.remove.call(this, object);
    };
    Service.prototype.create = function create(rpcImpl, requestDelimited, responseDelimited) {
      var rpcService = new rpc.Service(rpcImpl, requestDelimited, responseDelimited);
      for (var i = 0, method; i < /* initializes */
      this.methodsArray.length; ++i) {
        var methodName = util.lcFirst((method = this._methodsArray[i]).resolve().name).replace(/[^$\w_]/g, "");
        rpcService[methodName] = util.codegen(["r", "c"], util.isReserved(methodName) ? methodName + "_" : methodName)("return this.rpcCall(m,q,s,r,c)")({
          m: method,
          q: method.resolvedRequestType.ctor,
          s: method.resolvedResponseType.ctor
        });
      }
      return rpcService;
    };
  }
});

// node_modules/protobufjs/src/message.js
var require_message = __commonJS({
  "node_modules/protobufjs/src/message.js"(exports2, module2) {
    "use strict";
    module2.exports = Message;
    var util = require_minimal();
    function Message(properties) {
      if (properties)
        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
          this[keys[i]] = properties[keys[i]];
    }
    Message.create = function create(properties) {
      return this.$type.create(properties);
    };
    Message.encode = function encode3(message, writer) {
      return this.$type.encode(message, writer);
    };
    Message.encodeDelimited = function encodeDelimited(message, writer) {
      return this.$type.encodeDelimited(message, writer);
    };
    Message.decode = function decode2(reader) {
      return this.$type.decode(reader);
    };
    Message.decodeDelimited = function decodeDelimited(reader) {
      return this.$type.decodeDelimited(reader);
    };
    Message.verify = function verify(message) {
      return this.$type.verify(message);
    };
    Message.fromObject = function fromObject(object) {
      return this.$type.fromObject(object);
    };
    Message.toObject = function toObject(message, options) {
      return this.$type.toObject(message, options);
    };
    Message.prototype.toJSON = function toJSON() {
      return this.$type.toObject(this, util.toJSONOptions);
    };
  }
});

// node_modules/protobufjs/src/decoder.js
var require_decoder2 = __commonJS({
  "node_modules/protobufjs/src/decoder.js"(exports2, module2) {
    "use strict";
    module2.exports = decoder;
    var Enum = require_enum();
    var types = require_types();
    var util = require_util();
    function missing(field) {
      return "missing required '" + field.name + "'";
    }
    function decoder(mtype) {
      var gen = util.codegen(["r", "l"], mtype.name + "$decode")("if(!(r instanceof Reader))")("r=Reader.create(r)")("var c=l===undefined?r.len:r.pos+l,m=new this.ctor" + (mtype.fieldsArray.filter(function(field2) {
        return field2.map;
      }).length ? ",k,value" : ""))("while(r.pos<c){")("var t=r.uint32()");
      if (mtype.group)
        gen("if((t&7)===4)")("break");
      gen("switch(t>>>3){");
      var i = 0;
      for (; i < /* initializes */
      mtype.fieldsArray.length; ++i) {
        var field = mtype._fieldsArray[i].resolve(), type = field.resolvedType instanceof Enum ? "int32" : field.type, ref = "m" + util.safeProp(field.name);
        gen("case %i: {", field.id);
        if (field.map) {
          gen("if(%s===util.emptyObject)", ref)("%s={}", ref)("var c2 = r.uint32()+r.pos");
          if (types.defaults[field.keyType] !== void 0)
            gen("k=%j", types.defaults[field.keyType]);
          else
            gen("k=null");
          if (types.defaults[type] !== void 0)
            gen("value=%j", types.defaults[type]);
          else
            gen("value=null");
          gen("while(r.pos<c2){")("var tag2=r.uint32()")("switch(tag2>>>3){")("case 1: k=r.%s(); break", field.keyType)("case 2:");
          if (types.basic[type] === void 0)
            gen("value=types[%i].decode(r,r.uint32())", i);
          else
            gen("value=r.%s()", type);
          gen("break")("default:")("r.skipType(tag2&7)")("break")("}")("}");
          if (types.long[field.keyType] !== void 0)
            gen('%s[typeof k==="object"?util.longToHash(k):k]=value', ref);
          else
            gen("%s[k]=value", ref);
        } else if (field.repeated) {
          gen("if(!(%s&&%s.length))", ref, ref)("%s=[]", ref);
          if (types.packed[type] !== void 0)
            gen("if((t&7)===2){")("var c2=r.uint32()+r.pos")("while(r.pos<c2)")("%s.push(r.%s())", ref, type)("}else");
          if (types.basic[type] === void 0)
            gen(field.resolvedType.group ? "%s.push(types[%i].decode(r))" : "%s.push(types[%i].decode(r,r.uint32()))", ref, i);
          else
            gen("%s.push(r.%s())", ref, type);
        } else if (types.basic[type] === void 0)
          gen(field.resolvedType.group ? "%s=types[%i].decode(r)" : "%s=types[%i].decode(r,r.uint32())", ref, i);
        else
          gen("%s=r.%s()", ref, type);
        gen("break")("}");
      }
      gen("default:")("r.skipType(t&7)")("break")("}")("}");
      for (i = 0; i < mtype._fieldsArray.length; ++i) {
        var rfield = mtype._fieldsArray[i];
        if (rfield.required)
          gen("if(!m.hasOwnProperty(%j))", rfield.name)("throw util.ProtocolError(%j,{instance:m})", missing(rfield));
      }
      return gen("return m");
    }
  }
});

// node_modules/protobufjs/src/verifier.js
var require_verifier = __commonJS({
  "node_modules/protobufjs/src/verifier.js"(exports2, module2) {
    "use strict";
    module2.exports = verifier;
    var Enum = require_enum();
    var util = require_util();
    function invalid(field, expected) {
      return field.name + ": " + expected + (field.repeated && expected !== "array" ? "[]" : field.map && expected !== "object" ? "{k:" + field.keyType + "}" : "") + " expected";
    }
    function genVerifyValue(gen, field, fieldIndex, ref) {
      if (field.resolvedType) {
        if (field.resolvedType instanceof Enum) {
          gen("switch(%s){", ref)("default:")("return%j", invalid(field, "enum value"));
          for (var keys = Object.keys(field.resolvedType.values), j = 0; j < keys.length; ++j)
            gen("case %i:", field.resolvedType.values[keys[j]]);
          gen("break")("}");
        } else {
          gen("{")("var e=types[%i].verify(%s);", fieldIndex, ref)("if(e)")("return%j+e", field.name + ".")("}");
        }
      } else {
        switch (field.type) {
          case "int32":
          case "uint32":
          case "sint32":
          case "fixed32":
          case "sfixed32":
            gen("if(!util.isInteger(%s))", ref)("return%j", invalid(field, "integer"));
            break;
          case "int64":
          case "uint64":
          case "sint64":
          case "fixed64":
          case "sfixed64":
            gen("if(!util.isInteger(%s)&&!(%s&&util.isInteger(%s.low)&&util.isInteger(%s.high)))", ref, ref, ref, ref)("return%j", invalid(field, "integer|Long"));
            break;
          case "float":
          case "double":
            gen('if(typeof %s!=="number")', ref)("return%j", invalid(field, "number"));
            break;
          case "bool":
            gen('if(typeof %s!=="boolean")', ref)("return%j", invalid(field, "boolean"));
            break;
          case "string":
            gen("if(!util.isString(%s))", ref)("return%j", invalid(field, "string"));
            break;
          case "bytes":
            gen('if(!(%s&&typeof %s.length==="number"||util.isString(%s)))', ref, ref, ref)("return%j", invalid(field, "buffer"));
            break;
        }
      }
      return gen;
    }
    function genVerifyKey(gen, field, ref) {
      switch (field.keyType) {
        case "int32":
        case "uint32":
        case "sint32":
        case "fixed32":
        case "sfixed32":
          gen("if(!util.key32Re.test(%s))", ref)("return%j", invalid(field, "integer key"));
          break;
        case "int64":
        case "uint64":
        case "sint64":
        case "fixed64":
        case "sfixed64":
          gen("if(!util.key64Re.test(%s))", ref)("return%j", invalid(field, "integer|Long key"));
          break;
        case "bool":
          gen("if(!util.key2Re.test(%s))", ref)("return%j", invalid(field, "boolean key"));
          break;
      }
      return gen;
    }
    function verifier(mtype) {
      var gen = util.codegen(["m"], mtype.name + "$verify")('if(typeof m!=="object"||m===null)')("return%j", "object expected");
      var oneofs = mtype.oneofsArray, seenFirstField = {};
      if (oneofs.length)
        gen("var p={}");
      for (var i = 0; i < /* initializes */
      mtype.fieldsArray.length; ++i) {
        var field = mtype._fieldsArray[i].resolve(), ref = "m" + util.safeProp(field.name);
        if (field.optional)
          gen("if(%s!=null&&m.hasOwnProperty(%j)){", ref, field.name);
        if (field.map) {
          gen("if(!util.isObject(%s))", ref)("return%j", invalid(field, "object"))("var k=Object.keys(%s)", ref)("for(var i=0;i<k.length;++i){");
          genVerifyKey(gen, field, "k[i]");
          genVerifyValue(gen, field, i, ref + "[k[i]]")("}");
        } else if (field.repeated) {
          gen("if(!Array.isArray(%s))", ref)("return%j", invalid(field, "array"))("for(var i=0;i<%s.length;++i){", ref);
          genVerifyValue(gen, field, i, ref + "[i]")("}");
        } else {
          if (field.partOf) {
            var oneofProp = util.safeProp(field.partOf.name);
            if (seenFirstField[field.partOf.name] === 1)
              gen("if(p%s===1)", oneofProp)("return%j", field.partOf.name + ": multiple values");
            seenFirstField[field.partOf.name] = 1;
            gen("p%s=1", oneofProp);
          }
          genVerifyValue(gen, field, i, ref);
        }
        if (field.optional)
          gen("}");
      }
      return gen("return null");
    }
  }
});

// node_modules/protobufjs/src/converter.js
var require_converter = __commonJS({
  "node_modules/protobufjs/src/converter.js"(exports2) {
    "use strict";
    var converter = exports2;
    var Enum = require_enum();
    var util = require_util();
    function genValuePartial_fromObject(gen, field, fieldIndex, prop) {
      var defaultAlreadyEmitted = false;
      if (field.resolvedType) {
        if (field.resolvedType instanceof Enum) {
          gen("switch(d%s){", prop);
          for (var values = field.resolvedType.values, keys = Object.keys(values), i = 0; i < keys.length; ++i) {
            if (values[keys[i]] === field.typeDefault && !defaultAlreadyEmitted) {
              gen("default:")('if(typeof(d%s)==="number"){m%s=d%s;break}', prop, prop, prop);
              if (!field.repeated)
                gen("break");
              defaultAlreadyEmitted = true;
            }
            gen("case%j:", keys[i])("case %i:", values[keys[i]])("m%s=%j", prop, values[keys[i]])("break");
          }
          gen("}");
        } else
          gen('if(typeof d%s!=="object")', prop)("throw TypeError(%j)", field.fullName + ": object expected")("m%s=types[%i].fromObject(d%s)", prop, fieldIndex, prop);
      } else {
        var isUnsigned = false;
        switch (field.type) {
          case "double":
          case "float":
            gen("m%s=Number(d%s)", prop, prop);
            break;
          case "uint32":
          case "fixed32":
            gen("m%s=d%s>>>0", prop, prop);
            break;
          case "int32":
          case "sint32":
          case "sfixed32":
            gen("m%s=d%s|0", prop, prop);
            break;
          case "uint64":
            isUnsigned = true;
          case "int64":
          case "sint64":
          case "fixed64":
          case "sfixed64":
            gen("if(util.Long)")("(m%s=util.Long.fromValue(d%s)).unsigned=%j", prop, prop, isUnsigned)('else if(typeof d%s==="string")', prop)("m%s=parseInt(d%s,10)", prop, prop)('else if(typeof d%s==="number")', prop)("m%s=d%s", prop, prop)('else if(typeof d%s==="object")', prop)("m%s=new util.LongBits(d%s.low>>>0,d%s.high>>>0).toNumber(%s)", prop, prop, prop, isUnsigned ? "true" : "");
            break;
          case "bytes":
            gen('if(typeof d%s==="string")', prop)("util.base64.decode(d%s,m%s=util.newBuffer(util.base64.length(d%s)),0)", prop, prop, prop)("else if(d%s.length >= 0)", prop)("m%s=d%s", prop, prop);
            break;
          case "string":
            gen("m%s=String(d%s)", prop, prop);
            break;
          case "bool":
            gen("m%s=Boolean(d%s)", prop, prop);
            break;
        }
      }
      return gen;
    }
    converter.fromObject = function fromObject(mtype) {
      var fields = mtype.fieldsArray;
      var gen = util.codegen(["d"], mtype.name + "$fromObject")("if(d instanceof this.ctor)")("return d");
      if (!fields.length)
        return gen("return new this.ctor");
      gen("var m=new this.ctor");
      for (var i = 0; i < fields.length; ++i) {
        var field = fields[i].resolve(), prop = util.safeProp(field.name);
        if (field.map) {
          gen("if(d%s){", prop)('if(typeof d%s!=="object")', prop)("throw TypeError(%j)", field.fullName + ": object expected")("m%s={}", prop)("for(var ks=Object.keys(d%s),i=0;i<ks.length;++i){", prop);
          genValuePartial_fromObject(
            gen,
            field,
            /* not sorted */
            i,
            prop + "[ks[i]]"
          )("}")("}");
        } else if (field.repeated) {
          gen("if(d%s){", prop)("if(!Array.isArray(d%s))", prop)("throw TypeError(%j)", field.fullName + ": array expected")("m%s=[]", prop)("for(var i=0;i<d%s.length;++i){", prop);
          genValuePartial_fromObject(
            gen,
            field,
            /* not sorted */
            i,
            prop + "[i]"
          )("}")("}");
        } else {
          if (!(field.resolvedType instanceof Enum))
            gen("if(d%s!=null){", prop);
          genValuePartial_fromObject(
            gen,
            field,
            /* not sorted */
            i,
            prop
          );
          if (!(field.resolvedType instanceof Enum))
            gen("}");
        }
      }
      return gen("return m");
    };
    function genValuePartial_toObject(gen, field, fieldIndex, prop) {
      if (field.resolvedType) {
        if (field.resolvedType instanceof Enum)
          gen("d%s=o.enums===String?(types[%i].values[m%s]===undefined?m%s:types[%i].values[m%s]):m%s", prop, fieldIndex, prop, prop, fieldIndex, prop, prop);
        else
          gen("d%s=types[%i].toObject(m%s,o)", prop, fieldIndex, prop);
      } else {
        var isUnsigned = false;
        switch (field.type) {
          case "double":
          case "float":
            gen("d%s=o.json&&!isFinite(m%s)?String(m%s):m%s", prop, prop, prop, prop);
            break;
          case "uint64":
            isUnsigned = true;
          case "int64":
          case "sint64":
          case "fixed64":
          case "sfixed64":
            gen('if(typeof m%s==="number")', prop)("d%s=o.longs===String?String(m%s):m%s", prop, prop, prop)("else")("d%s=o.longs===String?util.Long.prototype.toString.call(m%s):o.longs===Number?new util.LongBits(m%s.low>>>0,m%s.high>>>0).toNumber(%s):m%s", prop, prop, prop, prop, isUnsigned ? "true" : "", prop);
            break;
          case "bytes":
            gen("d%s=o.bytes===String?util.base64.encode(m%s,0,m%s.length):o.bytes===Array?Array.prototype.slice.call(m%s):m%s", prop, prop, prop, prop, prop);
            break;
          default:
            gen("d%s=m%s", prop, prop);
            break;
        }
      }
      return gen;
    }
    converter.toObject = function toObject(mtype) {
      var fields = mtype.fieldsArray.slice().sort(util.compareFieldsById);
      if (!fields.length)
        return util.codegen()("return {}");
      var gen = util.codegen(["m", "o"], mtype.name + "$toObject")("if(!o)")("o={}")("var d={}");
      var repeatedFields = [], mapFields = [], normalFields = [], i = 0;
      for (; i < fields.length; ++i)
        if (!fields[i].partOf)
          (fields[i].resolve().repeated ? repeatedFields : fields[i].map ? mapFields : normalFields).push(fields[i]);
      if (repeatedFields.length) {
        gen("if(o.arrays||o.defaults){");
        for (i = 0; i < repeatedFields.length; ++i)
          gen("d%s=[]", util.safeProp(repeatedFields[i].name));
        gen("}");
      }
      if (mapFields.length) {
        gen("if(o.objects||o.defaults){");
        for (i = 0; i < mapFields.length; ++i)
          gen("d%s={}", util.safeProp(mapFields[i].name));
        gen("}");
      }
      if (normalFields.length) {
        gen("if(o.defaults){");
        for (i = 0; i < normalFields.length; ++i) {
          var field = normalFields[i], prop = util.safeProp(field.name);
          if (field.resolvedType instanceof Enum)
            gen("d%s=o.enums===String?%j:%j", prop, field.resolvedType.valuesById[field.typeDefault], field.typeDefault);
          else if (field.long)
            gen("if(util.Long){")("var n=new util.Long(%i,%i,%j)", field.typeDefault.low, field.typeDefault.high, field.typeDefault.unsigned)("d%s=o.longs===String?n.toString():o.longs===Number?n.toNumber():n", prop)("}else")("d%s=o.longs===String?%j:%i", prop, field.typeDefault.toString(), field.typeDefault.toNumber());
          else if (field.bytes) {
            var arrayDefault = "[" + Array.prototype.slice.call(field.typeDefault).join(",") + "]";
            gen("if(o.bytes===String)d%s=%j", prop, String.fromCharCode.apply(String, field.typeDefault))("else{")("d%s=%s", prop, arrayDefault)("if(o.bytes!==Array)d%s=util.newBuffer(d%s)", prop, prop)("}");
          } else
            gen("d%s=%j", prop, field.typeDefault);
        }
        gen("}");
      }
      var hasKs2 = false;
      for (i = 0; i < fields.length; ++i) {
        var field = fields[i], index = mtype._fieldsArray.indexOf(field), prop = util.safeProp(field.name);
        if (field.map) {
          if (!hasKs2) {
            hasKs2 = true;
            gen("var ks2");
          }
          gen("if(m%s&&(ks2=Object.keys(m%s)).length){", prop, prop)("d%s={}", prop)("for(var j=0;j<ks2.length;++j){");
          genValuePartial_toObject(
            gen,
            field,
            /* sorted */
            index,
            prop + "[ks2[j]]"
          )("}");
        } else if (field.repeated) {
          gen("if(m%s&&m%s.length){", prop, prop)("d%s=[]", prop)("for(var j=0;j<m%s.length;++j){", prop);
          genValuePartial_toObject(
            gen,
            field,
            /* sorted */
            index,
            prop + "[j]"
          )("}");
        } else {
          gen("if(m%s!=null&&m.hasOwnProperty(%j)){", prop, field.name);
          genValuePartial_toObject(
            gen,
            field,
            /* sorted */
            index,
            prop
          );
          if (field.partOf)
            gen("if(o.oneofs)")("d%s=%j", util.safeProp(field.partOf.name), field.name);
        }
        gen("}");
      }
      return gen("return d");
    };
  }
});

// node_modules/protobufjs/src/wrappers.js
var require_wrappers = __commonJS({
  "node_modules/protobufjs/src/wrappers.js"(exports2) {
    "use strict";
    var wrappers = exports2;
    var Message = require_message();
    wrappers[".google.protobuf.Any"] = {
      fromObject: function(object) {
        if (object && object["@type"]) {
          var name = object["@type"].substring(object["@type"].lastIndexOf("/") + 1);
          var type = this.lookup(name);
          if (type) {
            var type_url = object["@type"].charAt(0) === "." ? object["@type"].slice(1) : object["@type"];
            if (type_url.indexOf("/") === -1) {
              type_url = "/" + type_url;
            }
            return this.create({
              type_url,
              value: type.encode(type.fromObject(object)).finish()
            });
          }
        }
        return this.fromObject(object);
      },
      toObject: function(message, options) {
        var googleApi = "type.googleapis.com/";
        var prefix = "";
        var name = "";
        if (options && options.json && message.type_url && message.value) {
          name = message.type_url.substring(message.type_url.lastIndexOf("/") + 1);
          prefix = message.type_url.substring(0, message.type_url.lastIndexOf("/") + 1);
          var type = this.lookup(name);
          if (type)
            message = type.decode(message.value);
        }
        if (!(message instanceof this.ctor) && message instanceof Message) {
          var object = message.$type.toObject(message, options);
          var messageName = message.$type.fullName[0] === "." ? message.$type.fullName.slice(1) : message.$type.fullName;
          if (prefix === "") {
            prefix = googleApi;
          }
          name = prefix + messageName;
          object["@type"] = name;
          return object;
        }
        return this.toObject(message, options);
      }
    };
  }
});

// node_modules/protobufjs/src/type.js
var require_type = __commonJS({
  "node_modules/protobufjs/src/type.js"(exports2, module2) {
    "use strict";
    module2.exports = Type;
    var Namespace = require_namespace();
    ((Type.prototype = Object.create(Namespace.prototype)).constructor = Type).className = "Type";
    var Enum = require_enum();
    var OneOf = require_oneof();
    var Field = require_field();
    var MapField = require_mapfield();
    var Service = require_service2();
    var Message = require_message();
    var Reader = require_reader();
    var Writer = require_writer();
    var util = require_util();
    var encoder = require_encoder2();
    var decoder = require_decoder2();
    var verifier = require_verifier();
    var converter = require_converter();
    var wrappers = require_wrappers();
    function Type(name, options) {
      Namespace.call(this, name, options);
      this.fields = {};
      this.oneofs = void 0;
      this.extensions = void 0;
      this.reserved = void 0;
      this.group = void 0;
      this._fieldsById = null;
      this._fieldsArray = null;
      this._oneofsArray = null;
      this._ctor = null;
    }
    Object.defineProperties(Type.prototype, {
      /**
       * Message fields by id.
       * @name Type#fieldsById
       * @type {Object.<number,Field>}
       * @readonly
       */
      fieldsById: {
        get: function() {
          if (this._fieldsById)
            return this._fieldsById;
          this._fieldsById = {};
          for (var names = Object.keys(this.fields), i = 0; i < names.length; ++i) {
            var field = this.fields[names[i]], id = field.id;
            if (this._fieldsById[id])
              throw Error("duplicate id " + id + " in " + this);
            this._fieldsById[id] = field;
          }
          return this._fieldsById;
        }
      },
      /**
       * Fields of this message as an array for iteration.
       * @name Type#fieldsArray
       * @type {Field[]}
       * @readonly
       */
      fieldsArray: {
        get: function() {
          return this._fieldsArray || (this._fieldsArray = util.toArray(this.fields));
        }
      },
      /**
       * Oneofs of this message as an array for iteration.
       * @name Type#oneofsArray
       * @type {OneOf[]}
       * @readonly
       */
      oneofsArray: {
        get: function() {
          return this._oneofsArray || (this._oneofsArray = util.toArray(this.oneofs));
        }
      },
      /**
       * The registered constructor, if any registered, otherwise a generic constructor.
       * Assigning a function replaces the internal constructor. If the function does not extend {@link Message} yet, its prototype will be setup accordingly and static methods will be populated. If it already extends {@link Message}, it will just replace the internal constructor.
       * @name Type#ctor
       * @type {Constructor<{}>}
       */
      ctor: {
        get: function() {
          return this._ctor || (this.ctor = Type.generateConstructor(this)());
        },
        set: function(ctor) {
          var prototype = ctor.prototype;
          if (!(prototype instanceof Message)) {
            (ctor.prototype = new Message()).constructor = ctor;
            util.merge(ctor.prototype, prototype);
          }
          ctor.$type = ctor.prototype.$type = this;
          util.merge(ctor, Message, true);
          this._ctor = ctor;
          var i = 0;
          for (; i < /* initializes */
          this.fieldsArray.length; ++i)
            this._fieldsArray[i].resolve();
          var ctorProperties = {};
          for (i = 0; i < /* initializes */
          this.oneofsArray.length; ++i)
            ctorProperties[this._oneofsArray[i].resolve().name] = {
              get: util.oneOfGetter(this._oneofsArray[i].oneof),
              set: util.oneOfSetter(this._oneofsArray[i].oneof)
            };
          if (i)
            Object.defineProperties(ctor.prototype, ctorProperties);
        }
      }
    });
    Type.generateConstructor = function generateConstructor(mtype) {
      var gen = util.codegen(["p"], mtype.name);
      for (var i = 0, field; i < mtype.fieldsArray.length; ++i)
        if ((field = mtype._fieldsArray[i]).map)
          gen("this%s={}", util.safeProp(field.name));
        else if (field.repeated)
          gen("this%s=[]", util.safeProp(field.name));
      return gen("if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)")("this[ks[i]]=p[ks[i]]");
    };
    function clearCache(type) {
      type._fieldsById = type._fieldsArray = type._oneofsArray = null;
      delete type.encode;
      delete type.decode;
      delete type.verify;
      return type;
    }
    Type.fromJSON = function fromJSON(name, json) {
      var type = new Type(name, json.options);
      type.extensions = json.extensions;
      type.reserved = json.reserved;
      var names = Object.keys(json.fields), i = 0;
      for (; i < names.length; ++i)
        type.add(
          (typeof json.fields[names[i]].keyType !== "undefined" ? MapField.fromJSON : Field.fromJSON)(names[i], json.fields[names[i]])
        );
      if (json.oneofs)
        for (names = Object.keys(json.oneofs), i = 0; i < names.length; ++i)
          type.add(OneOf.fromJSON(names[i], json.oneofs[names[i]]));
      if (json.nested)
        for (names = Object.keys(json.nested), i = 0; i < names.length; ++i) {
          var nested = json.nested[names[i]];
          type.add(
            // most to least likely
            (nested.id !== void 0 ? Field.fromJSON : nested.fields !== void 0 ? Type.fromJSON : nested.values !== void 0 ? Enum.fromJSON : nested.methods !== void 0 ? Service.fromJSON : Namespace.fromJSON)(names[i], nested)
          );
        }
      if (json.extensions && json.extensions.length)
        type.extensions = json.extensions;
      if (json.reserved && json.reserved.length)
        type.reserved = json.reserved;
      if (json.group)
        type.group = true;
      if (json.comment)
        type.comment = json.comment;
      return type;
    };
    Type.prototype.toJSON = function toJSON(toJSONOptions) {
      var inherited = Namespace.prototype.toJSON.call(this, toJSONOptions);
      var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
      return util.toObject([
        "options",
        inherited && inherited.options || void 0,
        "oneofs",
        Namespace.arrayToJSON(this.oneofsArray, toJSONOptions),
        "fields",
        Namespace.arrayToJSON(this.fieldsArray.filter(function(obj) {
          return !obj.declaringField;
        }), toJSONOptions) || {},
        "extensions",
        this.extensions && this.extensions.length ? this.extensions : void 0,
        "reserved",
        this.reserved && this.reserved.length ? this.reserved : void 0,
        "group",
        this.group || void 0,
        "nested",
        inherited && inherited.nested || void 0,
        "comment",
        keepComments ? this.comment : void 0
      ]);
    };
    Type.prototype.resolveAll = function resolveAll() {
      var fields = this.fieldsArray, i = 0;
      while (i < fields.length)
        fields[i++].resolve();
      var oneofs = this.oneofsArray;
      i = 0;
      while (i < oneofs.length)
        oneofs[i++].resolve();
      return Namespace.prototype.resolveAll.call(this);
    };
    Type.prototype.get = function get(name) {
      return this.fields[name] || this.oneofs && this.oneofs[name] || this.nested && this.nested[name] || null;
    };
    Type.prototype.add = function add(object) {
      if (this.get(object.name))
        throw Error("duplicate name '" + object.name + "' in " + this);
      if (object instanceof Field && object.extend === void 0) {
        if (this._fieldsById ? (
          /* istanbul ignore next */
          this._fieldsById[object.id]
        ) : this.fieldsById[object.id])
          throw Error("duplicate id " + object.id + " in " + this);
        if (this.isReservedId(object.id))
          throw Error("id " + object.id + " is reserved in " + this);
        if (this.isReservedName(object.name))
          throw Error("name '" + object.name + "' is reserved in " + this);
        if (object.parent)
          object.parent.remove(object);
        this.fields[object.name] = object;
        object.message = this;
        object.onAdd(this);
        return clearCache(this);
      }
      if (object instanceof OneOf) {
        if (!this.oneofs)
          this.oneofs = {};
        this.oneofs[object.name] = object;
        object.onAdd(this);
        return clearCache(this);
      }
      return Namespace.prototype.add.call(this, object);
    };
    Type.prototype.remove = function remove(object) {
      if (object instanceof Field && object.extend === void 0) {
        if (!this.fields || this.fields[object.name] !== object)
          throw Error(object + " is not a member of " + this);
        delete this.fields[object.name];
        object.parent = null;
        object.onRemove(this);
        return clearCache(this);
      }
      if (object instanceof OneOf) {
        if (!this.oneofs || this.oneofs[object.name] !== object)
          throw Error(object + " is not a member of " + this);
        delete this.oneofs[object.name];
        object.parent = null;
        object.onRemove(this);
        return clearCache(this);
      }
      return Namespace.prototype.remove.call(this, object);
    };
    Type.prototype.isReservedId = function isReservedId(id) {
      return Namespace.isReservedId(this.reserved, id);
    };
    Type.prototype.isReservedName = function isReservedName(name) {
      return Namespace.isReservedName(this.reserved, name);
    };
    Type.prototype.create = function create(properties) {
      return new this.ctor(properties);
    };
    Type.prototype.setup = function setup() {
      var fullName = this.fullName, types = [];
      for (var i = 0; i < /* initializes */
      this.fieldsArray.length; ++i)
        types.push(this._fieldsArray[i].resolve().resolvedType);
      this.encode = encoder(this)({
        Writer,
        types,
        util
      });
      this.decode = decoder(this)({
        Reader,
        types,
        util
      });
      this.verify = verifier(this)({
        types,
        util
      });
      this.fromObject = converter.fromObject(this)({
        types,
        util
      });
      this.toObject = converter.toObject(this)({
        types,
        util
      });
      var wrapper = wrappers[fullName];
      if (wrapper) {
        var originalThis = Object.create(this);
        originalThis.fromObject = this.fromObject;
        this.fromObject = wrapper.fromObject.bind(originalThis);
        originalThis.toObject = this.toObject;
        this.toObject = wrapper.toObject.bind(originalThis);
      }
      return this;
    };
    Type.prototype.encode = function encode_setup(message, writer) {
      return this.setup().encode(message, writer);
    };
    Type.prototype.encodeDelimited = function encodeDelimited(message, writer) {
      return this.encode(message, writer && writer.len ? writer.fork() : writer).ldelim();
    };
    Type.prototype.decode = function decode_setup(reader, length) {
      return this.setup().decode(reader, length);
    };
    Type.prototype.decodeDelimited = function decodeDelimited(reader) {
      if (!(reader instanceof Reader))
        reader = Reader.create(reader);
      return this.decode(reader, reader.uint32());
    };
    Type.prototype.verify = function verify_setup(message) {
      return this.setup().verify(message);
    };
    Type.prototype.fromObject = function fromObject(object) {
      return this.setup().fromObject(object);
    };
    Type.prototype.toObject = function toObject(message, options) {
      return this.setup().toObject(message, options);
    };
    Type.d = function decorateType(typeName) {
      return function typeDecorator(target) {
        util.decorateType(target, typeName);
      };
    };
  }
});

// node_modules/protobufjs/src/root.js
var require_root = __commonJS({
  "node_modules/protobufjs/src/root.js"(exports2, module2) {
    "use strict";
    module2.exports = Root;
    var Namespace = require_namespace();
    ((Root.prototype = Object.create(Namespace.prototype)).constructor = Root).className = "Root";
    var Field = require_field();
    var Enum = require_enum();
    var OneOf = require_oneof();
    var util = require_util();
    var Type;
    var parse;
    var common;
    function Root(options) {
      Namespace.call(this, "", options);
      this.deferred = [];
      this.files = [];
    }
    Root.fromJSON = function fromJSON(json, root) {
      if (!root)
        root = new Root();
      if (json.options)
        root.setOptions(json.options);
      return root.addJSON(json.nested);
    };
    Root.prototype.resolvePath = util.path.resolve;
    Root.prototype.fetch = util.fetch;
    function SYNC() {
    }
    Root.prototype.load = function load(filename, options, callback) {
      if (typeof options === "function") {
        callback = options;
        options = void 0;
      }
      var self2 = this;
      if (!callback)
        return util.asPromise(load, self2, filename, options);
      var sync = callback === SYNC;
      function finish(err, root) {
        if (!callback)
          return;
        var cb = callback;
        callback = null;
        if (sync)
          throw err;
        cb(err, root);
      }
      function getBundledFileName(filename2) {
        var idx = filename2.lastIndexOf("google/protobuf/");
        if (idx > -1) {
          var altname = filename2.substring(idx);
          if (altname in common)
            return altname;
        }
        return null;
      }
      function process2(filename2, source) {
        try {
          if (util.isString(source) && source.charAt(0) === "{")
            source = JSON.parse(source);
          if (!util.isString(source))
            self2.setOptions(source.options).addJSON(source.nested);
          else {
            parse.filename = filename2;
            var parsed = parse(source, self2, options), resolved2, i2 = 0;
            if (parsed.imports) {
              for (; i2 < parsed.imports.length; ++i2)
                if (resolved2 = getBundledFileName(parsed.imports[i2]) || self2.resolvePath(filename2, parsed.imports[i2]))
                  fetch(resolved2);
            }
            if (parsed.weakImports) {
              for (i2 = 0; i2 < parsed.weakImports.length; ++i2)
                if (resolved2 = getBundledFileName(parsed.weakImports[i2]) || self2.resolvePath(filename2, parsed.weakImports[i2]))
                  fetch(resolved2, true);
            }
          }
        } catch (err) {
          finish(err);
        }
        if (!sync && !queued)
          finish(null, self2);
      }
      function fetch(filename2, weak) {
        if (self2.files.indexOf(filename2) > -1)
          return;
        self2.files.push(filename2);
        if (filename2 in common) {
          if (sync)
            process2(filename2, common[filename2]);
          else {
            ++queued;
            setTimeout(function() {
              --queued;
              process2(filename2, common[filename2]);
            });
          }
          return;
        }
        if (sync) {
          var source;
          try {
            source = util.fs.readFileSync(filename2).toString("utf8");
          } catch (err) {
            if (!weak)
              finish(err);
            return;
          }
          process2(filename2, source);
        } else {
          ++queued;
          self2.fetch(filename2, function(err, source2) {
            --queued;
            if (!callback)
              return;
            if (err) {
              if (!weak)
                finish(err);
              else if (!queued)
                finish(null, self2);
              return;
            }
            process2(filename2, source2);
          });
        }
      }
      var queued = 0;
      if (util.isString(filename))
        filename = [filename];
      for (var i = 0, resolved; i < filename.length; ++i)
        if (resolved = self2.resolvePath("", filename[i]))
          fetch(resolved);
      if (sync)
        return self2;
      if (!queued)
        finish(null, self2);
      return void 0;
    };
    Root.prototype.loadSync = function loadSync(filename, options) {
      if (!util.isNode)
        throw Error("not supported");
      return this.load(filename, options, SYNC);
    };
    Root.prototype.resolveAll = function resolveAll() {
      if (this.deferred.length)
        throw Error("unresolvable extensions: " + this.deferred.map(function(field) {
          return "'extend " + field.extend + "' in " + field.parent.fullName;
        }).join(", "));
      return Namespace.prototype.resolveAll.call(this);
    };
    var exposeRe = /^[A-Z]/;
    function tryHandleExtension(root, field) {
      var extendedType = field.parent.lookup(field.extend);
      if (extendedType) {
        var sisterField = new Field(field.fullName, field.id, field.type, field.rule, void 0, field.options);
        sisterField.declaringField = field;
        field.extensionField = sisterField;
        extendedType.add(sisterField);
        return true;
      }
      return false;
    }
    Root.prototype._handleAdd = function _handleAdd(object) {
      if (object instanceof Field) {
        if (
          /* an extension field (implies not part of a oneof) */
          object.extend !== void 0 && /* not already handled */
          !object.extensionField
        ) {
          if (!tryHandleExtension(this, object))
            this.deferred.push(object);
        }
      } else if (object instanceof Enum) {
        if (exposeRe.test(object.name))
          object.parent[object.name] = object.values;
      } else if (!(object instanceof OneOf)) {
        if (object instanceof Type)
          for (var i = 0; i < this.deferred.length; )
            if (tryHandleExtension(this, this.deferred[i]))
              this.deferred.splice(i, 1);
            else
              ++i;
        for (var j = 0; j < /* initializes */
        object.nestedArray.length; ++j)
          this._handleAdd(object._nestedArray[j]);
        if (exposeRe.test(object.name))
          object.parent[object.name] = object;
      }
    };
    Root.prototype._handleRemove = function _handleRemove(object) {
      if (object instanceof Field) {
        if (
          /* an extension field */
          object.extend !== void 0
        ) {
          if (
            /* already handled */
            object.extensionField
          ) {
            object.extensionField.parent.remove(object.extensionField);
            object.extensionField = null;
          } else {
            var index = this.deferred.indexOf(object);
            if (index > -1)
              this.deferred.splice(index, 1);
          }
        }
      } else if (object instanceof Enum) {
        if (exposeRe.test(object.name))
          delete object.parent[object.name];
      } else if (object instanceof Namespace) {
        for (var i = 0; i < /* initializes */
        object.nestedArray.length; ++i)
          this._handleRemove(object._nestedArray[i]);
        if (exposeRe.test(object.name))
          delete object.parent[object.name];
      }
    };
    Root._configure = function(Type_, parse_, common_) {
      Type = Type_;
      parse = parse_;
      common = common_;
    };
  }
});

// node_modules/protobufjs/src/util.js
var require_util = __commonJS({
  "node_modules/protobufjs/src/util.js"(exports2, module2) {
    "use strict";
    var util = module2.exports = require_minimal();
    var roots = require_roots();
    var Type;
    var Enum;
    util.codegen = require_codegen();
    util.fetch = require_fetch();
    util.path = require_path();
    util.fs = util.inquire("fs");
    util.toArray = function toArray(object) {
      if (object) {
        var keys = Object.keys(object), array = new Array(keys.length), index = 0;
        while (index < keys.length)
          array[index] = object[keys[index++]];
        return array;
      }
      return [];
    };
    util.toObject = function toObject(array) {
      var object = {}, index = 0;
      while (index < array.length) {
        var key = array[index++], val = array[index++];
        if (val !== void 0)
          object[key] = val;
      }
      return object;
    };
    var safePropBackslashRe = /\\/g;
    var safePropQuoteRe = /"/g;
    util.isReserved = function isReserved(name) {
      return /^(?:do|if|in|for|let|new|try|var|case|else|enum|eval|false|null|this|true|void|with|break|catch|class|const|super|throw|while|yield|delete|export|import|public|return|static|switch|typeof|default|extends|finally|package|private|continue|debugger|function|arguments|interface|protected|implements|instanceof)$/.test(name);
    };
    util.safeProp = function safeProp(prop) {
      if (!/^[$\w_]+$/.test(prop) || util.isReserved(prop))
        return '["' + prop.replace(safePropBackslashRe, "\\\\").replace(safePropQuoteRe, '\\"') + '"]';
      return "." + prop;
    };
    util.ucFirst = function ucFirst(str) {
      return str.charAt(0).toUpperCase() + str.substring(1);
    };
    var camelCaseRe = /_([a-z])/g;
    util.camelCase = function camelCase(str) {
      return str.substring(0, 1) + str.substring(1).replace(camelCaseRe, function($0, $1) {
        return $1.toUpperCase();
      });
    };
    util.compareFieldsById = function compareFieldsById(a2, b2) {
      return a2.id - b2.id;
    };
    util.decorateType = function decorateType(ctor, typeName) {
      if (ctor.$type) {
        if (typeName && ctor.$type.name !== typeName) {
          util.decorateRoot.remove(ctor.$type);
          ctor.$type.name = typeName;
          util.decorateRoot.add(ctor.$type);
        }
        return ctor.$type;
      }
      if (!Type)
        Type = require_type();
      var type = new Type(typeName || ctor.name);
      util.decorateRoot.add(type);
      type.ctor = ctor;
      Object.defineProperty(ctor, "$type", { value: type, enumerable: false });
      Object.defineProperty(ctor.prototype, "$type", { value: type, enumerable: false });
      return type;
    };
    var decorateEnumIndex = 0;
    util.decorateEnum = function decorateEnum(object) {
      if (object.$type)
        return object.$type;
      if (!Enum)
        Enum = require_enum();
      var enm = new Enum("Enum" + decorateEnumIndex++, object);
      util.decorateRoot.add(enm);
      Object.defineProperty(object, "$type", { value: enm, enumerable: false });
      return enm;
    };
    util.setProperty = function setProperty(dst, path2, value) {
      function setProp(dst2, path3, value2) {
        var part = path3.shift();
        if (part === "__proto__") {
          return dst2;
        }
        if (path3.length > 0) {
          dst2[part] = setProp(dst2[part] || {}, path3, value2);
        } else {
          var prevValue = dst2[part];
          if (prevValue)
            value2 = [].concat(prevValue).concat(value2);
          dst2[part] = value2;
        }
        return dst2;
      }
      if (typeof dst !== "object")
        throw TypeError("dst must be an object");
      if (!path2)
        throw TypeError("path must be specified");
      path2 = path2.split(".");
      return setProp(dst, path2, value);
    };
    Object.defineProperty(util, "decorateRoot", {
      get: function() {
        return roots["decorated"] || (roots["decorated"] = new (require_root())());
      }
    });
  }
});

// node_modules/protobufjs/src/object.js
var require_object = __commonJS({
  "node_modules/protobufjs/src/object.js"(exports2, module2) {
    "use strict";
    module2.exports = ReflectionObject;
    ReflectionObject.className = "ReflectionObject";
    var util = require_util();
    var Root;
    function ReflectionObject(name, options) {
      if (!util.isString(name))
        throw TypeError("name must be a string");
      if (options && !util.isObject(options))
        throw TypeError("options must be an object");
      this.options = options;
      this.parsedOptions = null;
      this.name = name;
      this.parent = null;
      this.resolved = false;
      this.comment = null;
      this.filename = null;
    }
    Object.defineProperties(ReflectionObject.prototype, {
      /**
       * Reference to the root namespace.
       * @name ReflectionObject#root
       * @type {Root}
       * @readonly
       */
      root: {
        get: function() {
          var ptr = this;
          while (ptr.parent !== null)
            ptr = ptr.parent;
          return ptr;
        }
      },
      /**
       * Full name including leading dot.
       * @name ReflectionObject#fullName
       * @type {string}
       * @readonly
       */
      fullName: {
        get: function() {
          var path2 = [this.name], ptr = this.parent;
          while (ptr) {
            path2.unshift(ptr.name);
            ptr = ptr.parent;
          }
          return path2.join(".");
        }
      }
    });
    ReflectionObject.prototype.toJSON = /* istanbul ignore next */
    function toJSON() {
      throw Error();
    };
    ReflectionObject.prototype.onAdd = function onAdd(parent) {
      if (this.parent && this.parent !== parent)
        this.parent.remove(this);
      this.parent = parent;
      this.resolved = false;
      var root = parent.root;
      if (root instanceof Root)
        root._handleAdd(this);
    };
    ReflectionObject.prototype.onRemove = function onRemove(parent) {
      var root = parent.root;
      if (root instanceof Root)
        root._handleRemove(this);
      this.parent = null;
      this.resolved = false;
    };
    ReflectionObject.prototype.resolve = function resolve() {
      if (this.resolved)
        return this;
      if (this.root instanceof Root)
        this.resolved = true;
      return this;
    };
    ReflectionObject.prototype.getOption = function getOption(name) {
      if (this.options)
        return this.options[name];
      return void 0;
    };
    ReflectionObject.prototype.setOption = function setOption(name, value, ifNotSet) {
      if (!ifNotSet || !this.options || this.options[name] === void 0)
        (this.options || (this.options = {}))[name] = value;
      return this;
    };
    ReflectionObject.prototype.setParsedOption = function setParsedOption(name, value, propName) {
      if (!this.parsedOptions) {
        this.parsedOptions = [];
      }
      var parsedOptions = this.parsedOptions;
      if (propName) {
        var opt = parsedOptions.find(function(opt2) {
          return Object.prototype.hasOwnProperty.call(opt2, name);
        });
        if (opt) {
          var newValue = opt[name];
          util.setProperty(newValue, propName, value);
        } else {
          opt = {};
          opt[name] = util.setProperty({}, propName, value);
          parsedOptions.push(opt);
        }
      } else {
        var newOpt = {};
        newOpt[name] = value;
        parsedOptions.push(newOpt);
      }
      return this;
    };
    ReflectionObject.prototype.setOptions = function setOptions(options, ifNotSet) {
      if (options)
        for (var keys = Object.keys(options), i = 0; i < keys.length; ++i)
          this.setOption(keys[i], options[keys[i]], ifNotSet);
      return this;
    };
    ReflectionObject.prototype.toString = function toString() {
      var className = this.constructor.className, fullName = this.fullName;
      if (fullName.length)
        return className + " " + fullName;
      return className;
    };
    ReflectionObject._configure = function(Root_) {
      Root = Root_;
    };
  }
});

// node_modules/protobufjs/src/enum.js
var require_enum = __commonJS({
  "node_modules/protobufjs/src/enum.js"(exports2, module2) {
    "use strict";
    module2.exports = Enum;
    var ReflectionObject = require_object();
    ((Enum.prototype = Object.create(ReflectionObject.prototype)).constructor = Enum).className = "Enum";
    var Namespace = require_namespace();
    var util = require_util();
    function Enum(name, values, options, comment, comments, valuesOptions) {
      ReflectionObject.call(this, name, options);
      if (values && typeof values !== "object")
        throw TypeError("values must be an object");
      this.valuesById = {};
      this.values = Object.create(this.valuesById);
      this.comment = comment;
      this.comments = comments || {};
      this.valuesOptions = valuesOptions;
      this.reserved = void 0;
      if (values) {
        for (var keys = Object.keys(values), i = 0; i < keys.length; ++i)
          if (typeof values[keys[i]] === "number")
            this.valuesById[this.values[keys[i]] = values[keys[i]]] = keys[i];
      }
    }
    Enum.fromJSON = function fromJSON(name, json) {
      var enm = new Enum(name, json.values, json.options, json.comment, json.comments);
      enm.reserved = json.reserved;
      return enm;
    };
    Enum.prototype.toJSON = function toJSON(toJSONOptions) {
      var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
      return util.toObject([
        "options",
        this.options,
        "valuesOptions",
        this.valuesOptions,
        "values",
        this.values,
        "reserved",
        this.reserved && this.reserved.length ? this.reserved : void 0,
        "comment",
        keepComments ? this.comment : void 0,
        "comments",
        keepComments ? this.comments : void 0
      ]);
    };
    Enum.prototype.add = function add(name, id, comment, options) {
      if (!util.isString(name))
        throw TypeError("name must be a string");
      if (!util.isInteger(id))
        throw TypeError("id must be an integer");
      if (this.values[name] !== void 0)
        throw Error("duplicate name '" + name + "' in " + this);
      if (this.isReservedId(id))
        throw Error("id " + id + " is reserved in " + this);
      if (this.isReservedName(name))
        throw Error("name '" + name + "' is reserved in " + this);
      if (this.valuesById[id] !== void 0) {
        if (!(this.options && this.options.allow_alias))
          throw Error("duplicate id " + id + " in " + this);
        this.values[name] = id;
      } else
        this.valuesById[this.values[name] = id] = name;
      if (options) {
        if (this.valuesOptions === void 0)
          this.valuesOptions = {};
        this.valuesOptions[name] = options || null;
      }
      this.comments[name] = comment || null;
      return this;
    };
    Enum.prototype.remove = function remove(name) {
      if (!util.isString(name))
        throw TypeError("name must be a string");
      var val = this.values[name];
      if (val == null)
        throw Error("name '" + name + "' does not exist in " + this);
      delete this.valuesById[val];
      delete this.values[name];
      delete this.comments[name];
      if (this.valuesOptions)
        delete this.valuesOptions[name];
      return this;
    };
    Enum.prototype.isReservedId = function isReservedId(id) {
      return Namespace.isReservedId(this.reserved, id);
    };
    Enum.prototype.isReservedName = function isReservedName(name) {
      return Namespace.isReservedName(this.reserved, name);
    };
  }
});

// node_modules/protobufjs/src/encoder.js
var require_encoder2 = __commonJS({
  "node_modules/protobufjs/src/encoder.js"(exports2, module2) {
    "use strict";
    module2.exports = encoder;
    var Enum = require_enum();
    var types = require_types();
    var util = require_util();
    function genTypePartial(gen, field, fieldIndex, ref) {
      return field.resolvedType.group ? gen("types[%i].encode(%s,w.uint32(%i)).uint32(%i)", fieldIndex, ref, (field.id << 3 | 3) >>> 0, (field.id << 3 | 4) >>> 0) : gen("types[%i].encode(%s,w.uint32(%i).fork()).ldelim()", fieldIndex, ref, (field.id << 3 | 2) >>> 0);
    }
    function encoder(mtype) {
      var gen = util.codegen(["m", "w"], mtype.name + "$encode")("if(!w)")("w=Writer.create()");
      var i, ref;
      var fields = (
        /* initializes */
        mtype.fieldsArray.slice().sort(util.compareFieldsById)
      );
      for (var i = 0; i < fields.length; ++i) {
        var field = fields[i].resolve(), index = mtype._fieldsArray.indexOf(field), type = field.resolvedType instanceof Enum ? "int32" : field.type, wireType = types.basic[type];
        ref = "m" + util.safeProp(field.name);
        if (field.map) {
          gen("if(%s!=null&&Object.hasOwnProperty.call(m,%j)){", ref, field.name)("for(var ks=Object.keys(%s),i=0;i<ks.length;++i){", ref)("w.uint32(%i).fork().uint32(%i).%s(ks[i])", (field.id << 3 | 2) >>> 0, 8 | types.mapKey[field.keyType], field.keyType);
          if (wireType === void 0)
            gen("types[%i].encode(%s[ks[i]],w.uint32(18).fork()).ldelim().ldelim()", index, ref);
          else
            gen(".uint32(%i).%s(%s[ks[i]]).ldelim()", 16 | wireType, type, ref);
          gen("}")("}");
        } else if (field.repeated) {
          gen("if(%s!=null&&%s.length){", ref, ref);
          if (field.packed && types.packed[type] !== void 0) {
            gen("w.uint32(%i).fork()", (field.id << 3 | 2) >>> 0)("for(var i=0;i<%s.length;++i)", ref)("w.%s(%s[i])", type, ref)("w.ldelim()");
          } else {
            gen("for(var i=0;i<%s.length;++i)", ref);
            if (wireType === void 0)
              genTypePartial(gen, field, index, ref + "[i]");
            else
              gen("w.uint32(%i).%s(%s[i])", (field.id << 3 | wireType) >>> 0, type, ref);
          }
          gen("}");
        } else {
          if (field.optional)
            gen("if(%s!=null&&Object.hasOwnProperty.call(m,%j))", ref, field.name);
          if (wireType === void 0)
            genTypePartial(gen, field, index, ref);
          else
            gen("w.uint32(%i).%s(%s)", (field.id << 3 | wireType) >>> 0, type, ref);
        }
      }
      return gen("return w");
    }
  }
});

// node_modules/protobufjs/src/index-light.js
var require_index_light = __commonJS({
  "node_modules/protobufjs/src/index-light.js"(exports2, module2) {
    "use strict";
    var protobuf = module2.exports = require_index_minimal();
    protobuf.build = "light";
    function load(filename, root, callback) {
      if (typeof root === "function") {
        callback = root;
        root = new protobuf.Root();
      } else if (!root)
        root = new protobuf.Root();
      return root.load(filename, callback);
    }
    protobuf.load = load;
    function loadSync(filename, root) {
      if (!root)
        root = new protobuf.Root();
      return root.loadSync(filename);
    }
    protobuf.loadSync = loadSync;
    protobuf.encoder = require_encoder2();
    protobuf.decoder = require_decoder2();
    protobuf.verifier = require_verifier();
    protobuf.converter = require_converter();
    protobuf.ReflectionObject = require_object();
    protobuf.Namespace = require_namespace();
    protobuf.Root = require_root();
    protobuf.Enum = require_enum();
    protobuf.Type = require_type();
    protobuf.Field = require_field();
    protobuf.OneOf = require_oneof();
    protobuf.MapField = require_mapfield();
    protobuf.Service = require_service2();
    protobuf.Method = require_method();
    protobuf.Message = require_message();
    protobuf.wrappers = require_wrappers();
    protobuf.types = require_types();
    protobuf.util = require_util();
    protobuf.ReflectionObject._configure(protobuf.Root);
    protobuf.Namespace._configure(protobuf.Type, protobuf.Service, protobuf.Enum);
    protobuf.Root._configure(protobuf.Type);
    protobuf.Field._configure(protobuf.Type);
  }
});

// node_modules/protobufjs/src/tokenize.js
var require_tokenize = __commonJS({
  "node_modules/protobufjs/src/tokenize.js"(exports2, module2) {
    "use strict";
    module2.exports = tokenize;
    var delimRe = /[\s{}=;:[\],'"()<>]/g;
    var stringDoubleRe = /(?:"([^"\\]*(?:\\.[^"\\]*)*)")/g;
    var stringSingleRe = /(?:'([^'\\]*(?:\\.[^'\\]*)*)')/g;
    var setCommentRe = /^ *[*/]+ */;
    var setCommentAltRe = /^\s*\*?\/*/;
    var setCommentSplitRe = /\n/g;
    var whitespaceRe = /\s/;
    var unescapeRe = /\\(.?)/g;
    var unescapeMap = {
      "0": "\0",
      "r": "\r",
      "n": "\n",
      "t": "	"
    };
    function unescape(str) {
      return str.replace(unescapeRe, function($0, $1) {
        switch ($1) {
          case "\\":
          case "":
            return $1;
          default:
            return unescapeMap[$1] || "";
        }
      });
    }
    tokenize.unescape = unescape;
    function tokenize(source, alternateCommentMode) {
      source = source.toString();
      var offset = 0, length = source.length, line = 1, lastCommentLine = 0, comments = {};
      var stack = [];
      var stringDelim = null;
      function illegal(subject) {
        return Error("illegal " + subject + " (line " + line + ")");
      }
      function readString() {
        var re = stringDelim === "'" ? stringSingleRe : stringDoubleRe;
        re.lastIndex = offset - 1;
        var match = re.exec(source);
        if (!match)
          throw illegal("string");
        offset = re.lastIndex;
        push(stringDelim);
        stringDelim = null;
        return unescape(match[1]);
      }
      function charAt(pos) {
        return source.charAt(pos);
      }
      function setComment(start, end, isLeading) {
        var comment = {
          type: source.charAt(start++),
          lineEmpty: false,
          leading: isLeading
        };
        var lookback;
        if (alternateCommentMode) {
          lookback = 2;
        } else {
          lookback = 3;
        }
        var commentOffset = start - lookback, c2;
        do {
          if (--commentOffset < 0 || (c2 = source.charAt(commentOffset)) === "\n") {
            comment.lineEmpty = true;
            break;
          }
        } while (c2 === " " || c2 === "	");
        var lines = source.substring(start, end).split(setCommentSplitRe);
        for (var i = 0; i < lines.length; ++i)
          lines[i] = lines[i].replace(alternateCommentMode ? setCommentAltRe : setCommentRe, "").trim();
        comment.text = lines.join("\n").trim();
        comments[line] = comment;
        lastCommentLine = line;
      }
      function isDoubleSlashCommentLine(startOffset) {
        var endOffset = findEndOfLine(startOffset);
        var lineText = source.substring(startOffset, endOffset);
        var isComment = /^\s*\/{1,2}/.test(lineText);
        return isComment;
      }
      function findEndOfLine(cursor) {
        var endOffset = cursor;
        while (endOffset < length && charAt(endOffset) !== "\n") {
          endOffset++;
        }
        return endOffset;
      }
      function next() {
        if (stack.length > 0)
          return stack.shift();
        if (stringDelim)
          return readString();
        var repeat, prev, curr, start, isDoc, isLeadingComment = offset === 0;
        do {
          if (offset === length)
            return null;
          repeat = false;
          while (whitespaceRe.test(curr = charAt(offset))) {
            if (curr === "\n") {
              isLeadingComment = true;
              ++line;
            }
            if (++offset === length)
              return null;
          }
          if (charAt(offset) === "/") {
            if (++offset === length) {
              throw illegal("comment");
            }
            if (charAt(offset) === "/") {
              if (!alternateCommentMode) {
                isDoc = charAt(start = offset + 1) === "/";
                while (charAt(++offset) !== "\n") {
                  if (offset === length) {
                    return null;
                  }
                }
                ++offset;
                if (isDoc) {
                  setComment(start, offset - 1, isLeadingComment);
                  isLeadingComment = true;
                }
                ++line;
                repeat = true;
              } else {
                start = offset;
                isDoc = false;
                if (isDoubleSlashCommentLine(offset)) {
                  isDoc = true;
                  do {
                    offset = findEndOfLine(offset);
                    if (offset === length) {
                      break;
                    }
                    offset++;
                    if (!isLeadingComment) {
                      break;
                    }
                  } while (isDoubleSlashCommentLine(offset));
                } else {
                  offset = Math.min(length, findEndOfLine(offset) + 1);
                }
                if (isDoc) {
                  setComment(start, offset, isLeadingComment);
                  isLeadingComment = true;
                }
                line++;
                repeat = true;
              }
            } else if ((curr = charAt(offset)) === "*") {
              start = offset + 1;
              isDoc = alternateCommentMode || charAt(start) === "*";
              do {
                if (curr === "\n") {
                  ++line;
                }
                if (++offset === length) {
                  throw illegal("comment");
                }
                prev = curr;
                curr = charAt(offset);
              } while (prev !== "*" || curr !== "/");
              ++offset;
              if (isDoc) {
                setComment(start, offset - 2, isLeadingComment);
                isLeadingComment = true;
              }
              repeat = true;
            } else {
              return "/";
            }
          }
        } while (repeat);
        var end = offset;
        delimRe.lastIndex = 0;
        var delim = delimRe.test(charAt(end++));
        if (!delim)
          while (end < length && !delimRe.test(charAt(end)))
            ++end;
        var token = source.substring(offset, offset = end);
        if (token === '"' || token === "'")
          stringDelim = token;
        return token;
      }
      function push(token) {
        stack.push(token);
      }
      function peek() {
        if (!stack.length) {
          var token = next();
          if (token === null)
            return null;
          push(token);
        }
        return stack[0];
      }
      function skip(expected, optional) {
        var actual = peek(), equals = actual === expected;
        if (equals) {
          next();
          return true;
        }
        if (!optional)
          throw illegal("token '" + actual + "', '" + expected + "' expected");
        return false;
      }
      function cmnt(trailingLine) {
        var ret = null;
        var comment;
        if (trailingLine === void 0) {
          comment = comments[line - 1];
          delete comments[line - 1];
          if (comment && (alternateCommentMode || comment.type === "*" || comment.lineEmpty)) {
            ret = comment.leading ? comment.text : null;
          }
        } else {
          if (lastCommentLine < trailingLine) {
            peek();
          }
          comment = comments[trailingLine];
          delete comments[trailingLine];
          if (comment && !comment.lineEmpty && (alternateCommentMode || comment.type === "/")) {
            ret = comment.leading ? null : comment.text;
          }
        }
        return ret;
      }
      return Object.defineProperty({
        next,
        peek,
        push,
        skip,
        cmnt
      }, "line", {
        get: function() {
          return line;
        }
      });
    }
  }
});

// node_modules/protobufjs/src/parse.js
var require_parse = __commonJS({
  "node_modules/protobufjs/src/parse.js"(exports2, module2) {
    "use strict";
    module2.exports = parse;
    parse.filename = null;
    parse.defaults = { keepCase: false };
    var tokenize = require_tokenize();
    var Root = require_root();
    var Type = require_type();
    var Field = require_field();
    var MapField = require_mapfield();
    var OneOf = require_oneof();
    var Enum = require_enum();
    var Service = require_service2();
    var Method = require_method();
    var types = require_types();
    var util = require_util();
    var base10Re = /^[1-9][0-9]*$/;
    var base10NegRe = /^-?[1-9][0-9]*$/;
    var base16Re = /^0[x][0-9a-fA-F]+$/;
    var base16NegRe = /^-?0[x][0-9a-fA-F]+$/;
    var base8Re = /^0[0-7]+$/;
    var base8NegRe = /^-?0[0-7]+$/;
    var numberRe = /^(?![eE])[0-9]*(?:\.[0-9]*)?(?:[eE][+-]?[0-9]+)?$/;
    var nameRe = /^[a-zA-Z_][a-zA-Z_0-9]*$/;
    var typeRefRe = /^(?:\.?[a-zA-Z_][a-zA-Z_0-9]*)(?:\.[a-zA-Z_][a-zA-Z_0-9]*)*$/;
    var fqTypeRefRe = /^(?:\.[a-zA-Z_][a-zA-Z_0-9]*)+$/;
    function parse(source, root, options) {
      if (!(root instanceof Root)) {
        options = root;
        root = new Root();
      }
      if (!options)
        options = parse.defaults;
      var preferTrailingComment = options.preferTrailingComment || false;
      var tn = tokenize(source, options.alternateCommentMode || false), next = tn.next, push = tn.push, peek = tn.peek, skip = tn.skip, cmnt = tn.cmnt;
      var head = true, pkg, imports, weakImports, syntax, isProto3 = false;
      var ptr = root;
      var applyCase = options.keepCase ? function(name) {
        return name;
      } : util.camelCase;
      function illegal(token2, name, insideTryCatch) {
        var filename = parse.filename;
        if (!insideTryCatch)
          parse.filename = null;
        return Error("illegal " + (name || "token") + " '" + token2 + "' (" + (filename ? filename + ", " : "") + "line " + tn.line + ")");
      }
      function readString() {
        var values = [], token2;
        do {
          if ((token2 = next()) !== '"' && token2 !== "'")
            throw illegal(token2);
          values.push(next());
          skip(token2);
          token2 = peek();
        } while (token2 === '"' || token2 === "'");
        return values.join("");
      }
      function readValue(acceptTypeRef) {
        var token2 = next();
        switch (token2) {
          case "'":
          case '"':
            push(token2);
            return readString();
          case "true":
          case "TRUE":
            return true;
          case "false":
          case "FALSE":
            return false;
        }
        try {
          return parseNumber(
            token2,
            /* insideTryCatch */
            true
          );
        } catch (e2) {
          if (acceptTypeRef && typeRefRe.test(token2))
            return token2;
          throw illegal(token2, "value");
        }
      }
      function readRanges(target, acceptStrings) {
        var token2, start;
        do {
          if (acceptStrings && ((token2 = peek()) === '"' || token2 === "'"))
            target.push(readString());
          else
            target.push([start = parseId(next()), skip("to", true) ? parseId(next()) : start]);
        } while (skip(",", true));
        skip(";");
      }
      function parseNumber(token2, insideTryCatch) {
        var sign = 1;
        if (token2.charAt(0) === "-") {
          sign = -1;
          token2 = token2.substring(1);
        }
        switch (token2) {
          case "inf":
          case "INF":
          case "Inf":
            return sign * Infinity;
          case "nan":
          case "NAN":
          case "Nan":
          case "NaN":
            return NaN;
          case "0":
            return 0;
        }
        if (base10Re.test(token2))
          return sign * parseInt(token2, 10);
        if (base16Re.test(token2))
          return sign * parseInt(token2, 16);
        if (base8Re.test(token2))
          return sign * parseInt(token2, 8);
        if (numberRe.test(token2))
          return sign * parseFloat(token2);
        throw illegal(token2, "number", insideTryCatch);
      }
      function parseId(token2, acceptNegative) {
        switch (token2) {
          case "max":
          case "MAX":
          case "Max":
            return 536870911;
          case "0":
            return 0;
        }
        if (!acceptNegative && token2.charAt(0) === "-")
          throw illegal(token2, "id");
        if (base10NegRe.test(token2))
          return parseInt(token2, 10);
        if (base16NegRe.test(token2))
          return parseInt(token2, 16);
        if (base8NegRe.test(token2))
          return parseInt(token2, 8);
        throw illegal(token2, "id");
      }
      function parsePackage() {
        if (pkg !== void 0)
          throw illegal("package");
        pkg = next();
        if (!typeRefRe.test(pkg))
          throw illegal(pkg, "name");
        ptr = ptr.define(pkg);
        skip(";");
      }
      function parseImport() {
        var token2 = peek();
        var whichImports;
        switch (token2) {
          case "weak":
            whichImports = weakImports || (weakImports = []);
            next();
            break;
          case "public":
            next();
          default:
            whichImports = imports || (imports = []);
            break;
        }
        token2 = readString();
        skip(";");
        whichImports.push(token2);
      }
      function parseSyntax() {
        skip("=");
        syntax = readString();
        isProto3 = syntax === "proto3";
        if (!isProto3 && syntax !== "proto2")
          throw illegal(syntax, "syntax");
        skip(";");
      }
      function parseCommon(parent, token2) {
        switch (token2) {
          case "option":
            parseOption(parent, token2);
            skip(";");
            return true;
          case "message":
            parseType(parent, token2);
            return true;
          case "enum":
            parseEnum(parent, token2);
            return true;
          case "service":
            parseService(parent, token2);
            return true;
          case "extend":
            parseExtension(parent, token2);
            return true;
        }
        return false;
      }
      function ifBlock(obj, fnIf, fnElse) {
        var trailingLine = tn.line;
        if (obj) {
          if (typeof obj.comment !== "string") {
            obj.comment = cmnt();
          }
          obj.filename = parse.filename;
        }
        if (skip("{", true)) {
          var token2;
          while ((token2 = next()) !== "}")
            fnIf(token2);
          skip(";", true);
        } else {
          if (fnElse)
            fnElse();
          skip(";");
          if (obj && (typeof obj.comment !== "string" || preferTrailingComment))
            obj.comment = cmnt(trailingLine) || obj.comment;
        }
      }
      function parseType(parent, token2) {
        if (!nameRe.test(token2 = next()))
          throw illegal(token2, "type name");
        var type = new Type(token2);
        ifBlock(type, function parseType_block(token3) {
          if (parseCommon(type, token3))
            return;
          switch (token3) {
            case "map":
              parseMapField(type, token3);
              break;
            case "required":
            case "repeated":
              parseField(type, token3);
              break;
            case "optional":
              if (isProto3) {
                parseField(type, "proto3_optional");
              } else {
                parseField(type, "optional");
              }
              break;
            case "oneof":
              parseOneOf(type, token3);
              break;
            case "extensions":
              readRanges(type.extensions || (type.extensions = []));
              break;
            case "reserved":
              readRanges(type.reserved || (type.reserved = []), true);
              break;
            default:
              if (!isProto3 || !typeRefRe.test(token3))
                throw illegal(token3);
              push(token3);
              parseField(type, "optional");
              break;
          }
        });
        parent.add(type);
      }
      function parseField(parent, rule, extend) {
        var type = next();
        if (type === "group") {
          parseGroup(parent, rule);
          return;
        }
        if (!typeRefRe.test(type))
          throw illegal(type, "type");
        var name = next();
        if (!nameRe.test(name))
          throw illegal(name, "name");
        name = applyCase(name);
        skip("=");
        var field = new Field(name, parseId(next()), type, rule, extend);
        ifBlock(field, function parseField_block(token2) {
          if (token2 === "option") {
            parseOption(field, token2);
            skip(";");
          } else
            throw illegal(token2);
        }, function parseField_line() {
          parseInlineOptions(field);
        });
        if (rule === "proto3_optional") {
          var oneof = new OneOf("_" + name);
          field.setOption("proto3_optional", true);
          oneof.add(field);
          parent.add(oneof);
        } else {
          parent.add(field);
        }
        if (!isProto3 && field.repeated && (types.packed[type] !== void 0 || types.basic[type] === void 0))
          field.setOption(
            "packed",
            false,
            /* ifNotSet */
            true
          );
      }
      function parseGroup(parent, rule) {
        var name = next();
        if (!nameRe.test(name))
          throw illegal(name, "name");
        var fieldName = util.lcFirst(name);
        if (name === fieldName)
          name = util.ucFirst(name);
        skip("=");
        var id = parseId(next());
        var type = new Type(name);
        type.group = true;
        var field = new Field(fieldName, id, name, rule);
        field.filename = parse.filename;
        ifBlock(type, function parseGroup_block(token2) {
          switch (token2) {
            case "option":
              parseOption(type, token2);
              skip(";");
              break;
            case "required":
            case "repeated":
              parseField(type, token2);
              break;
            case "optional":
              if (isProto3) {
                parseField(type, "proto3_optional");
              } else {
                parseField(type, "optional");
              }
              break;
            case "message":
              parseType(type, token2);
              break;
            case "enum":
              parseEnum(type, token2);
              break;
            default:
              throw illegal(token2);
          }
        });
        parent.add(type).add(field);
      }
      function parseMapField(parent) {
        skip("<");
        var keyType = next();
        if (types.mapKey[keyType] === void 0)
          throw illegal(keyType, "type");
        skip(",");
        var valueType = next();
        if (!typeRefRe.test(valueType))
          throw illegal(valueType, "type");
        skip(">");
        var name = next();
        if (!nameRe.test(name))
          throw illegal(name, "name");
        skip("=");
        var field = new MapField(applyCase(name), parseId(next()), keyType, valueType);
        ifBlock(field, function parseMapField_block(token2) {
          if (token2 === "option") {
            parseOption(field, token2);
            skip(";");
          } else
            throw illegal(token2);
        }, function parseMapField_line() {
          parseInlineOptions(field);
        });
        parent.add(field);
      }
      function parseOneOf(parent, token2) {
        if (!nameRe.test(token2 = next()))
          throw illegal(token2, "name");
        var oneof = new OneOf(applyCase(token2));
        ifBlock(oneof, function parseOneOf_block(token3) {
          if (token3 === "option") {
            parseOption(oneof, token3);
            skip(";");
          } else {
            push(token3);
            parseField(oneof, "optional");
          }
        });
        parent.add(oneof);
      }
      function parseEnum(parent, token2) {
        if (!nameRe.test(token2 = next()))
          throw illegal(token2, "name");
        var enm = new Enum(token2);
        ifBlock(enm, function parseEnum_block(token3) {
          switch (token3) {
            case "option":
              parseOption(enm, token3);
              skip(";");
              break;
            case "reserved":
              readRanges(enm.reserved || (enm.reserved = []), true);
              break;
            default:
              parseEnumValue(enm, token3);
          }
        });
        parent.add(enm);
      }
      function parseEnumValue(parent, token2) {
        if (!nameRe.test(token2))
          throw illegal(token2, "name");
        skip("=");
        var value = parseId(next(), true), dummy = {
          options: void 0
        };
        dummy.setOption = function(name, value2) {
          if (this.options === void 0)
            this.options = {};
          this.options[name] = value2;
        };
        ifBlock(dummy, function parseEnumValue_block(token3) {
          if (token3 === "option") {
            parseOption(dummy, token3);
            skip(";");
          } else
            throw illegal(token3);
        }, function parseEnumValue_line() {
          parseInlineOptions(dummy);
        });
        parent.add(token2, value, dummy.comment, dummy.options);
      }
      function parseOption(parent, token2) {
        var isCustom = skip("(", true);
        if (!typeRefRe.test(token2 = next()))
          throw illegal(token2, "name");
        var name = token2;
        var option = name;
        var propName;
        if (isCustom) {
          skip(")");
          name = "(" + name + ")";
          option = name;
          token2 = peek();
          if (fqTypeRefRe.test(token2)) {
            propName = token2.slice(1);
            name += token2;
            next();
          }
        }
        skip("=");
        var optionValue = parseOptionValue(parent, name);
        setParsedOption(parent, option, optionValue, propName);
      }
      function parseOptionValue(parent, name) {
        if (skip("{", true)) {
          var objectResult = {};
          while (!skip("}", true)) {
            if (!nameRe.test(token = next())) {
              throw illegal(token, "name");
            }
            var value;
            var propName = token;
            skip(":", true);
            if (peek() === "{")
              value = parseOptionValue(parent, name + "." + token);
            else if (peek() === "[") {
              value = [];
              var lastValue;
              if (skip("[", true)) {
                do {
                  lastValue = readValue(true);
                  value.push(lastValue);
                } while (skip(",", true));
                skip("]");
                if (typeof lastValue !== "undefined") {
                  setOption(parent, name + "." + token, lastValue);
                }
              }
            } else {
              value = readValue(true);
              setOption(parent, name + "." + token, value);
            }
            var prevValue = objectResult[propName];
            if (prevValue)
              value = [].concat(prevValue).concat(value);
            objectResult[propName] = value;
            skip(",", true);
            skip(";", true);
          }
          return objectResult;
        }
        var simpleValue = readValue(true);
        setOption(parent, name, simpleValue);
        return simpleValue;
      }
      function setOption(parent, name, value) {
        if (parent.setOption)
          parent.setOption(name, value);
      }
      function setParsedOption(parent, name, value, propName) {
        if (parent.setParsedOption)
          parent.setParsedOption(name, value, propName);
      }
      function parseInlineOptions(parent) {
        if (skip("[", true)) {
          do {
            parseOption(parent, "option");
          } while (skip(",", true));
          skip("]");
        }
        return parent;
      }
      function parseService(parent, token2) {
        if (!nameRe.test(token2 = next()))
          throw illegal(token2, "service name");
        var service = new Service(token2);
        ifBlock(service, function parseService_block(token3) {
          if (parseCommon(service, token3))
            return;
          if (token3 === "rpc")
            parseMethod(service, token3);
          else
            throw illegal(token3);
        });
        parent.add(service);
      }
      function parseMethod(parent, token2) {
        var commentText = cmnt();
        var type = token2;
        if (!nameRe.test(token2 = next()))
          throw illegal(token2, "name");
        var name = token2, requestType, requestStream, responseType, responseStream;
        skip("(");
        if (skip("stream", true))
          requestStream = true;
        if (!typeRefRe.test(token2 = next()))
          throw illegal(token2);
        requestType = token2;
        skip(")");
        skip("returns");
        skip("(");
        if (skip("stream", true))
          responseStream = true;
        if (!typeRefRe.test(token2 = next()))
          throw illegal(token2);
        responseType = token2;
        skip(")");
        var method = new Method(name, type, requestType, responseType, requestStream, responseStream);
        method.comment = commentText;
        ifBlock(method, function parseMethod_block(token3) {
          if (token3 === "option") {
            parseOption(method, token3);
            skip(";");
          } else
            throw illegal(token3);
        });
        parent.add(method);
      }
      function parseExtension(parent, token2) {
        if (!typeRefRe.test(token2 = next()))
          throw illegal(token2, "reference");
        var reference = token2;
        ifBlock(null, function parseExtension_block(token3) {
          switch (token3) {
            case "required":
            case "repeated":
              parseField(parent, token3, reference);
              break;
            case "optional":
              if (isProto3) {
                parseField(parent, "proto3_optional", reference);
              } else {
                parseField(parent, "optional", reference);
              }
              break;
            default:
              if (!isProto3 || !typeRefRe.test(token3))
                throw illegal(token3);
              push(token3);
              parseField(parent, "optional", reference);
              break;
          }
        });
      }
      var token;
      while ((token = next()) !== null) {
        switch (token) {
          case "package":
            if (!head)
              throw illegal(token);
            parsePackage();
            break;
          case "import":
            if (!head)
              throw illegal(token);
            parseImport();
            break;
          case "syntax":
            if (!head)
              throw illegal(token);
            parseSyntax();
            break;
          case "option":
            parseOption(ptr, token);
            skip(";");
            break;
          default:
            if (parseCommon(ptr, token)) {
              head = false;
              continue;
            }
            throw illegal(token);
        }
      }
      parse.filename = null;
      return {
        "package": pkg,
        "imports": imports,
        weakImports,
        syntax,
        root
      };
    }
  }
});

// node_modules/protobufjs/src/common.js
var require_common = __commonJS({
  "node_modules/protobufjs/src/common.js"(exports2, module2) {
    "use strict";
    module2.exports = common;
    var commonRe = /\/|\./;
    function common(name, json) {
      if (!commonRe.test(name)) {
        name = "google/protobuf/" + name + ".proto";
        json = { nested: { google: { nested: { protobuf: { nested: json } } } } };
      }
      common[name] = json;
    }
    common("any", {
      /**
       * Properties of a google.protobuf.Any message.
       * @interface IAny
       * @type {Object}
       * @property {string} [typeUrl]
       * @property {Uint8Array} [bytes]
       * @memberof common
       */
      Any: {
        fields: {
          type_url: {
            type: "string",
            id: 1
          },
          value: {
            type: "bytes",
            id: 2
          }
        }
      }
    });
    var timeType;
    common("duration", {
      /**
       * Properties of a google.protobuf.Duration message.
       * @interface IDuration
       * @type {Object}
       * @property {number|Long} [seconds]
       * @property {number} [nanos]
       * @memberof common
       */
      Duration: timeType = {
        fields: {
          seconds: {
            type: "int64",
            id: 1
          },
          nanos: {
            type: "int32",
            id: 2
          }
        }
      }
    });
    common("timestamp", {
      /**
       * Properties of a google.protobuf.Timestamp message.
       * @interface ITimestamp
       * @type {Object}
       * @property {number|Long} [seconds]
       * @property {number} [nanos]
       * @memberof common
       */
      Timestamp: timeType
    });
    common("empty", {
      /**
       * Properties of a google.protobuf.Empty message.
       * @interface IEmpty
       * @memberof common
       */
      Empty: {
        fields: {}
      }
    });
    common("struct", {
      /**
       * Properties of a google.protobuf.Struct message.
       * @interface IStruct
       * @type {Object}
       * @property {Object.<string,IValue>} [fields]
       * @memberof common
       */
      Struct: {
        fields: {
          fields: {
            keyType: "string",
            type: "Value",
            id: 1
          }
        }
      },
      /**
       * Properties of a google.protobuf.Value message.
       * @interface IValue
       * @type {Object}
       * @property {string} [kind]
       * @property {0} [nullValue]
       * @property {number} [numberValue]
       * @property {string} [stringValue]
       * @property {boolean} [boolValue]
       * @property {IStruct} [structValue]
       * @property {IListValue} [listValue]
       * @memberof common
       */
      Value: {
        oneofs: {
          kind: {
            oneof: [
              "nullValue",
              "numberValue",
              "stringValue",
              "boolValue",
              "structValue",
              "listValue"
            ]
          }
        },
        fields: {
          nullValue: {
            type: "NullValue",
            id: 1
          },
          numberValue: {
            type: "double",
            id: 2
          },
          stringValue: {
            type: "string",
            id: 3
          },
          boolValue: {
            type: "bool",
            id: 4
          },
          structValue: {
            type: "Struct",
            id: 5
          },
          listValue: {
            type: "ListValue",
            id: 6
          }
        }
      },
      NullValue: {
        values: {
          NULL_VALUE: 0
        }
      },
      /**
       * Properties of a google.protobuf.ListValue message.
       * @interface IListValue
       * @type {Object}
       * @property {Array.<IValue>} [values]
       * @memberof common
       */
      ListValue: {
        fields: {
          values: {
            rule: "repeated",
            type: "Value",
            id: 1
          }
        }
      }
    });
    common("wrappers", {
      /**
       * Properties of a google.protobuf.DoubleValue message.
       * @interface IDoubleValue
       * @type {Object}
       * @property {number} [value]
       * @memberof common
       */
      DoubleValue: {
        fields: {
          value: {
            type: "double",
            id: 1
          }
        }
      },
      /**
       * Properties of a google.protobuf.FloatValue message.
       * @interface IFloatValue
       * @type {Object}
       * @property {number} [value]
       * @memberof common
       */
      FloatValue: {
        fields: {
          value: {
            type: "float",
            id: 1
          }
        }
      },
      /**
       * Properties of a google.protobuf.Int64Value message.
       * @interface IInt64Value
       * @type {Object}
       * @property {number|Long} [value]
       * @memberof common
       */
      Int64Value: {
        fields: {
          value: {
            type: "int64",
            id: 1
          }
        }
      },
      /**
       * Properties of a google.protobuf.UInt64Value message.
       * @interface IUInt64Value
       * @type {Object}
       * @property {number|Long} [value]
       * @memberof common
       */
      UInt64Value: {
        fields: {
          value: {
            type: "uint64",
            id: 1
          }
        }
      },
      /**
       * Properties of a google.protobuf.Int32Value message.
       * @interface IInt32Value
       * @type {Object}
       * @property {number} [value]
       * @memberof common
       */
      Int32Value: {
        fields: {
          value: {
            type: "int32",
            id: 1
          }
        }
      },
      /**
       * Properties of a google.protobuf.UInt32Value message.
       * @interface IUInt32Value
       * @type {Object}
       * @property {number} [value]
       * @memberof common
       */
      UInt32Value: {
        fields: {
          value: {
            type: "uint32",
            id: 1
          }
        }
      },
      /**
       * Properties of a google.protobuf.BoolValue message.
       * @interface IBoolValue
       * @type {Object}
       * @property {boolean} [value]
       * @memberof common
       */
      BoolValue: {
        fields: {
          value: {
            type: "bool",
            id: 1
          }
        }
      },
      /**
       * Properties of a google.protobuf.StringValue message.
       * @interface IStringValue
       * @type {Object}
       * @property {string} [value]
       * @memberof common
       */
      StringValue: {
        fields: {
          value: {
            type: "string",
            id: 1
          }
        }
      },
      /**
       * Properties of a google.protobuf.BytesValue message.
       * @interface IBytesValue
       * @type {Object}
       * @property {Uint8Array} [value]
       * @memberof common
       */
      BytesValue: {
        fields: {
          value: {
            type: "bytes",
            id: 1
          }
        }
      }
    });
    common("field_mask", {
      /**
       * Properties of a google.protobuf.FieldMask message.
       * @interface IDoubleValue
       * @type {Object}
       * @property {number} [value]
       * @memberof common
       */
      FieldMask: {
        fields: {
          paths: {
            rule: "repeated",
            type: "string",
            id: 1
          }
        }
      }
    });
    common.get = function get(file) {
      return common[file] || null;
    };
  }
});

// node_modules/protobufjs/src/index.js
var require_src = __commonJS({
  "node_modules/protobufjs/src/index.js"(exports2, module2) {
    "use strict";
    var protobuf = module2.exports = require_index_light();
    protobuf.build = "full";
    protobuf.tokenize = require_tokenize();
    protobuf.parse = require_parse();
    protobuf.common = require_common();
    protobuf.Root._configure(protobuf.Type, protobuf.parse, protobuf.common);
  }
});

// node_modules/protobufjs/index.js
var require_protobufjs = __commonJS({
  "node_modules/protobufjs/index.js"(exports2, module2) {
    "use strict";
    module2.exports = require_src();
  }
});

// node_modules/protobufjs/google/protobuf/descriptor.json
var require_descriptor = __commonJS({
  "node_modules/protobufjs/google/protobuf/descriptor.json"(exports2, module2) {
    module2.exports = {
      nested: {
        google: {
          nested: {
            protobuf: {
              nested: {
                FileDescriptorSet: {
                  fields: {
                    file: {
                      rule: "repeated",
                      type: "FileDescriptorProto",
                      id: 1
                    }
                  }
                },
                FileDescriptorProto: {
                  fields: {
                    name: {
                      type: "string",
                      id: 1
                    },
                    package: {
                      type: "string",
                      id: 2
                    },
                    dependency: {
                      rule: "repeated",
                      type: "string",
                      id: 3
                    },
                    publicDependency: {
                      rule: "repeated",
                      type: "int32",
                      id: 10,
                      options: {
                        packed: false
                      }
                    },
                    weakDependency: {
                      rule: "repeated",
                      type: "int32",
                      id: 11,
                      options: {
                        packed: false
                      }
                    },
                    messageType: {
                      rule: "repeated",
                      type: "DescriptorProto",
                      id: 4
                    },
                    enumType: {
                      rule: "repeated",
                      type: "EnumDescriptorProto",
                      id: 5
                    },
                    service: {
                      rule: "repeated",
                      type: "ServiceDescriptorProto",
                      id: 6
                    },
                    extension: {
                      rule: "repeated",
                      type: "FieldDescriptorProto",
                      id: 7
                    },
                    options: {
                      type: "FileOptions",
                      id: 8
                    },
                    sourceCodeInfo: {
                      type: "SourceCodeInfo",
                      id: 9
                    },
                    syntax: {
                      type: "string",
                      id: 12
                    }
                  }
                },
                DescriptorProto: {
                  fields: {
                    name: {
                      type: "string",
                      id: 1
                    },
                    field: {
                      rule: "repeated",
                      type: "FieldDescriptorProto",
                      id: 2
                    },
                    extension: {
                      rule: "repeated",
                      type: "FieldDescriptorProto",
                      id: 6
                    },
                    nestedType: {
                      rule: "repeated",
                      type: "DescriptorProto",
                      id: 3
                    },
                    enumType: {
                      rule: "repeated",
                      type: "EnumDescriptorProto",
                      id: 4
                    },
                    extensionRange: {
                      rule: "repeated",
                      type: "ExtensionRange",
                      id: 5
                    },
                    oneofDecl: {
                      rule: "repeated",
                      type: "OneofDescriptorProto",
                      id: 8
                    },
                    options: {
                      type: "MessageOptions",
                      id: 7
                    },
                    reservedRange: {
                      rule: "repeated",
                      type: "ReservedRange",
                      id: 9
                    },
                    reservedName: {
                      rule: "repeated",
                      type: "string",
                      id: 10
                    }
                  },
                  nested: {
                    ExtensionRange: {
                      fields: {
                        start: {
                          type: "int32",
                          id: 1
                        },
                        end: {
                          type: "int32",
                          id: 2
                        }
                      }
                    },
                    ReservedRange: {
                      fields: {
                        start: {
                          type: "int32",
                          id: 1
                        },
                        end: {
                          type: "int32",
                          id: 2
                        }
                      }
                    }
                  }
                },
                FieldDescriptorProto: {
                  fields: {
                    name: {
                      type: "string",
                      id: 1
                    },
                    number: {
                      type: "int32",
                      id: 3
                    },
                    label: {
                      type: "Label",
                      id: 4
                    },
                    type: {
                      type: "Type",
                      id: 5
                    },
                    typeName: {
                      type: "string",
                      id: 6
                    },
                    extendee: {
                      type: "string",
                      id: 2
                    },
                    defaultValue: {
                      type: "string",
                      id: 7
                    },
                    oneofIndex: {
                      type: "int32",
                      id: 9
                    },
                    jsonName: {
                      type: "string",
                      id: 10
                    },
                    options: {
                      type: "FieldOptions",
                      id: 8
                    }
                  },
                  nested: {
                    Type: {
                      values: {
                        TYPE_DOUBLE: 1,
                        TYPE_FLOAT: 2,
                        TYPE_INT64: 3,
                        TYPE_UINT64: 4,
                        TYPE_INT32: 5,
                        TYPE_FIXED64: 6,
                        TYPE_FIXED32: 7,
                        TYPE_BOOL: 8,
                        TYPE_STRING: 9,
                        TYPE_GROUP: 10,
                        TYPE_MESSAGE: 11,
                        TYPE_BYTES: 12,
                        TYPE_UINT32: 13,
                        TYPE_ENUM: 14,
                        TYPE_SFIXED32: 15,
                        TYPE_SFIXED64: 16,
                        TYPE_SINT32: 17,
                        TYPE_SINT64: 18
                      }
                    },
                    Label: {
                      values: {
                        LABEL_OPTIONAL: 1,
                        LABEL_REQUIRED: 2,
                        LABEL_REPEATED: 3
                      }
                    }
                  }
                },
                OneofDescriptorProto: {
                  fields: {
                    name: {
                      type: "string",
                      id: 1
                    },
                    options: {
                      type: "OneofOptions",
                      id: 2
                    }
                  }
                },
                EnumDescriptorProto: {
                  fields: {
                    name: {
                      type: "string",
                      id: 1
                    },
                    value: {
                      rule: "repeated",
                      type: "EnumValueDescriptorProto",
                      id: 2
                    },
                    options: {
                      type: "EnumOptions",
                      id: 3
                    }
                  }
                },
                EnumValueDescriptorProto: {
                  fields: {
                    name: {
                      type: "string",
                      id: 1
                    },
                    number: {
                      type: "int32",
                      id: 2
                    },
                    options: {
                      type: "EnumValueOptions",
                      id: 3
                    }
                  }
                },
                ServiceDescriptorProto: {
                  fields: {
                    name: {
                      type: "string",
                      id: 1
                    },
                    method: {
                      rule: "repeated",
                      type: "MethodDescriptorProto",
                      id: 2
                    },
                    options: {
                      type: "ServiceOptions",
                      id: 3
                    }
                  }
                },
                MethodDescriptorProto: {
                  fields: {
                    name: {
                      type: "string",
                      id: 1
                    },
                    inputType: {
                      type: "string",
                      id: 2
                    },
                    outputType: {
                      type: "string",
                      id: 3
                    },
                    options: {
                      type: "MethodOptions",
                      id: 4
                    },
                    clientStreaming: {
                      type: "bool",
                      id: 5
                    },
                    serverStreaming: {
                      type: "bool",
                      id: 6
                    }
                  }
                },
                FileOptions: {
                  fields: {
                    javaPackage: {
                      type: "string",
                      id: 1
                    },
                    javaOuterClassname: {
                      type: "string",
                      id: 8
                    },
                    javaMultipleFiles: {
                      type: "bool",
                      id: 10
                    },
                    javaGenerateEqualsAndHash: {
                      type: "bool",
                      id: 20,
                      options: {
                        deprecated: true
                      }
                    },
                    javaStringCheckUtf8: {
                      type: "bool",
                      id: 27
                    },
                    optimizeFor: {
                      type: "OptimizeMode",
                      id: 9,
                      options: {
                        default: "SPEED"
                      }
                    },
                    goPackage: {
                      type: "string",
                      id: 11
                    },
                    ccGenericServices: {
                      type: "bool",
                      id: 16
                    },
                    javaGenericServices: {
                      type: "bool",
                      id: 17
                    },
                    pyGenericServices: {
                      type: "bool",
                      id: 18
                    },
                    deprecated: {
                      type: "bool",
                      id: 23
                    },
                    ccEnableArenas: {
                      type: "bool",
                      id: 31
                    },
                    objcClassPrefix: {
                      type: "string",
                      id: 36
                    },
                    csharpNamespace: {
                      type: "string",
                      id: 37
                    },
                    uninterpretedOption: {
                      rule: "repeated",
                      type: "UninterpretedOption",
                      id: 999
                    }
                  },
                  extensions: [
                    [
                      1e3,
                      536870911
                    ]
                  ],
                  reserved: [
                    [
                      38,
                      38
                    ]
                  ],
                  nested: {
                    OptimizeMode: {
                      values: {
                        SPEED: 1,
                        CODE_SIZE: 2,
                        LITE_RUNTIME: 3
                      }
                    }
                  }
                },
                MessageOptions: {
                  fields: {
                    messageSetWireFormat: {
                      type: "bool",
                      id: 1
                    },
                    noStandardDescriptorAccessor: {
                      type: "bool",
                      id: 2
                    },
                    deprecated: {
                      type: "bool",
                      id: 3
                    },
                    mapEntry: {
                      type: "bool",
                      id: 7
                    },
                    uninterpretedOption: {
                      rule: "repeated",
                      type: "UninterpretedOption",
                      id: 999
                    }
                  },
                  extensions: [
                    [
                      1e3,
                      536870911
                    ]
                  ],
                  reserved: [
                    [
                      8,
                      8
                    ]
                  ]
                },
                FieldOptions: {
                  fields: {
                    ctype: {
                      type: "CType",
                      id: 1,
                      options: {
                        default: "STRING"
                      }
                    },
                    packed: {
                      type: "bool",
                      id: 2
                    },
                    jstype: {
                      type: "JSType",
                      id: 6,
                      options: {
                        default: "JS_NORMAL"
                      }
                    },
                    lazy: {
                      type: "bool",
                      id: 5
                    },
                    deprecated: {
                      type: "bool",
                      id: 3
                    },
                    weak: {
                      type: "bool",
                      id: 10
                    },
                    uninterpretedOption: {
                      rule: "repeated",
                      type: "UninterpretedOption",
                      id: 999
                    }
                  },
                  extensions: [
                    [
                      1e3,
                      536870911
                    ]
                  ],
                  reserved: [
                    [
                      4,
                      4
                    ]
                  ],
                  nested: {
                    CType: {
                      values: {
                        STRING: 0,
                        CORD: 1,
                        STRING_PIECE: 2
                      }
                    },
                    JSType: {
                      values: {
                        JS_NORMAL: 0,
                        JS_STRING: 1,
                        JS_NUMBER: 2
                      }
                    }
                  }
                },
                OneofOptions: {
                  fields: {
                    uninterpretedOption: {
                      rule: "repeated",
                      type: "UninterpretedOption",
                      id: 999
                    }
                  },
                  extensions: [
                    [
                      1e3,
                      536870911
                    ]
                  ]
                },
                EnumOptions: {
                  fields: {
                    allowAlias: {
                      type: "bool",
                      id: 2
                    },
                    deprecated: {
                      type: "bool",
                      id: 3
                    },
                    uninterpretedOption: {
                      rule: "repeated",
                      type: "UninterpretedOption",
                      id: 999
                    }
                  },
                  extensions: [
                    [
                      1e3,
                      536870911
                    ]
                  ]
                },
                EnumValueOptions: {
                  fields: {
                    deprecated: {
                      type: "bool",
                      id: 1
                    },
                    uninterpretedOption: {
                      rule: "repeated",
                      type: "UninterpretedOption",
                      id: 999
                    }
                  },
                  extensions: [
                    [
                      1e3,
                      536870911
                    ]
                  ]
                },
                ServiceOptions: {
                  fields: {
                    deprecated: {
                      type: "bool",
                      id: 33
                    },
                    uninterpretedOption: {
                      rule: "repeated",
                      type: "UninterpretedOption",
                      id: 999
                    }
                  },
                  extensions: [
                    [
                      1e3,
                      536870911
                    ]
                  ]
                },
                MethodOptions: {
                  fields: {
                    deprecated: {
                      type: "bool",
                      id: 33
                    },
                    uninterpretedOption: {
                      rule: "repeated",
                      type: "UninterpretedOption",
                      id: 999
                    }
                  },
                  extensions: [
                    [
                      1e3,
                      536870911
                    ]
                  ]
                },
                UninterpretedOption: {
                  fields: {
                    name: {
                      rule: "repeated",
                      type: "NamePart",
                      id: 2
                    },
                    identifierValue: {
                      type: "string",
                      id: 3
                    },
                    positiveIntValue: {
                      type: "uint64",
                      id: 4
                    },
                    negativeIntValue: {
                      type: "int64",
                      id: 5
                    },
                    doubleValue: {
                      type: "double",
                      id: 6
                    },
                    stringValue: {
                      type: "bytes",
                      id: 7
                    },
                    aggregateValue: {
                      type: "string",
                      id: 8
                    }
                  },
                  nested: {
                    NamePart: {
                      fields: {
                        namePart: {
                          rule: "required",
                          type: "string",
                          id: 1
                        },
                        isExtension: {
                          rule: "required",
                          type: "bool",
                          id: 2
                        }
                      }
                    }
                  }
                },
                SourceCodeInfo: {
                  fields: {
                    location: {
                      rule: "repeated",
                      type: "Location",
                      id: 1
                    }
                  },
                  nested: {
                    Location: {
                      fields: {
                        path: {
                          rule: "repeated",
                          type: "int32",
                          id: 1
                        },
                        span: {
                          rule: "repeated",
                          type: "int32",
                          id: 2
                        },
                        leadingComments: {
                          type: "string",
                          id: 3
                        },
                        trailingComments: {
                          type: "string",
                          id: 4
                        },
                        leadingDetachedComments: {
                          rule: "repeated",
                          type: "string",
                          id: 6
                        }
                      }
                    }
                  }
                },
                GeneratedCodeInfo: {
                  fields: {
                    annotation: {
                      rule: "repeated",
                      type: "Annotation",
                      id: 1
                    }
                  },
                  nested: {
                    Annotation: {
                      fields: {
                        path: {
                          rule: "repeated",
                          type: "int32",
                          id: 1
                        },
                        sourceFile: {
                          type: "string",
                          id: 2
                        },
                        begin: {
                          type: "int32",
                          id: 3
                        },
                        end: {
                          type: "int32",
                          id: 4
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    };
  }
});

// node_modules/protobufjs/ext/descriptor/index.js
var require_descriptor2 = __commonJS({
  "node_modules/protobufjs/ext/descriptor/index.js"(exports2, module2) {
    "use strict";
    var $protobuf = require_protobufjs();
    module2.exports = exports2 = $protobuf.descriptor = $protobuf.Root.fromJSON(require_descriptor()).lookup(".google.protobuf");
    var Namespace = $protobuf.Namespace;
    var Root = $protobuf.Root;
    var Enum = $protobuf.Enum;
    var Type = $protobuf.Type;
    var Field = $protobuf.Field;
    var MapField = $protobuf.MapField;
    var OneOf = $protobuf.OneOf;
    var Service = $protobuf.Service;
    var Method = $protobuf.Method;
    Root.fromDescriptor = function fromDescriptor(descriptor) {
      if (typeof descriptor.length === "number")
        descriptor = exports2.FileDescriptorSet.decode(descriptor);
      var root = new Root();
      if (descriptor.file) {
        var fileDescriptor, filePackage;
        for (var j = 0, i; j < descriptor.file.length; ++j) {
          filePackage = root;
          if ((fileDescriptor = descriptor.file[j])["package"] && fileDescriptor["package"].length)
            filePackage = root.define(fileDescriptor["package"]);
          if (fileDescriptor.name && fileDescriptor.name.length)
            root.files.push(filePackage.filename = fileDescriptor.name);
          if (fileDescriptor.messageType)
            for (i = 0; i < fileDescriptor.messageType.length; ++i)
              filePackage.add(Type.fromDescriptor(fileDescriptor.messageType[i], fileDescriptor.syntax));
          if (fileDescriptor.enumType)
            for (i = 0; i < fileDescriptor.enumType.length; ++i)
              filePackage.add(Enum.fromDescriptor(fileDescriptor.enumType[i]));
          if (fileDescriptor.extension)
            for (i = 0; i < fileDescriptor.extension.length; ++i)
              filePackage.add(Field.fromDescriptor(fileDescriptor.extension[i]));
          if (fileDescriptor.service)
            for (i = 0; i < fileDescriptor.service.length; ++i)
              filePackage.add(Service.fromDescriptor(fileDescriptor.service[i]));
          var opts = fromDescriptorOptions(fileDescriptor.options, exports2.FileOptions);
          if (opts) {
            var ks = Object.keys(opts);
            for (i = 0; i < ks.length; ++i)
              filePackage.setOption(ks[i], opts[ks[i]]);
          }
        }
      }
      return root;
    };
    Root.prototype.toDescriptor = function toDescriptor(syntax) {
      var set = exports2.FileDescriptorSet.create();
      Root_toDescriptorRecursive(this, set.file, syntax);
      return set;
    };
    function Root_toDescriptorRecursive(ns, files, syntax) {
      var file = exports2.FileDescriptorProto.create({ name: ns.filename || (ns.fullName.substring(1).replace(/\./g, "_") || "root") + ".proto" });
      if (syntax)
        file.syntax = syntax;
      if (!(ns instanceof Root))
        file["package"] = ns.fullName.substring(1);
      for (var i = 0, nested; i < ns.nestedArray.length; ++i)
        if ((nested = ns._nestedArray[i]) instanceof Type)
          file.messageType.push(nested.toDescriptor(syntax));
        else if (nested instanceof Enum)
          file.enumType.push(nested.toDescriptor());
        else if (nested instanceof Field)
          file.extension.push(nested.toDescriptor(syntax));
        else if (nested instanceof Service)
          file.service.push(nested.toDescriptor());
        else if (nested instanceof /* plain */
        Namespace)
          Root_toDescriptorRecursive(nested, files, syntax);
      file.options = toDescriptorOptions(ns.options, exports2.FileOptions);
      if (file.messageType.length + file.enumType.length + file.extension.length + file.service.length)
        files.push(file);
    }
    var unnamedMessageIndex = 0;
    Type.fromDescriptor = function fromDescriptor(descriptor, syntax) {
      if (typeof descriptor.length === "number")
        descriptor = exports2.DescriptorProto.decode(descriptor);
      var type = new Type(descriptor.name.length ? descriptor.name : "Type" + unnamedMessageIndex++, fromDescriptorOptions(descriptor.options, exports2.MessageOptions)), i;
      if (descriptor.oneofDecl)
        for (i = 0; i < descriptor.oneofDecl.length; ++i)
          type.add(OneOf.fromDescriptor(descriptor.oneofDecl[i]));
      if (descriptor.field)
        for (i = 0; i < descriptor.field.length; ++i) {
          var field = Field.fromDescriptor(descriptor.field[i], syntax);
          type.add(field);
          if (descriptor.field[i].hasOwnProperty("oneofIndex"))
            type.oneofsArray[descriptor.field[i].oneofIndex].add(field);
        }
      if (descriptor.extension)
        for (i = 0; i < descriptor.extension.length; ++i)
          type.add(Field.fromDescriptor(descriptor.extension[i], syntax));
      if (descriptor.nestedType)
        for (i = 0; i < descriptor.nestedType.length; ++i) {
          type.add(Type.fromDescriptor(descriptor.nestedType[i], syntax));
          if (descriptor.nestedType[i].options && descriptor.nestedType[i].options.mapEntry)
            type.setOption("map_entry", true);
        }
      if (descriptor.enumType)
        for (i = 0; i < descriptor.enumType.length; ++i)
          type.add(Enum.fromDescriptor(descriptor.enumType[i]));
      if (descriptor.extensionRange && descriptor.extensionRange.length) {
        type.extensions = [];
        for (i = 0; i < descriptor.extensionRange.length; ++i)
          type.extensions.push([descriptor.extensionRange[i].start, descriptor.extensionRange[i].end]);
      }
      if (descriptor.reservedRange && descriptor.reservedRange.length || descriptor.reservedName && descriptor.reservedName.length) {
        type.reserved = [];
        if (descriptor.reservedRange)
          for (i = 0; i < descriptor.reservedRange.length; ++i)
            type.reserved.push([descriptor.reservedRange[i].start, descriptor.reservedRange[i].end]);
        if (descriptor.reservedName)
          for (i = 0; i < descriptor.reservedName.length; ++i)
            type.reserved.push(descriptor.reservedName[i]);
      }
      return type;
    };
    Type.prototype.toDescriptor = function toDescriptor(syntax) {
      var descriptor = exports2.DescriptorProto.create({ name: this.name }), i;
      for (i = 0; i < this.fieldsArray.length; ++i) {
        var fieldDescriptor;
        descriptor.field.push(fieldDescriptor = this._fieldsArray[i].toDescriptor(syntax));
        if (this._fieldsArray[i] instanceof MapField) {
          var keyType = toDescriptorType(this._fieldsArray[i].keyType, this._fieldsArray[i].resolvedKeyType), valueType = toDescriptorType(this._fieldsArray[i].type, this._fieldsArray[i].resolvedType), valueTypeName = valueType === /* type */
          11 || valueType === /* enum */
          14 ? this._fieldsArray[i].resolvedType && shortname(this.parent, this._fieldsArray[i].resolvedType) || this._fieldsArray[i].type : void 0;
          descriptor.nestedType.push(exports2.DescriptorProto.create({
            name: fieldDescriptor.typeName,
            field: [
              exports2.FieldDescriptorProto.create({ name: "key", number: 1, label: 1, type: keyType }),
              // can't reference a type or enum
              exports2.FieldDescriptorProto.create({ name: "value", number: 2, label: 1, type: valueType, typeName: valueTypeName })
            ],
            options: exports2.MessageOptions.create({ mapEntry: true })
          }));
        }
      }
      for (i = 0; i < this.oneofsArray.length; ++i)
        descriptor.oneofDecl.push(this._oneofsArray[i].toDescriptor());
      for (i = 0; i < this.nestedArray.length; ++i) {
        if (this._nestedArray[i] instanceof Field)
          descriptor.field.push(this._nestedArray[i].toDescriptor(syntax));
        else if (this._nestedArray[i] instanceof Type)
          descriptor.nestedType.push(this._nestedArray[i].toDescriptor(syntax));
        else if (this._nestedArray[i] instanceof Enum)
          descriptor.enumType.push(this._nestedArray[i].toDescriptor());
      }
      if (this.extensions)
        for (i = 0; i < this.extensions.length; ++i)
          descriptor.extensionRange.push(exports2.DescriptorProto.ExtensionRange.create({ start: this.extensions[i][0], end: this.extensions[i][1] }));
      if (this.reserved)
        for (i = 0; i < this.reserved.length; ++i)
          if (typeof this.reserved[i] === "string")
            descriptor.reservedName.push(this.reserved[i]);
          else
            descriptor.reservedRange.push(exports2.DescriptorProto.ReservedRange.create({ start: this.reserved[i][0], end: this.reserved[i][1] }));
      descriptor.options = toDescriptorOptions(this.options, exports2.MessageOptions);
      return descriptor;
    };
    var numberRe = /^(?![eE])[0-9]*(?:\.[0-9]*)?(?:[eE][+-]?[0-9]+)?$/;
    Field.fromDescriptor = function fromDescriptor(descriptor, syntax) {
      if (typeof descriptor.length === "number")
        descriptor = exports2.DescriptorProto.decode(descriptor);
      if (typeof descriptor.number !== "number")
        throw Error("missing field id");
      var fieldType;
      if (descriptor.typeName && descriptor.typeName.length)
        fieldType = descriptor.typeName;
      else
        fieldType = fromDescriptorType(descriptor.type);
      var fieldRule;
      switch (descriptor.label) {
        case 1:
          fieldRule = void 0;
          break;
        case 2:
          fieldRule = "required";
          break;
        case 3:
          fieldRule = "repeated";
          break;
        default:
          throw Error("illegal label: " + descriptor.label);
      }
      var extendee = descriptor.extendee;
      if (descriptor.extendee !== void 0) {
        extendee = extendee.length ? extendee : void 0;
      }
      var field = new Field(
        descriptor.name.length ? descriptor.name : "field" + descriptor.number,
        descriptor.number,
        fieldType,
        fieldRule,
        extendee
      );
      field.options = fromDescriptorOptions(descriptor.options, exports2.FieldOptions);
      if (descriptor.defaultValue && descriptor.defaultValue.length) {
        var defaultValue = descriptor.defaultValue;
        switch (defaultValue) {
          case "true":
          case "TRUE":
            defaultValue = true;
            break;
          case "false":
          case "FALSE":
            defaultValue = false;
            break;
          default:
            var match = numberRe.exec(defaultValue);
            if (match)
              defaultValue = parseInt(defaultValue);
            break;
        }
        field.setOption("default", defaultValue);
      }
      if (packableDescriptorType(descriptor.type)) {
        if (syntax === "proto3") {
          if (descriptor.options && !descriptor.options.packed)
            field.setOption("packed", false);
        } else if (!(descriptor.options && descriptor.options.packed))
          field.setOption("packed", false);
      }
      return field;
    };
    Field.prototype.toDescriptor = function toDescriptor(syntax) {
      var descriptor = exports2.FieldDescriptorProto.create({ name: this.name, number: this.id });
      if (this.map) {
        descriptor.type = 11;
        descriptor.typeName = $protobuf.util.ucFirst(this.name);
        descriptor.label = 3;
      } else {
        switch (descriptor.type = toDescriptorType(this.type, this.resolve().resolvedType)) {
          case 10:
          case 11:
          case 14:
            descriptor.typeName = this.resolvedType ? shortname(this.parent, this.resolvedType) : this.type;
            break;
        }
        switch (this.rule) {
          case "repeated":
            descriptor.label = 3;
            break;
          case "required":
            descriptor.label = 2;
            break;
          default:
            descriptor.label = 1;
            break;
        }
      }
      descriptor.extendee = this.extensionField ? this.extensionField.parent.fullName : this.extend;
      if (this.partOf) {
        if ((descriptor.oneofIndex = this.parent.oneofsArray.indexOf(this.partOf)) < 0)
          throw Error("missing oneof");
      }
      if (this.options) {
        descriptor.options = toDescriptorOptions(this.options, exports2.FieldOptions);
        if (this.options["default"] != null)
          descriptor.defaultValue = String(this.options["default"]);
      }
      if (syntax === "proto3") {
        if (!this.packed)
          (descriptor.options || (descriptor.options = exports2.FieldOptions.create())).packed = false;
      } else if (this.packed)
        (descriptor.options || (descriptor.options = exports2.FieldOptions.create())).packed = true;
      return descriptor;
    };
    var unnamedEnumIndex = 0;
    Enum.fromDescriptor = function fromDescriptor(descriptor) {
      if (typeof descriptor.length === "number")
        descriptor = exports2.EnumDescriptorProto.decode(descriptor);
      var values = {};
      if (descriptor.value)
        for (var i = 0; i < descriptor.value.length; ++i) {
          var name = descriptor.value[i].name, value = descriptor.value[i].number || 0;
          values[name && name.length ? name : "NAME" + value] = value;
        }
      return new Enum(
        descriptor.name && descriptor.name.length ? descriptor.name : "Enum" + unnamedEnumIndex++,
        values,
        fromDescriptorOptions(descriptor.options, exports2.EnumOptions)
      );
    };
    Enum.prototype.toDescriptor = function toDescriptor() {
      var values = [];
      for (var i = 0, ks = Object.keys(this.values); i < ks.length; ++i)
        values.push(exports2.EnumValueDescriptorProto.create({ name: ks[i], number: this.values[ks[i]] }));
      return exports2.EnumDescriptorProto.create({
        name: this.name,
        value: values,
        options: toDescriptorOptions(this.options, exports2.EnumOptions)
      });
    };
    var unnamedOneofIndex = 0;
    OneOf.fromDescriptor = function fromDescriptor(descriptor) {
      if (typeof descriptor.length === "number")
        descriptor = exports2.OneofDescriptorProto.decode(descriptor);
      return new OneOf(
        // unnamedOneOfIndex is global, not per type, because we have no ref to a type here
        descriptor.name && descriptor.name.length ? descriptor.name : "oneof" + unnamedOneofIndex++
        // fromDescriptorOptions(descriptor.options, exports.OneofOptions) - only uninterpreted_option
      );
    };
    OneOf.prototype.toDescriptor = function toDescriptor() {
      return exports2.OneofDescriptorProto.create({
        name: this.name
        // options: toDescriptorOptions(this.options, exports.OneofOptions) - only uninterpreted_option
      });
    };
    var unnamedServiceIndex = 0;
    Service.fromDescriptor = function fromDescriptor(descriptor) {
      if (typeof descriptor.length === "number")
        descriptor = exports2.ServiceDescriptorProto.decode(descriptor);
      var service = new Service(descriptor.name && descriptor.name.length ? descriptor.name : "Service" + unnamedServiceIndex++, fromDescriptorOptions(descriptor.options, exports2.ServiceOptions));
      if (descriptor.method)
        for (var i = 0; i < descriptor.method.length; ++i)
          service.add(Method.fromDescriptor(descriptor.method[i]));
      return service;
    };
    Service.prototype.toDescriptor = function toDescriptor() {
      var methods = [];
      for (var i = 0; i < this.methodsArray.length; ++i)
        methods.push(this._methodsArray[i].toDescriptor());
      return exports2.ServiceDescriptorProto.create({
        name: this.name,
        method: methods,
        options: toDescriptorOptions(this.options, exports2.ServiceOptions)
      });
    };
    var unnamedMethodIndex = 0;
    Method.fromDescriptor = function fromDescriptor(descriptor) {
      if (typeof descriptor.length === "number")
        descriptor = exports2.MethodDescriptorProto.decode(descriptor);
      return new Method(
        // unnamedMethodIndex is global, not per service, because we have no ref to a service here
        descriptor.name && descriptor.name.length ? descriptor.name : "Method" + unnamedMethodIndex++,
        "rpc",
        descriptor.inputType,
        descriptor.outputType,
        Boolean(descriptor.clientStreaming),
        Boolean(descriptor.serverStreaming),
        fromDescriptorOptions(descriptor.options, exports2.MethodOptions)
      );
    };
    Method.prototype.toDescriptor = function toDescriptor() {
      return exports2.MethodDescriptorProto.create({
        name: this.name,
        inputType: this.resolvedRequestType ? this.resolvedRequestType.fullName : this.requestType,
        outputType: this.resolvedResponseType ? this.resolvedResponseType.fullName : this.responseType,
        clientStreaming: this.requestStream,
        serverStreaming: this.responseStream,
        options: toDescriptorOptions(this.options, exports2.MethodOptions)
      });
    };
    function fromDescriptorType(type) {
      switch (type) {
        case 1:
          return "double";
        case 2:
          return "float";
        case 3:
          return "int64";
        case 4:
          return "uint64";
        case 5:
          return "int32";
        case 6:
          return "fixed64";
        case 7:
          return "fixed32";
        case 8:
          return "bool";
        case 9:
          return "string";
        case 12:
          return "bytes";
        case 13:
          return "uint32";
        case 15:
          return "sfixed32";
        case 16:
          return "sfixed64";
        case 17:
          return "sint32";
        case 18:
          return "sint64";
      }
      throw Error("illegal type: " + type);
    }
    function packableDescriptorType(type) {
      switch (type) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
        case 6:
        case 7:
        case 8:
        case 13:
        case 14:
        case 15:
        case 16:
        case 17:
        case 18:
          return true;
      }
      return false;
    }
    function toDescriptorType(type, resolvedType) {
      switch (type) {
        case "double":
          return 1;
        case "float":
          return 2;
        case "int64":
          return 3;
        case "uint64":
          return 4;
        case "int32":
          return 5;
        case "fixed64":
          return 6;
        case "fixed32":
          return 7;
        case "bool":
          return 8;
        case "string":
          return 9;
        case "bytes":
          return 12;
        case "uint32":
          return 13;
        case "sfixed32":
          return 15;
        case "sfixed64":
          return 16;
        case "sint32":
          return 17;
        case "sint64":
          return 18;
      }
      if (resolvedType instanceof Enum)
        return 14;
      if (resolvedType instanceof Type)
        return resolvedType.group ? 10 : 11;
      throw Error("illegal type: " + type);
    }
    function fromDescriptorOptions(options, type) {
      if (!options)
        return void 0;
      var out = [];
      for (var i = 0, field, key, val; i < type.fieldsArray.length; ++i)
        if ((key = (field = type._fieldsArray[i]).name) !== "uninterpretedOption") {
          if (options.hasOwnProperty(key)) {
            val = options[key];
            if (field.resolvedType instanceof Enum && typeof val === "number" && field.resolvedType.valuesById[val] !== void 0)
              val = field.resolvedType.valuesById[val];
            out.push(underScore(key), val);
          }
        }
      return out.length ? $protobuf.util.toObject(out) : void 0;
    }
    function toDescriptorOptions(options, type) {
      if (!options)
        return void 0;
      var out = [];
      for (var i = 0, ks = Object.keys(options), key, val; i < ks.length; ++i) {
        val = options[key = ks[i]];
        if (key === "default")
          continue;
        var field = type.fields[key];
        if (!field && !(field = type.fields[key = $protobuf.util.camelCase(key)]))
          continue;
        out.push(key, val);
      }
      return out.length ? type.fromObject($protobuf.util.toObject(out)) : void 0;
    }
    function shortname(from, to) {
      var fromPath = from.fullName.split("."), toPath = to.fullName.split("."), i = 0, j = 0, k = toPath.length - 1;
      if (!(from instanceof Root) && to instanceof Namespace)
        while (i < fromPath.length && j < k && fromPath[i] === toPath[j]) {
          var other = to.lookup(fromPath[i++], true);
          if (other !== null && other !== to)
            break;
          ++j;
        }
      else
        for (; i < fromPath.length && j < k && fromPath[i] === toPath[j]; ++i, ++j)
          ;
      return toPath.slice(j).join(".");
    }
    function underScore(str) {
      return str.substring(0, 1) + str.substring(1).replace(/([A-Z])(?=[a-z]|$)/g, function($0, $1) {
        return "_" + $1.toLowerCase();
      });
    }
  }
});

// node_modules/protobufjs/google/protobuf/api.json
var require_api = __commonJS({
  "node_modules/protobufjs/google/protobuf/api.json"(exports2, module2) {
    module2.exports = {
      nested: {
        google: {
          nested: {
            protobuf: {
              nested: {
                Api: {
                  fields: {
                    name: {
                      type: "string",
                      id: 1
                    },
                    methods: {
                      rule: "repeated",
                      type: "Method",
                      id: 2
                    },
                    options: {
                      rule: "repeated",
                      type: "Option",
                      id: 3
                    },
                    version: {
                      type: "string",
                      id: 4
                    },
                    sourceContext: {
                      type: "SourceContext",
                      id: 5
                    },
                    mixins: {
                      rule: "repeated",
                      type: "Mixin",
                      id: 6
                    },
                    syntax: {
                      type: "Syntax",
                      id: 7
                    }
                  }
                },
                Method: {
                  fields: {
                    name: {
                      type: "string",
                      id: 1
                    },
                    requestTypeUrl: {
                      type: "string",
                      id: 2
                    },
                    requestStreaming: {
                      type: "bool",
                      id: 3
                    },
                    responseTypeUrl: {
                      type: "string",
                      id: 4
                    },
                    responseStreaming: {
                      type: "bool",
                      id: 5
                    },
                    options: {
                      rule: "repeated",
                      type: "Option",
                      id: 6
                    },
                    syntax: {
                      type: "Syntax",
                      id: 7
                    }
                  }
                },
                Mixin: {
                  fields: {
                    name: {
                      type: "string",
                      id: 1
                    },
                    root: {
                      type: "string",
                      id: 2
                    }
                  }
                },
                SourceContext: {
                  fields: {
                    fileName: {
                      type: "string",
                      id: 1
                    }
                  }
                },
                Option: {
                  fields: {
                    name: {
                      type: "string",
                      id: 1
                    },
                    value: {
                      type: "Any",
                      id: 2
                    }
                  }
                },
                Syntax: {
                  values: {
                    SYNTAX_PROTO2: 0,
                    SYNTAX_PROTO3: 1
                  }
                }
              }
            }
          }
        }
      }
    };
  }
});

// node_modules/protobufjs/google/protobuf/source_context.json
var require_source_context = __commonJS({
  "node_modules/protobufjs/google/protobuf/source_context.json"(exports2, module2) {
    module2.exports = {
      nested: {
        google: {
          nested: {
            protobuf: {
              nested: {
                SourceContext: {
                  fields: {
                    fileName: {
                      type: "string",
                      id: 1
                    }
                  }
                }
              }
            }
          }
        }
      }
    };
  }
});

// node_modules/protobufjs/google/protobuf/type.json
var require_type2 = __commonJS({
  "node_modules/protobufjs/google/protobuf/type.json"(exports2, module2) {
    module2.exports = {
      nested: {
        google: {
          nested: {
            protobuf: {
              nested: {
                Type: {
                  fields: {
                    name: {
                      type: "string",
                      id: 1
                    },
                    fields: {
                      rule: "repeated",
                      type: "Field",
                      id: 2
                    },
                    oneofs: {
                      rule: "repeated",
                      type: "string",
                      id: 3
                    },
                    options: {
                      rule: "repeated",
                      type: "Option",
                      id: 4
                    },
                    sourceContext: {
                      type: "SourceContext",
                      id: 5
                    },
                    syntax: {
                      type: "Syntax",
                      id: 6
                    }
                  }
                },
                Field: {
                  fields: {
                    kind: {
                      type: "Kind",
                      id: 1
                    },
                    cardinality: {
                      type: "Cardinality",
                      id: 2
                    },
                    number: {
                      type: "int32",
                      id: 3
                    },
                    name: {
                      type: "string",
                      id: 4
                    },
                    typeUrl: {
                      type: "string",
                      id: 6
                    },
                    oneofIndex: {
                      type: "int32",
                      id: 7
                    },
                    packed: {
                      type: "bool",
                      id: 8
                    },
                    options: {
                      rule: "repeated",
                      type: "Option",
                      id: 9
                    },
                    jsonName: {
                      type: "string",
                      id: 10
                    },
                    defaultValue: {
                      type: "string",
                      id: 11
                    }
                  },
                  nested: {
                    Kind: {
                      values: {
                        TYPE_UNKNOWN: 0,
                        TYPE_DOUBLE: 1,
                        TYPE_FLOAT: 2,
                        TYPE_INT64: 3,
                        TYPE_UINT64: 4,
                        TYPE_INT32: 5,
                        TYPE_FIXED64: 6,
                        TYPE_FIXED32: 7,
                        TYPE_BOOL: 8,
                        TYPE_STRING: 9,
                        TYPE_GROUP: 10,
                        TYPE_MESSAGE: 11,
                        TYPE_BYTES: 12,
                        TYPE_UINT32: 13,
                        TYPE_ENUM: 14,
                        TYPE_SFIXED32: 15,
                        TYPE_SFIXED64: 16,
                        TYPE_SINT32: 17,
                        TYPE_SINT64: 18
                      }
                    },
                    Cardinality: {
                      values: {
                        CARDINALITY_UNKNOWN: 0,
                        CARDINALITY_OPTIONAL: 1,
                        CARDINALITY_REQUIRED: 2,
                        CARDINALITY_REPEATED: 3
                      }
                    }
                  }
                },
                Enum: {
                  fields: {
                    name: {
                      type: "string",
                      id: 1
                    },
                    enumvalue: {
                      rule: "repeated",
                      type: "EnumValue",
                      id: 2
                    },
                    options: {
                      rule: "repeated",
                      type: "Option",
                      id: 3
                    },
                    sourceContext: {
                      type: "SourceContext",
                      id: 4
                    },
                    syntax: {
                      type: "Syntax",
                      id: 5
                    }
                  }
                },
                EnumValue: {
                  fields: {
                    name: {
                      type: "string",
                      id: 1
                    },
                    number: {
                      type: "int32",
                      id: 2
                    },
                    options: {
                      rule: "repeated",
                      type: "Option",
                      id: 3
                    }
                  }
                },
                Option: {
                  fields: {
                    name: {
                      type: "string",
                      id: 1
                    },
                    value: {
                      type: "Any",
                      id: 2
                    }
                  }
                },
                Syntax: {
                  values: {
                    SYNTAX_PROTO2: 0,
                    SYNTAX_PROTO3: 1
                  }
                },
                Any: {
                  fields: {
                    type_url: {
                      type: "string",
                      id: 1
                    },
                    value: {
                      type: "bytes",
                      id: 2
                    }
                  }
                },
                SourceContext: {
                  fields: {
                    fileName: {
                      type: "string",
                      id: 1
                    }
                  }
                }
              }
            }
          }
        }
      }
    };
  }
});

// node_modules/@grpc/proto-loader/build/src/util.js
var require_util2 = __commonJS({
  "node_modules/@grpc/proto-loader/build/src/util.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.addCommonProtos = exports2.loadProtosWithOptionsSync = exports2.loadProtosWithOptions = void 0;
    var fs2 = require("fs");
    var path2 = require("path");
    var Protobuf = require_protobufjs();
    function addIncludePathResolver(root, includePaths) {
      const originalResolvePath = root.resolvePath;
      root.resolvePath = (origin, target) => {
        if (path2.isAbsolute(target)) {
          return target;
        }
        for (const directory of includePaths) {
          const fullPath = path2.join(directory, target);
          try {
            fs2.accessSync(fullPath, fs2.constants.R_OK);
            return fullPath;
          } catch (err) {
            continue;
          }
        }
        process.emitWarning(`${target} not found in any of the include paths ${includePaths}`);
        return originalResolvePath(origin, target);
      };
    }
    async function loadProtosWithOptions(filename, options) {
      const root = new Protobuf.Root();
      options = options || {};
      if (!!options.includeDirs) {
        if (!Array.isArray(options.includeDirs)) {
          return Promise.reject(new Error("The includeDirs option must be an array"));
        }
        addIncludePathResolver(root, options.includeDirs);
      }
      const loadedRoot = await root.load(filename, options);
      loadedRoot.resolveAll();
      return loadedRoot;
    }
    exports2.loadProtosWithOptions = loadProtosWithOptions;
    function loadProtosWithOptionsSync(filename, options) {
      const root = new Protobuf.Root();
      options = options || {};
      if (!!options.includeDirs) {
        if (!Array.isArray(options.includeDirs)) {
          throw new Error("The includeDirs option must be an array");
        }
        addIncludePathResolver(root, options.includeDirs);
      }
      const loadedRoot = root.loadSync(filename, options);
      loadedRoot.resolveAll();
      return loadedRoot;
    }
    exports2.loadProtosWithOptionsSync = loadProtosWithOptionsSync;
    function addCommonProtos() {
      const apiDescriptor = require_api();
      const descriptorDescriptor = require_descriptor();
      const sourceContextDescriptor = require_source_context();
      const typeDescriptor = require_type2();
      Protobuf.common("api", apiDescriptor.nested.google.nested.protobuf.nested);
      Protobuf.common("descriptor", descriptorDescriptor.nested.google.nested.protobuf.nested);
      Protobuf.common("source_context", sourceContextDescriptor.nested.google.nested.protobuf.nested);
      Protobuf.common("type", typeDescriptor.nested.google.nested.protobuf.nested);
    }
    exports2.addCommonProtos = addCommonProtos;
  }
});

// node_modules/long/src/long.js
var require_long = __commonJS({
  "node_modules/long/src/long.js"(exports2, module2) {
    module2.exports = Long;
    var wasm = null;
    try {
      wasm = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([
        0,
        97,
        115,
        109,
        1,
        0,
        0,
        0,
        1,
        13,
        2,
        96,
        0,
        1,
        127,
        96,
        4,
        127,
        127,
        127,
        127,
        1,
        127,
        3,
        7,
        6,
        0,
        1,
        1,
        1,
        1,
        1,
        6,
        6,
        1,
        127,
        1,
        65,
        0,
        11,
        7,
        50,
        6,
        3,
        109,
        117,
        108,
        0,
        1,
        5,
        100,
        105,
        118,
        95,
        115,
        0,
        2,
        5,
        100,
        105,
        118,
        95,
        117,
        0,
        3,
        5,
        114,
        101,
        109,
        95,
        115,
        0,
        4,
        5,
        114,
        101,
        109,
        95,
        117,
        0,
        5,
        8,
        103,
        101,
        116,
        95,
        104,
        105,
        103,
        104,
        0,
        0,
        10,
        191,
        1,
        6,
        4,
        0,
        35,
        0,
        11,
        36,
        1,
        1,
        126,
        32,
        0,
        173,
        32,
        1,
        173,
        66,
        32,
        134,
        132,
        32,
        2,
        173,
        32,
        3,
        173,
        66,
        32,
        134,
        132,
        126,
        34,
        4,
        66,
        32,
        135,
        167,
        36,
        0,
        32,
        4,
        167,
        11,
        36,
        1,
        1,
        126,
        32,
        0,
        173,
        32,
        1,
        173,
        66,
        32,
        134,
        132,
        32,
        2,
        173,
        32,
        3,
        173,
        66,
        32,
        134,
        132,
        127,
        34,
        4,
        66,
        32,
        135,
        167,
        36,
        0,
        32,
        4,
        167,
        11,
        36,
        1,
        1,
        126,
        32,
        0,
        173,
        32,
        1,
        173,
        66,
        32,
        134,
        132,
        32,
        2,
        173,
        32,
        3,
        173,
        66,
        32,
        134,
        132,
        128,
        34,
        4,
        66,
        32,
        135,
        167,
        36,
        0,
        32,
        4,
        167,
        11,
        36,
        1,
        1,
        126,
        32,
        0,
        173,
        32,
        1,
        173,
        66,
        32,
        134,
        132,
        32,
        2,
        173,
        32,
        3,
        173,
        66,
        32,
        134,
        132,
        129,
        34,
        4,
        66,
        32,
        135,
        167,
        36,
        0,
        32,
        4,
        167,
        11,
        36,
        1,
        1,
        126,
        32,
        0,
        173,
        32,
        1,
        173,
        66,
        32,
        134,
        132,
        32,
        2,
        173,
        32,
        3,
        173,
        66,
        32,
        134,
        132,
        130,
        34,
        4,
        66,
        32,
        135,
        167,
        36,
        0,
        32,
        4,
        167,
        11
      ])), {}).exports;
    } catch (e2) {
    }
    function Long(low, high, unsigned) {
      this.low = low | 0;
      this.high = high | 0;
      this.unsigned = !!unsigned;
    }
    Long.prototype.__isLong__;
    Object.defineProperty(Long.prototype, "__isLong__", { value: true });
    function isLong(obj) {
      return (obj && obj["__isLong__"]) === true;
    }
    Long.isLong = isLong;
    var INT_CACHE = {};
    var UINT_CACHE = {};
    function fromInt(value, unsigned) {
      var obj, cachedObj, cache;
      if (unsigned) {
        value >>>= 0;
        if (cache = 0 <= value && value < 256) {
          cachedObj = UINT_CACHE[value];
          if (cachedObj)
            return cachedObj;
        }
        obj = fromBits(value, (value | 0) < 0 ? -1 : 0, true);
        if (cache)
          UINT_CACHE[value] = obj;
        return obj;
      } else {
        value |= 0;
        if (cache = -128 <= value && value < 128) {
          cachedObj = INT_CACHE[value];
          if (cachedObj)
            return cachedObj;
        }
        obj = fromBits(value, value < 0 ? -1 : 0, false);
        if (cache)
          INT_CACHE[value] = obj;
        return obj;
      }
    }
    Long.fromInt = fromInt;
    function fromNumber(value, unsigned) {
      if (isNaN(value))
        return unsigned ? UZERO : ZERO;
      if (unsigned) {
        if (value < 0)
          return UZERO;
        if (value >= TWO_PWR_64_DBL)
          return MAX_UNSIGNED_VALUE;
      } else {
        if (value <= -TWO_PWR_63_DBL)
          return MIN_VALUE;
        if (value + 1 >= TWO_PWR_63_DBL)
          return MAX_VALUE;
      }
      if (value < 0)
        return fromNumber(-value, unsigned).neg();
      return fromBits(value % TWO_PWR_32_DBL | 0, value / TWO_PWR_32_DBL | 0, unsigned);
    }
    Long.fromNumber = fromNumber;
    function fromBits(lowBits, highBits, unsigned) {
      return new Long(lowBits, highBits, unsigned);
    }
    Long.fromBits = fromBits;
    var pow_dbl = Math.pow;
    function fromString(str, unsigned, radix) {
      if (str.length === 0)
        throw Error("empty string");
      if (str === "NaN" || str === "Infinity" || str === "+Infinity" || str === "-Infinity")
        return ZERO;
      if (typeof unsigned === "number") {
        radix = unsigned, unsigned = false;
      } else {
        unsigned = !!unsigned;
      }
      radix = radix || 10;
      if (radix < 2 || 36 < radix)
        throw RangeError("radix");
      var p;
      if ((p = str.indexOf("-")) > 0)
        throw Error("interior hyphen");
      else if (p === 0) {
        return fromString(str.substring(1), unsigned, radix).neg();
      }
      var radixToPower = fromNumber(pow_dbl(radix, 8));
      var result = ZERO;
      for (var i = 0; i < str.length; i += 8) {
        var size = Math.min(8, str.length - i), value = parseInt(str.substring(i, i + size), radix);
        if (size < 8) {
          var power = fromNumber(pow_dbl(radix, size));
          result = result.mul(power).add(fromNumber(value));
        } else {
          result = result.mul(radixToPower);
          result = result.add(fromNumber(value));
        }
      }
      result.unsigned = unsigned;
      return result;
    }
    Long.fromString = fromString;
    function fromValue(val, unsigned) {
      if (typeof val === "number")
        return fromNumber(val, unsigned);
      if (typeof val === "string")
        return fromString(val, unsigned);
      return fromBits(val.low, val.high, typeof unsigned === "boolean" ? unsigned : val.unsigned);
    }
    Long.fromValue = fromValue;
    var TWO_PWR_16_DBL = 1 << 16;
    var TWO_PWR_24_DBL = 1 << 24;
    var TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;
    var TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;
    var TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;
    var TWO_PWR_24 = fromInt(TWO_PWR_24_DBL);
    var ZERO = fromInt(0);
    Long.ZERO = ZERO;
    var UZERO = fromInt(0, true);
    Long.UZERO = UZERO;
    var ONE = fromInt(1);
    Long.ONE = ONE;
    var UONE = fromInt(1, true);
    Long.UONE = UONE;
    var NEG_ONE = fromInt(-1);
    Long.NEG_ONE = NEG_ONE;
    var MAX_VALUE = fromBits(4294967295 | 0, 2147483647 | 0, false);
    Long.MAX_VALUE = MAX_VALUE;
    var MAX_UNSIGNED_VALUE = fromBits(4294967295 | 0, 4294967295 | 0, true);
    Long.MAX_UNSIGNED_VALUE = MAX_UNSIGNED_VALUE;
    var MIN_VALUE = fromBits(0, 2147483648 | 0, false);
    Long.MIN_VALUE = MIN_VALUE;
    var LongPrototype = Long.prototype;
    LongPrototype.toInt = function toInt() {
      return this.unsigned ? this.low >>> 0 : this.low;
    };
    LongPrototype.toNumber = function toNumber() {
      if (this.unsigned)
        return (this.high >>> 0) * TWO_PWR_32_DBL + (this.low >>> 0);
      return this.high * TWO_PWR_32_DBL + (this.low >>> 0);
    };
    LongPrototype.toString = function toString(radix) {
      radix = radix || 10;
      if (radix < 2 || 36 < radix)
        throw RangeError("radix");
      if (this.isZero())
        return "0";
      if (this.isNegative()) {
        if (this.eq(MIN_VALUE)) {
          var radixLong = fromNumber(radix), div = this.div(radixLong), rem1 = div.mul(radixLong).sub(this);
          return div.toString(radix) + rem1.toInt().toString(radix);
        } else
          return "-" + this.neg().toString(radix);
      }
      var radixToPower = fromNumber(pow_dbl(radix, 6), this.unsigned), rem = this;
      var result = "";
      while (true) {
        var remDiv = rem.div(radixToPower), intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0, digits = intval.toString(radix);
        rem = remDiv;
        if (rem.isZero())
          return digits + result;
        else {
          while (digits.length < 6)
            digits = "0" + digits;
          result = "" + digits + result;
        }
      }
    };
    LongPrototype.getHighBits = function getHighBits() {
      return this.high;
    };
    LongPrototype.getHighBitsUnsigned = function getHighBitsUnsigned() {
      return this.high >>> 0;
    };
    LongPrototype.getLowBits = function getLowBits() {
      return this.low;
    };
    LongPrototype.getLowBitsUnsigned = function getLowBitsUnsigned() {
      return this.low >>> 0;
    };
    LongPrototype.getNumBitsAbs = function getNumBitsAbs() {
      if (this.isNegative())
        return this.eq(MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();
      var val = this.high != 0 ? this.high : this.low;
      for (var bit = 31; bit > 0; bit--)
        if ((val & 1 << bit) != 0)
          break;
      return this.high != 0 ? bit + 33 : bit + 1;
    };
    LongPrototype.isZero = function isZero() {
      return this.high === 0 && this.low === 0;
    };
    LongPrototype.eqz = LongPrototype.isZero;
    LongPrototype.isNegative = function isNegative() {
      return !this.unsigned && this.high < 0;
    };
    LongPrototype.isPositive = function isPositive() {
      return this.unsigned || this.high >= 0;
    };
    LongPrototype.isOdd = function isOdd() {
      return (this.low & 1) === 1;
    };
    LongPrototype.isEven = function isEven() {
      return (this.low & 1) === 0;
    };
    LongPrototype.equals = function equals(other) {
      if (!isLong(other))
        other = fromValue(other);
      if (this.unsigned !== other.unsigned && this.high >>> 31 === 1 && other.high >>> 31 === 1)
        return false;
      return this.high === other.high && this.low === other.low;
    };
    LongPrototype.eq = LongPrototype.equals;
    LongPrototype.notEquals = function notEquals(other) {
      return !this.eq(
        /* validates */
        other
      );
    };
    LongPrototype.neq = LongPrototype.notEquals;
    LongPrototype.ne = LongPrototype.notEquals;
    LongPrototype.lessThan = function lessThan(other) {
      return this.comp(
        /* validates */
        other
      ) < 0;
    };
    LongPrototype.lt = LongPrototype.lessThan;
    LongPrototype.lessThanOrEqual = function lessThanOrEqual(other) {
      return this.comp(
        /* validates */
        other
      ) <= 0;
    };
    LongPrototype.lte = LongPrototype.lessThanOrEqual;
    LongPrototype.le = LongPrototype.lessThanOrEqual;
    LongPrototype.greaterThan = function greaterThan(other) {
      return this.comp(
        /* validates */
        other
      ) > 0;
    };
    LongPrototype.gt = LongPrototype.greaterThan;
    LongPrototype.greaterThanOrEqual = function greaterThanOrEqual(other) {
      return this.comp(
        /* validates */
        other
      ) >= 0;
    };
    LongPrototype.gte = LongPrototype.greaterThanOrEqual;
    LongPrototype.ge = LongPrototype.greaterThanOrEqual;
    LongPrototype.compare = function compare(other) {
      if (!isLong(other))
        other = fromValue(other);
      if (this.eq(other))
        return 0;
      var thisNeg = this.isNegative(), otherNeg = other.isNegative();
      if (thisNeg && !otherNeg)
        return -1;
      if (!thisNeg && otherNeg)
        return 1;
      if (!this.unsigned)
        return this.sub(other).isNegative() ? -1 : 1;
      return other.high >>> 0 > this.high >>> 0 || other.high === this.high && other.low >>> 0 > this.low >>> 0 ? -1 : 1;
    };
    LongPrototype.comp = LongPrototype.compare;
    LongPrototype.negate = function negate() {
      if (!this.unsigned && this.eq(MIN_VALUE))
        return MIN_VALUE;
      return this.not().add(ONE);
    };
    LongPrototype.neg = LongPrototype.negate;
    LongPrototype.add = function add(addend) {
      if (!isLong(addend))
        addend = fromValue(addend);
      var a48 = this.high >>> 16;
      var a32 = this.high & 65535;
      var a16 = this.low >>> 16;
      var a00 = this.low & 65535;
      var b48 = addend.high >>> 16;
      var b32 = addend.high & 65535;
      var b16 = addend.low >>> 16;
      var b00 = addend.low & 65535;
      var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
      c00 += a00 + b00;
      c16 += c00 >>> 16;
      c00 &= 65535;
      c16 += a16 + b16;
      c32 += c16 >>> 16;
      c16 &= 65535;
      c32 += a32 + b32;
      c48 += c32 >>> 16;
      c32 &= 65535;
      c48 += a48 + b48;
      c48 &= 65535;
      return fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);
    };
    LongPrototype.subtract = function subtract(subtrahend) {
      if (!isLong(subtrahend))
        subtrahend = fromValue(subtrahend);
      return this.add(subtrahend.neg());
    };
    LongPrototype.sub = LongPrototype.subtract;
    LongPrototype.multiply = function multiply(multiplier) {
      if (this.isZero())
        return ZERO;
      if (!isLong(multiplier))
        multiplier = fromValue(multiplier);
      if (wasm) {
        var low = wasm.mul(
          this.low,
          this.high,
          multiplier.low,
          multiplier.high
        );
        return fromBits(low, wasm.get_high(), this.unsigned);
      }
      if (multiplier.isZero())
        return ZERO;
      if (this.eq(MIN_VALUE))
        return multiplier.isOdd() ? MIN_VALUE : ZERO;
      if (multiplier.eq(MIN_VALUE))
        return this.isOdd() ? MIN_VALUE : ZERO;
      if (this.isNegative()) {
        if (multiplier.isNegative())
          return this.neg().mul(multiplier.neg());
        else
          return this.neg().mul(multiplier).neg();
      } else if (multiplier.isNegative())
        return this.mul(multiplier.neg()).neg();
      if (this.lt(TWO_PWR_24) && multiplier.lt(TWO_PWR_24))
        return fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned);
      var a48 = this.high >>> 16;
      var a32 = this.high & 65535;
      var a16 = this.low >>> 16;
      var a00 = this.low & 65535;
      var b48 = multiplier.high >>> 16;
      var b32 = multiplier.high & 65535;
      var b16 = multiplier.low >>> 16;
      var b00 = multiplier.low & 65535;
      var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
      c00 += a00 * b00;
      c16 += c00 >>> 16;
      c00 &= 65535;
      c16 += a16 * b00;
      c32 += c16 >>> 16;
      c16 &= 65535;
      c16 += a00 * b16;
      c32 += c16 >>> 16;
      c16 &= 65535;
      c32 += a32 * b00;
      c48 += c32 >>> 16;
      c32 &= 65535;
      c32 += a16 * b16;
      c48 += c32 >>> 16;
      c32 &= 65535;
      c32 += a00 * b32;
      c48 += c32 >>> 16;
      c32 &= 65535;
      c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
      c48 &= 65535;
      return fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);
    };
    LongPrototype.mul = LongPrototype.multiply;
    LongPrototype.divide = function divide(divisor) {
      if (!isLong(divisor))
        divisor = fromValue(divisor);
      if (divisor.isZero())
        throw Error("division by zero");
      if (wasm) {
        if (!this.unsigned && this.high === -2147483648 && divisor.low === -1 && divisor.high === -1) {
          return this;
        }
        var low = (this.unsigned ? wasm.div_u : wasm.div_s)(
          this.low,
          this.high,
          divisor.low,
          divisor.high
        );
        return fromBits(low, wasm.get_high(), this.unsigned);
      }
      if (this.isZero())
        return this.unsigned ? UZERO : ZERO;
      var approx, rem, res;
      if (!this.unsigned) {
        if (this.eq(MIN_VALUE)) {
          if (divisor.eq(ONE) || divisor.eq(NEG_ONE))
            return MIN_VALUE;
          else if (divisor.eq(MIN_VALUE))
            return ONE;
          else {
            var halfThis = this.shr(1);
            approx = halfThis.div(divisor).shl(1);
            if (approx.eq(ZERO)) {
              return divisor.isNegative() ? ONE : NEG_ONE;
            } else {
              rem = this.sub(divisor.mul(approx));
              res = approx.add(rem.div(divisor));
              return res;
            }
          }
        } else if (divisor.eq(MIN_VALUE))
          return this.unsigned ? UZERO : ZERO;
        if (this.isNegative()) {
          if (divisor.isNegative())
            return this.neg().div(divisor.neg());
          return this.neg().div(divisor).neg();
        } else if (divisor.isNegative())
          return this.div(divisor.neg()).neg();
        res = ZERO;
      } else {
        if (!divisor.unsigned)
          divisor = divisor.toUnsigned();
        if (divisor.gt(this))
          return UZERO;
        if (divisor.gt(this.shru(1)))
          return UONE;
        res = UZERO;
      }
      rem = this;
      while (rem.gte(divisor)) {
        approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber()));
        var log2 = Math.ceil(Math.log(approx) / Math.LN2), delta = log2 <= 48 ? 1 : pow_dbl(2, log2 - 48), approxRes = fromNumber(approx), approxRem = approxRes.mul(divisor);
        while (approxRem.isNegative() || approxRem.gt(rem)) {
          approx -= delta;
          approxRes = fromNumber(approx, this.unsigned);
          approxRem = approxRes.mul(divisor);
        }
        if (approxRes.isZero())
          approxRes = ONE;
        res = res.add(approxRes);
        rem = rem.sub(approxRem);
      }
      return res;
    };
    LongPrototype.div = LongPrototype.divide;
    LongPrototype.modulo = function modulo(divisor) {
      if (!isLong(divisor))
        divisor = fromValue(divisor);
      if (wasm) {
        var low = (this.unsigned ? wasm.rem_u : wasm.rem_s)(
          this.low,
          this.high,
          divisor.low,
          divisor.high
        );
        return fromBits(low, wasm.get_high(), this.unsigned);
      }
      return this.sub(this.div(divisor).mul(divisor));
    };
    LongPrototype.mod = LongPrototype.modulo;
    LongPrototype.rem = LongPrototype.modulo;
    LongPrototype.not = function not() {
      return fromBits(~this.low, ~this.high, this.unsigned);
    };
    LongPrototype.and = function and(other) {
      if (!isLong(other))
        other = fromValue(other);
      return fromBits(this.low & other.low, this.high & other.high, this.unsigned);
    };
    LongPrototype.or = function or(other) {
      if (!isLong(other))
        other = fromValue(other);
      return fromBits(this.low | other.low, this.high | other.high, this.unsigned);
    };
    LongPrototype.xor = function xor(other) {
      if (!isLong(other))
        other = fromValue(other);
      return fromBits(this.low ^ other.low, this.high ^ other.high, this.unsigned);
    };
    LongPrototype.shiftLeft = function shiftLeft(numBits) {
      if (isLong(numBits))
        numBits = numBits.toInt();
      if ((numBits &= 63) === 0)
        return this;
      else if (numBits < 32)
        return fromBits(this.low << numBits, this.high << numBits | this.low >>> 32 - numBits, this.unsigned);
      else
        return fromBits(0, this.low << numBits - 32, this.unsigned);
    };
    LongPrototype.shl = LongPrototype.shiftLeft;
    LongPrototype.shiftRight = function shiftRight(numBits) {
      if (isLong(numBits))
        numBits = numBits.toInt();
      if ((numBits &= 63) === 0)
        return this;
      else if (numBits < 32)
        return fromBits(this.low >>> numBits | this.high << 32 - numBits, this.high >> numBits, this.unsigned);
      else
        return fromBits(this.high >> numBits - 32, this.high >= 0 ? 0 : -1, this.unsigned);
    };
    LongPrototype.shr = LongPrototype.shiftRight;
    LongPrototype.shiftRightUnsigned = function shiftRightUnsigned(numBits) {
      if (isLong(numBits))
        numBits = numBits.toInt();
      numBits &= 63;
      if (numBits === 0)
        return this;
      else {
        var high = this.high;
        if (numBits < 32) {
          var low = this.low;
          return fromBits(low >>> numBits | high << 32 - numBits, high >>> numBits, this.unsigned);
        } else if (numBits === 32)
          return fromBits(high, 0, this.unsigned);
        else
          return fromBits(high >>> numBits - 32, 0, this.unsigned);
      }
    };
    LongPrototype.shru = LongPrototype.shiftRightUnsigned;
    LongPrototype.shr_u = LongPrototype.shiftRightUnsigned;
    LongPrototype.toSigned = function toSigned() {
      if (!this.unsigned)
        return this;
      return fromBits(this.low, this.high, false);
    };
    LongPrototype.toUnsigned = function toUnsigned() {
      if (this.unsigned)
        return this;
      return fromBits(this.low, this.high, true);
    };
    LongPrototype.toBytes = function toBytes(le) {
      return le ? this.toBytesLE() : this.toBytesBE();
    };
    LongPrototype.toBytesLE = function toBytesLE() {
      var hi = this.high, lo = this.low;
      return [
        lo & 255,
        lo >>> 8 & 255,
        lo >>> 16 & 255,
        lo >>> 24,
        hi & 255,
        hi >>> 8 & 255,
        hi >>> 16 & 255,
        hi >>> 24
      ];
    };
    LongPrototype.toBytesBE = function toBytesBE() {
      var hi = this.high, lo = this.low;
      return [
        hi >>> 24,
        hi >>> 16 & 255,
        hi >>> 8 & 255,
        hi & 255,
        lo >>> 24,
        lo >>> 16 & 255,
        lo >>> 8 & 255,
        lo & 255
      ];
    };
    Long.fromBytes = function fromBytes(bytes, unsigned, le) {
      return le ? Long.fromBytesLE(bytes, unsigned) : Long.fromBytesBE(bytes, unsigned);
    };
    Long.fromBytesLE = function fromBytesLE(bytes, unsigned) {
      return new Long(
        bytes[0] | bytes[1] << 8 | bytes[2] << 16 | bytes[3] << 24,
        bytes[4] | bytes[5] << 8 | bytes[6] << 16 | bytes[7] << 24,
        unsigned
      );
    };
    Long.fromBytesBE = function fromBytesBE(bytes, unsigned) {
      return new Long(
        bytes[4] << 24 | bytes[5] << 16 | bytes[6] << 8 | bytes[7],
        bytes[0] << 24 | bytes[1] << 16 | bytes[2] << 8 | bytes[3],
        unsigned
      );
    };
  }
});

// node_modules/@grpc/proto-loader/build/src/index.js
var require_src2 = __commonJS({
  "node_modules/@grpc/proto-loader/build/src/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.loadFileDescriptorSetFromObject = exports2.loadFileDescriptorSetFromBuffer = exports2.fromJSON = exports2.loadSync = exports2.load = exports2.isAnyExtension = exports2.Long = void 0;
    var camelCase = require_lodash();
    var Protobuf = require_protobufjs();
    var descriptor = require_descriptor2();
    var util_1 = require_util2();
    var Long = require_long();
    exports2.Long = Long;
    function isAnyExtension(obj) {
      return "@type" in obj && typeof obj["@type"] === "string";
    }
    exports2.isAnyExtension = isAnyExtension;
    var descriptorOptions = {
      longs: String,
      enums: String,
      bytes: String,
      defaults: true,
      oneofs: true,
      json: true
    };
    function joinName(baseName, name) {
      if (baseName === "") {
        return name;
      } else {
        return baseName + "." + name;
      }
    }
    function isHandledReflectionObject(obj) {
      return obj instanceof Protobuf.Service || obj instanceof Protobuf.Type || obj instanceof Protobuf.Enum;
    }
    function isNamespaceBase(obj) {
      return obj instanceof Protobuf.Namespace || obj instanceof Protobuf.Root;
    }
    function getAllHandledReflectionObjects(obj, parentName) {
      const objName = joinName(parentName, obj.name);
      if (isHandledReflectionObject(obj)) {
        return [[objName, obj]];
      } else {
        if (isNamespaceBase(obj) && typeof obj.nested !== "undefined") {
          return Object.keys(obj.nested).map((name) => {
            return getAllHandledReflectionObjects(obj.nested[name], objName);
          }).reduce((accumulator, currentValue) => accumulator.concat(currentValue), []);
        }
      }
      return [];
    }
    function createDeserializer(cls, options) {
      return function deserialize(argBuf) {
        return cls.toObject(cls.decode(argBuf), options);
      };
    }
    function createSerializer(cls) {
      return function serialize(arg) {
        if (Array.isArray(arg)) {
          throw new Error(`Failed to serialize message: expected object with ${cls.name} structure, got array instead`);
        }
        const message = cls.fromObject(arg);
        return cls.encode(message).finish();
      };
    }
    function createMethodDefinition(method, serviceName, options, fileDescriptors) {
      const requestType = method.resolvedRequestType;
      const responseType = method.resolvedResponseType;
      return {
        path: "/" + serviceName + "/" + method.name,
        requestStream: !!method.requestStream,
        responseStream: !!method.responseStream,
        requestSerialize: createSerializer(requestType),
        requestDeserialize: createDeserializer(requestType, options),
        responseSerialize: createSerializer(responseType),
        responseDeserialize: createDeserializer(responseType, options),
        // TODO(murgatroid99): Find a better way to handle this
        originalName: camelCase(method.name),
        requestType: createMessageDefinition(requestType, fileDescriptors),
        responseType: createMessageDefinition(responseType, fileDescriptors)
      };
    }
    function createServiceDefinition(service, name, options, fileDescriptors) {
      const def = {};
      for (const method of service.methodsArray) {
        def[method.name] = createMethodDefinition(method, name, options, fileDescriptors);
      }
      return def;
    }
    function createMessageDefinition(message, fileDescriptors) {
      const messageDescriptor = message.toDescriptor("proto3");
      return {
        format: "Protocol Buffer 3 DescriptorProto",
        type: messageDescriptor.$type.toObject(messageDescriptor, descriptorOptions),
        fileDescriptorProtos: fileDescriptors
      };
    }
    function createEnumDefinition(enumType, fileDescriptors) {
      const enumDescriptor = enumType.toDescriptor("proto3");
      return {
        format: "Protocol Buffer 3 EnumDescriptorProto",
        type: enumDescriptor.$type.toObject(enumDescriptor, descriptorOptions),
        fileDescriptorProtos: fileDescriptors
      };
    }
    function createDefinition(obj, name, options, fileDescriptors) {
      if (obj instanceof Protobuf.Service) {
        return createServiceDefinition(obj, name, options, fileDescriptors);
      } else if (obj instanceof Protobuf.Type) {
        return createMessageDefinition(obj, fileDescriptors);
      } else if (obj instanceof Protobuf.Enum) {
        return createEnumDefinition(obj, fileDescriptors);
      } else {
        throw new Error("Type mismatch in reflection object handling");
      }
    }
    function createPackageDefinition(root, options) {
      const def = {};
      root.resolveAll();
      const descriptorList = root.toDescriptor("proto3").file;
      const bufferList = descriptorList.map((value) => Buffer.from(descriptor.FileDescriptorProto.encode(value).finish()));
      for (const [name, obj] of getAllHandledReflectionObjects(root, "")) {
        def[name] = createDefinition(obj, name, options, bufferList);
      }
      return def;
    }
    function createPackageDefinitionFromDescriptorSet(decodedDescriptorSet, options) {
      options = options || {};
      const root = Protobuf.Root.fromDescriptor(decodedDescriptorSet);
      root.resolveAll();
      return createPackageDefinition(root, options);
    }
    function load(filename, options) {
      return (0, util_1.loadProtosWithOptions)(filename, options).then((loadedRoot) => {
        return createPackageDefinition(loadedRoot, options);
      });
    }
    exports2.load = load;
    function loadSync(filename, options) {
      const loadedRoot = (0, util_1.loadProtosWithOptionsSync)(filename, options);
      return createPackageDefinition(loadedRoot, options);
    }
    exports2.loadSync = loadSync;
    function fromJSON(json, options) {
      options = options || {};
      const loadedRoot = Protobuf.Root.fromJSON(json);
      loadedRoot.resolveAll();
      return createPackageDefinition(loadedRoot, options);
    }
    exports2.fromJSON = fromJSON;
    function loadFileDescriptorSetFromBuffer(descriptorSet, options) {
      const decodedDescriptorSet = descriptor.FileDescriptorSet.decode(descriptorSet);
      return createPackageDefinitionFromDescriptorSet(decodedDescriptorSet, options);
    }
    exports2.loadFileDescriptorSetFromBuffer = loadFileDescriptorSetFromBuffer;
    function loadFileDescriptorSetFromObject(descriptorSet, options) {
      const decodedDescriptorSet = descriptor.FileDescriptorSet.fromObject(descriptorSet);
      return createPackageDefinitionFromDescriptorSet(decodedDescriptorSet, options);
    }
    exports2.loadFileDescriptorSetFromObject = loadFileDescriptorSetFromObject;
    (0, util_1.addCommonProtos)();
  }
});

// node_modules/@grpc/grpc-js/build/src/channelz.js
var require_channelz = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/channelz.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.setup = exports2.getChannelzServiceDefinition = exports2.getChannelzHandlers = exports2.unregisterChannelzRef = exports2.registerChannelzSocket = exports2.registerChannelzServer = exports2.registerChannelzSubchannel = exports2.registerChannelzChannel = exports2.ChannelzCallTracker = exports2.ChannelzChildrenTracker = exports2.ChannelzTrace = void 0;
    var net_1 = require("net");
    var connectivity_state_1 = require_connectivity_state();
    var constants_1 = require_constants();
    var subchannel_address_1 = require_subchannel_address();
    var admin_1 = require_admin();
    var make_client_1 = require_make_client();
    function channelRefToMessage(ref) {
      return {
        channel_id: ref.id,
        name: ref.name
      };
    }
    function subchannelRefToMessage(ref) {
      return {
        subchannel_id: ref.id,
        name: ref.name
      };
    }
    function serverRefToMessage(ref) {
      return {
        server_id: ref.id
      };
    }
    function socketRefToMessage(ref) {
      return {
        socket_id: ref.id,
        name: ref.name
      };
    }
    var TARGET_RETAINED_TRACES = 32;
    var ChannelzTrace = class {
      constructor() {
        this.events = [];
        this.eventsLogged = 0;
        this.creationTimestamp = new Date();
      }
      addTrace(severity, description, child) {
        const timestamp = new Date();
        this.events.push({
          description,
          severity,
          timestamp,
          childChannel: (child === null || child === void 0 ? void 0 : child.kind) === "channel" ? child : void 0,
          childSubchannel: (child === null || child === void 0 ? void 0 : child.kind) === "subchannel" ? child : void 0
        });
        if (this.events.length >= TARGET_RETAINED_TRACES * 2) {
          this.events = this.events.slice(TARGET_RETAINED_TRACES);
        }
        this.eventsLogged += 1;
      }
      getTraceMessage() {
        return {
          creation_timestamp: dateToProtoTimestamp(this.creationTimestamp),
          num_events_logged: this.eventsLogged,
          events: this.events.map((event) => {
            return {
              description: event.description,
              severity: event.severity,
              timestamp: dateToProtoTimestamp(event.timestamp),
              channel_ref: event.childChannel ? channelRefToMessage(event.childChannel) : null,
              subchannel_ref: event.childSubchannel ? subchannelRefToMessage(event.childSubchannel) : null
            };
          })
        };
      }
    };
    exports2.ChannelzTrace = ChannelzTrace;
    var ChannelzChildrenTracker = class {
      constructor() {
        this.channelChildren = /* @__PURE__ */ new Map();
        this.subchannelChildren = /* @__PURE__ */ new Map();
        this.socketChildren = /* @__PURE__ */ new Map();
      }
      refChild(child) {
        var _a, _b, _c;
        switch (child.kind) {
          case "channel": {
            let trackedChild = (_a = this.channelChildren.get(child.id)) !== null && _a !== void 0 ? _a : { ref: child, count: 0 };
            trackedChild.count += 1;
            this.channelChildren.set(child.id, trackedChild);
            break;
          }
          case "subchannel": {
            let trackedChild = (_b = this.subchannelChildren.get(child.id)) !== null && _b !== void 0 ? _b : { ref: child, count: 0 };
            trackedChild.count += 1;
            this.subchannelChildren.set(child.id, trackedChild);
            break;
          }
          case "socket": {
            let trackedChild = (_c = this.socketChildren.get(child.id)) !== null && _c !== void 0 ? _c : { ref: child, count: 0 };
            trackedChild.count += 1;
            this.socketChildren.set(child.id, trackedChild);
            break;
          }
        }
      }
      unrefChild(child) {
        switch (child.kind) {
          case "channel": {
            let trackedChild = this.channelChildren.get(child.id);
            if (trackedChild !== void 0) {
              trackedChild.count -= 1;
              if (trackedChild.count === 0) {
                this.channelChildren.delete(child.id);
              } else {
                this.channelChildren.set(child.id, trackedChild);
              }
            }
            break;
          }
          case "subchannel": {
            let trackedChild = this.subchannelChildren.get(child.id);
            if (trackedChild !== void 0) {
              trackedChild.count -= 1;
              if (trackedChild.count === 0) {
                this.subchannelChildren.delete(child.id);
              } else {
                this.subchannelChildren.set(child.id, trackedChild);
              }
            }
            break;
          }
          case "socket": {
            let trackedChild = this.socketChildren.get(child.id);
            if (trackedChild !== void 0) {
              trackedChild.count -= 1;
              if (trackedChild.count === 0) {
                this.socketChildren.delete(child.id);
              } else {
                this.socketChildren.set(child.id, trackedChild);
              }
            }
            break;
          }
        }
      }
      getChildLists() {
        const channels2 = [];
        for (const { ref } of this.channelChildren.values()) {
          channels2.push(ref);
        }
        const subchannels2 = [];
        for (const { ref } of this.subchannelChildren.values()) {
          subchannels2.push(ref);
        }
        const sockets2 = [];
        for (const { ref } of this.socketChildren.values()) {
          sockets2.push(ref);
        }
        return { channels: channels2, subchannels: subchannels2, sockets: sockets2 };
      }
    };
    exports2.ChannelzChildrenTracker = ChannelzChildrenTracker;
    var ChannelzCallTracker = class {
      constructor() {
        this.callsStarted = 0;
        this.callsSucceeded = 0;
        this.callsFailed = 0;
        this.lastCallStartedTimestamp = null;
      }
      addCallStarted() {
        this.callsStarted += 1;
        this.lastCallStartedTimestamp = new Date();
      }
      addCallSucceeded() {
        this.callsSucceeded += 1;
      }
      addCallFailed() {
        this.callsFailed += 1;
      }
    };
    exports2.ChannelzCallTracker = ChannelzCallTracker;
    var nextId = 1;
    function getNextId() {
      return nextId++;
    }
    var channels = [];
    var subchannels = [];
    var servers = [];
    var sockets = [];
    function registerChannelzChannel(name, getInfo, channelzEnabled) {
      const id = getNextId();
      const ref = { id, name, kind: "channel" };
      if (channelzEnabled) {
        channels[id] = { ref, getInfo };
      }
      return ref;
    }
    exports2.registerChannelzChannel = registerChannelzChannel;
    function registerChannelzSubchannel(name, getInfo, channelzEnabled) {
      const id = getNextId();
      const ref = { id, name, kind: "subchannel" };
      if (channelzEnabled) {
        subchannels[id] = { ref, getInfo };
      }
      return ref;
    }
    exports2.registerChannelzSubchannel = registerChannelzSubchannel;
    function registerChannelzServer(getInfo, channelzEnabled) {
      const id = getNextId();
      const ref = { id, kind: "server" };
      if (channelzEnabled) {
        servers[id] = { ref, getInfo };
      }
      return ref;
    }
    exports2.registerChannelzServer = registerChannelzServer;
    function registerChannelzSocket(name, getInfo, channelzEnabled) {
      const id = getNextId();
      const ref = { id, name, kind: "socket" };
      if (channelzEnabled) {
        sockets[id] = { ref, getInfo };
      }
      return ref;
    }
    exports2.registerChannelzSocket = registerChannelzSocket;
    function unregisterChannelzRef(ref) {
      switch (ref.kind) {
        case "channel":
          delete channels[ref.id];
          return;
        case "subchannel":
          delete subchannels[ref.id];
          return;
        case "server":
          delete servers[ref.id];
          return;
        case "socket":
          delete sockets[ref.id];
          return;
      }
    }
    exports2.unregisterChannelzRef = unregisterChannelzRef;
    function parseIPv6Section(addressSection) {
      const numberValue = Number.parseInt(addressSection, 16);
      return [numberValue / 256 | 0, numberValue % 256];
    }
    function parseIPv6Chunk(addressChunk) {
      if (addressChunk === "") {
        return [];
      }
      const bytePairs = addressChunk.split(":").map((section) => parseIPv6Section(section));
      const result = [];
      return result.concat(...bytePairs);
    }
    function ipAddressStringToBuffer(ipAddress) {
      if ((0, net_1.isIPv4)(ipAddress)) {
        return Buffer.from(Uint8Array.from(ipAddress.split(".").map((segment) => Number.parseInt(segment))));
      } else if ((0, net_1.isIPv6)(ipAddress)) {
        let leftSection;
        let rightSection;
        const doubleColonIndex = ipAddress.indexOf("::");
        if (doubleColonIndex === -1) {
          leftSection = ipAddress;
          rightSection = "";
        } else {
          leftSection = ipAddress.substring(0, doubleColonIndex);
          rightSection = ipAddress.substring(doubleColonIndex + 2);
        }
        const leftBuffer = Buffer.from(parseIPv6Chunk(leftSection));
        const rightBuffer = Buffer.from(parseIPv6Chunk(rightSection));
        const middleBuffer = Buffer.alloc(16 - leftBuffer.length - rightBuffer.length, 0);
        return Buffer.concat([leftBuffer, middleBuffer, rightBuffer]);
      } else {
        return null;
      }
    }
    function connectivityStateToMessage(state) {
      switch (state) {
        case connectivity_state_1.ConnectivityState.CONNECTING:
          return {
            state: "CONNECTING"
          };
        case connectivity_state_1.ConnectivityState.IDLE:
          return {
            state: "IDLE"
          };
        case connectivity_state_1.ConnectivityState.READY:
          return {
            state: "READY"
          };
        case connectivity_state_1.ConnectivityState.SHUTDOWN:
          return {
            state: "SHUTDOWN"
          };
        case connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE:
          return {
            state: "TRANSIENT_FAILURE"
          };
        default:
          return {
            state: "UNKNOWN"
          };
      }
    }
    function dateToProtoTimestamp(date) {
      if (!date) {
        return null;
      }
      const millisSinceEpoch = date.getTime();
      return {
        seconds: millisSinceEpoch / 1e3 | 0,
        nanos: millisSinceEpoch % 1e3 * 1e6
      };
    }
    function getChannelMessage(channelEntry) {
      const resolvedInfo = channelEntry.getInfo();
      return {
        ref: channelRefToMessage(channelEntry.ref),
        data: {
          target: resolvedInfo.target,
          state: connectivityStateToMessage(resolvedInfo.state),
          calls_started: resolvedInfo.callTracker.callsStarted,
          calls_succeeded: resolvedInfo.callTracker.callsSucceeded,
          calls_failed: resolvedInfo.callTracker.callsFailed,
          last_call_started_timestamp: dateToProtoTimestamp(resolvedInfo.callTracker.lastCallStartedTimestamp),
          trace: resolvedInfo.trace.getTraceMessage()
        },
        channel_ref: resolvedInfo.children.channels.map((ref) => channelRefToMessage(ref)),
        subchannel_ref: resolvedInfo.children.subchannels.map((ref) => subchannelRefToMessage(ref))
      };
    }
    function GetChannel(call, callback) {
      const channelId = Number.parseInt(call.request.channel_id);
      const channelEntry = channels[channelId];
      if (channelEntry === void 0) {
        callback({
          "code": constants_1.Status.NOT_FOUND,
          "details": "No channel data found for id " + channelId
        });
        return;
      }
      callback(null, { channel: getChannelMessage(channelEntry) });
    }
    function GetTopChannels(call, callback) {
      const maxResults = Number.parseInt(call.request.max_results);
      const resultList = [];
      let i = Number.parseInt(call.request.start_channel_id);
      for (; i < channels.length; i++) {
        const channelEntry = channels[i];
        if (channelEntry === void 0) {
          continue;
        }
        resultList.push(getChannelMessage(channelEntry));
        if (resultList.length >= maxResults) {
          break;
        }
      }
      callback(null, {
        channel: resultList,
        end: i >= servers.length
      });
    }
    function getServerMessage(serverEntry) {
      const resolvedInfo = serverEntry.getInfo();
      return {
        ref: serverRefToMessage(serverEntry.ref),
        data: {
          calls_started: resolvedInfo.callTracker.callsStarted,
          calls_succeeded: resolvedInfo.callTracker.callsSucceeded,
          calls_failed: resolvedInfo.callTracker.callsFailed,
          last_call_started_timestamp: dateToProtoTimestamp(resolvedInfo.callTracker.lastCallStartedTimestamp),
          trace: resolvedInfo.trace.getTraceMessage()
        },
        listen_socket: resolvedInfo.listenerChildren.sockets.map((ref) => socketRefToMessage(ref))
      };
    }
    function GetServer(call, callback) {
      const serverId = Number.parseInt(call.request.server_id);
      const serverEntry = servers[serverId];
      if (serverEntry === void 0) {
        callback({
          "code": constants_1.Status.NOT_FOUND,
          "details": "No server data found for id " + serverId
        });
        return;
      }
      callback(null, { server: getServerMessage(serverEntry) });
    }
    function GetServers(call, callback) {
      const maxResults = Number.parseInt(call.request.max_results);
      const resultList = [];
      let i = Number.parseInt(call.request.start_server_id);
      for (; i < servers.length; i++) {
        const serverEntry = servers[i];
        if (serverEntry === void 0) {
          continue;
        }
        resultList.push(getServerMessage(serverEntry));
        if (resultList.length >= maxResults) {
          break;
        }
      }
      callback(null, {
        server: resultList,
        end: i >= servers.length
      });
    }
    function GetSubchannel(call, callback) {
      const subchannelId = Number.parseInt(call.request.subchannel_id);
      const subchannelEntry = subchannels[subchannelId];
      if (subchannelEntry === void 0) {
        callback({
          "code": constants_1.Status.NOT_FOUND,
          "details": "No subchannel data found for id " + subchannelId
        });
        return;
      }
      const resolvedInfo = subchannelEntry.getInfo();
      const subchannelMessage = {
        ref: subchannelRefToMessage(subchannelEntry.ref),
        data: {
          target: resolvedInfo.target,
          state: connectivityStateToMessage(resolvedInfo.state),
          calls_started: resolvedInfo.callTracker.callsStarted,
          calls_succeeded: resolvedInfo.callTracker.callsSucceeded,
          calls_failed: resolvedInfo.callTracker.callsFailed,
          last_call_started_timestamp: dateToProtoTimestamp(resolvedInfo.callTracker.lastCallStartedTimestamp),
          trace: resolvedInfo.trace.getTraceMessage()
        },
        socket_ref: resolvedInfo.children.sockets.map((ref) => socketRefToMessage(ref))
      };
      callback(null, { subchannel: subchannelMessage });
    }
    function subchannelAddressToAddressMessage(subchannelAddress) {
      var _a;
      if ((0, subchannel_address_1.isTcpSubchannelAddress)(subchannelAddress)) {
        return {
          address: "tcpip_address",
          tcpip_address: {
            ip_address: (_a = ipAddressStringToBuffer(subchannelAddress.host)) !== null && _a !== void 0 ? _a : void 0,
            port: subchannelAddress.port
          }
        };
      } else {
        return {
          address: "uds_address",
          uds_address: {
            filename: subchannelAddress.path
          }
        };
      }
    }
    function GetSocket(call, callback) {
      var _a, _b, _c, _d, _e;
      const socketId = Number.parseInt(call.request.socket_id);
      const socketEntry = sockets[socketId];
      if (socketEntry === void 0) {
        callback({
          "code": constants_1.Status.NOT_FOUND,
          "details": "No socket data found for id " + socketId
        });
        return;
      }
      const resolvedInfo = socketEntry.getInfo();
      const securityMessage = resolvedInfo.security ? {
        model: "tls",
        tls: {
          cipher_suite: resolvedInfo.security.cipherSuiteStandardName ? "standard_name" : "other_name",
          standard_name: (_a = resolvedInfo.security.cipherSuiteStandardName) !== null && _a !== void 0 ? _a : void 0,
          other_name: (_b = resolvedInfo.security.cipherSuiteOtherName) !== null && _b !== void 0 ? _b : void 0,
          local_certificate: (_c = resolvedInfo.security.localCertificate) !== null && _c !== void 0 ? _c : void 0,
          remote_certificate: (_d = resolvedInfo.security.remoteCertificate) !== null && _d !== void 0 ? _d : void 0
        }
      } : null;
      const socketMessage = {
        ref: socketRefToMessage(socketEntry.ref),
        local: resolvedInfo.localAddress ? subchannelAddressToAddressMessage(resolvedInfo.localAddress) : null,
        remote: resolvedInfo.remoteAddress ? subchannelAddressToAddressMessage(resolvedInfo.remoteAddress) : null,
        remote_name: (_e = resolvedInfo.remoteName) !== null && _e !== void 0 ? _e : void 0,
        security: securityMessage,
        data: {
          keep_alives_sent: resolvedInfo.keepAlivesSent,
          streams_started: resolvedInfo.streamsStarted,
          streams_succeeded: resolvedInfo.streamsSucceeded,
          streams_failed: resolvedInfo.streamsFailed,
          last_local_stream_created_timestamp: dateToProtoTimestamp(resolvedInfo.lastLocalStreamCreatedTimestamp),
          last_remote_stream_created_timestamp: dateToProtoTimestamp(resolvedInfo.lastRemoteStreamCreatedTimestamp),
          messages_received: resolvedInfo.messagesReceived,
          messages_sent: resolvedInfo.messagesSent,
          last_message_received_timestamp: dateToProtoTimestamp(resolvedInfo.lastMessageReceivedTimestamp),
          last_message_sent_timestamp: dateToProtoTimestamp(resolvedInfo.lastMessageSentTimestamp),
          local_flow_control_window: resolvedInfo.localFlowControlWindow ? { value: resolvedInfo.localFlowControlWindow } : null,
          remote_flow_control_window: resolvedInfo.remoteFlowControlWindow ? { value: resolvedInfo.remoteFlowControlWindow } : null
        }
      };
      callback(null, { socket: socketMessage });
    }
    function GetServerSockets(call, callback) {
      const serverId = Number.parseInt(call.request.server_id);
      const serverEntry = servers[serverId];
      if (serverEntry === void 0) {
        callback({
          "code": constants_1.Status.NOT_FOUND,
          "details": "No server data found for id " + serverId
        });
        return;
      }
      const startId = Number.parseInt(call.request.start_socket_id);
      const maxResults = Number.parseInt(call.request.max_results);
      const resolvedInfo = serverEntry.getInfo();
      const allSockets = resolvedInfo.sessionChildren.sockets.sort((ref1, ref2) => ref1.id - ref2.id);
      const resultList = [];
      let i = 0;
      for (; i < allSockets.length; i++) {
        if (allSockets[i].id >= startId) {
          resultList.push(socketRefToMessage(allSockets[i]));
          if (resultList.length >= maxResults) {
            break;
          }
        }
      }
      callback(null, {
        socket_ref: resultList,
        end: i >= allSockets.length
      });
    }
    function getChannelzHandlers() {
      return {
        GetChannel,
        GetTopChannels,
        GetServer,
        GetServers,
        GetSubchannel,
        GetSocket,
        GetServerSockets
      };
    }
    exports2.getChannelzHandlers = getChannelzHandlers;
    var loadedChannelzDefinition = null;
    function getChannelzServiceDefinition() {
      if (loadedChannelzDefinition) {
        return loadedChannelzDefinition;
      }
      const loaderLoadSync = require_src2().loadSync;
      const loadedProto = loaderLoadSync("channelz.proto", {
        keepCase: true,
        longs: String,
        enums: String,
        defaults: true,
        oneofs: true,
        includeDirs: [
          `${__dirname}/../../proto`
        ]
      });
      const channelzGrpcObject = (0, make_client_1.loadPackageDefinition)(loadedProto);
      loadedChannelzDefinition = channelzGrpcObject.grpc.channelz.v1.Channelz.service;
      return loadedChannelzDefinition;
    }
    exports2.getChannelzServiceDefinition = getChannelzServiceDefinition;
    function setup() {
      (0, admin_1.registerAdminService)(getChannelzServiceDefinition, getChannelzHandlers);
    }
    exports2.setup = setup;
  }
});

// node_modules/@grpc/grpc-js/build/src/subchannel.js
var require_subchannel = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/subchannel.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Subchannel = void 0;
    var connectivity_state_1 = require_connectivity_state();
    var backoff_timeout_1 = require_backoff_timeout();
    var logging = require_logging();
    var constants_1 = require_constants();
    var uri_parser_1 = require_uri_parser();
    var subchannel_address_1 = require_subchannel_address();
    var channelz_1 = require_channelz();
    var TRACER_NAME = "subchannel";
    var KEEPALIVE_MAX_TIME_MS = ~(1 << 31);
    var Subchannel = class {
      /**
       * A class representing a connection to a single backend.
       * @param channelTarget The target string for the channel as a whole
       * @param subchannelAddress The address for the backend that this subchannel
       *     will connect to
       * @param options The channel options, plus any specific subchannel options
       *     for this subchannel
       * @param credentials The channel credentials used to establish this
       *     connection
       */
      constructor(channelTarget, subchannelAddress, options, credentials2, connector) {
        this.channelTarget = channelTarget;
        this.subchannelAddress = subchannelAddress;
        this.options = options;
        this.credentials = credentials2;
        this.connector = connector;
        this.connectivityState = connectivity_state_1.ConnectivityState.IDLE;
        this.transport = null;
        this.continueConnecting = false;
        this.stateListeners = [];
        this.keepaliveTimeMultiplier = 1;
        this.refcount = 0;
        this.channelzEnabled = true;
        this.callTracker = new channelz_1.ChannelzCallTracker();
        this.childrenTracker = new channelz_1.ChannelzChildrenTracker();
        this.streamTracker = new channelz_1.ChannelzCallTracker();
        const backoffOptions = {
          initialDelay: options["grpc.initial_reconnect_backoff_ms"],
          maxDelay: options["grpc.max_reconnect_backoff_ms"]
        };
        this.backoffTimeout = new backoff_timeout_1.BackoffTimeout(() => {
          this.handleBackoffTimer();
        }, backoffOptions);
        this.subchannelAddressString = (0, subchannel_address_1.subchannelAddressToString)(subchannelAddress);
        if (options["grpc.enable_channelz"] === 0) {
          this.channelzEnabled = false;
        }
        this.channelzTrace = new channelz_1.ChannelzTrace();
        this.channelzRef = (0, channelz_1.registerChannelzSubchannel)(this.subchannelAddressString, () => this.getChannelzInfo(), this.channelzEnabled);
        if (this.channelzEnabled) {
          this.channelzTrace.addTrace("CT_INFO", "Subchannel created");
        }
        this.trace("Subchannel constructed with options " + JSON.stringify(options, void 0, 2));
      }
      getChannelzInfo() {
        return {
          state: this.connectivityState,
          trace: this.channelzTrace,
          callTracker: this.callTracker,
          children: this.childrenTracker.getChildLists(),
          target: this.subchannelAddressString
        };
      }
      trace(text) {
        logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, "(" + this.channelzRef.id + ") " + this.subchannelAddressString + " " + text);
      }
      refTrace(text) {
        logging.trace(constants_1.LogVerbosity.DEBUG, "subchannel_refcount", "(" + this.channelzRef.id + ") " + this.subchannelAddressString + " " + text);
      }
      handleBackoffTimer() {
        if (this.continueConnecting) {
          this.transitionToState([connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE], connectivity_state_1.ConnectivityState.CONNECTING);
        } else {
          this.transitionToState([connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE], connectivity_state_1.ConnectivityState.IDLE);
        }
      }
      /**
       * Start a backoff timer with the current nextBackoff timeout
       */
      startBackoff() {
        this.backoffTimeout.runOnce();
      }
      stopBackoff() {
        this.backoffTimeout.stop();
        this.backoffTimeout.reset();
      }
      startConnectingInternal() {
        let options = this.options;
        if (options["grpc.keepalive_time_ms"]) {
          const adjustedKeepaliveTime = Math.min(options["grpc.keepalive_time_ms"] * this.keepaliveTimeMultiplier, KEEPALIVE_MAX_TIME_MS);
          options = Object.assign(Object.assign({}, options), { "grpc.keepalive_time_ms": adjustedKeepaliveTime });
        }
        this.connector.connect(this.subchannelAddress, this.credentials, options).then((transport) => {
          if (this.transitionToState([connectivity_state_1.ConnectivityState.CONNECTING], connectivity_state_1.ConnectivityState.READY)) {
            this.transport = transport;
            if (this.channelzEnabled) {
              this.childrenTracker.refChild(transport.getChannelzRef());
            }
            transport.addDisconnectListener((tooManyPings) => {
              this.transitionToState([connectivity_state_1.ConnectivityState.READY], connectivity_state_1.ConnectivityState.IDLE);
              if (tooManyPings) {
                this.keepaliveTimeMultiplier *= 2;
                logging.log(constants_1.LogVerbosity.ERROR, `Connection to ${(0, uri_parser_1.uriToString)(this.channelTarget)} at ${this.subchannelAddressString} rejected by server because of excess pings. Increasing ping interval multiplier to ${this.keepaliveTimeMultiplier} ms`);
              }
            });
          }
        }, (error) => {
          this.transitionToState([connectivity_state_1.ConnectivityState.CONNECTING], connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE);
        });
      }
      /**
       * Initiate a state transition from any element of oldStates to the new
       * state. If the current connectivityState is not in oldStates, do nothing.
       * @param oldStates The set of states to transition from
       * @param newState The state to transition to
       * @returns True if the state changed, false otherwise
       */
      transitionToState(oldStates, newState) {
        var _a, _b;
        if (oldStates.indexOf(this.connectivityState) === -1) {
          return false;
        }
        this.trace(connectivity_state_1.ConnectivityState[this.connectivityState] + " -> " + connectivity_state_1.ConnectivityState[newState]);
        if (this.channelzEnabled) {
          this.channelzTrace.addTrace("CT_INFO", connectivity_state_1.ConnectivityState[this.connectivityState] + " -> " + connectivity_state_1.ConnectivityState[newState]);
        }
        const previousState = this.connectivityState;
        this.connectivityState = newState;
        switch (newState) {
          case connectivity_state_1.ConnectivityState.READY:
            this.stopBackoff();
            break;
          case connectivity_state_1.ConnectivityState.CONNECTING:
            this.startBackoff();
            this.startConnectingInternal();
            this.continueConnecting = false;
            break;
          case connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE:
            if (this.channelzEnabled && this.transport) {
              this.childrenTracker.unrefChild(this.transport.getChannelzRef());
            }
            (_a = this.transport) === null || _a === void 0 ? void 0 : _a.shutdown();
            this.transport = null;
            if (!this.backoffTimeout.isRunning()) {
              process.nextTick(() => {
                this.handleBackoffTimer();
              });
            }
            break;
          case connectivity_state_1.ConnectivityState.IDLE:
            if (this.channelzEnabled && this.transport) {
              this.childrenTracker.unrefChild(this.transport.getChannelzRef());
            }
            (_b = this.transport) === null || _b === void 0 ? void 0 : _b.shutdown();
            this.transport = null;
            break;
          default:
            throw new Error(`Invalid state: unknown ConnectivityState ${newState}`);
        }
        for (const listener of [...this.stateListeners]) {
          listener(this, previousState, newState);
        }
        return true;
      }
      ref() {
        this.refTrace("refcount " + this.refcount + " -> " + (this.refcount + 1));
        this.refcount += 1;
      }
      unref() {
        this.refTrace("refcount " + this.refcount + " -> " + (this.refcount - 1));
        this.refcount -= 1;
        if (this.refcount === 0) {
          if (this.channelzEnabled) {
            this.channelzTrace.addTrace("CT_INFO", "Shutting down");
          }
          this.transitionToState([connectivity_state_1.ConnectivityState.CONNECTING, connectivity_state_1.ConnectivityState.READY], connectivity_state_1.ConnectivityState.IDLE);
          if (this.channelzEnabled) {
            (0, channelz_1.unregisterChannelzRef)(this.channelzRef);
          }
        }
      }
      unrefIfOneRef() {
        if (this.refcount === 1) {
          this.unref();
          return true;
        }
        return false;
      }
      createCall(metadata, host, method, listener) {
        if (!this.transport) {
          throw new Error("Cannot create call, subchannel not READY");
        }
        let statsTracker;
        if (this.channelzEnabled) {
          this.callTracker.addCallStarted();
          this.streamTracker.addCallStarted();
          statsTracker = {
            onCallEnd: (status) => {
              if (status.code === constants_1.Status.OK) {
                this.callTracker.addCallSucceeded();
              } else {
                this.callTracker.addCallFailed();
              }
            }
          };
        } else {
          statsTracker = {};
        }
        return this.transport.createCall(metadata, host, method, listener, statsTracker);
      }
      /**
       * If the subchannel is currently IDLE, start connecting and switch to the
       * CONNECTING state. If the subchannel is current in TRANSIENT_FAILURE,
       * the next time it would transition to IDLE, start connecting again instead.
       * Otherwise, do nothing.
       */
      startConnecting() {
        if (!this.transitionToState([connectivity_state_1.ConnectivityState.IDLE], connectivity_state_1.ConnectivityState.CONNECTING)) {
          if (this.connectivityState === connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE) {
            this.continueConnecting = true;
          }
        }
      }
      /**
       * Get the subchannel's current connectivity state.
       */
      getConnectivityState() {
        return this.connectivityState;
      }
      /**
       * Add a listener function to be called whenever the subchannel's
       * connectivity state changes.
       * @param listener
       */
      addConnectivityStateListener(listener) {
        this.stateListeners.push(listener);
      }
      /**
       * Remove a listener previously added with `addConnectivityStateListener`
       * @param listener A reference to a function previously passed to
       *     `addConnectivityStateListener`
       */
      removeConnectivityStateListener(listener) {
        const listenerIndex = this.stateListeners.indexOf(listener);
        if (listenerIndex > -1) {
          this.stateListeners.splice(listenerIndex, 1);
        }
      }
      /**
       * Reset the backoff timeout, and immediately start connecting if in backoff.
       */
      resetBackoff() {
        this.backoffTimeout.reset();
        this.transitionToState([connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE], connectivity_state_1.ConnectivityState.CONNECTING);
      }
      getAddress() {
        return this.subchannelAddressString;
      }
      getChannelzRef() {
        return this.channelzRef;
      }
      getRealSubchannel() {
        return this;
      }
    };
    exports2.Subchannel = Subchannel;
  }
});

// node_modules/@grpc/grpc-js/build/src/http_proxy.js
var require_http_proxy = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/http_proxy.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getProxiedConnection = exports2.mapProxyName = void 0;
    var logging_1 = require_logging();
    var constants_1 = require_constants();
    var resolver_1 = require_resolver();
    var http = require("http");
    var tls = require("tls");
    var logging = require_logging();
    var subchannel_address_1 = require_subchannel_address();
    var uri_parser_1 = require_uri_parser();
    var url_1 = require("url");
    var TRACER_NAME = "proxy";
    function trace(text) {
      logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, text);
    }
    function getProxyInfo() {
      let proxyEnv = "";
      let envVar = "";
      if (process.env.grpc_proxy) {
        envVar = "grpc_proxy";
        proxyEnv = process.env.grpc_proxy;
      } else if (process.env.https_proxy) {
        envVar = "https_proxy";
        proxyEnv = process.env.https_proxy;
      } else if (process.env.http_proxy) {
        envVar = "http_proxy";
        proxyEnv = process.env.http_proxy;
      } else {
        return {};
      }
      let proxyUrl;
      try {
        proxyUrl = new url_1.URL(proxyEnv);
      } catch (e2) {
        (0, logging_1.log)(constants_1.LogVerbosity.ERROR, `cannot parse value of "${envVar}" env var`);
        return {};
      }
      if (proxyUrl.protocol !== "http:") {
        (0, logging_1.log)(constants_1.LogVerbosity.ERROR, `"${proxyUrl.protocol}" scheme not supported in proxy URI`);
        return {};
      }
      let userCred = null;
      if (proxyUrl.username) {
        if (proxyUrl.password) {
          (0, logging_1.log)(constants_1.LogVerbosity.INFO, "userinfo found in proxy URI");
          userCred = `${proxyUrl.username}:${proxyUrl.password}`;
        } else {
          userCred = proxyUrl.username;
        }
      }
      const hostname = proxyUrl.hostname;
      let port = proxyUrl.port;
      if (port === "") {
        port = "80";
      }
      const result = {
        address: `${hostname}:${port}`
      };
      if (userCred) {
        result.creds = userCred;
      }
      trace("Proxy server " + result.address + " set by environment variable " + envVar);
      return result;
    }
    function getNoProxyHostList() {
      let noProxyStr = process.env.no_grpc_proxy;
      let envVar = "no_grpc_proxy";
      if (!noProxyStr) {
        noProxyStr = process.env.no_proxy;
        envVar = "no_proxy";
      }
      if (noProxyStr) {
        trace("No proxy server list set by environment variable " + envVar);
        return noProxyStr.split(",");
      } else {
        return [];
      }
    }
    function mapProxyName(target, options) {
      var _a;
      const noProxyResult = {
        target,
        extraOptions: {}
      };
      if (((_a = options["grpc.enable_http_proxy"]) !== null && _a !== void 0 ? _a : 1) === 0) {
        return noProxyResult;
      }
      if (target.scheme === "unix") {
        return noProxyResult;
      }
      const proxyInfo = getProxyInfo();
      if (!proxyInfo.address) {
        return noProxyResult;
      }
      const hostPort = (0, uri_parser_1.splitHostPort)(target.path);
      if (!hostPort) {
        return noProxyResult;
      }
      const serverHost = hostPort.host;
      for (const host of getNoProxyHostList()) {
        if (host === serverHost) {
          trace("Not using proxy for target in no_proxy list: " + (0, uri_parser_1.uriToString)(target));
          return noProxyResult;
        }
      }
      const extraOptions = {
        "grpc.http_connect_target": (0, uri_parser_1.uriToString)(target)
      };
      if (proxyInfo.creds) {
        extraOptions["grpc.http_connect_creds"] = proxyInfo.creds;
      }
      return {
        target: {
          scheme: "dns",
          path: proxyInfo.address
        },
        extraOptions
      };
    }
    exports2.mapProxyName = mapProxyName;
    function getProxiedConnection(address, channelOptions, connectionOptions) {
      if (!("grpc.http_connect_target" in channelOptions)) {
        return Promise.resolve({});
      }
      const realTarget = channelOptions["grpc.http_connect_target"];
      const parsedTarget = (0, uri_parser_1.parseUri)(realTarget);
      if (parsedTarget === null) {
        return Promise.resolve({});
      }
      const options = {
        method: "CONNECT",
        path: parsedTarget.path
      };
      const headers = {
        Host: parsedTarget.path
      };
      if ((0, subchannel_address_1.isTcpSubchannelAddress)(address)) {
        options.host = address.host;
        options.port = address.port;
      } else {
        options.socketPath = address.path;
      }
      if ("grpc.http_connect_creds" in channelOptions) {
        headers["Proxy-Authorization"] = "Basic " + Buffer.from(channelOptions["grpc.http_connect_creds"]).toString("base64");
      }
      options.headers = headers;
      const proxyAddressString = (0, subchannel_address_1.subchannelAddressToString)(address);
      trace("Using proxy " + proxyAddressString + " to connect to " + options.path);
      return new Promise((resolve, reject) => {
        const request = http.request(options);
        request.once("connect", (res, socket, head) => {
          var _a;
          request.removeAllListeners();
          socket.removeAllListeners();
          if (res.statusCode === 200) {
            trace("Successfully connected to " + options.path + " through proxy " + proxyAddressString);
            if ("secureContext" in connectionOptions) {
              const targetPath = (0, resolver_1.getDefaultAuthority)(parsedTarget);
              const hostPort = (0, uri_parser_1.splitHostPort)(targetPath);
              const remoteHost = (_a = hostPort === null || hostPort === void 0 ? void 0 : hostPort.host) !== null && _a !== void 0 ? _a : targetPath;
              const cts = tls.connect(Object.assign({ host: remoteHost, servername: remoteHost, socket }, connectionOptions), () => {
                trace("Successfully established a TLS connection to " + options.path + " through proxy " + proxyAddressString);
                resolve({ socket: cts, realTarget: parsedTarget });
              });
              cts.on("error", (error) => {
                trace("Failed to establish a TLS connection to " + options.path + " through proxy " + proxyAddressString + " with error " + error.message);
                reject();
              });
            } else {
              trace("Successfully established a plaintext connection to " + options.path + " through proxy " + proxyAddressString);
              resolve({
                socket,
                realTarget: parsedTarget
              });
            }
          } else {
            (0, logging_1.log)(constants_1.LogVerbosity.ERROR, "Failed to connect to " + options.path + " through proxy " + proxyAddressString + " with status " + res.statusCode);
            reject();
          }
        });
        request.once("error", (err) => {
          request.removeAllListeners();
          (0, logging_1.log)(constants_1.LogVerbosity.ERROR, "Failed to connect to proxy " + proxyAddressString + " with error " + err.message);
          reject();
        });
        request.end();
      });
    }
    exports2.getProxiedConnection = getProxiedConnection;
  }
});

// node_modules/@grpc/grpc-js/build/src/stream-decoder.js
var require_stream_decoder = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/stream-decoder.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.StreamDecoder = void 0;
    var ReadState;
    (function(ReadState2) {
      ReadState2[ReadState2["NO_DATA"] = 0] = "NO_DATA";
      ReadState2[ReadState2["READING_SIZE"] = 1] = "READING_SIZE";
      ReadState2[ReadState2["READING_MESSAGE"] = 2] = "READING_MESSAGE";
    })(ReadState || (ReadState = {}));
    var StreamDecoder = class {
      constructor() {
        this.readState = ReadState.NO_DATA;
        this.readCompressFlag = Buffer.alloc(1);
        this.readPartialSize = Buffer.alloc(4);
        this.readSizeRemaining = 4;
        this.readMessageSize = 0;
        this.readPartialMessage = [];
        this.readMessageRemaining = 0;
      }
      write(data) {
        let readHead = 0;
        let toRead;
        const result = [];
        while (readHead < data.length) {
          switch (this.readState) {
            case ReadState.NO_DATA:
              this.readCompressFlag = data.slice(readHead, readHead + 1);
              readHead += 1;
              this.readState = ReadState.READING_SIZE;
              this.readPartialSize.fill(0);
              this.readSizeRemaining = 4;
              this.readMessageSize = 0;
              this.readMessageRemaining = 0;
              this.readPartialMessage = [];
              break;
            case ReadState.READING_SIZE:
              toRead = Math.min(data.length - readHead, this.readSizeRemaining);
              data.copy(this.readPartialSize, 4 - this.readSizeRemaining, readHead, readHead + toRead);
              this.readSizeRemaining -= toRead;
              readHead += toRead;
              if (this.readSizeRemaining === 0) {
                this.readMessageSize = this.readPartialSize.readUInt32BE(0);
                this.readMessageRemaining = this.readMessageSize;
                if (this.readMessageRemaining > 0) {
                  this.readState = ReadState.READING_MESSAGE;
                } else {
                  const message = Buffer.concat([this.readCompressFlag, this.readPartialSize], 5);
                  this.readState = ReadState.NO_DATA;
                  result.push(message);
                }
              }
              break;
            case ReadState.READING_MESSAGE:
              toRead = Math.min(data.length - readHead, this.readMessageRemaining);
              this.readPartialMessage.push(data.slice(readHead, readHead + toRead));
              this.readMessageRemaining -= toRead;
              readHead += toRead;
              if (this.readMessageRemaining === 0) {
                const framedMessageBuffers = [
                  this.readCompressFlag,
                  this.readPartialSize
                ].concat(this.readPartialMessage);
                const framedMessage = Buffer.concat(framedMessageBuffers, this.readMessageSize + 5);
                this.readState = ReadState.NO_DATA;
                result.push(framedMessage);
              }
              break;
            default:
              throw new Error("Unexpected read state");
          }
        }
        return result;
      }
    };
    exports2.StreamDecoder = StreamDecoder;
  }
});

// node_modules/@grpc/grpc-js/build/src/subchannel-call.js
var require_subchannel_call = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/subchannel-call.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Http2SubchannelCall = void 0;
    var http2 = require("http2");
    var os = require("os");
    var constants_1 = require_constants();
    var metadata_1 = require_metadata();
    var stream_decoder_1 = require_stream_decoder();
    var logging = require_logging();
    var constants_2 = require_constants();
    var TRACER_NAME = "subchannel_call";
    var { HTTP2_HEADER_STATUS, HTTP2_HEADER_CONTENT_TYPE, NGHTTP2_CANCEL } = http2.constants;
    function getSystemErrorName(errno) {
      for (const [name, num] of Object.entries(os.constants.errno)) {
        if (num === errno) {
          return name;
        }
      }
      return "Unknown system error " + errno;
    }
    var Http2SubchannelCall = class {
      constructor(http2Stream, callEventTracker, listener, peerName, callId) {
        this.http2Stream = http2Stream;
        this.callEventTracker = callEventTracker;
        this.listener = listener;
        this.peerName = peerName;
        this.callId = callId;
        this.decoder = new stream_decoder_1.StreamDecoder();
        this.isReadFilterPending = false;
        this.isPushPending = false;
        this.canPush = false;
        this.readsClosed = false;
        this.statusOutput = false;
        this.unpushedReadMessages = [];
        this.mappedStatusCode = constants_1.Status.UNKNOWN;
        this.finalStatus = null;
        this.internalError = null;
        this.disconnectListener = () => {
          this.endCall({
            code: constants_1.Status.UNAVAILABLE,
            details: "Connection dropped",
            metadata: new metadata_1.Metadata()
          });
        };
        http2Stream.on("response", (headers, flags) => {
          let headersString = "";
          for (const header of Object.keys(headers)) {
            headersString += "		" + header + ": " + headers[header] + "\n";
          }
          this.trace("Received server headers:\n" + headersString);
          switch (headers[":status"]) {
            case 400:
              this.mappedStatusCode = constants_1.Status.INTERNAL;
              break;
            case 401:
              this.mappedStatusCode = constants_1.Status.UNAUTHENTICATED;
              break;
            case 403:
              this.mappedStatusCode = constants_1.Status.PERMISSION_DENIED;
              break;
            case 404:
              this.mappedStatusCode = constants_1.Status.UNIMPLEMENTED;
              break;
            case 429:
            case 502:
            case 503:
            case 504:
              this.mappedStatusCode = constants_1.Status.UNAVAILABLE;
              break;
            default:
              this.mappedStatusCode = constants_1.Status.UNKNOWN;
          }
          if (flags & http2.constants.NGHTTP2_FLAG_END_STREAM) {
            this.handleTrailers(headers);
          } else {
            let metadata;
            try {
              metadata = metadata_1.Metadata.fromHttp2Headers(headers);
            } catch (error) {
              this.endCall({
                code: constants_1.Status.UNKNOWN,
                details: error.message,
                metadata: new metadata_1.Metadata()
              });
              return;
            }
            this.listener.onReceiveMetadata(metadata);
          }
        });
        http2Stream.on("trailers", (headers) => {
          this.handleTrailers(headers);
        });
        http2Stream.on("data", (data) => {
          if (this.statusOutput) {
            return;
          }
          this.trace("receive HTTP/2 data frame of length " + data.length);
          const messages = this.decoder.write(data);
          for (const message of messages) {
            this.trace("parsed message of length " + message.length);
            this.callEventTracker.addMessageReceived();
            this.tryPush(message);
          }
        });
        http2Stream.on("end", () => {
          this.readsClosed = true;
          this.maybeOutputStatus();
        });
        http2Stream.on("close", () => {
          process.nextTick(() => {
            var _a;
            this.trace("HTTP/2 stream closed with code " + http2Stream.rstCode);
            if (((_a = this.finalStatus) === null || _a === void 0 ? void 0 : _a.code) === constants_1.Status.OK) {
              return;
            }
            let code;
            let details = "";
            switch (http2Stream.rstCode) {
              case http2.constants.NGHTTP2_NO_ERROR:
                if (this.finalStatus !== null) {
                  return;
                }
                code = constants_1.Status.INTERNAL;
                details = `Received RST_STREAM with code ${http2Stream.rstCode}`;
                break;
              case http2.constants.NGHTTP2_REFUSED_STREAM:
                code = constants_1.Status.UNAVAILABLE;
                details = "Stream refused by server";
                break;
              case http2.constants.NGHTTP2_CANCEL:
                code = constants_1.Status.CANCELLED;
                details = "Call cancelled";
                break;
              case http2.constants.NGHTTP2_ENHANCE_YOUR_CALM:
                code = constants_1.Status.RESOURCE_EXHAUSTED;
                details = "Bandwidth exhausted or memory limit exceeded";
                break;
              case http2.constants.NGHTTP2_INADEQUATE_SECURITY:
                code = constants_1.Status.PERMISSION_DENIED;
                details = "Protocol not secure enough";
                break;
              case http2.constants.NGHTTP2_INTERNAL_ERROR:
                code = constants_1.Status.INTERNAL;
                if (this.internalError === null) {
                  details = `Received RST_STREAM with code ${http2Stream.rstCode} (Internal server error)`;
                } else {
                  if (this.internalError.code === "ECONNRESET" || this.internalError.code === "ETIMEDOUT") {
                    code = constants_1.Status.UNAVAILABLE;
                    details = this.internalError.message;
                  } else {
                    details = `Received RST_STREAM with code ${http2Stream.rstCode} triggered by internal client error: ${this.internalError.message}`;
                  }
                }
                break;
              default:
                code = constants_1.Status.INTERNAL;
                details = `Received RST_STREAM with code ${http2Stream.rstCode}`;
            }
            this.endCall({ code, details, metadata: new metadata_1.Metadata(), rstCode: http2Stream.rstCode });
          });
        });
        http2Stream.on("error", (err) => {
          if (err.code !== "ERR_HTTP2_STREAM_ERROR") {
            this.trace("Node error event: message=" + err.message + " code=" + err.code + " errno=" + getSystemErrorName(err.errno) + " syscall=" + err.syscall);
            this.internalError = err;
          }
          this.callEventTracker.onStreamEnd(false);
        });
      }
      onDisconnect() {
        this.endCall({
          code: constants_1.Status.UNAVAILABLE,
          details: "Connection dropped",
          metadata: new metadata_1.Metadata()
        });
      }
      outputStatus() {
        if (!this.statusOutput) {
          this.statusOutput = true;
          this.trace("ended with status: code=" + this.finalStatus.code + ' details="' + this.finalStatus.details + '"');
          this.callEventTracker.onCallEnd(this.finalStatus);
          process.nextTick(() => {
            this.listener.onReceiveStatus(this.finalStatus);
          });
          this.http2Stream.resume();
        }
      }
      trace(text) {
        logging.trace(constants_2.LogVerbosity.DEBUG, TRACER_NAME, "[" + this.callId + "] " + text);
      }
      /**
       * On first call, emits a 'status' event with the given StatusObject.
       * Subsequent calls are no-ops.
       * @param status The status of the call.
       */
      endCall(status) {
        if (this.finalStatus === null || this.finalStatus.code === constants_1.Status.OK) {
          this.finalStatus = status;
          this.maybeOutputStatus();
        }
        this.destroyHttp2Stream();
      }
      maybeOutputStatus() {
        if (this.finalStatus !== null) {
          if (this.finalStatus.code !== constants_1.Status.OK || this.readsClosed && this.unpushedReadMessages.length === 0 && !this.isReadFilterPending && !this.isPushPending) {
            this.outputStatus();
          }
        }
      }
      push(message) {
        this.trace("pushing to reader message of length " + (message instanceof Buffer ? message.length : null));
        this.canPush = false;
        this.isPushPending = true;
        process.nextTick(() => {
          this.isPushPending = false;
          if (this.statusOutput) {
            return;
          }
          this.listener.onReceiveMessage(message);
          this.maybeOutputStatus();
        });
      }
      tryPush(messageBytes) {
        if (this.canPush) {
          this.http2Stream.pause();
          this.push(messageBytes);
        } else {
          this.trace("unpushedReadMessages.push message of length " + messageBytes.length);
          this.unpushedReadMessages.push(messageBytes);
        }
      }
      handleTrailers(headers) {
        this.callEventTracker.onStreamEnd(true);
        let headersString = "";
        for (const header of Object.keys(headers)) {
          headersString += "		" + header + ": " + headers[header] + "\n";
        }
        this.trace("Received server trailers:\n" + headersString);
        let metadata;
        try {
          metadata = metadata_1.Metadata.fromHttp2Headers(headers);
        } catch (e2) {
          metadata = new metadata_1.Metadata();
        }
        const metadataMap = metadata.getMap();
        let code = this.mappedStatusCode;
        if (code === constants_1.Status.UNKNOWN && typeof metadataMap["grpc-status"] === "string") {
          const receivedStatus = Number(metadataMap["grpc-status"]);
          if (receivedStatus in constants_1.Status) {
            code = receivedStatus;
            this.trace("received status code " + receivedStatus + " from server");
          }
          metadata.remove("grpc-status");
        }
        let details = "";
        if (typeof metadataMap["grpc-message"] === "string") {
          try {
            details = decodeURI(metadataMap["grpc-message"]);
          } catch (e2) {
            details = metadataMap["grpc-message"];
          }
          metadata.remove("grpc-message");
          this.trace('received status details string "' + details + '" from server');
        }
        const status = { code, details, metadata };
        this.endCall(status);
      }
      destroyHttp2Stream() {
        var _a;
        if (!this.http2Stream.destroyed) {
          let code;
          if (((_a = this.finalStatus) === null || _a === void 0 ? void 0 : _a.code) === constants_1.Status.OK) {
            code = http2.constants.NGHTTP2_NO_ERROR;
          } else {
            code = http2.constants.NGHTTP2_CANCEL;
          }
          this.trace("close http2 stream with code " + code);
          this.http2Stream.close(code);
        }
      }
      cancelWithStatus(status, details) {
        this.trace("cancelWithStatus code: " + status + ' details: "' + details + '"');
        this.endCall({ code: status, details, metadata: new metadata_1.Metadata() });
      }
      getStatus() {
        return this.finalStatus;
      }
      getPeer() {
        return this.peerName;
      }
      getCallNumber() {
        return this.callId;
      }
      startRead() {
        if (this.finalStatus !== null && this.finalStatus.code !== constants_1.Status.OK) {
          this.readsClosed = true;
          this.maybeOutputStatus();
          return;
        }
        this.canPush = true;
        if (this.unpushedReadMessages.length > 0) {
          const nextMessage = this.unpushedReadMessages.shift();
          this.push(nextMessage);
          return;
        }
        this.http2Stream.resume();
      }
      sendMessageWithContext(context, message) {
        this.trace("write() called with message of length " + message.length);
        const cb = (error) => {
          var _a;
          let code = constants_1.Status.UNAVAILABLE;
          if ((error === null || error === void 0 ? void 0 : error.code) === "ERR_STREAM_WRITE_AFTER_END") {
            code = constants_1.Status.INTERNAL;
          }
          if (error) {
            this.cancelWithStatus(code, `Write error: ${error.message}`);
          }
          (_a = context.callback) === null || _a === void 0 ? void 0 : _a.call(context);
        };
        this.trace("sending data chunk of length " + message.length);
        this.callEventTracker.addMessageSent();
        try {
          this.http2Stream.write(message, cb);
        } catch (error) {
          this.endCall({
            code: constants_1.Status.UNAVAILABLE,
            details: `Write failed with error ${error.message}`,
            metadata: new metadata_1.Metadata()
          });
        }
      }
      halfClose() {
        this.trace("end() called");
        this.trace("calling end() on HTTP/2 stream");
        this.http2Stream.end();
      }
    };
    exports2.Http2SubchannelCall = Http2SubchannelCall;
  }
});

// node_modules/@grpc/grpc-js/build/src/call-number.js
var require_call_number = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/call-number.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getNextCallNumber = void 0;
    var nextCallNumber = 0;
    function getNextCallNumber() {
      return nextCallNumber++;
    }
    exports2.getNextCallNumber = getNextCallNumber;
  }
});

// node_modules/@grpc/grpc-js/package.json
var require_package = __commonJS({
  "node_modules/@grpc/grpc-js/package.json"(exports2, module2) {
    module2.exports = {
      name: "@grpc/grpc-js",
      version: "1.8.4",
      description: "gRPC Library for Node - pure JS implementation",
      homepage: "https://grpc.io/",
      repository: "https://github.com/grpc/grpc-node/tree/master/packages/grpc-js",
      main: "build/src/index.js",
      engines: {
        node: "^8.13.0 || >=10.10.0"
      },
      keywords: [],
      author: {
        name: "Google Inc."
      },
      types: "build/src/index.d.ts",
      license: "Apache-2.0",
      devDependencies: {
        "@types/gulp": "^4.0.6",
        "@types/gulp-mocha": "0.0.32",
        "@types/lodash": "^4.14.186",
        "@types/mocha": "^5.2.6",
        "@types/ncp": "^2.0.1",
        "@types/pify": "^3.0.2",
        "@types/semver": "^7.3.9",
        "clang-format": "^1.0.55",
        execa: "^2.0.3",
        gts: "^3.1.1",
        gulp: "^4.0.2",
        "gulp-mocha": "^6.0.0",
        lodash: "^4.17.4",
        madge: "^5.0.1",
        "mocha-jenkins-reporter": "^0.4.1",
        ncp: "^2.0.0",
        pify: "^4.0.1",
        rimraf: "^3.0.2",
        semver: "^7.3.5",
        "ts-node": "^8.3.0",
        typescript: "^4.8.4"
      },
      contributors: [
        {
          name: "Google Inc."
        }
      ],
      scripts: {
        build: "npm run compile",
        clean: "rimraf ./build",
        compile: "tsc -p .",
        format: 'clang-format -i -style="{Language: JavaScript, BasedOnStyle: Google, ColumnLimit: 80}" src/*.ts test/*.ts',
        lint: "npm run check",
        prepare: "npm run generate-types && npm run compile",
        test: "gulp test",
        check: "gts check src/**/*.ts",
        fix: "gts fix src/*.ts",
        pretest: "npm run generate-types && npm run generate-test-types && npm run compile",
        posttest: "npm run check && madge -c ./build/src",
        "generate-types": "proto-loader-gen-types --keepCase --longs String --enums String --defaults --oneofs --includeComments --includeDirs proto/ --include-dirs test/fixtures/ -O src/generated/ --grpcLib ../index channelz.proto",
        "generate-test-types": "proto-loader-gen-types --keepCase --longs String --enums String --defaults --oneofs --includeComments --include-dirs test/fixtures/ -O test/generated/ --grpcLib ../../src/index test_service.proto"
      },
      dependencies: {
        "@grpc/proto-loader": "^0.7.0",
        "@types/node": ">=12.12.47"
      },
      files: [
        "src/**/*.ts",
        "build/src/**/*.{js,d.ts,js.map}",
        "proto/*.proto",
        "LICENSE",
        "deps/envoy-api/envoy/api/v2/**/*.proto",
        "deps/envoy-api/envoy/config/**/*.proto",
        "deps/envoy-api/envoy/service/**/*.proto",
        "deps/envoy-api/envoy/type/**/*.proto",
        "deps/udpa/udpa/**/*.proto",
        "deps/googleapis/google/api/*.proto",
        "deps/googleapis/google/rpc/*.proto",
        "deps/protoc-gen-validate/validate/**/*.proto"
      ]
    };
  }
});

// node_modules/@grpc/grpc-js/build/src/transport.js
var require_transport = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/transport.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Http2SubchannelConnector = void 0;
    var http2 = require("http2");
    var tls_1 = require("tls");
    var channelz_1 = require_channelz();
    var constants_1 = require_constants();
    var http_proxy_1 = require_http_proxy();
    var logging = require_logging();
    var resolver_1 = require_resolver();
    var subchannel_address_1 = require_subchannel_address();
    var uri_parser_1 = require_uri_parser();
    var net = require("net");
    var subchannel_call_1 = require_subchannel_call();
    var call_number_1 = require_call_number();
    var TRACER_NAME = "transport";
    var FLOW_CONTROL_TRACER_NAME = "transport_flowctrl";
    var clientVersion = require_package().version;
    var { HTTP2_HEADER_AUTHORITY, HTTP2_HEADER_CONTENT_TYPE, HTTP2_HEADER_METHOD, HTTP2_HEADER_PATH, HTTP2_HEADER_TE, HTTP2_HEADER_USER_AGENT } = http2.constants;
    var KEEPALIVE_MAX_TIME_MS = ~(1 << 31);
    var KEEPALIVE_TIMEOUT_MS = 2e4;
    var tooManyPingsData = Buffer.from("too_many_pings", "ascii");
    var Http2Transport = class {
      constructor(session, subchannelAddress, options) {
        this.session = session;
        this.keepaliveTimeMs = KEEPALIVE_MAX_TIME_MS;
        this.keepaliveTimeoutMs = KEEPALIVE_TIMEOUT_MS;
        this.keepaliveTimeoutId = null;
        this.keepaliveWithoutCalls = false;
        this.activeCalls = /* @__PURE__ */ new Set();
        this.disconnectListeners = [];
        this.disconnectHandled = false;
        this.channelzEnabled = true;
        this.remoteName = null;
        this.streamTracker = new channelz_1.ChannelzCallTracker();
        this.keepalivesSent = 0;
        this.messagesSent = 0;
        this.messagesReceived = 0;
        this.lastMessageSentTimestamp = null;
        this.lastMessageReceivedTimestamp = null;
        this.userAgent = [
          options["grpc.primary_user_agent"],
          `grpc-node-js/${clientVersion}`,
          options["grpc.secondary_user_agent"]
        ].filter((e2) => e2).join(" ");
        if ("grpc.keepalive_time_ms" in options) {
          this.keepaliveTimeMs = options["grpc.keepalive_time_ms"];
        }
        if ("grpc.keepalive_timeout_ms" in options) {
          this.keepaliveTimeoutMs = options["grpc.keepalive_timeout_ms"];
        }
        if ("grpc.keepalive_permit_without_calls" in options) {
          this.keepaliveWithoutCalls = options["grpc.keepalive_permit_without_calls"] === 1;
        } else {
          this.keepaliveWithoutCalls = false;
        }
        this.keepaliveIntervalId = setTimeout(() => {
        }, 0);
        clearTimeout(this.keepaliveIntervalId);
        if (this.keepaliveWithoutCalls) {
          this.startKeepalivePings();
        }
        this.subchannelAddressString = (0, subchannel_address_1.subchannelAddressToString)(subchannelAddress);
        if (options["grpc.enable_channelz"] === 0) {
          this.channelzEnabled = false;
        }
        this.channelzRef = (0, channelz_1.registerChannelzSocket)(this.subchannelAddressString, () => this.getChannelzInfo(), this.channelzEnabled);
        session.once("close", () => {
          this.trace("session closed");
          this.stopKeepalivePings();
          this.handleDisconnect();
        });
        session.once("goaway", (errorCode, lastStreamID, opaqueData) => {
          let tooManyPings = false;
          if (errorCode === http2.constants.NGHTTP2_ENHANCE_YOUR_CALM && opaqueData.equals(tooManyPingsData)) {
            tooManyPings = true;
          }
          this.trace("connection closed by GOAWAY with code " + errorCode);
          this.reportDisconnectToOwner(tooManyPings);
        });
        session.once("error", (error) => {
          this.trace("connection closed with error " + error.message);
        });
        if (logging.isTracerEnabled(TRACER_NAME)) {
          session.on("remoteSettings", (settings) => {
            this.trace("new settings received" + (this.session !== session ? " on the old connection" : "") + ": " + JSON.stringify(settings));
          });
          session.on("localSettings", (settings) => {
            this.trace("local settings acknowledged by remote" + (this.session !== session ? " on the old connection" : "") + ": " + JSON.stringify(settings));
          });
        }
      }
      getChannelzInfo() {
        var _a, _b, _c;
        const sessionSocket = this.session.socket;
        const remoteAddress = sessionSocket.remoteAddress ? (0, subchannel_address_1.stringToSubchannelAddress)(sessionSocket.remoteAddress, sessionSocket.remotePort) : null;
        const localAddress = sessionSocket.localAddress ? (0, subchannel_address_1.stringToSubchannelAddress)(sessionSocket.localAddress, sessionSocket.localPort) : null;
        let tlsInfo;
        if (this.session.encrypted) {
          const tlsSocket = sessionSocket;
          const cipherInfo = tlsSocket.getCipher();
          const certificate = tlsSocket.getCertificate();
          const peerCertificate = tlsSocket.getPeerCertificate();
          tlsInfo = {
            cipherSuiteStandardName: (_a = cipherInfo.standardName) !== null && _a !== void 0 ? _a : null,
            cipherSuiteOtherName: cipherInfo.standardName ? null : cipherInfo.name,
            localCertificate: certificate && "raw" in certificate ? certificate.raw : null,
            remoteCertificate: peerCertificate && "raw" in peerCertificate ? peerCertificate.raw : null
          };
        } else {
          tlsInfo = null;
        }
        const socketInfo = {
          remoteAddress,
          localAddress,
          security: tlsInfo,
          remoteName: this.remoteName,
          streamsStarted: this.streamTracker.callsStarted,
          streamsSucceeded: this.streamTracker.callsSucceeded,
          streamsFailed: this.streamTracker.callsFailed,
          messagesSent: this.messagesSent,
          messagesReceived: this.messagesReceived,
          keepAlivesSent: this.keepalivesSent,
          lastLocalStreamCreatedTimestamp: this.streamTracker.lastCallStartedTimestamp,
          lastRemoteStreamCreatedTimestamp: null,
          lastMessageSentTimestamp: this.lastMessageSentTimestamp,
          lastMessageReceivedTimestamp: this.lastMessageReceivedTimestamp,
          localFlowControlWindow: (_b = this.session.state.localWindowSize) !== null && _b !== void 0 ? _b : null,
          remoteFlowControlWindow: (_c = this.session.state.remoteWindowSize) !== null && _c !== void 0 ? _c : null
        };
        return socketInfo;
      }
      trace(text) {
        logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, "(" + this.channelzRef.id + ") " + this.subchannelAddressString + " " + text);
      }
      keepaliveTrace(text) {
        logging.trace(constants_1.LogVerbosity.DEBUG, "keepalive", "(" + this.channelzRef.id + ") " + this.subchannelAddressString + " " + text);
      }
      flowControlTrace(text) {
        logging.trace(constants_1.LogVerbosity.DEBUG, FLOW_CONTROL_TRACER_NAME, "(" + this.channelzRef.id + ") " + this.subchannelAddressString + " " + text);
      }
      internalsTrace(text) {
        logging.trace(constants_1.LogVerbosity.DEBUG, "transport_internals", "(" + this.channelzRef.id + ") " + this.subchannelAddressString + " " + text);
      }
      /**
       * Indicate to the owner of this object that this transport should no longer
       * be used. That happens if the connection drops, or if the server sends a
       * GOAWAY.
       * @param tooManyPings If true, this was triggered by a GOAWAY with data
       * indicating that the session was closed becaues the client sent too many
       * pings.
       * @returns
       */
      reportDisconnectToOwner(tooManyPings) {
        if (this.disconnectHandled) {
          return;
        }
        this.disconnectHandled = true;
        this.disconnectListeners.forEach((listener) => listener(tooManyPings));
      }
      /**
       * Handle connection drops, but not GOAWAYs.
       */
      handleDisconnect() {
        this.reportDisconnectToOwner(false);
        setImmediate(() => {
          for (const call of this.activeCalls) {
            call.onDisconnect();
          }
        });
      }
      addDisconnectListener(listener) {
        this.disconnectListeners.push(listener);
      }
      clearKeepaliveTimeout() {
        if (!this.keepaliveTimeoutId) {
          return;
        }
        clearTimeout(this.keepaliveTimeoutId);
        this.keepaliveTimeoutId = null;
      }
      sendPing() {
        var _a, _b;
        if (this.channelzEnabled) {
          this.keepalivesSent += 1;
        }
        this.keepaliveTrace("Sending ping with timeout " + this.keepaliveTimeoutMs + "ms");
        if (!this.keepaliveTimeoutId) {
          this.keepaliveTimeoutId = setTimeout(() => {
            this.keepaliveTrace("Ping timeout passed without response");
            this.handleDisconnect();
          }, this.keepaliveTimeoutMs);
          (_b = (_a = this.keepaliveTimeoutId).unref) === null || _b === void 0 ? void 0 : _b.call(_a);
        }
        try {
          this.session.ping((err, duration, payload) => {
            this.keepaliveTrace("Received ping response");
            this.clearKeepaliveTimeout();
          });
        } catch (e2) {
          this.handleDisconnect();
        }
      }
      startKeepalivePings() {
        var _a, _b;
        this.keepaliveIntervalId = setInterval(() => {
          this.sendPing();
        }, this.keepaliveTimeMs);
        (_b = (_a = this.keepaliveIntervalId).unref) === null || _b === void 0 ? void 0 : _b.call(_a);
      }
      /**
       * Stop keepalive pings when terminating a connection. This discards the
       * outstanding ping timeout, so it should not be called if the same
       * connection will still be used.
       */
      stopKeepalivePings() {
        clearInterval(this.keepaliveIntervalId);
        this.clearKeepaliveTimeout();
      }
      removeActiveCall(call) {
        this.activeCalls.delete(call);
        if (this.activeCalls.size === 0 && !this.keepaliveWithoutCalls) {
          this.session.unref();
          this.stopKeepalivePings();
        }
      }
      addActiveCall(call) {
        if (this.activeCalls.size === 0 && !this.keepaliveWithoutCalls) {
          this.session.ref();
          this.startKeepalivePings();
        }
        this.activeCalls.add(call);
      }
      createCall(metadata, host, method, listener, subchannelCallStatsTracker) {
        const headers = metadata.toHttp2Headers();
        headers[HTTP2_HEADER_AUTHORITY] = host;
        headers[HTTP2_HEADER_USER_AGENT] = this.userAgent;
        headers[HTTP2_HEADER_CONTENT_TYPE] = "application/grpc";
        headers[HTTP2_HEADER_METHOD] = "POST";
        headers[HTTP2_HEADER_PATH] = method;
        headers[HTTP2_HEADER_TE] = "trailers";
        let http2Stream;
        try {
          http2Stream = this.session.request(headers);
        } catch (e2) {
          this.handleDisconnect();
          throw e2;
        }
        this.flowControlTrace("local window size: " + this.session.state.localWindowSize + " remote window size: " + this.session.state.remoteWindowSize);
        this.internalsTrace("session.closed=" + this.session.closed + " session.destroyed=" + this.session.destroyed + " session.socket.destroyed=" + this.session.socket.destroyed);
        let eventTracker;
        let call;
        if (this.channelzEnabled) {
          this.streamTracker.addCallStarted();
          eventTracker = {
            addMessageSent: () => {
              var _a;
              this.messagesSent += 1;
              this.lastMessageSentTimestamp = new Date();
              (_a = subchannelCallStatsTracker.addMessageSent) === null || _a === void 0 ? void 0 : _a.call(subchannelCallStatsTracker);
            },
            addMessageReceived: () => {
              var _a;
              this.messagesReceived += 1;
              this.lastMessageReceivedTimestamp = new Date();
              (_a = subchannelCallStatsTracker.addMessageReceived) === null || _a === void 0 ? void 0 : _a.call(subchannelCallStatsTracker);
            },
            onCallEnd: (status) => {
              var _a;
              (_a = subchannelCallStatsTracker.onCallEnd) === null || _a === void 0 ? void 0 : _a.call(subchannelCallStatsTracker, status);
              this.removeActiveCall(call);
            },
            onStreamEnd: (success) => {
              var _a;
              if (success) {
                this.streamTracker.addCallSucceeded();
              } else {
                this.streamTracker.addCallFailed();
              }
              (_a = subchannelCallStatsTracker.onStreamEnd) === null || _a === void 0 ? void 0 : _a.call(subchannelCallStatsTracker, success);
            }
          };
        } else {
          eventTracker = {
            addMessageSent: () => {
              var _a;
              (_a = subchannelCallStatsTracker.addMessageSent) === null || _a === void 0 ? void 0 : _a.call(subchannelCallStatsTracker);
            },
            addMessageReceived: () => {
              var _a;
              (_a = subchannelCallStatsTracker.addMessageReceived) === null || _a === void 0 ? void 0 : _a.call(subchannelCallStatsTracker);
            },
            onCallEnd: (status) => {
              var _a;
              (_a = subchannelCallStatsTracker.onCallEnd) === null || _a === void 0 ? void 0 : _a.call(subchannelCallStatsTracker, status);
              this.removeActiveCall(call);
            },
            onStreamEnd: (success) => {
              var _a;
              (_a = subchannelCallStatsTracker.onStreamEnd) === null || _a === void 0 ? void 0 : _a.call(subchannelCallStatsTracker, success);
            }
          };
        }
        call = new subchannel_call_1.Http2SubchannelCall(http2Stream, eventTracker, listener, this.subchannelAddressString, (0, call_number_1.getNextCallNumber)());
        this.addActiveCall(call);
        return call;
      }
      getChannelzRef() {
        return this.channelzRef;
      }
      shutdown() {
        this.session.close();
      }
    };
    var Http2SubchannelConnector = class {
      constructor(channelTarget) {
        this.channelTarget = channelTarget;
        this.session = null;
        this.isShutdown = false;
      }
      trace(text) {
      }
      createSession(address, credentials2, options, proxyConnectionResult) {
        if (this.isShutdown) {
          return Promise.reject();
        }
        return new Promise((resolve, reject) => {
          var _a, _b, _c;
          let remoteName;
          if (proxyConnectionResult.realTarget) {
            remoteName = (0, uri_parser_1.uriToString)(proxyConnectionResult.realTarget);
            this.trace("creating HTTP/2 session through proxy to " + (0, uri_parser_1.uriToString)(proxyConnectionResult.realTarget));
          } else {
            remoteName = null;
            this.trace("creating HTTP/2 session to " + (0, subchannel_address_1.subchannelAddressToString)(address));
          }
          const targetAuthority = (0, resolver_1.getDefaultAuthority)((_a = proxyConnectionResult.realTarget) !== null && _a !== void 0 ? _a : this.channelTarget);
          let connectionOptions = credentials2._getConnectionOptions() || {};
          connectionOptions.maxSendHeaderBlockLength = Number.MAX_SAFE_INTEGER;
          if ("grpc-node.max_session_memory" in options) {
            connectionOptions.maxSessionMemory = options["grpc-node.max_session_memory"];
          } else {
            connectionOptions.maxSessionMemory = Number.MAX_SAFE_INTEGER;
          }
          let addressScheme = "http://";
          if ("secureContext" in connectionOptions) {
            addressScheme = "https://";
            if (options["grpc.ssl_target_name_override"]) {
              const sslTargetNameOverride = options["grpc.ssl_target_name_override"];
              connectionOptions.checkServerIdentity = (host, cert) => {
                return (0, tls_1.checkServerIdentity)(sslTargetNameOverride, cert);
              };
              connectionOptions.servername = sslTargetNameOverride;
            } else {
              const authorityHostname = (_c = (_b = (0, uri_parser_1.splitHostPort)(targetAuthority)) === null || _b === void 0 ? void 0 : _b.host) !== null && _c !== void 0 ? _c : "localhost";
              connectionOptions.servername = authorityHostname;
            }
            if (proxyConnectionResult.socket) {
              connectionOptions.createConnection = (authority, option) => {
                return proxyConnectionResult.socket;
              };
            }
          } else {
            connectionOptions.createConnection = (authority, option) => {
              if (proxyConnectionResult.socket) {
                return proxyConnectionResult.socket;
              } else {
                return net.connect(address);
              }
            };
          }
          connectionOptions = Object.assign(Object.assign({}, connectionOptions), address);
          const session = http2.connect(addressScheme + targetAuthority, connectionOptions);
          this.session = session;
          session.unref();
          session.once("connect", () => {
            session.removeAllListeners();
            resolve(new Http2Transport(session, address, options));
            this.session = null;
          });
          session.once("close", () => {
            this.session = null;
            reject();
          });
          session.once("error", (error) => {
            this.trace("connection failed with error " + error.message);
          });
        });
      }
      connect(address, credentials2, options) {
        var _a, _b;
        if (this.isShutdown) {
          return Promise.reject();
        }
        const connectionOptions = credentials2._getConnectionOptions() || {};
        if ("secureContext" in connectionOptions) {
          connectionOptions.ALPNProtocols = ["h2"];
          if (options["grpc.ssl_target_name_override"]) {
            const sslTargetNameOverride = options["grpc.ssl_target_name_override"];
            connectionOptions.checkServerIdentity = (host, cert) => {
              return (0, tls_1.checkServerIdentity)(sslTargetNameOverride, cert);
            };
            connectionOptions.servername = sslTargetNameOverride;
          } else {
            if ("grpc.http_connect_target" in options) {
              const targetPath = (0, resolver_1.getDefaultAuthority)((_a = (0, uri_parser_1.parseUri)(options["grpc.http_connect_target"])) !== null && _a !== void 0 ? _a : {
                path: "localhost"
              });
              const hostPort = (0, uri_parser_1.splitHostPort)(targetPath);
              connectionOptions.servername = (_b = hostPort === null || hostPort === void 0 ? void 0 : hostPort.host) !== null && _b !== void 0 ? _b : targetPath;
            }
          }
        }
        return (0, http_proxy_1.getProxiedConnection)(address, options, connectionOptions).then((result) => this.createSession(address, credentials2, options, result));
      }
      shutdown() {
        var _a;
        this.isShutdown = true;
        (_a = this.session) === null || _a === void 0 ? void 0 : _a.close();
        this.session = null;
      }
    };
    exports2.Http2SubchannelConnector = Http2SubchannelConnector;
  }
});

// node_modules/@grpc/grpc-js/build/src/subchannel-pool.js
var require_subchannel_pool = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/subchannel-pool.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getSubchannelPool = exports2.SubchannelPool = void 0;
    var channel_options_1 = require_channel_options();
    var subchannel_1 = require_subchannel();
    var subchannel_address_1 = require_subchannel_address();
    var uri_parser_1 = require_uri_parser();
    var transport_1 = require_transport();
    var REF_CHECK_INTERVAL = 1e4;
    var SubchannelPool = class {
      /**
       * A pool of subchannels use for making connections. Subchannels with the
       * exact same parameters will be reused.
       */
      constructor() {
        this.pool = /* @__PURE__ */ Object.create(null);
        this.cleanupTimer = null;
      }
      /**
       * Unrefs all unused subchannels and cancels the cleanup task if all
       * subchannels have been unrefed.
       */
      unrefUnusedSubchannels() {
        let allSubchannelsUnrefed = true;
        for (const channelTarget in this.pool) {
          const subchannelObjArray = this.pool[channelTarget];
          const refedSubchannels = subchannelObjArray.filter((value) => !value.subchannel.unrefIfOneRef());
          if (refedSubchannels.length > 0) {
            allSubchannelsUnrefed = false;
          }
          this.pool[channelTarget] = refedSubchannels;
        }
        if (allSubchannelsUnrefed && this.cleanupTimer !== null) {
          clearInterval(this.cleanupTimer);
          this.cleanupTimer = null;
        }
      }
      /**
       * Ensures that the cleanup task is spawned.
       */
      ensureCleanupTask() {
        var _a, _b;
        if (this.cleanupTimer === null) {
          this.cleanupTimer = setInterval(() => {
            this.unrefUnusedSubchannels();
          }, REF_CHECK_INTERVAL);
          (_b = (_a = this.cleanupTimer).unref) === null || _b === void 0 ? void 0 : _b.call(_a);
        }
      }
      /**
       * Get a subchannel if one already exists with exactly matching parameters.
       * Otherwise, create and save a subchannel with those parameters.
       * @param channelTarget
       * @param subchannelTarget
       * @param channelArguments
       * @param channelCredentials
       */
      getOrCreateSubchannel(channelTargetUri, subchannelTarget, channelArguments, channelCredentials) {
        this.ensureCleanupTask();
        const channelTarget = (0, uri_parser_1.uriToString)(channelTargetUri);
        if (channelTarget in this.pool) {
          const subchannelObjArray = this.pool[channelTarget];
          for (const subchannelObj of subchannelObjArray) {
            if ((0, subchannel_address_1.subchannelAddressEqual)(subchannelTarget, subchannelObj.subchannelAddress) && (0, channel_options_1.channelOptionsEqual)(channelArguments, subchannelObj.channelArguments) && channelCredentials._equals(subchannelObj.channelCredentials)) {
              return subchannelObj.subchannel;
            }
          }
        }
        const subchannel = new subchannel_1.Subchannel(channelTargetUri, subchannelTarget, channelArguments, channelCredentials, new transport_1.Http2SubchannelConnector(channelTargetUri));
        if (!(channelTarget in this.pool)) {
          this.pool[channelTarget] = [];
        }
        this.pool[channelTarget].push({
          subchannelAddress: subchannelTarget,
          channelArguments,
          channelCredentials,
          subchannel
        });
        subchannel.ref();
        return subchannel;
      }
    };
    exports2.SubchannelPool = SubchannelPool;
    var globalSubchannelPool = new SubchannelPool();
    function getSubchannelPool(global2) {
      if (global2) {
        return globalSubchannelPool;
      } else {
        return new SubchannelPool();
      }
    }
    exports2.getSubchannelPool = getSubchannelPool;
  }
});

// node_modules/@grpc/grpc-js/build/src/filter-stack.js
var require_filter_stack = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/filter-stack.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.FilterStackFactory = exports2.FilterStack = void 0;
    var FilterStack = class {
      constructor(filters) {
        this.filters = filters;
      }
      sendMetadata(metadata) {
        let result = metadata;
        for (let i = 0; i < this.filters.length; i++) {
          result = this.filters[i].sendMetadata(result);
        }
        return result;
      }
      receiveMetadata(metadata) {
        let result = metadata;
        for (let i = this.filters.length - 1; i >= 0; i--) {
          result = this.filters[i].receiveMetadata(result);
        }
        return result;
      }
      sendMessage(message) {
        let result = message;
        for (let i = 0; i < this.filters.length; i++) {
          result = this.filters[i].sendMessage(result);
        }
        return result;
      }
      receiveMessage(message) {
        let result = message;
        for (let i = this.filters.length - 1; i >= 0; i--) {
          result = this.filters[i].receiveMessage(result);
        }
        return result;
      }
      receiveTrailers(status) {
        let result = status;
        for (let i = this.filters.length - 1; i >= 0; i--) {
          result = this.filters[i].receiveTrailers(result);
        }
        return result;
      }
      push(filters) {
        this.filters.unshift(...filters);
      }
      getFilters() {
        return this.filters;
      }
    };
    exports2.FilterStack = FilterStack;
    var FilterStackFactory = class {
      constructor(factories) {
        this.factories = factories;
      }
      push(filterFactories) {
        this.factories.unshift(...filterFactories);
      }
      clone() {
        return new FilterStackFactory([...this.factories]);
      }
      createFilter() {
        return new FilterStack(this.factories.map((factory) => factory.createFilter()));
      }
    };
    exports2.FilterStackFactory = FilterStackFactory;
  }
});

// node_modules/@grpc/grpc-js/build/src/compression-algorithms.js
var require_compression_algorithms = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/compression-algorithms.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CompressionAlgorithms = void 0;
    var CompressionAlgorithms;
    (function(CompressionAlgorithms2) {
      CompressionAlgorithms2[CompressionAlgorithms2["identity"] = 0] = "identity";
      CompressionAlgorithms2[CompressionAlgorithms2["deflate"] = 1] = "deflate";
      CompressionAlgorithms2[CompressionAlgorithms2["gzip"] = 2] = "gzip";
    })(CompressionAlgorithms = exports2.CompressionAlgorithms || (exports2.CompressionAlgorithms = {}));
  }
});

// node_modules/@grpc/grpc-js/build/src/filter.js
var require_filter = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/filter.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.BaseFilter = void 0;
    var BaseFilter = class {
      async sendMetadata(metadata) {
        return metadata;
      }
      receiveMetadata(metadata) {
        return metadata;
      }
      async sendMessage(message) {
        return message;
      }
      async receiveMessage(message) {
        return message;
      }
      receiveTrailers(status) {
        return status;
      }
    };
    exports2.BaseFilter = BaseFilter;
  }
});

// node_modules/@grpc/grpc-js/build/src/compression-filter.js
var require_compression_filter = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/compression-filter.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CompressionFilterFactory = exports2.CompressionFilter = void 0;
    var zlib = require("zlib");
    var compression_algorithms_1 = require_compression_algorithms();
    var constants_1 = require_constants();
    var filter_1 = require_filter();
    var logging = require_logging();
    var isCompressionAlgorithmKey = (key) => {
      return typeof key === "number" && typeof compression_algorithms_1.CompressionAlgorithms[key] === "string";
    };
    var CompressionHandler = class {
      /**
       * @param message Raw uncompressed message bytes
       * @param compress Indicates whether the message should be compressed
       * @return Framed message, compressed if applicable
       */
      async writeMessage(message, compress) {
        let messageBuffer = message;
        if (compress) {
          messageBuffer = await this.compressMessage(messageBuffer);
        }
        const output = Buffer.allocUnsafe(messageBuffer.length + 5);
        output.writeUInt8(compress ? 1 : 0, 0);
        output.writeUInt32BE(messageBuffer.length, 1);
        messageBuffer.copy(output, 5);
        return output;
      }
      /**
       * @param data Framed message, possibly compressed
       * @return Uncompressed message
       */
      async readMessage(data) {
        const compressed = data.readUInt8(0) === 1;
        let messageBuffer = data.slice(5);
        if (compressed) {
          messageBuffer = await this.decompressMessage(messageBuffer);
        }
        return messageBuffer;
      }
    };
    var IdentityHandler = class extends CompressionHandler {
      async compressMessage(message) {
        return message;
      }
      async writeMessage(message, compress) {
        const output = Buffer.allocUnsafe(message.length + 5);
        output.writeUInt8(0, 0);
        output.writeUInt32BE(message.length, 1);
        message.copy(output, 5);
        return output;
      }
      decompressMessage(message) {
        return Promise.reject(new Error('Received compressed message but "grpc-encoding" header was identity'));
      }
    };
    var DeflateHandler = class extends CompressionHandler {
      compressMessage(message) {
        return new Promise((resolve, reject) => {
          zlib.deflate(message, (err, output) => {
            if (err) {
              reject(err);
            } else {
              resolve(output);
            }
          });
        });
      }
      decompressMessage(message) {
        return new Promise((resolve, reject) => {
          zlib.inflate(message, (err, output) => {
            if (err) {
              reject(err);
            } else {
              resolve(output);
            }
          });
        });
      }
    };
    var GzipHandler = class extends CompressionHandler {
      compressMessage(message) {
        return new Promise((resolve, reject) => {
          zlib.gzip(message, (err, output) => {
            if (err) {
              reject(err);
            } else {
              resolve(output);
            }
          });
        });
      }
      decompressMessage(message) {
        return new Promise((resolve, reject) => {
          zlib.unzip(message, (err, output) => {
            if (err) {
              reject(err);
            } else {
              resolve(output);
            }
          });
        });
      }
    };
    var UnknownHandler = class extends CompressionHandler {
      constructor(compressionName) {
        super();
        this.compressionName = compressionName;
      }
      compressMessage(message) {
        return Promise.reject(new Error(`Received message compressed with unsupported compression method ${this.compressionName}`));
      }
      decompressMessage(message) {
        return Promise.reject(new Error(`Compression method not supported: ${this.compressionName}`));
      }
    };
    function getCompressionHandler(compressionName) {
      switch (compressionName) {
        case "identity":
          return new IdentityHandler();
        case "deflate":
          return new DeflateHandler();
        case "gzip":
          return new GzipHandler();
        default:
          return new UnknownHandler(compressionName);
      }
    }
    var CompressionFilter = class extends filter_1.BaseFilter {
      constructor(channelOptions, sharedFilterConfig) {
        var _a;
        super();
        this.sharedFilterConfig = sharedFilterConfig;
        this.sendCompression = new IdentityHandler();
        this.receiveCompression = new IdentityHandler();
        this.currentCompressionAlgorithm = "identity";
        const compressionAlgorithmKey = channelOptions["grpc.default_compression_algorithm"];
        if (compressionAlgorithmKey !== void 0) {
          if (isCompressionAlgorithmKey(compressionAlgorithmKey)) {
            const clientSelectedEncoding = compression_algorithms_1.CompressionAlgorithms[compressionAlgorithmKey];
            const serverSupportedEncodings = (_a = sharedFilterConfig.serverSupportedEncodingHeader) === null || _a === void 0 ? void 0 : _a.split(",");
            if (!serverSupportedEncodings || serverSupportedEncodings.includes(clientSelectedEncoding)) {
              this.currentCompressionAlgorithm = clientSelectedEncoding;
              this.sendCompression = getCompressionHandler(this.currentCompressionAlgorithm);
            }
          } else {
            logging.log(constants_1.LogVerbosity.ERROR, `Invalid value provided for grpc.default_compression_algorithm option: ${compressionAlgorithmKey}`);
          }
        }
      }
      async sendMetadata(metadata) {
        const headers = await metadata;
        headers.set("grpc-accept-encoding", "identity,deflate,gzip");
        headers.set("accept-encoding", "identity");
        if (this.currentCompressionAlgorithm === "identity") {
          headers.remove("grpc-encoding");
        } else {
          headers.set("grpc-encoding", this.currentCompressionAlgorithm);
        }
        return headers;
      }
      receiveMetadata(metadata) {
        const receiveEncoding = metadata.get("grpc-encoding");
        if (receiveEncoding.length > 0) {
          const encoding = receiveEncoding[0];
          if (typeof encoding === "string") {
            this.receiveCompression = getCompressionHandler(encoding);
          }
        }
        metadata.remove("grpc-encoding");
        const serverSupportedEncodingsHeader = metadata.get("grpc-accept-encoding")[0];
        if (serverSupportedEncodingsHeader) {
          this.sharedFilterConfig.serverSupportedEncodingHeader = serverSupportedEncodingsHeader;
          const serverSupportedEncodings = serverSupportedEncodingsHeader.split(",");
          if (!serverSupportedEncodings.includes(this.currentCompressionAlgorithm)) {
            this.sendCompression = new IdentityHandler();
            this.currentCompressionAlgorithm = "identity";
          }
        }
        metadata.remove("grpc-accept-encoding");
        return metadata;
      }
      async sendMessage(message) {
        var _a;
        const resolvedMessage = await message;
        let compress;
        if (this.sendCompression instanceof IdentityHandler) {
          compress = false;
        } else {
          compress = (((_a = resolvedMessage.flags) !== null && _a !== void 0 ? _a : 0) & 2) === 0;
        }
        return {
          message: await this.sendCompression.writeMessage(resolvedMessage.message, compress),
          flags: resolvedMessage.flags
        };
      }
      async receiveMessage(message) {
        return this.receiveCompression.readMessage(await message);
      }
    };
    exports2.CompressionFilter = CompressionFilter;
    var CompressionFilterFactory = class {
      constructor(channel, options) {
        this.channel = channel;
        this.options = options;
        this.sharedFilterConfig = {};
      }
      createFilter() {
        return new CompressionFilter(this.options, this.sharedFilterConfig);
      }
    };
    exports2.CompressionFilterFactory = CompressionFilterFactory;
  }
});

// node_modules/@grpc/grpc-js/build/src/max-message-size-filter.js
var require_max_message_size_filter = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/max-message-size-filter.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MaxMessageSizeFilterFactory = exports2.MaxMessageSizeFilter = void 0;
    var filter_1 = require_filter();
    var constants_1 = require_constants();
    var metadata_1 = require_metadata();
    var MaxMessageSizeFilter = class extends filter_1.BaseFilter {
      constructor(options) {
        super();
        this.options = options;
        this.maxSendMessageSize = constants_1.DEFAULT_MAX_SEND_MESSAGE_LENGTH;
        this.maxReceiveMessageSize = constants_1.DEFAULT_MAX_RECEIVE_MESSAGE_LENGTH;
        if ("grpc.max_send_message_length" in options) {
          this.maxSendMessageSize = options["grpc.max_send_message_length"];
        }
        if ("grpc.max_receive_message_length" in options) {
          this.maxReceiveMessageSize = options["grpc.max_receive_message_length"];
        }
      }
      async sendMessage(message) {
        if (this.maxSendMessageSize === -1) {
          return message;
        } else {
          const concreteMessage = await message;
          if (concreteMessage.message.length > this.maxSendMessageSize) {
            throw {
              code: constants_1.Status.RESOURCE_EXHAUSTED,
              details: `Sent message larger than max (${concreteMessage.message.length} vs. ${this.maxSendMessageSize})`,
              metadata: new metadata_1.Metadata()
            };
          } else {
            return concreteMessage;
          }
        }
      }
      async receiveMessage(message) {
        if (this.maxReceiveMessageSize === -1) {
          return message;
        } else {
          const concreteMessage = await message;
          if (concreteMessage.length > this.maxReceiveMessageSize) {
            throw {
              code: constants_1.Status.RESOURCE_EXHAUSTED,
              details: `Received message larger than max (${concreteMessage.length} vs. ${this.maxReceiveMessageSize})`,
              metadata: new metadata_1.Metadata()
            };
          } else {
            return concreteMessage;
          }
        }
      }
    };
    exports2.MaxMessageSizeFilter = MaxMessageSizeFilter;
    var MaxMessageSizeFilterFactory = class {
      constructor(options) {
        this.options = options;
      }
      createFilter() {
        return new MaxMessageSizeFilter(this.options);
      }
    };
    exports2.MaxMessageSizeFilterFactory = MaxMessageSizeFilterFactory;
  }
});

// node_modules/@grpc/grpc-js/build/src/deadline.js
var require_deadline = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/deadline.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getRelativeTimeout = exports2.getDeadlineTimeoutString = exports2.minDeadline = void 0;
    function minDeadline(...deadlineList) {
      let minValue = Infinity;
      for (const deadline of deadlineList) {
        const deadlineMsecs = deadline instanceof Date ? deadline.getTime() : deadline;
        if (deadlineMsecs < minValue) {
          minValue = deadlineMsecs;
        }
      }
      return minValue;
    }
    exports2.minDeadline = minDeadline;
    var units = [
      ["m", 1],
      ["S", 1e3],
      ["M", 60 * 1e3],
      ["H", 60 * 60 * 1e3]
    ];
    function getDeadlineTimeoutString(deadline) {
      const now = new Date().getTime();
      if (deadline instanceof Date) {
        deadline = deadline.getTime();
      }
      const timeoutMs = Math.max(deadline - now, 0);
      for (const [unit, factor] of units) {
        const amount = timeoutMs / factor;
        if (amount < 1e8) {
          return String(Math.ceil(amount)) + unit;
        }
      }
      throw new Error("Deadline is too far in the future");
    }
    exports2.getDeadlineTimeoutString = getDeadlineTimeoutString;
    function getRelativeTimeout(deadline) {
      const deadlineMs = deadline instanceof Date ? deadline.getTime() : deadline;
      const now = new Date().getTime();
      return deadlineMs - now;
    }
    exports2.getRelativeTimeout = getRelativeTimeout;
  }
});

// node_modules/@grpc/grpc-js/build/src/control-plane-status.js
var require_control_plane_status = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/control-plane-status.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.restrictControlPlaneStatusCode = void 0;
    var constants_1 = require_constants();
    var INAPPROPRIATE_CONTROL_PLANE_CODES = [
      constants_1.Status.OK,
      constants_1.Status.INVALID_ARGUMENT,
      constants_1.Status.NOT_FOUND,
      constants_1.Status.ALREADY_EXISTS,
      constants_1.Status.FAILED_PRECONDITION,
      constants_1.Status.ABORTED,
      constants_1.Status.OUT_OF_RANGE,
      constants_1.Status.DATA_LOSS
    ];
    function restrictControlPlaneStatusCode(code, details) {
      if (INAPPROPRIATE_CONTROL_PLANE_CODES.includes(code)) {
        return {
          code: constants_1.Status.INTERNAL,
          details: `Invalid status from control plane: ${code} ${constants_1.Status[code]} ${details}`
        };
      } else {
        return { code, details };
      }
    }
    exports2.restrictControlPlaneStatusCode = restrictControlPlaneStatusCode;
  }
});

// node_modules/@grpc/grpc-js/build/src/load-balancing-call.js
var require_load_balancing_call = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/load-balancing-call.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.LoadBalancingCall = void 0;
    var connectivity_state_1 = require_connectivity_state();
    var constants_1 = require_constants();
    var deadline_1 = require_deadline();
    var metadata_1 = require_metadata();
    var picker_1 = require_picker();
    var uri_parser_1 = require_uri_parser();
    var logging = require_logging();
    var control_plane_status_1 = require_control_plane_status();
    var http2 = require("http2");
    var TRACER_NAME = "load_balancing_call";
    var LoadBalancingCall = class {
      constructor(channel, callConfig, methodName, host, credentials2, deadline, callNumber) {
        var _a, _b;
        this.channel = channel;
        this.callConfig = callConfig;
        this.methodName = methodName;
        this.host = host;
        this.credentials = credentials2;
        this.deadline = deadline;
        this.callNumber = callNumber;
        this.child = null;
        this.readPending = false;
        this.pendingMessage = null;
        this.pendingHalfClose = false;
        this.pendingChildStatus = null;
        this.ended = false;
        this.metadata = null;
        this.listener = null;
        this.onCallEnded = null;
        const splitPath = this.methodName.split("/");
        let serviceName = "";
        if (splitPath.length >= 2) {
          serviceName = splitPath[1];
        }
        const hostname = (_b = (_a = (0, uri_parser_1.splitHostPort)(this.host)) === null || _a === void 0 ? void 0 : _a.host) !== null && _b !== void 0 ? _b : "localhost";
        this.serviceUrl = `https://${hostname}/${serviceName}`;
      }
      trace(text) {
        logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, "[" + this.callNumber + "] " + text);
      }
      outputStatus(status, progress) {
        var _a, _b;
        if (!this.ended) {
          this.ended = true;
          this.trace("ended with status: code=" + status.code + ' details="' + status.details + '"');
          const finalStatus = Object.assign(Object.assign({}, status), { progress });
          (_a = this.listener) === null || _a === void 0 ? void 0 : _a.onReceiveStatus(finalStatus);
          (_b = this.onCallEnded) === null || _b === void 0 ? void 0 : _b.call(this, finalStatus.code);
        }
      }
      doPick() {
        var _a, _b;
        if (this.ended) {
          return;
        }
        if (!this.metadata) {
          throw new Error("doPick called before start");
        }
        const pickResult = this.channel.doPick(this.metadata, this.callConfig.pickInformation);
        const subchannelString = pickResult.subchannel ? "(" + pickResult.subchannel.getChannelzRef().id + ") " + pickResult.subchannel.getAddress() : "" + pickResult.subchannel;
        this.trace("Pick result: " + picker_1.PickResultType[pickResult.pickResultType] + " subchannel: " + subchannelString + " status: " + ((_a = pickResult.status) === null || _a === void 0 ? void 0 : _a.code) + " " + ((_b = pickResult.status) === null || _b === void 0 ? void 0 : _b.details));
        switch (pickResult.pickResultType) {
          case picker_1.PickResultType.COMPLETE:
            this.credentials.generateMetadata({ service_url: this.serviceUrl }).then((credsMetadata) => {
              var _a2, _b2, _c;
              const finalMetadata = this.metadata.clone();
              finalMetadata.merge(credsMetadata);
              if (finalMetadata.get("authorization").length > 1) {
                this.outputStatus({
                  code: constants_1.Status.INTERNAL,
                  details: '"authorization" metadata cannot have multiple values',
                  metadata: new metadata_1.Metadata()
                }, "PROCESSED");
              }
              if (pickResult.subchannel.getConnectivityState() !== connectivity_state_1.ConnectivityState.READY) {
                this.trace("Picked subchannel " + subchannelString + " has state " + connectivity_state_1.ConnectivityState[pickResult.subchannel.getConnectivityState()] + " after getting credentials metadata. Retrying pick");
                this.doPick();
                return;
              }
              if (this.deadline !== Infinity) {
                finalMetadata.set("grpc-timeout", (0, deadline_1.getDeadlineTimeoutString)(this.deadline));
              }
              try {
                this.child = pickResult.subchannel.getRealSubchannel().createCall(finalMetadata, this.host, this.methodName, {
                  onReceiveMetadata: (metadata) => {
                    this.trace("Received metadata");
                    this.listener.onReceiveMetadata(metadata);
                  },
                  onReceiveMessage: (message) => {
                    this.trace("Received message");
                    this.listener.onReceiveMessage(message);
                  },
                  onReceiveStatus: (status) => {
                    this.trace("Received status");
                    if (status.rstCode === http2.constants.NGHTTP2_REFUSED_STREAM) {
                      this.outputStatus(status, "REFUSED");
                    } else {
                      this.outputStatus(status, "PROCESSED");
                    }
                  }
                });
              } catch (error) {
                this.trace("Failed to start call on picked subchannel " + subchannelString + " with error " + error.message);
                this.outputStatus({
                  code: constants_1.Status.INTERNAL,
                  details: "Failed to start HTTP/2 stream with error " + error.message,
                  metadata: new metadata_1.Metadata()
                }, "NOT_STARTED");
                return;
              }
              (_b2 = (_a2 = this.callConfig).onCommitted) === null || _b2 === void 0 ? void 0 : _b2.call(_a2);
              (_c = pickResult.onCallStarted) === null || _c === void 0 ? void 0 : _c.call(pickResult);
              this.onCallEnded = pickResult.onCallEnded;
              this.trace("Created child call [" + this.child.getCallNumber() + "]");
              if (this.readPending) {
                this.child.startRead();
              }
              if (this.pendingMessage) {
                this.child.sendMessageWithContext(this.pendingMessage.context, this.pendingMessage.message);
              }
              if (this.pendingHalfClose) {
                this.child.halfClose();
              }
            }, (error) => {
              const { code: code2, details: details2 } = (0, control_plane_status_1.restrictControlPlaneStatusCode)(typeof error.code === "number" ? error.code : constants_1.Status.UNKNOWN, `Getting metadata from plugin failed with error: ${error.message}`);
              this.outputStatus({
                code: code2,
                details: details2,
                metadata: new metadata_1.Metadata()
              }, "PROCESSED");
            });
            break;
          case picker_1.PickResultType.DROP:
            const { code, details } = (0, control_plane_status_1.restrictControlPlaneStatusCode)(pickResult.status.code, pickResult.status.details);
            this.outputStatus({ code, details, metadata: pickResult.status.metadata }, "DROP");
            break;
          case picker_1.PickResultType.TRANSIENT_FAILURE:
            if (this.metadata.getOptions().waitForReady) {
              this.channel.queueCallForPick(this);
            } else {
              const { code: code2, details: details2 } = (0, control_plane_status_1.restrictControlPlaneStatusCode)(pickResult.status.code, pickResult.status.details);
              this.outputStatus({ code: code2, details: details2, metadata: pickResult.status.metadata }, "PROCESSED");
            }
            break;
          case picker_1.PickResultType.QUEUE:
            this.channel.queueCallForPick(this);
        }
      }
      cancelWithStatus(status, details) {
        var _a;
        this.trace("cancelWithStatus code: " + status + ' details: "' + details + '"');
        (_a = this.child) === null || _a === void 0 ? void 0 : _a.cancelWithStatus(status, details);
        this.outputStatus({ code: status, details, metadata: new metadata_1.Metadata() }, "PROCESSED");
      }
      getPeer() {
        var _a, _b;
        return (_b = (_a = this.child) === null || _a === void 0 ? void 0 : _a.getPeer()) !== null && _b !== void 0 ? _b : this.channel.getTarget();
      }
      start(metadata, listener) {
        this.trace("start called");
        this.listener = listener;
        this.metadata = metadata;
        this.doPick();
      }
      sendMessageWithContext(context, message) {
        this.trace("write() called with message of length " + message.length);
        if (this.child) {
          this.child.sendMessageWithContext(context, message);
        } else {
          this.pendingMessage = { context, message };
        }
      }
      startRead() {
        this.trace("startRead called");
        if (this.child) {
          this.child.startRead();
        } else {
          this.readPending = true;
        }
      }
      halfClose() {
        this.trace("halfClose called");
        if (this.child) {
          this.child.halfClose();
        } else {
          this.pendingHalfClose = true;
        }
      }
      setCredentials(credentials2) {
        throw new Error("Method not implemented.");
      }
      getCallNumber() {
        return this.callNumber;
      }
    };
    exports2.LoadBalancingCall = LoadBalancingCall;
  }
});

// node_modules/@grpc/grpc-js/build/src/resolving-call.js
var require_resolving_call = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/resolving-call.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ResolvingCall = void 0;
    var constants_1 = require_constants();
    var deadline_1 = require_deadline();
    var metadata_1 = require_metadata();
    var logging = require_logging();
    var control_plane_status_1 = require_control_plane_status();
    var TRACER_NAME = "resolving_call";
    var ResolvingCall = class {
      constructor(channel, method, options, filterStackFactory, credentials2, callNumber) {
        this.channel = channel;
        this.method = method;
        this.filterStackFactory = filterStackFactory;
        this.credentials = credentials2;
        this.callNumber = callNumber;
        this.child = null;
        this.readPending = false;
        this.pendingMessage = null;
        this.pendingHalfClose = false;
        this.ended = false;
        this.readFilterPending = false;
        this.writeFilterPending = false;
        this.pendingChildStatus = null;
        this.metadata = null;
        this.listener = null;
        this.statusWatchers = [];
        this.deadlineTimer = setTimeout(() => {
        }, 0);
        this.filterStack = null;
        this.deadline = options.deadline;
        this.host = options.host;
        if (options.parentCall) {
          if (options.flags & constants_1.Propagate.CANCELLATION) {
            options.parentCall.on("cancelled", () => {
              this.cancelWithStatus(constants_1.Status.CANCELLED, "Cancelled by parent call");
            });
          }
          if (options.flags & constants_1.Propagate.DEADLINE) {
            this.trace("Propagating deadline from parent: " + options.parentCall.getDeadline());
            this.deadline = (0, deadline_1.minDeadline)(this.deadline, options.parentCall.getDeadline());
          }
        }
        this.trace("Created");
        this.runDeadlineTimer();
      }
      trace(text) {
        logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, "[" + this.callNumber + "] " + text);
      }
      runDeadlineTimer() {
        clearTimeout(this.deadlineTimer);
        this.trace("Deadline: " + this.deadline);
        if (this.deadline !== Infinity) {
          const timeout = (0, deadline_1.getRelativeTimeout)(this.deadline);
          this.trace("Deadline will be reached in " + timeout + "ms");
          const handleDeadline = () => {
            this.cancelWithStatus(constants_1.Status.DEADLINE_EXCEEDED, "Deadline exceeded");
          };
          if (timeout <= 0) {
            process.nextTick(handleDeadline);
          } else {
            this.deadlineTimer = setTimeout(handleDeadline, timeout);
          }
        }
      }
      outputStatus(status) {
        if (!this.ended) {
          this.ended = true;
          if (!this.filterStack) {
            this.filterStack = this.filterStackFactory.createFilter();
          }
          const filteredStatus = this.filterStack.receiveTrailers(status);
          this.trace("ended with status: code=" + filteredStatus.code + ' details="' + filteredStatus.details + '"');
          this.statusWatchers.forEach((watcher) => watcher(filteredStatus));
          process.nextTick(() => {
            var _a;
            (_a = this.listener) === null || _a === void 0 ? void 0 : _a.onReceiveStatus(filteredStatus);
          });
        }
      }
      sendMessageOnChild(context, message) {
        if (!this.child) {
          throw new Error("sendMessageonChild called with child not populated");
        }
        const child = this.child;
        this.writeFilterPending = true;
        this.filterStack.sendMessage(Promise.resolve({ message, flags: context.flags })).then((filteredMessage) => {
          this.writeFilterPending = false;
          child.sendMessageWithContext(context, filteredMessage.message);
          if (this.pendingHalfClose) {
            child.halfClose();
          }
        }, (status) => {
          this.cancelWithStatus(status.code, status.details);
        });
      }
      getConfig() {
        if (this.ended) {
          return;
        }
        if (!this.metadata || !this.listener) {
          throw new Error("getConfig called before start");
        }
        const configResult = this.channel.getConfig(this.method, this.metadata);
        if (configResult.type === "NONE") {
          this.channel.queueCallForConfig(this);
          return;
        } else if (configResult.type === "ERROR") {
          if (this.metadata.getOptions().waitForReady) {
            this.channel.queueCallForConfig(this);
          } else {
            this.outputStatus(configResult.error);
          }
          return;
        }
        const config4 = configResult.config;
        if (config4.status !== constants_1.Status.OK) {
          const { code, details } = (0, control_plane_status_1.restrictControlPlaneStatusCode)(config4.status, "Failed to route call to method " + this.method);
          this.outputStatus({
            code,
            details,
            metadata: new metadata_1.Metadata()
          });
          return;
        }
        if (config4.methodConfig.timeout) {
          const configDeadline = new Date();
          configDeadline.setSeconds(configDeadline.getSeconds() + config4.methodConfig.timeout.seconds);
          configDeadline.setMilliseconds(configDeadline.getMilliseconds() + config4.methodConfig.timeout.nanos / 1e6);
          this.deadline = (0, deadline_1.minDeadline)(this.deadline, configDeadline);
          this.runDeadlineTimer();
        }
        this.filterStackFactory.push(config4.dynamicFilterFactories);
        this.filterStack = this.filterStackFactory.createFilter();
        this.filterStack.sendMetadata(Promise.resolve(this.metadata)).then((filteredMetadata) => {
          this.child = this.channel.createInnerCall(config4, this.method, this.host, this.credentials, this.deadline);
          this.child.start(filteredMetadata, {
            onReceiveMetadata: (metadata) => {
              this.listener.onReceiveMetadata(this.filterStack.receiveMetadata(metadata));
            },
            onReceiveMessage: (message) => {
              this.readFilterPending = true;
              this.filterStack.receiveMessage(message).then((filteredMesssage) => {
                this.readFilterPending = false;
                this.listener.onReceiveMessage(filteredMesssage);
                if (this.pendingChildStatus) {
                  this.outputStatus(this.pendingChildStatus);
                }
              }, (status) => {
                this.cancelWithStatus(status.code, status.details);
              });
            },
            onReceiveStatus: (status) => {
              if (this.readFilterPending) {
                this.pendingChildStatus = status;
              } else {
                this.outputStatus(status);
              }
            }
          });
          if (this.readPending) {
            this.child.startRead();
          }
          if (this.pendingMessage) {
            this.sendMessageOnChild(this.pendingMessage.context, this.pendingMessage.message);
          } else if (this.pendingHalfClose) {
            this.child.halfClose();
          }
        }, (status) => {
          this.outputStatus(status);
        });
      }
      reportResolverError(status) {
        var _a;
        if ((_a = this.metadata) === null || _a === void 0 ? void 0 : _a.getOptions().waitForReady) {
          this.channel.queueCallForConfig(this);
        } else {
          this.outputStatus(status);
        }
      }
      cancelWithStatus(status, details) {
        var _a;
        this.trace("cancelWithStatus code: " + status + ' details: "' + details + '"');
        (_a = this.child) === null || _a === void 0 ? void 0 : _a.cancelWithStatus(status, details);
        this.outputStatus({ code: status, details, metadata: new metadata_1.Metadata() });
      }
      getPeer() {
        var _a, _b;
        return (_b = (_a = this.child) === null || _a === void 0 ? void 0 : _a.getPeer()) !== null && _b !== void 0 ? _b : this.channel.getTarget();
      }
      start(metadata, listener) {
        this.trace("start called");
        this.metadata = metadata.clone();
        this.listener = listener;
        this.getConfig();
      }
      sendMessageWithContext(context, message) {
        this.trace("write() called with message of length " + message.length);
        if (this.child) {
          this.sendMessageOnChild(context, message);
        } else {
          this.pendingMessage = { context, message };
        }
      }
      startRead() {
        this.trace("startRead called");
        if (this.child) {
          this.child.startRead();
        } else {
          this.readPending = true;
        }
      }
      halfClose() {
        this.trace("halfClose called");
        if (this.child && !this.writeFilterPending) {
          this.child.halfClose();
        } else {
          this.pendingHalfClose = true;
        }
      }
      setCredentials(credentials2) {
        this.credentials = this.credentials.compose(credentials2);
      }
      addStatusWatcher(watcher) {
        this.statusWatchers.push(watcher);
      }
      getCallNumber() {
        return this.callNumber;
      }
    };
    exports2.ResolvingCall = ResolvingCall;
  }
});

// node_modules/@grpc/grpc-js/build/src/retrying-call.js
var require_retrying_call = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/retrying-call.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.RetryingCall = exports2.MessageBufferTracker = exports2.RetryThrottler = void 0;
    var constants_1 = require_constants();
    var metadata_1 = require_metadata();
    var logging = require_logging();
    var TRACER_NAME = "retrying_call";
    var RetryThrottler = class {
      constructor(maxTokens, tokenRatio, previousRetryThrottler) {
        this.maxTokens = maxTokens;
        this.tokenRatio = tokenRatio;
        if (previousRetryThrottler) {
          this.tokens = previousRetryThrottler.tokens * (maxTokens / previousRetryThrottler.maxTokens);
        } else {
          this.tokens = maxTokens;
        }
      }
      addCallSucceeded() {
        this.tokens = Math.max(this.tokens + this.tokenRatio, this.maxTokens);
      }
      addCallFailed() {
        this.tokens = Math.min(this.tokens - 1, 0);
      }
      canRetryCall() {
        return this.tokens > this.maxTokens / 2;
      }
    };
    exports2.RetryThrottler = RetryThrottler;
    var MessageBufferTracker = class {
      constructor(totalLimit, limitPerCall) {
        this.totalLimit = totalLimit;
        this.limitPerCall = limitPerCall;
        this.totalAllocated = 0;
        this.allocatedPerCall = /* @__PURE__ */ new Map();
      }
      allocate(size, callId) {
        var _a;
        const currentPerCall = (_a = this.allocatedPerCall.get(callId)) !== null && _a !== void 0 ? _a : 0;
        if (this.limitPerCall - currentPerCall < size || this.totalLimit - this.totalAllocated < size) {
          return false;
        }
        this.allocatedPerCall.set(callId, currentPerCall + size);
        this.totalAllocated += size;
        return true;
      }
      free(size, callId) {
        var _a;
        if (this.totalAllocated < size) {
          throw new Error(`Invalid buffer allocation state: call ${callId} freed ${size} > total allocated ${this.totalAllocated}`);
        }
        this.totalAllocated -= size;
        const currentPerCall = (_a = this.allocatedPerCall.get(callId)) !== null && _a !== void 0 ? _a : 0;
        if (currentPerCall < size) {
          throw new Error(`Invalid buffer allocation state: call ${callId} freed ${size} > allocated for call ${currentPerCall}`);
        }
        this.allocatedPerCall.set(callId, currentPerCall - size);
      }
      freeAll(callId) {
        var _a;
        const currentPerCall = (_a = this.allocatedPerCall.get(callId)) !== null && _a !== void 0 ? _a : 0;
        if (this.totalAllocated < currentPerCall) {
          throw new Error(`Invalid buffer allocation state: call ${callId} allocated ${currentPerCall} > total allocated ${this.totalAllocated}`);
        }
        this.totalAllocated -= currentPerCall;
        this.allocatedPerCall.delete(callId);
      }
    };
    exports2.MessageBufferTracker = MessageBufferTracker;
    var PREVIONS_RPC_ATTEMPTS_METADATA_KEY = "grpc-previous-rpc-attempts";
    var RetryingCall = class {
      constructor(channel, callConfig, methodName, host, credentials2, deadline, callNumber, bufferTracker, retryThrottler) {
        this.channel = channel;
        this.callConfig = callConfig;
        this.methodName = methodName;
        this.host = host;
        this.credentials = credentials2;
        this.deadline = deadline;
        this.callNumber = callNumber;
        this.bufferTracker = bufferTracker;
        this.retryThrottler = retryThrottler;
        this.listener = null;
        this.initialMetadata = null;
        this.underlyingCalls = [];
        this.writeBuffer = [];
        this.readStarted = false;
        this.transparentRetryUsed = false;
        this.attempts = 0;
        this.hedgingTimer = null;
        this.committedCallIndex = null;
        this.initialRetryBackoffSec = 0;
        this.nextRetryBackoffSec = 0;
        if (callConfig.methodConfig.retryPolicy) {
          this.state = "RETRY";
          const retryPolicy = callConfig.methodConfig.retryPolicy;
          this.nextRetryBackoffSec = this.initialRetryBackoffSec = Number(retryPolicy.initialBackoff.substring(0, retryPolicy.initialBackoff.length - 1));
        } else if (callConfig.methodConfig.hedgingPolicy) {
          this.state = "HEDGING";
        } else {
          this.state = "TRANSPARENT_ONLY";
        }
      }
      getCallNumber() {
        return this.callNumber;
      }
      trace(text) {
        logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, "[" + this.callNumber + "] " + text);
      }
      reportStatus(statusObject) {
        this.trace("ended with status: code=" + statusObject.code + ' details="' + statusObject.details + '"');
        this.bufferTracker.freeAll(this.callNumber);
        for (let i = 0; i < this.writeBuffer.length; i++) {
          if (this.writeBuffer[i].entryType === "MESSAGE") {
            this.writeBuffer[i] = {
              entryType: "FREED",
              allocated: false
            };
          }
        }
        process.nextTick(() => {
          var _a;
          (_a = this.listener) === null || _a === void 0 ? void 0 : _a.onReceiveStatus(statusObject);
        });
      }
      cancelWithStatus(status, details) {
        this.trace("cancelWithStatus code: " + status + ' details: "' + details + '"');
        this.reportStatus({ code: status, details, metadata: new metadata_1.Metadata() });
        for (const { call } of this.underlyingCalls) {
          call.cancelWithStatus(status, details);
        }
      }
      getPeer() {
        if (this.committedCallIndex !== null) {
          return this.underlyingCalls[this.committedCallIndex].call.getPeer();
        } else {
          return "unknown";
        }
      }
      maybefreeMessageBufferEntry(messageIndex) {
        if (this.state !== "COMMITTED") {
          return;
        }
        const bufferEntry = this.writeBuffer[messageIndex];
        if (bufferEntry.entryType === "MESSAGE") {
          if (bufferEntry.allocated) {
            this.bufferTracker.free(bufferEntry.message.message.length, this.callNumber);
          }
          this.writeBuffer[messageIndex] = {
            entryType: "FREED",
            allocated: false
          };
        }
      }
      commitCall(index) {
        if (this.state === "COMMITTED") {
          return;
        }
        if (this.underlyingCalls[index].state === "COMPLETED") {
          return;
        }
        this.trace("Committing call [" + this.underlyingCalls[index].call.getCallNumber() + "] at index " + index);
        this.state = "COMMITTED";
        this.committedCallIndex = index;
        for (let i = 0; i < this.underlyingCalls.length; i++) {
          if (i === index) {
            continue;
          }
          if (this.underlyingCalls[i].state === "COMPLETED") {
            continue;
          }
          this.underlyingCalls[i].state = "COMPLETED";
          this.underlyingCalls[i].call.cancelWithStatus(constants_1.Status.CANCELLED, "Discarded in favor of other hedged attempt");
        }
        for (let messageIndex = 0; messageIndex < this.underlyingCalls[index].nextMessageToSend - 1; messageIndex += 1) {
          this.maybefreeMessageBufferEntry(messageIndex);
        }
      }
      commitCallWithMostMessages() {
        let mostMessages = -1;
        let callWithMostMessages = -1;
        for (const [index, childCall] of this.underlyingCalls.entries()) {
          if (childCall.nextMessageToSend > mostMessages) {
            mostMessages = childCall.nextMessageToSend;
            callWithMostMessages = index;
          }
        }
        this.commitCall(callWithMostMessages);
      }
      isStatusCodeInList(list, code) {
        return list.some((value) => value === code || value.toString().toLowerCase() === constants_1.Status[code].toLowerCase());
      }
      getNextRetryBackoffMs() {
        var _a;
        const retryPolicy = (_a = this.callConfig) === null || _a === void 0 ? void 0 : _a.methodConfig.retryPolicy;
        if (!retryPolicy) {
          return 0;
        }
        const nextBackoffMs = Math.random() * this.nextRetryBackoffSec * 1e3;
        const maxBackoffSec = Number(retryPolicy.maxBackoff.substring(0, retryPolicy.maxBackoff.length - 1));
        this.nextRetryBackoffSec = Math.min(this.nextRetryBackoffSec * retryPolicy.backoffMultiplier, maxBackoffSec);
        return nextBackoffMs;
      }
      maybeRetryCall(pushback, callback) {
        if (this.state !== "RETRY") {
          callback(false);
          return;
        }
        const retryPolicy = this.callConfig.methodConfig.retryPolicy;
        if (this.attempts >= Math.min(retryPolicy.maxAttempts, 5)) {
          callback(false);
          return;
        }
        let retryDelayMs;
        if (pushback === null) {
          retryDelayMs = this.getNextRetryBackoffMs();
        } else if (pushback < 0) {
          this.state = "TRANSPARENT_ONLY";
          callback(false);
          return;
        } else {
          retryDelayMs = pushback;
          this.nextRetryBackoffSec = this.initialRetryBackoffSec;
        }
        setTimeout(() => {
          var _a, _b;
          if (this.state !== "RETRY") {
            callback(false);
            return;
          }
          if ((_b = (_a = this.retryThrottler) === null || _a === void 0 ? void 0 : _a.canRetryCall()) !== null && _b !== void 0 ? _b : true) {
            callback(true);
            this.attempts += 1;
            this.startNewAttempt();
          }
        }, retryDelayMs);
      }
      countActiveCalls() {
        let count = 0;
        for (const call of this.underlyingCalls) {
          if ((call === null || call === void 0 ? void 0 : call.state) === "ACTIVE") {
            count += 1;
          }
        }
        return count;
      }
      handleProcessedStatus(status, callIndex, pushback) {
        var _a, _b, _c;
        switch (this.state) {
          case "COMMITTED":
          case "TRANSPARENT_ONLY":
            this.commitCall(callIndex);
            this.reportStatus(status);
            break;
          case "HEDGING":
            if (this.isStatusCodeInList((_a = this.callConfig.methodConfig.hedgingPolicy.nonFatalStatusCodes) !== null && _a !== void 0 ? _a : [], status.code)) {
              (_b = this.retryThrottler) === null || _b === void 0 ? void 0 : _b.addCallFailed();
              let delayMs;
              if (pushback === null) {
                delayMs = 0;
              } else if (pushback < 0) {
                this.state = "TRANSPARENT_ONLY";
                this.commitCall(callIndex);
                this.reportStatus(status);
                return;
              } else {
                delayMs = pushback;
              }
              setTimeout(() => {
                this.maybeStartHedgingAttempt();
                if (this.countActiveCalls() === 0) {
                  this.commitCall(callIndex);
                  this.reportStatus(status);
                }
              }, delayMs);
            } else {
              this.commitCall(callIndex);
              this.reportStatus(status);
            }
            break;
          case "RETRY":
            if (this.isStatusCodeInList(this.callConfig.methodConfig.retryPolicy.retryableStatusCodes, status.code)) {
              (_c = this.retryThrottler) === null || _c === void 0 ? void 0 : _c.addCallFailed();
              this.maybeRetryCall(pushback, (retried) => {
                if (!retried) {
                  this.commitCall(callIndex);
                  this.reportStatus(status);
                }
              });
            } else {
              this.commitCall(callIndex);
              this.reportStatus(status);
            }
            break;
        }
      }
      getPushback(metadata) {
        const mdValue = metadata.get("grpc-retry-pushback-ms");
        if (mdValue.length === 0) {
          return null;
        }
        try {
          return parseInt(mdValue[0]);
        } catch (e2) {
          return -1;
        }
      }
      handleChildStatus(status, callIndex) {
        var _a;
        if (this.underlyingCalls[callIndex].state === "COMPLETED") {
          return;
        }
        this.trace("state=" + this.state + " handling status with progress " + status.progress + " from child [" + this.underlyingCalls[callIndex].call.getCallNumber() + "] in state " + this.underlyingCalls[callIndex].state);
        this.underlyingCalls[callIndex].state = "COMPLETED";
        if (status.code === constants_1.Status.OK) {
          (_a = this.retryThrottler) === null || _a === void 0 ? void 0 : _a.addCallSucceeded();
          this.commitCall(callIndex);
          this.reportStatus(status);
          return;
        }
        if (this.state === "COMMITTED") {
          this.reportStatus(status);
          return;
        }
        const pushback = this.getPushback(status.metadata);
        switch (status.progress) {
          case "NOT_STARTED":
            this.startNewAttempt();
            break;
          case "REFUSED":
            if (this.transparentRetryUsed) {
              this.handleProcessedStatus(status, callIndex, pushback);
            } else {
              this.transparentRetryUsed = true;
              this.startNewAttempt();
            }
            ;
            break;
          case "DROP":
            this.commitCall(callIndex);
            this.reportStatus(status);
            break;
          case "PROCESSED":
            this.handleProcessedStatus(status, callIndex, pushback);
            break;
        }
      }
      maybeStartHedgingAttempt() {
        if (this.state !== "HEDGING") {
          return;
        }
        if (!this.callConfig.methodConfig.hedgingPolicy) {
          return;
        }
        const hedgingPolicy = this.callConfig.methodConfig.hedgingPolicy;
        if (this.attempts >= Math.min(hedgingPolicy.maxAttempts, 5)) {
          return;
        }
        this.attempts += 1;
        this.startNewAttempt();
        this.maybeStartHedgingTimer();
      }
      maybeStartHedgingTimer() {
        var _a, _b, _c;
        if (this.hedgingTimer) {
          clearTimeout(this.hedgingTimer);
        }
        if (this.state !== "HEDGING") {
          return;
        }
        if (!this.callConfig.methodConfig.hedgingPolicy) {
          return;
        }
        const hedgingPolicy = this.callConfig.methodConfig.hedgingPolicy;
        if (this.attempts >= Math.min(hedgingPolicy.maxAttempts, 5)) {
          return;
        }
        const hedgingDelayString = (_a = hedgingPolicy.hedgingDelay) !== null && _a !== void 0 ? _a : "0s";
        const hedgingDelaySec = Number(hedgingDelayString.substring(0, hedgingDelayString.length - 1));
        this.hedgingTimer = setTimeout(() => {
          this.maybeStartHedgingAttempt();
        }, hedgingDelaySec * 1e3);
        (_c = (_b = this.hedgingTimer).unref) === null || _c === void 0 ? void 0 : _c.call(_b);
      }
      startNewAttempt() {
        const child = this.channel.createLoadBalancingCall(this.callConfig, this.methodName, this.host, this.credentials, this.deadline);
        this.trace("Created child call [" + child.getCallNumber() + "] for attempt " + this.attempts);
        const index = this.underlyingCalls.length;
        this.underlyingCalls.push({ state: "ACTIVE", call: child, nextMessageToSend: 0 });
        const previousAttempts = this.attempts - 1;
        const initialMetadata = this.initialMetadata.clone();
        if (previousAttempts > 0) {
          initialMetadata.set(PREVIONS_RPC_ATTEMPTS_METADATA_KEY, `${previousAttempts}`);
        }
        let receivedMetadata = false;
        child.start(initialMetadata, {
          onReceiveMetadata: (metadata) => {
            this.trace("Received metadata from child [" + child.getCallNumber() + "]");
            this.commitCall(index);
            receivedMetadata = true;
            if (previousAttempts > 0) {
              metadata.set(PREVIONS_RPC_ATTEMPTS_METADATA_KEY, `${previousAttempts}`);
            }
            if (this.underlyingCalls[index].state === "ACTIVE") {
              this.listener.onReceiveMetadata(metadata);
            }
          },
          onReceiveMessage: (message) => {
            this.trace("Received message from child [" + child.getCallNumber() + "]");
            this.commitCall(index);
            if (this.underlyingCalls[index].state === "ACTIVE") {
              this.listener.onReceiveMessage(message);
            }
          },
          onReceiveStatus: (status) => {
            this.trace("Received status from child [" + child.getCallNumber() + "]");
            if (!receivedMetadata && previousAttempts > 0) {
              status.metadata.set(PREVIONS_RPC_ATTEMPTS_METADATA_KEY, `${previousAttempts}`);
            }
            this.handleChildStatus(status, index);
          }
        });
        this.sendNextChildMessage(index);
        if (this.readStarted) {
          child.startRead();
        }
      }
      start(metadata, listener) {
        this.trace("start called");
        this.listener = listener;
        this.initialMetadata = metadata;
        this.attempts += 1;
        this.startNewAttempt();
        this.maybeStartHedgingTimer();
      }
      handleChildWriteCompleted(childIndex) {
        var _a, _b;
        const childCall = this.underlyingCalls[childIndex];
        const messageIndex = childCall.nextMessageToSend;
        (_b = (_a = this.writeBuffer[messageIndex]).callback) === null || _b === void 0 ? void 0 : _b.call(_a);
        this.maybefreeMessageBufferEntry(messageIndex);
        childCall.nextMessageToSend += 1;
        this.sendNextChildMessage(childIndex);
      }
      sendNextChildMessage(childIndex) {
        const childCall = this.underlyingCalls[childIndex];
        if (childCall.state === "COMPLETED") {
          return;
        }
        if (this.writeBuffer[childCall.nextMessageToSend]) {
          const bufferEntry = this.writeBuffer[childCall.nextMessageToSend];
          switch (bufferEntry.entryType) {
            case "MESSAGE":
              childCall.call.sendMessageWithContext({
                callback: (error) => {
                  this.handleChildWriteCompleted(childIndex);
                }
              }, bufferEntry.message.message);
              break;
            case "HALF_CLOSE":
              childCall.nextMessageToSend += 1;
              childCall.call.halfClose();
              break;
            case "FREED":
              break;
          }
        }
      }
      sendMessageWithContext(context, message) {
        var _a;
        this.trace("write() called with message of length " + message.length);
        const writeObj = {
          message,
          flags: context.flags
        };
        const messageIndex = this.writeBuffer.length;
        const bufferEntry = {
          entryType: "MESSAGE",
          message: writeObj,
          allocated: this.bufferTracker.allocate(message.length, this.callNumber)
        };
        this.writeBuffer[messageIndex] = bufferEntry;
        if (bufferEntry.allocated) {
          (_a = context.callback) === null || _a === void 0 ? void 0 : _a.call(context);
          for (const [callIndex, call] of this.underlyingCalls.entries()) {
            if (call.state === "ACTIVE" && call.nextMessageToSend === messageIndex) {
              call.call.sendMessageWithContext({
                callback: (error) => {
                  this.handleChildWriteCompleted(callIndex);
                }
              }, message);
            }
          }
        } else {
          this.commitCallWithMostMessages();
          const call = this.underlyingCalls[this.committedCallIndex];
          bufferEntry.callback = context.callback;
          if (call.state === "ACTIVE" && call.nextMessageToSend === messageIndex) {
            call.call.sendMessageWithContext({
              callback: (error) => {
                this.handleChildWriteCompleted(this.committedCallIndex);
              }
            }, message);
          }
        }
      }
      startRead() {
        this.trace("startRead called");
        this.readStarted = true;
        for (const underlyingCall of this.underlyingCalls) {
          if ((underlyingCall === null || underlyingCall === void 0 ? void 0 : underlyingCall.state) === "ACTIVE") {
            underlyingCall.call.startRead();
          }
        }
      }
      halfClose() {
        this.trace("halfClose called");
        const halfCloseIndex = this.writeBuffer.length;
        this.writeBuffer[halfCloseIndex] = {
          entryType: "HALF_CLOSE",
          allocated: false
        };
        for (const call of this.underlyingCalls) {
          if ((call === null || call === void 0 ? void 0 : call.state) === "ACTIVE" && call.nextMessageToSend === halfCloseIndex) {
            call.nextMessageToSend += 1;
            call.call.halfClose();
          }
        }
      }
      setCredentials(newCredentials) {
        throw new Error("Method not implemented.");
      }
      getMethod() {
        return this.methodName;
      }
      getHost() {
        return this.host;
      }
    };
    exports2.RetryingCall = RetryingCall;
  }
});

// node_modules/@grpc/grpc-js/build/src/internal-channel.js
var require_internal_channel = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/internal-channel.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.InternalChannel = void 0;
    var channel_credentials_1 = require_channel_credentials();
    var resolving_load_balancer_1 = require_resolving_load_balancer();
    var subchannel_pool_1 = require_subchannel_pool();
    var picker_1 = require_picker();
    var constants_1 = require_constants();
    var filter_stack_1 = require_filter_stack();
    var compression_filter_1 = require_compression_filter();
    var resolver_1 = require_resolver();
    var logging_1 = require_logging();
    var max_message_size_filter_1 = require_max_message_size_filter();
    var http_proxy_1 = require_http_proxy();
    var uri_parser_1 = require_uri_parser();
    var connectivity_state_1 = require_connectivity_state();
    var channelz_1 = require_channelz();
    var load_balancing_call_1 = require_load_balancing_call();
    var resolving_call_1 = require_resolving_call();
    var call_number_1 = require_call_number();
    var control_plane_status_1 = require_control_plane_status();
    var retrying_call_1 = require_retrying_call();
    var MAX_TIMEOUT_TIME = 2147483647;
    var RETRY_THROTTLER_MAP = /* @__PURE__ */ new Map();
    var DEFAULT_RETRY_BUFFER_SIZE_BYTES = 1 << 24;
    var DEFAULT_PER_RPC_RETRY_BUFFER_SIZE_BYTES = 1 << 20;
    var InternalChannel = class {
      constructor(target, credentials2, options) {
        var _a, _b, _c, _d, _e, _f;
        this.credentials = credentials2;
        this.options = options;
        this.connectivityState = connectivity_state_1.ConnectivityState.IDLE;
        this.currentPicker = new picker_1.UnavailablePicker();
        this.configSelectionQueue = [];
        this.pickQueue = [];
        this.connectivityStateWatchers = [];
        this.configSelector = null;
        this.currentResolutionError = null;
        this.channelzEnabled = true;
        this.callTracker = new channelz_1.ChannelzCallTracker();
        this.childrenTracker = new channelz_1.ChannelzChildrenTracker();
        if (typeof target !== "string") {
          throw new TypeError("Channel target must be a string");
        }
        if (!(credentials2 instanceof channel_credentials_1.ChannelCredentials)) {
          throw new TypeError("Channel credentials must be a ChannelCredentials object");
        }
        if (options) {
          if (typeof options !== "object") {
            throw new TypeError("Channel options must be an object");
          }
        }
        this.originalTarget = target;
        const originalTargetUri = (0, uri_parser_1.parseUri)(target);
        if (originalTargetUri === null) {
          throw new Error(`Could not parse target name "${target}"`);
        }
        const defaultSchemeMapResult = (0, resolver_1.mapUriDefaultScheme)(originalTargetUri);
        if (defaultSchemeMapResult === null) {
          throw new Error(`Could not find a default scheme for target name "${target}"`);
        }
        this.callRefTimer = setInterval(() => {
        }, MAX_TIMEOUT_TIME);
        (_b = (_a = this.callRefTimer).unref) === null || _b === void 0 ? void 0 : _b.call(_a);
        if (this.options["grpc.enable_channelz"] === 0) {
          this.channelzEnabled = false;
        }
        this.channelzTrace = new channelz_1.ChannelzTrace();
        this.channelzRef = (0, channelz_1.registerChannelzChannel)(target, () => this.getChannelzInfo(), this.channelzEnabled);
        if (this.channelzEnabled) {
          this.channelzTrace.addTrace("CT_INFO", "Channel created");
        }
        if (this.options["grpc.default_authority"]) {
          this.defaultAuthority = this.options["grpc.default_authority"];
        } else {
          this.defaultAuthority = (0, resolver_1.getDefaultAuthority)(defaultSchemeMapResult);
        }
        const proxyMapResult = (0, http_proxy_1.mapProxyName)(defaultSchemeMapResult, options);
        this.target = proxyMapResult.target;
        this.options = Object.assign({}, this.options, proxyMapResult.extraOptions);
        this.subchannelPool = (0, subchannel_pool_1.getSubchannelPool)(((_c = options["grpc.use_local_subchannel_pool"]) !== null && _c !== void 0 ? _c : 0) === 0);
        this.retryBufferTracker = new retrying_call_1.MessageBufferTracker((_d = options["grpc.retry_buffer_size"]) !== null && _d !== void 0 ? _d : DEFAULT_RETRY_BUFFER_SIZE_BYTES, (_e = options["grpc.per_rpc_retry_buffer_size"]) !== null && _e !== void 0 ? _e : DEFAULT_PER_RPC_RETRY_BUFFER_SIZE_BYTES);
        const channelControlHelper = {
          createSubchannel: (subchannelAddress, subchannelArgs) => {
            const subchannel = this.subchannelPool.getOrCreateSubchannel(this.target, subchannelAddress, Object.assign({}, this.options, subchannelArgs), this.credentials);
            if (this.channelzEnabled) {
              this.channelzTrace.addTrace("CT_INFO", "Created subchannel or used existing subchannel", subchannel.getChannelzRef());
            }
            return subchannel;
          },
          updateState: (connectivityState, picker) => {
            this.currentPicker = picker;
            const queueCopy = this.pickQueue.slice();
            this.pickQueue = [];
            this.callRefTimerUnref();
            for (const call of queueCopy) {
              call.doPick();
            }
            this.updateState(connectivityState);
          },
          requestReresolution: () => {
            throw new Error("Resolving load balancer should never call requestReresolution");
          },
          addChannelzChild: (child) => {
            if (this.channelzEnabled) {
              this.childrenTracker.refChild(child);
            }
          },
          removeChannelzChild: (child) => {
            if (this.channelzEnabled) {
              this.childrenTracker.unrefChild(child);
            }
          }
        };
        this.resolvingLoadBalancer = new resolving_load_balancer_1.ResolvingLoadBalancer(this.target, channelControlHelper, options, (serviceConfig, configSelector) => {
          if (serviceConfig.retryThrottling) {
            RETRY_THROTTLER_MAP.set(this.getTarget(), new retrying_call_1.RetryThrottler(serviceConfig.retryThrottling.maxTokens, serviceConfig.retryThrottling.tokenRatio, RETRY_THROTTLER_MAP.get(this.getTarget())));
          } else {
            RETRY_THROTTLER_MAP.delete(this.getTarget());
          }
          if (this.channelzEnabled) {
            this.channelzTrace.addTrace("CT_INFO", "Address resolution succeeded");
          }
          this.configSelector = configSelector;
          this.currentResolutionError = null;
          process.nextTick(() => {
            const localQueue = this.configSelectionQueue;
            this.configSelectionQueue = [];
            this.callRefTimerUnref();
            for (const call of localQueue) {
              call.getConfig();
            }
            this.configSelectionQueue = [];
          });
        }, (status) => {
          if (this.channelzEnabled) {
            this.channelzTrace.addTrace("CT_WARNING", "Address resolution failed with code " + status.code + ' and details "' + status.details + '"');
          }
          if (this.configSelectionQueue.length > 0) {
            this.trace("Name resolution failed with calls queued for config selection");
          }
          if (this.configSelector === null) {
            this.currentResolutionError = Object.assign(Object.assign({}, (0, control_plane_status_1.restrictControlPlaneStatusCode)(status.code, status.details)), { metadata: status.metadata });
          }
          const localQueue = this.configSelectionQueue;
          this.configSelectionQueue = [];
          this.callRefTimerUnref();
          for (const call of localQueue) {
            call.reportResolverError(status);
          }
        });
        this.filterStackFactory = new filter_stack_1.FilterStackFactory([
          new max_message_size_filter_1.MaxMessageSizeFilterFactory(this.options),
          new compression_filter_1.CompressionFilterFactory(this, this.options)
        ]);
        this.trace("Channel constructed with options " + JSON.stringify(options, void 0, 2));
        const error = new Error();
        (0, logging_1.trace)(constants_1.LogVerbosity.DEBUG, "channel_stacktrace", "(" + this.channelzRef.id + ") Channel constructed \n" + ((_f = error.stack) === null || _f === void 0 ? void 0 : _f.substring(error.stack.indexOf("\n") + 1)));
      }
      getChannelzInfo() {
        return {
          target: this.originalTarget,
          state: this.connectivityState,
          trace: this.channelzTrace,
          callTracker: this.callTracker,
          children: this.childrenTracker.getChildLists()
        };
      }
      trace(text, verbosityOverride) {
        (0, logging_1.trace)(verbosityOverride !== null && verbosityOverride !== void 0 ? verbosityOverride : constants_1.LogVerbosity.DEBUG, "channel", "(" + this.channelzRef.id + ") " + (0, uri_parser_1.uriToString)(this.target) + " " + text);
      }
      callRefTimerRef() {
        var _a, _b, _c, _d;
        if (!((_b = (_a = this.callRefTimer).hasRef) === null || _b === void 0 ? void 0 : _b.call(_a))) {
          this.trace("callRefTimer.ref | configSelectionQueue.length=" + this.configSelectionQueue.length + " pickQueue.length=" + this.pickQueue.length);
          (_d = (_c = this.callRefTimer).ref) === null || _d === void 0 ? void 0 : _d.call(_c);
        }
      }
      callRefTimerUnref() {
        var _a, _b;
        if (!this.callRefTimer.hasRef || this.callRefTimer.hasRef()) {
          this.trace("callRefTimer.unref | configSelectionQueue.length=" + this.configSelectionQueue.length + " pickQueue.length=" + this.pickQueue.length);
          (_b = (_a = this.callRefTimer).unref) === null || _b === void 0 ? void 0 : _b.call(_a);
        }
      }
      removeConnectivityStateWatcher(watcherObject) {
        const watcherIndex = this.connectivityStateWatchers.findIndex((value) => value === watcherObject);
        if (watcherIndex >= 0) {
          this.connectivityStateWatchers.splice(watcherIndex, 1);
        }
      }
      updateState(newState) {
        (0, logging_1.trace)(constants_1.LogVerbosity.DEBUG, "connectivity_state", "(" + this.channelzRef.id + ") " + (0, uri_parser_1.uriToString)(this.target) + " " + connectivity_state_1.ConnectivityState[this.connectivityState] + " -> " + connectivity_state_1.ConnectivityState[newState]);
        if (this.channelzEnabled) {
          this.channelzTrace.addTrace("CT_INFO", connectivity_state_1.ConnectivityState[this.connectivityState] + " -> " + connectivity_state_1.ConnectivityState[newState]);
        }
        this.connectivityState = newState;
        const watchersCopy = this.connectivityStateWatchers.slice();
        for (const watcherObject of watchersCopy) {
          if (newState !== watcherObject.currentState) {
            if (watcherObject.timer) {
              clearTimeout(watcherObject.timer);
            }
            this.removeConnectivityStateWatcher(watcherObject);
            watcherObject.callback();
          }
        }
        if (newState !== connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE) {
          this.currentResolutionError = null;
        }
      }
      doPick(metadata, extraPickInfo) {
        return this.currentPicker.pick({ metadata, extraPickInfo });
      }
      queueCallForPick(call) {
        this.pickQueue.push(call);
        this.callRefTimerRef();
      }
      getConfig(method, metadata) {
        this.resolvingLoadBalancer.exitIdle();
        if (this.configSelector) {
          return {
            type: "SUCCESS",
            config: this.configSelector(method, metadata)
          };
        } else {
          if (this.currentResolutionError) {
            return {
              type: "ERROR",
              error: this.currentResolutionError
            };
          } else {
            return {
              type: "NONE"
            };
          }
        }
      }
      queueCallForConfig(call) {
        this.configSelectionQueue.push(call);
        this.callRefTimerRef();
      }
      createLoadBalancingCall(callConfig, method, host, credentials2, deadline) {
        const callNumber = (0, call_number_1.getNextCallNumber)();
        this.trace("createLoadBalancingCall [" + callNumber + '] method="' + method + '"');
        return new load_balancing_call_1.LoadBalancingCall(this, callConfig, method, host, credentials2, deadline, callNumber);
      }
      createRetryingCall(callConfig, method, host, credentials2, deadline) {
        const callNumber = (0, call_number_1.getNextCallNumber)();
        this.trace("createRetryingCall [" + callNumber + '] method="' + method + '"');
        return new retrying_call_1.RetryingCall(this, callConfig, method, host, credentials2, deadline, callNumber, this.retryBufferTracker, RETRY_THROTTLER_MAP.get(this.getTarget()));
      }
      createInnerCall(callConfig, method, host, credentials2, deadline) {
        if (this.options["grpc.enable_retries"] === 0) {
          return this.createLoadBalancingCall(callConfig, method, host, credentials2, deadline);
        } else {
          return this.createRetryingCall(callConfig, method, host, credentials2, deadline);
        }
      }
      createResolvingCall(method, deadline, host, parentCall, propagateFlags) {
        const callNumber = (0, call_number_1.getNextCallNumber)();
        this.trace("createResolvingCall [" + callNumber + '] method="' + method + '", deadline=' + deadline);
        const finalOptions = {
          deadline,
          flags: propagateFlags !== null && propagateFlags !== void 0 ? propagateFlags : constants_1.Propagate.DEFAULTS,
          host: host !== null && host !== void 0 ? host : this.defaultAuthority,
          parentCall
        };
        const call = new resolving_call_1.ResolvingCall(this, method, finalOptions, this.filterStackFactory.clone(), this.credentials._getCallCredentials(), callNumber);
        if (this.channelzEnabled) {
          this.callTracker.addCallStarted();
          call.addStatusWatcher((status) => {
            if (status.code === constants_1.Status.OK) {
              this.callTracker.addCallSucceeded();
            } else {
              this.callTracker.addCallFailed();
            }
          });
        }
        return call;
      }
      close() {
        this.resolvingLoadBalancer.destroy();
        this.updateState(connectivity_state_1.ConnectivityState.SHUTDOWN);
        clearInterval(this.callRefTimer);
        if (this.channelzEnabled) {
          (0, channelz_1.unregisterChannelzRef)(this.channelzRef);
        }
        this.subchannelPool.unrefUnusedSubchannels();
      }
      getTarget() {
        return (0, uri_parser_1.uriToString)(this.target);
      }
      getConnectivityState(tryToConnect) {
        const connectivityState = this.connectivityState;
        if (tryToConnect) {
          this.resolvingLoadBalancer.exitIdle();
        }
        return connectivityState;
      }
      watchConnectivityState(currentState, deadline, callback) {
        if (this.connectivityState === connectivity_state_1.ConnectivityState.SHUTDOWN) {
          throw new Error("Channel has been shut down");
        }
        let timer = null;
        if (deadline !== Infinity) {
          const deadlineDate = deadline instanceof Date ? deadline : new Date(deadline);
          const now = new Date();
          if (deadline === -Infinity || deadlineDate <= now) {
            process.nextTick(callback, new Error("Deadline passed without connectivity state change"));
            return;
          }
          timer = setTimeout(() => {
            this.removeConnectivityStateWatcher(watcherObject);
            callback(new Error("Deadline passed without connectivity state change"));
          }, deadlineDate.getTime() - now.getTime());
        }
        const watcherObject = {
          currentState,
          callback,
          timer
        };
        this.connectivityStateWatchers.push(watcherObject);
      }
      /**
       * Get the channelz reference object for this channel. The returned value is
       * garbage if channelz is disabled for this channel.
       * @returns
       */
      getChannelzRef() {
        return this.channelzRef;
      }
      createCall(method, deadline, host, parentCall, propagateFlags) {
        if (typeof method !== "string") {
          throw new TypeError("Channel#createCall: method must be a string");
        }
        if (!(typeof deadline === "number" || deadline instanceof Date)) {
          throw new TypeError("Channel#createCall: deadline must be a number or Date");
        }
        if (this.connectivityState === connectivity_state_1.ConnectivityState.SHUTDOWN) {
          throw new Error("Channel has been shut down");
        }
        return this.createResolvingCall(method, deadline, host, parentCall, propagateFlags);
      }
    };
    exports2.InternalChannel = InternalChannel;
  }
});

// node_modules/@grpc/grpc-js/build/src/channel.js
var require_channel = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/channel.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ChannelImplementation = void 0;
    var channel_credentials_1 = require_channel_credentials();
    var internal_channel_1 = require_internal_channel();
    var ChannelImplementation = class {
      constructor(target, credentials2, options) {
        if (typeof target !== "string") {
          throw new TypeError("Channel target must be a string");
        }
        if (!(credentials2 instanceof channel_credentials_1.ChannelCredentials)) {
          throw new TypeError("Channel credentials must be a ChannelCredentials object");
        }
        if (options) {
          if (typeof options !== "object") {
            throw new TypeError("Channel options must be an object");
          }
        }
        this.internalChannel = new internal_channel_1.InternalChannel(target, credentials2, options);
      }
      close() {
        this.internalChannel.close();
      }
      getTarget() {
        return this.internalChannel.getTarget();
      }
      getConnectivityState(tryToConnect) {
        return this.internalChannel.getConnectivityState(tryToConnect);
      }
      watchConnectivityState(currentState, deadline, callback) {
        this.internalChannel.watchConnectivityState(currentState, deadline, callback);
      }
      /**
       * Get the channelz reference object for this channel. The returned value is
       * garbage if channelz is disabled for this channel.
       * @returns
       */
      getChannelzRef() {
        return this.internalChannel.getChannelzRef();
      }
      createCall(method, deadline, host, parentCall, propagateFlags) {
        if (typeof method !== "string") {
          throw new TypeError("Channel#createCall: method must be a string");
        }
        if (!(typeof deadline === "number" || deadline instanceof Date)) {
          throw new TypeError("Channel#createCall: deadline must be a number or Date");
        }
        return this.internalChannel.createCall(method, deadline, host, parentCall, propagateFlags);
      }
    };
    exports2.ChannelImplementation = ChannelImplementation;
  }
});

// node_modules/@grpc/grpc-js/build/src/server-call.js
var require_server_call = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/server-call.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Http2ServerCallStream = exports2.ServerDuplexStreamImpl = exports2.ServerWritableStreamImpl = exports2.ServerReadableStreamImpl = exports2.ServerUnaryCallImpl = void 0;
    var events_1 = require("events");
    var http2 = require("http2");
    var stream_1 = require("stream");
    var zlib = require("zlib");
    var util_1 = require("util");
    var constants_1 = require_constants();
    var metadata_1 = require_metadata();
    var stream_decoder_1 = require_stream_decoder();
    var logging = require_logging();
    var error_1 = require_error();
    var TRACER_NAME = "server_call";
    var unzip = (0, util_1.promisify)(zlib.unzip);
    var inflate = (0, util_1.promisify)(zlib.inflate);
    function trace(text) {
      logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, text);
    }
    var GRPC_ACCEPT_ENCODING_HEADER = "grpc-accept-encoding";
    var GRPC_ENCODING_HEADER = "grpc-encoding";
    var GRPC_MESSAGE_HEADER = "grpc-message";
    var GRPC_STATUS_HEADER = "grpc-status";
    var GRPC_TIMEOUT_HEADER = "grpc-timeout";
    var DEADLINE_REGEX = /(\d{1,8})\s*([HMSmun])/;
    var deadlineUnitsToMs = {
      H: 36e5,
      M: 6e4,
      S: 1e3,
      m: 1,
      u: 1e-3,
      n: 1e-6
    };
    var defaultCompressionHeaders = {
      // TODO(cjihrig): Remove these encoding headers from the default response
      // once compression is integrated.
      [GRPC_ACCEPT_ENCODING_HEADER]: "identity,deflate,gzip",
      [GRPC_ENCODING_HEADER]: "identity"
    };
    var defaultResponseHeaders = {
      [http2.constants.HTTP2_HEADER_STATUS]: http2.constants.HTTP_STATUS_OK,
      [http2.constants.HTTP2_HEADER_CONTENT_TYPE]: "application/grpc+proto"
    };
    var defaultResponseOptions = {
      waitForTrailers: true
    };
    var ServerUnaryCallImpl = class extends events_1.EventEmitter {
      constructor(call, metadata, request) {
        super();
        this.call = call;
        this.metadata = metadata;
        this.request = request;
        this.cancelled = false;
        this.call.setupSurfaceCall(this);
      }
      getPeer() {
        return this.call.getPeer();
      }
      sendMetadata(responseMetadata) {
        this.call.sendMetadata(responseMetadata);
      }
      getDeadline() {
        return this.call.getDeadline();
      }
      getPath() {
        return this.call.getPath();
      }
    };
    exports2.ServerUnaryCallImpl = ServerUnaryCallImpl;
    var ServerReadableStreamImpl = class extends stream_1.Readable {
      constructor(call, metadata, deserialize, encoding) {
        super({ objectMode: true });
        this.call = call;
        this.metadata = metadata;
        this.deserialize = deserialize;
        this.cancelled = false;
        this.call.setupSurfaceCall(this);
        this.call.setupReadable(this, encoding);
      }
      _read(size) {
        if (!this.call.consumeUnpushedMessages(this)) {
          return;
        }
        this.call.resume();
      }
      getPeer() {
        return this.call.getPeer();
      }
      sendMetadata(responseMetadata) {
        this.call.sendMetadata(responseMetadata);
      }
      getDeadline() {
        return this.call.getDeadline();
      }
      getPath() {
        return this.call.getPath();
      }
    };
    exports2.ServerReadableStreamImpl = ServerReadableStreamImpl;
    var ServerWritableStreamImpl = class extends stream_1.Writable {
      constructor(call, metadata, serialize, request) {
        super({ objectMode: true });
        this.call = call;
        this.metadata = metadata;
        this.serialize = serialize;
        this.request = request;
        this.cancelled = false;
        this.trailingMetadata = new metadata_1.Metadata();
        this.call.setupSurfaceCall(this);
        this.on("error", (err) => {
          this.call.sendError(err);
          this.end();
        });
      }
      getPeer() {
        return this.call.getPeer();
      }
      sendMetadata(responseMetadata) {
        this.call.sendMetadata(responseMetadata);
      }
      getDeadline() {
        return this.call.getDeadline();
      }
      getPath() {
        return this.call.getPath();
      }
      _write(chunk, encoding, callback) {
        try {
          const response = this.call.serializeMessage(chunk);
          if (!this.call.write(response)) {
            this.call.once("drain", callback);
            return;
          }
        } catch (err) {
          this.emit("error", {
            details: (0, error_1.getErrorMessage)(err),
            code: constants_1.Status.INTERNAL
          });
        }
        callback();
      }
      _final(callback) {
        this.call.sendStatus({
          code: constants_1.Status.OK,
          details: "OK",
          metadata: this.trailingMetadata
        });
        callback(null);
      }
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      end(metadata) {
        if (metadata) {
          this.trailingMetadata = metadata;
        }
        return super.end();
      }
    };
    exports2.ServerWritableStreamImpl = ServerWritableStreamImpl;
    var ServerDuplexStreamImpl = class extends stream_1.Duplex {
      constructor(call, metadata, serialize, deserialize, encoding) {
        super({ objectMode: true });
        this.call = call;
        this.metadata = metadata;
        this.serialize = serialize;
        this.deserialize = deserialize;
        this.cancelled = false;
        this.trailingMetadata = new metadata_1.Metadata();
        this.call.setupSurfaceCall(this);
        this.call.setupReadable(this, encoding);
        this.on("error", (err) => {
          this.call.sendError(err);
          this.end();
        });
      }
      getPeer() {
        return this.call.getPeer();
      }
      sendMetadata(responseMetadata) {
        this.call.sendMetadata(responseMetadata);
      }
      getDeadline() {
        return this.call.getDeadline();
      }
      getPath() {
        return this.call.getPath();
      }
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      end(metadata) {
        if (metadata) {
          this.trailingMetadata = metadata;
        }
        return super.end();
      }
    };
    exports2.ServerDuplexStreamImpl = ServerDuplexStreamImpl;
    ServerDuplexStreamImpl.prototype._read = ServerReadableStreamImpl.prototype._read;
    ServerDuplexStreamImpl.prototype._write = ServerWritableStreamImpl.prototype._write;
    ServerDuplexStreamImpl.prototype._final = ServerWritableStreamImpl.prototype._final;
    var Http2ServerCallStream = class extends events_1.EventEmitter {
      constructor(stream, handler2, options) {
        super();
        this.stream = stream;
        this.handler = handler2;
        this.options = options;
        this.cancelled = false;
        this.deadlineTimer = null;
        this.statusSent = false;
        this.deadline = Infinity;
        this.wantTrailers = false;
        this.metadataSent = false;
        this.canPush = false;
        this.isPushPending = false;
        this.bufferedMessages = [];
        this.messagesToPush = [];
        this.maxSendMessageSize = constants_1.DEFAULT_MAX_SEND_MESSAGE_LENGTH;
        this.maxReceiveMessageSize = constants_1.DEFAULT_MAX_RECEIVE_MESSAGE_LENGTH;
        this.stream.once("error", (err) => {
        });
        this.stream.once("close", () => {
          var _a;
          trace("Request to method " + ((_a = this.handler) === null || _a === void 0 ? void 0 : _a.path) + " stream closed with rstCode " + this.stream.rstCode);
          if (!this.statusSent) {
            this.cancelled = true;
            this.emit("cancelled", "cancelled");
            this.emit("streamEnd", false);
            this.sendStatus({
              code: constants_1.Status.CANCELLED,
              details: "Cancelled by client",
              metadata: null
            });
          }
        });
        this.stream.on("drain", () => {
          this.emit("drain");
        });
        if ("grpc.max_send_message_length" in options) {
          this.maxSendMessageSize = options["grpc.max_send_message_length"];
        }
        if ("grpc.max_receive_message_length" in options) {
          this.maxReceiveMessageSize = options["grpc.max_receive_message_length"];
        }
      }
      checkCancelled() {
        if (this.stream.destroyed || this.stream.closed) {
          this.cancelled = true;
        }
        return this.cancelled;
      }
      getDecompressedMessage(message, encoding) {
        if (encoding === "deflate") {
          return inflate(message.subarray(5));
        } else if (encoding === "gzip") {
          return unzip(message.subarray(5));
        } else if (encoding === "identity") {
          return message.subarray(5);
        }
        return Promise.reject({
          code: constants_1.Status.UNIMPLEMENTED,
          details: `Received message compressed with unsupported encoding "${encoding}"`
        });
      }
      sendMetadata(customMetadata) {
        if (this.checkCancelled()) {
          return;
        }
        if (this.metadataSent) {
          return;
        }
        this.metadataSent = true;
        const custom = customMetadata ? customMetadata.toHttp2Headers() : null;
        const headers = Object.assign(Object.assign(Object.assign({}, defaultResponseHeaders), defaultCompressionHeaders), custom);
        this.stream.respond(headers, defaultResponseOptions);
      }
      receiveMetadata(headers) {
        const metadata = metadata_1.Metadata.fromHttp2Headers(headers);
        if (logging.isTracerEnabled(TRACER_NAME)) {
          trace("Request to " + this.handler.path + " received headers " + JSON.stringify(metadata.toJSON()));
        }
        const timeoutHeader = metadata.get(GRPC_TIMEOUT_HEADER);
        if (timeoutHeader.length > 0) {
          const match = timeoutHeader[0].toString().match(DEADLINE_REGEX);
          if (match === null) {
            const err = new Error("Invalid deadline");
            err.code = constants_1.Status.OUT_OF_RANGE;
            this.sendError(err);
            return metadata;
          }
          const timeout = +match[1] * deadlineUnitsToMs[match[2]] | 0;
          const now = new Date();
          this.deadline = now.setMilliseconds(now.getMilliseconds() + timeout);
          this.deadlineTimer = setTimeout(handleExpiredDeadline, timeout, this);
          metadata.remove(GRPC_TIMEOUT_HEADER);
        }
        metadata.remove(http2.constants.HTTP2_HEADER_ACCEPT_ENCODING);
        metadata.remove(http2.constants.HTTP2_HEADER_TE);
        metadata.remove(http2.constants.HTTP2_HEADER_CONTENT_TYPE);
        metadata.remove("grpc-accept-encoding");
        return metadata;
      }
      receiveUnaryMessage(encoding, next) {
        const { stream } = this;
        let receivedLength = 0;
        const call = this;
        const body = [];
        const limit = this.maxReceiveMessageSize;
        stream.on("data", onData);
        stream.on("end", onEnd);
        stream.on("error", onEnd);
        function onData(chunk) {
          receivedLength += chunk.byteLength;
          if (limit !== -1 && receivedLength > limit) {
            stream.removeListener("data", onData);
            stream.removeListener("end", onEnd);
            stream.removeListener("error", onEnd);
            next({
              code: constants_1.Status.RESOURCE_EXHAUSTED,
              details: `Received message larger than max (${receivedLength} vs. ${limit})`
            });
            return;
          }
          body.push(chunk);
        }
        function onEnd(err) {
          stream.removeListener("data", onData);
          stream.removeListener("end", onEnd);
          stream.removeListener("error", onEnd);
          if (err !== void 0) {
            next({ code: constants_1.Status.INTERNAL, details: err.message });
            return;
          }
          if (receivedLength === 0) {
            next({ code: constants_1.Status.INTERNAL, details: "received empty unary message" });
            return;
          }
          call.emit("receiveMessage");
          const requestBytes = Buffer.concat(body, receivedLength);
          const compressed = requestBytes.readUInt8(0) === 1;
          const compressedMessageEncoding = compressed ? encoding : "identity";
          const decompressedMessage = call.getDecompressedMessage(requestBytes, compressedMessageEncoding);
          if (Buffer.isBuffer(decompressedMessage)) {
            call.safeDeserializeMessage(decompressedMessage, next);
            return;
          }
          decompressedMessage.then((decompressed) => call.safeDeserializeMessage(decompressed, next), (err2) => next(err2.code ? err2 : {
            code: constants_1.Status.INTERNAL,
            details: `Received "grpc-encoding" header "${encoding}" but ${encoding} decompression failed`
          }));
        }
      }
      safeDeserializeMessage(buffer, next) {
        try {
          next(null, this.deserializeMessage(buffer));
        } catch (err) {
          next({
            details: (0, error_1.getErrorMessage)(err),
            code: constants_1.Status.INTERNAL
          });
        }
      }
      serializeMessage(value) {
        const messageBuffer = this.handler.serialize(value);
        const byteLength = messageBuffer.byteLength;
        const output = Buffer.allocUnsafe(byteLength + 5);
        output.writeUInt8(0, 0);
        output.writeUInt32BE(byteLength, 1);
        messageBuffer.copy(output, 5);
        return output;
      }
      deserializeMessage(bytes) {
        return this.handler.deserialize(bytes);
      }
      async sendUnaryMessage(err, value, metadata, flags) {
        if (this.checkCancelled()) {
          return;
        }
        if (metadata === void 0) {
          metadata = null;
        }
        if (err) {
          if (!Object.prototype.hasOwnProperty.call(err, "metadata") && metadata) {
            err.metadata = metadata;
          }
          this.sendError(err);
          return;
        }
        try {
          const response = this.serializeMessage(value);
          this.write(response);
          this.sendStatus({ code: constants_1.Status.OK, details: "OK", metadata });
        } catch (err2) {
          this.sendError({
            details: (0, error_1.getErrorMessage)(err2),
            code: constants_1.Status.INTERNAL
          });
        }
      }
      sendStatus(statusObj) {
        var _a, _b;
        this.emit("callEnd", statusObj.code);
        this.emit("streamEnd", statusObj.code === constants_1.Status.OK);
        if (this.checkCancelled()) {
          return;
        }
        trace("Request to method " + ((_a = this.handler) === null || _a === void 0 ? void 0 : _a.path) + " ended with status code: " + constants_1.Status[statusObj.code] + " details: " + statusObj.details);
        if (this.deadlineTimer)
          clearTimeout(this.deadlineTimer);
        if (this.stream.headersSent) {
          if (!this.wantTrailers) {
            this.wantTrailers = true;
            this.stream.once("wantTrailers", () => {
              var _a2;
              const trailersToSend = Object.assign({ [GRPC_STATUS_HEADER]: statusObj.code, [GRPC_MESSAGE_HEADER]: encodeURI(statusObj.details) }, (_a2 = statusObj.metadata) === null || _a2 === void 0 ? void 0 : _a2.toHttp2Headers());
              this.stream.sendTrailers(trailersToSend);
              this.statusSent = true;
            });
            this.stream.end();
          }
        } else {
          const trailersToSend = Object.assign(Object.assign({ [GRPC_STATUS_HEADER]: statusObj.code, [GRPC_MESSAGE_HEADER]: encodeURI(statusObj.details) }, defaultResponseHeaders), (_b = statusObj.metadata) === null || _b === void 0 ? void 0 : _b.toHttp2Headers());
          this.stream.respond(trailersToSend, { endStream: true });
          this.statusSent = true;
        }
      }
      sendError(error) {
        const status = {
          code: constants_1.Status.UNKNOWN,
          details: "message" in error ? error.message : "Unknown Error",
          metadata: "metadata" in error && error.metadata !== void 0 ? error.metadata : null
        };
        if ("code" in error && typeof error.code === "number" && Number.isInteger(error.code)) {
          status.code = error.code;
          if ("details" in error && typeof error.details === "string") {
            status.details = error.details;
          }
        }
        this.sendStatus(status);
      }
      write(chunk) {
        if (this.checkCancelled()) {
          return;
        }
        if (this.maxSendMessageSize !== -1 && chunk.length > this.maxSendMessageSize) {
          this.sendError({
            code: constants_1.Status.RESOURCE_EXHAUSTED,
            details: `Sent message larger than max (${chunk.length} vs. ${this.maxSendMessageSize})`
          });
          return;
        }
        this.sendMetadata();
        this.emit("sendMessage");
        return this.stream.write(chunk);
      }
      resume() {
        this.stream.resume();
      }
      setupSurfaceCall(call) {
        this.once("cancelled", (reason) => {
          call.cancelled = true;
          call.emit("cancelled", reason);
        });
        this.once("callEnd", (status) => call.emit("callEnd", status));
      }
      setupReadable(readable, encoding) {
        const decoder = new stream_decoder_1.StreamDecoder();
        let readsDone = false;
        let pendingMessageProcessing = false;
        let pushedEnd = false;
        const maybePushEnd = () => {
          if (!pushedEnd && readsDone && !pendingMessageProcessing) {
            pushedEnd = true;
            this.pushOrBufferMessage(readable, null);
          }
        };
        this.stream.on("data", async (data) => {
          const messages = decoder.write(data);
          pendingMessageProcessing = true;
          this.stream.pause();
          for (const message of messages) {
            if (this.maxReceiveMessageSize !== -1 && message.length > this.maxReceiveMessageSize) {
              this.sendError({
                code: constants_1.Status.RESOURCE_EXHAUSTED,
                details: `Received message larger than max (${message.length} vs. ${this.maxReceiveMessageSize})`
              });
              return;
            }
            this.emit("receiveMessage");
            const compressed = message.readUInt8(0) === 1;
            const compressedMessageEncoding = compressed ? encoding : "identity";
            const decompressedMessage = await this.getDecompressedMessage(message, compressedMessageEncoding);
            if (!decompressedMessage)
              return;
            this.pushOrBufferMessage(readable, decompressedMessage);
          }
          pendingMessageProcessing = false;
          this.stream.resume();
          maybePushEnd();
        });
        this.stream.once("end", () => {
          readsDone = true;
          maybePushEnd();
        });
      }
      consumeUnpushedMessages(readable) {
        this.canPush = true;
        while (this.messagesToPush.length > 0) {
          const nextMessage = this.messagesToPush.shift();
          const canPush = readable.push(nextMessage);
          if (nextMessage === null || canPush === false) {
            this.canPush = false;
            break;
          }
        }
        return this.canPush;
      }
      pushOrBufferMessage(readable, messageBytes) {
        if (this.isPushPending) {
          this.bufferedMessages.push(messageBytes);
        } else {
          this.pushMessage(readable, messageBytes);
        }
      }
      async pushMessage(readable, messageBytes) {
        if (messageBytes === null) {
          trace("Received end of stream");
          if (this.canPush) {
            readable.push(null);
          } else {
            this.messagesToPush.push(null);
          }
          return;
        }
        trace("Received message of length " + messageBytes.length);
        this.isPushPending = true;
        try {
          const deserialized = await this.deserializeMessage(messageBytes);
          if (this.canPush) {
            if (!readable.push(deserialized)) {
              this.canPush = false;
              this.stream.pause();
            }
          } else {
            this.messagesToPush.push(deserialized);
          }
        } catch (error) {
          this.bufferedMessages.length = 0;
          let code = (0, error_1.getErrorCode)(error);
          if (code === null || code < constants_1.Status.OK || code > constants_1.Status.UNAUTHENTICATED) {
            code = constants_1.Status.INTERNAL;
          }
          readable.emit("error", {
            details: (0, error_1.getErrorMessage)(error),
            code
          });
        }
        this.isPushPending = false;
        if (this.bufferedMessages.length > 0) {
          this.pushMessage(readable, this.bufferedMessages.shift());
        }
      }
      getPeer() {
        const socket = this.stream.session.socket;
        if (socket.remoteAddress) {
          if (socket.remotePort) {
            return `${socket.remoteAddress}:${socket.remotePort}`;
          } else {
            return socket.remoteAddress;
          }
        } else {
          return "unknown";
        }
      }
      getDeadline() {
        return this.deadline;
      }
      getPath() {
        return this.handler.path;
      }
    };
    exports2.Http2ServerCallStream = Http2ServerCallStream;
    function handleExpiredDeadline(call) {
      const err = new Error("Deadline exceeded");
      err.code = constants_1.Status.DEADLINE_EXCEEDED;
      call.sendError(err);
      call.cancelled = true;
      call.emit("cancelled", "deadline");
    }
  }
});

// node_modules/@grpc/grpc-js/build/src/server-credentials.js
var require_server_credentials = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/server-credentials.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ServerCredentials = void 0;
    var tls_helpers_1 = require_tls_helpers();
    var ServerCredentials = class {
      static createInsecure() {
        return new InsecureServerCredentials();
      }
      static createSsl(rootCerts, keyCertPairs, checkClientCertificate = false) {
        if (rootCerts !== null && !Buffer.isBuffer(rootCerts)) {
          throw new TypeError("rootCerts must be null or a Buffer");
        }
        if (!Array.isArray(keyCertPairs)) {
          throw new TypeError("keyCertPairs must be an array");
        }
        if (typeof checkClientCertificate !== "boolean") {
          throw new TypeError("checkClientCertificate must be a boolean");
        }
        const cert = [];
        const key = [];
        for (let i = 0; i < keyCertPairs.length; i++) {
          const pair = keyCertPairs[i];
          if (pair === null || typeof pair !== "object") {
            throw new TypeError(`keyCertPair[${i}] must be an object`);
          }
          if (!Buffer.isBuffer(pair.private_key)) {
            throw new TypeError(`keyCertPair[${i}].private_key must be a Buffer`);
          }
          if (!Buffer.isBuffer(pair.cert_chain)) {
            throw new TypeError(`keyCertPair[${i}].cert_chain must be a Buffer`);
          }
          cert.push(pair.cert_chain);
          key.push(pair.private_key);
        }
        return new SecureServerCredentials({
          ca: rootCerts || (0, tls_helpers_1.getDefaultRootsData)() || void 0,
          cert,
          key,
          requestCert: checkClientCertificate,
          ciphers: tls_helpers_1.CIPHER_SUITES
        });
      }
    };
    exports2.ServerCredentials = ServerCredentials;
    var InsecureServerCredentials = class extends ServerCredentials {
      _isSecure() {
        return false;
      }
      _getSettings() {
        return null;
      }
    };
    var SecureServerCredentials = class extends ServerCredentials {
      constructor(options) {
        super();
        this.options = options;
      }
      _isSecure() {
        return true;
      }
      _getSettings() {
        return this.options;
      }
    };
  }
});

// node_modules/@grpc/grpc-js/build/src/server.js
var require_server = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/server.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Server = void 0;
    var http2 = require("http2");
    var constants_1 = require_constants();
    var server_call_1 = require_server_call();
    var server_credentials_1 = require_server_credentials();
    var resolver_1 = require_resolver();
    var logging = require_logging();
    var subchannel_address_1 = require_subchannel_address();
    var uri_parser_1 = require_uri_parser();
    var channelz_1 = require_channelz();
    var error_1 = require_error();
    var UNLIMITED_CONNECTION_AGE_MS = ~(1 << 31);
    var KEEPALIVE_MAX_TIME_MS = ~(1 << 31);
    var KEEPALIVE_TIMEOUT_MS = 2e4;
    var { HTTP2_HEADER_PATH } = http2.constants;
    var TRACER_NAME = "server";
    function noop() {
    }
    function getUnimplementedStatusResponse(methodName) {
      return {
        code: constants_1.Status.UNIMPLEMENTED,
        details: `The server does not implement the method ${methodName}`
      };
    }
    function getDefaultHandler(handlerType, methodName) {
      const unimplementedStatusResponse = getUnimplementedStatusResponse(methodName);
      switch (handlerType) {
        case "unary":
          return (call, callback) => {
            callback(unimplementedStatusResponse, null);
          };
        case "clientStream":
          return (call, callback) => {
            callback(unimplementedStatusResponse, null);
          };
        case "serverStream":
          return (call) => {
            call.emit("error", unimplementedStatusResponse);
          };
        case "bidi":
          return (call) => {
            call.emit("error", unimplementedStatusResponse);
          };
        default:
          throw new Error(`Invalid handlerType ${handlerType}`);
      }
    }
    var Server = class {
      constructor(options) {
        var _a, _b, _c, _d;
        this.http2ServerList = [];
        this.handlers = /* @__PURE__ */ new Map();
        this.sessions = /* @__PURE__ */ new Map();
        this.started = false;
        this.serverAddressString = "null";
        this.channelzEnabled = true;
        this.channelzTrace = new channelz_1.ChannelzTrace();
        this.callTracker = new channelz_1.ChannelzCallTracker();
        this.listenerChildrenTracker = new channelz_1.ChannelzChildrenTracker();
        this.sessionChildrenTracker = new channelz_1.ChannelzChildrenTracker();
        this.options = options !== null && options !== void 0 ? options : {};
        if (this.options["grpc.enable_channelz"] === 0) {
          this.channelzEnabled = false;
        }
        this.channelzRef = (0, channelz_1.registerChannelzServer)(() => this.getChannelzInfo(), this.channelzEnabled);
        if (this.channelzEnabled) {
          this.channelzTrace.addTrace("CT_INFO", "Server created");
        }
        this.maxConnectionAgeMs = (_a = this.options["grpc.max_connection_age_ms"]) !== null && _a !== void 0 ? _a : UNLIMITED_CONNECTION_AGE_MS;
        this.maxConnectionAgeGraceMs = (_b = this.options["grpc.max_connection_age_grace_ms"]) !== null && _b !== void 0 ? _b : UNLIMITED_CONNECTION_AGE_MS;
        this.keepaliveTimeMs = (_c = this.options["grpc.keepalive_time_ms"]) !== null && _c !== void 0 ? _c : KEEPALIVE_MAX_TIME_MS;
        this.keepaliveTimeoutMs = (_d = this.options["grpc.keepalive_timeout_ms"]) !== null && _d !== void 0 ? _d : KEEPALIVE_TIMEOUT_MS;
        this.trace("Server constructed");
      }
      getChannelzInfo() {
        return {
          trace: this.channelzTrace,
          callTracker: this.callTracker,
          listenerChildren: this.listenerChildrenTracker.getChildLists(),
          sessionChildren: this.sessionChildrenTracker.getChildLists()
        };
      }
      getChannelzSessionInfoGetter(session) {
        return () => {
          var _a, _b, _c;
          const sessionInfo = this.sessions.get(session);
          const sessionSocket = session.socket;
          const remoteAddress = sessionSocket.remoteAddress ? (0, subchannel_address_1.stringToSubchannelAddress)(sessionSocket.remoteAddress, sessionSocket.remotePort) : null;
          const localAddress = sessionSocket.localAddress ? (0, subchannel_address_1.stringToSubchannelAddress)(sessionSocket.localAddress, sessionSocket.localPort) : null;
          let tlsInfo;
          if (session.encrypted) {
            const tlsSocket = sessionSocket;
            const cipherInfo = tlsSocket.getCipher();
            const certificate = tlsSocket.getCertificate();
            const peerCertificate = tlsSocket.getPeerCertificate();
            tlsInfo = {
              cipherSuiteStandardName: (_a = cipherInfo.standardName) !== null && _a !== void 0 ? _a : null,
              cipherSuiteOtherName: cipherInfo.standardName ? null : cipherInfo.name,
              localCertificate: certificate && "raw" in certificate ? certificate.raw : null,
              remoteCertificate: peerCertificate && "raw" in peerCertificate ? peerCertificate.raw : null
            };
          } else {
            tlsInfo = null;
          }
          const socketInfo = {
            remoteAddress,
            localAddress,
            security: tlsInfo,
            remoteName: null,
            streamsStarted: sessionInfo.streamTracker.callsStarted,
            streamsSucceeded: sessionInfo.streamTracker.callsSucceeded,
            streamsFailed: sessionInfo.streamTracker.callsFailed,
            messagesSent: sessionInfo.messagesSent,
            messagesReceived: sessionInfo.messagesReceived,
            keepAlivesSent: 0,
            lastLocalStreamCreatedTimestamp: null,
            lastRemoteStreamCreatedTimestamp: sessionInfo.streamTracker.lastCallStartedTimestamp,
            lastMessageSentTimestamp: sessionInfo.lastMessageSentTimestamp,
            lastMessageReceivedTimestamp: sessionInfo.lastMessageReceivedTimestamp,
            localFlowControlWindow: (_b = session.state.localWindowSize) !== null && _b !== void 0 ? _b : null,
            remoteFlowControlWindow: (_c = session.state.remoteWindowSize) !== null && _c !== void 0 ? _c : null
          };
          return socketInfo;
        };
      }
      trace(text) {
        logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, "(" + this.channelzRef.id + ") " + text);
      }
      addProtoService() {
        throw new Error("Not implemented. Use addService() instead");
      }
      addService(service, implementation) {
        if (service === null || typeof service !== "object" || implementation === null || typeof implementation !== "object") {
          throw new Error("addService() requires two objects as arguments");
        }
        const serviceKeys = Object.keys(service);
        if (serviceKeys.length === 0) {
          throw new Error("Cannot add an empty service to a server");
        }
        serviceKeys.forEach((name) => {
          const attrs = service[name];
          let methodType;
          if (attrs.requestStream) {
            if (attrs.responseStream) {
              methodType = "bidi";
            } else {
              methodType = "clientStream";
            }
          } else {
            if (attrs.responseStream) {
              methodType = "serverStream";
            } else {
              methodType = "unary";
            }
          }
          let implFn = implementation[name];
          let impl;
          if (implFn === void 0 && typeof attrs.originalName === "string") {
            implFn = implementation[attrs.originalName];
          }
          if (implFn !== void 0) {
            impl = implFn.bind(implementation);
          } else {
            impl = getDefaultHandler(methodType, name);
          }
          const success = this.register(attrs.path, impl, attrs.responseSerialize, attrs.requestDeserialize, methodType);
          if (success === false) {
            throw new Error(`Method handler for ${attrs.path} already provided.`);
          }
        });
      }
      removeService(service) {
        if (service === null || typeof service !== "object") {
          throw new Error("removeService() requires object as argument");
        }
        const serviceKeys = Object.keys(service);
        serviceKeys.forEach((name) => {
          const attrs = service[name];
          this.unregister(attrs.path);
        });
      }
      bind(port, creds) {
        throw new Error("Not implemented. Use bindAsync() instead");
      }
      bindAsync(port, creds, callback) {
        if (this.started === true) {
          throw new Error("server is already started");
        }
        if (typeof port !== "string") {
          throw new TypeError("port must be a string");
        }
        if (creds === null || !(creds instanceof server_credentials_1.ServerCredentials)) {
          throw new TypeError("creds must be a ServerCredentials object");
        }
        if (typeof callback !== "function") {
          throw new TypeError("callback must be a function");
        }
        const initialPortUri = (0, uri_parser_1.parseUri)(port);
        if (initialPortUri === null) {
          throw new Error(`Could not parse port "${port}"`);
        }
        const portUri = (0, resolver_1.mapUriDefaultScheme)(initialPortUri);
        if (portUri === null) {
          throw new Error(`Could not get a default scheme for port "${port}"`);
        }
        const serverOptions = {
          maxSendHeaderBlockLength: Number.MAX_SAFE_INTEGER
        };
        if ("grpc-node.max_session_memory" in this.options) {
          serverOptions.maxSessionMemory = this.options["grpc-node.max_session_memory"];
        } else {
          serverOptions.maxSessionMemory = Number.MAX_SAFE_INTEGER;
        }
        if ("grpc.max_concurrent_streams" in this.options) {
          serverOptions.settings = {
            maxConcurrentStreams: this.options["grpc.max_concurrent_streams"]
          };
        }
        const deferredCallback = (error, port2) => {
          process.nextTick(() => callback(error, port2));
        };
        const setupServer = () => {
          let http2Server;
          if (creds._isSecure()) {
            const secureServerOptions = Object.assign(serverOptions, creds._getSettings());
            http2Server = http2.createSecureServer(secureServerOptions);
            http2Server.on("secureConnection", (socket) => {
              socket.on("error", (e2) => {
                this.trace("An incoming TLS connection closed with error: " + e2.message);
              });
            });
          } else {
            http2Server = http2.createServer(serverOptions);
          }
          http2Server.setTimeout(0, noop);
          this._setupHandlers(http2Server);
          return http2Server;
        };
        const bindSpecificPort = (addressList, portNum, previousCount) => {
          if (addressList.length === 0) {
            return Promise.resolve({ port: portNum, count: previousCount });
          }
          return Promise.all(addressList.map((address) => {
            this.trace("Attempting to bind " + (0, subchannel_address_1.subchannelAddressToString)(address));
            let addr;
            if ((0, subchannel_address_1.isTcpSubchannelAddress)(address)) {
              addr = {
                host: address.host,
                port: portNum
              };
            } else {
              addr = address;
            }
            const http2Server = setupServer();
            return new Promise((resolve, reject) => {
              const onError = (err) => {
                this.trace("Failed to bind " + (0, subchannel_address_1.subchannelAddressToString)(address) + " with error " + err.message);
                resolve(err);
              };
              http2Server.once("error", onError);
              http2Server.listen(addr, () => {
                const boundAddress = http2Server.address();
                let boundSubchannelAddress;
                if (typeof boundAddress === "string") {
                  boundSubchannelAddress = {
                    path: boundAddress
                  };
                } else {
                  boundSubchannelAddress = {
                    host: boundAddress.address,
                    port: boundAddress.port
                  };
                }
                let channelzRef;
                channelzRef = (0, channelz_1.registerChannelzSocket)((0, subchannel_address_1.subchannelAddressToString)(boundSubchannelAddress), () => {
                  return {
                    localAddress: boundSubchannelAddress,
                    remoteAddress: null,
                    security: null,
                    remoteName: null,
                    streamsStarted: 0,
                    streamsSucceeded: 0,
                    streamsFailed: 0,
                    messagesSent: 0,
                    messagesReceived: 0,
                    keepAlivesSent: 0,
                    lastLocalStreamCreatedTimestamp: null,
                    lastRemoteStreamCreatedTimestamp: null,
                    lastMessageSentTimestamp: null,
                    lastMessageReceivedTimestamp: null,
                    localFlowControlWindow: null,
                    remoteFlowControlWindow: null
                  };
                }, this.channelzEnabled);
                if (this.channelzEnabled) {
                  this.listenerChildrenTracker.refChild(channelzRef);
                }
                this.http2ServerList.push({ server: http2Server, channelzRef });
                this.trace("Successfully bound " + (0, subchannel_address_1.subchannelAddressToString)(boundSubchannelAddress));
                resolve("port" in boundSubchannelAddress ? boundSubchannelAddress.port : portNum);
                http2Server.removeListener("error", onError);
              });
            });
          })).then((results) => {
            let count = 0;
            for (const result of results) {
              if (typeof result === "number") {
                count += 1;
                if (result !== portNum) {
                  throw new Error("Invalid state: multiple port numbers added from single address");
                }
              }
            }
            return {
              port: portNum,
              count: count + previousCount
            };
          });
        };
        const bindWildcardPort = (addressList) => {
          if (addressList.length === 0) {
            return Promise.resolve({ port: 0, count: 0 });
          }
          const address = addressList[0];
          const http2Server = setupServer();
          return new Promise((resolve, reject) => {
            const onError = (err) => {
              this.trace("Failed to bind " + (0, subchannel_address_1.subchannelAddressToString)(address) + " with error " + err.message);
              resolve(bindWildcardPort(addressList.slice(1)));
            };
            http2Server.once("error", onError);
            http2Server.listen(address, () => {
              const boundAddress = http2Server.address();
              const boundSubchannelAddress = {
                host: boundAddress.address,
                port: boundAddress.port
              };
              let channelzRef;
              channelzRef = (0, channelz_1.registerChannelzSocket)((0, subchannel_address_1.subchannelAddressToString)(boundSubchannelAddress), () => {
                return {
                  localAddress: boundSubchannelAddress,
                  remoteAddress: null,
                  security: null,
                  remoteName: null,
                  streamsStarted: 0,
                  streamsSucceeded: 0,
                  streamsFailed: 0,
                  messagesSent: 0,
                  messagesReceived: 0,
                  keepAlivesSent: 0,
                  lastLocalStreamCreatedTimestamp: null,
                  lastRemoteStreamCreatedTimestamp: null,
                  lastMessageSentTimestamp: null,
                  lastMessageReceivedTimestamp: null,
                  localFlowControlWindow: null,
                  remoteFlowControlWindow: null
                };
              }, this.channelzEnabled);
              if (this.channelzEnabled) {
                this.listenerChildrenTracker.refChild(channelzRef);
              }
              this.http2ServerList.push({ server: http2Server, channelzRef });
              this.trace("Successfully bound " + (0, subchannel_address_1.subchannelAddressToString)(boundSubchannelAddress));
              resolve(bindSpecificPort(addressList.slice(1), boundAddress.port, 1));
              http2Server.removeListener("error", onError);
            });
          });
        };
        const resolverListener = {
          onSuccessfulResolution: (addressList, serviceConfig, serviceConfigError) => {
            resolverListener.onSuccessfulResolution = () => {
            };
            if (addressList.length === 0) {
              deferredCallback(new Error(`No addresses resolved for port ${port}`), 0);
              return;
            }
            let bindResultPromise;
            if ((0, subchannel_address_1.isTcpSubchannelAddress)(addressList[0])) {
              if (addressList[0].port === 0) {
                bindResultPromise = bindWildcardPort(addressList);
              } else {
                bindResultPromise = bindSpecificPort(addressList, addressList[0].port, 0);
              }
            } else {
              bindResultPromise = bindSpecificPort(addressList, 1, 0);
            }
            bindResultPromise.then((bindResult) => {
              if (bindResult.count === 0) {
                const errorString = `No address added out of total ${addressList.length} resolved`;
                logging.log(constants_1.LogVerbosity.ERROR, errorString);
                deferredCallback(new Error(errorString), 0);
              } else {
                if (bindResult.count < addressList.length) {
                  logging.log(constants_1.LogVerbosity.INFO, `WARNING Only ${bindResult.count} addresses added out of total ${addressList.length} resolved`);
                }
                deferredCallback(null, bindResult.port);
              }
            }, (error) => {
              const errorString = `No address added out of total ${addressList.length} resolved`;
              logging.log(constants_1.LogVerbosity.ERROR, errorString);
              deferredCallback(new Error(errorString), 0);
            });
          },
          onError: (error) => {
            deferredCallback(new Error(error.details), 0);
          }
        };
        const resolver = (0, resolver_1.createResolver)(portUri, resolverListener, this.options);
        resolver.updateResolution();
      }
      forceShutdown() {
        for (const { server: http2Server, channelzRef: ref } of this.http2ServerList) {
          if (http2Server.listening) {
            http2Server.close(() => {
              if (this.channelzEnabled) {
                this.listenerChildrenTracker.unrefChild(ref);
                (0, channelz_1.unregisterChannelzRef)(ref);
              }
            });
          }
        }
        this.started = false;
        this.sessions.forEach((channelzInfo, session) => {
          session.destroy(http2.constants.NGHTTP2_CANCEL);
        });
        this.sessions.clear();
        if (this.channelzEnabled) {
          (0, channelz_1.unregisterChannelzRef)(this.channelzRef);
        }
      }
      register(name, handler2, serialize, deserialize, type) {
        if (this.handlers.has(name)) {
          return false;
        }
        this.handlers.set(name, {
          func: handler2,
          serialize,
          deserialize,
          type,
          path: name
        });
        return true;
      }
      unregister(name) {
        return this.handlers.delete(name);
      }
      start() {
        if (this.http2ServerList.length === 0 || this.http2ServerList.every(({ server: http2Server }) => http2Server.listening !== true)) {
          throw new Error("server must be bound in order to start");
        }
        if (this.started === true) {
          throw new Error("server is already started");
        }
        if (this.channelzEnabled) {
          this.channelzTrace.addTrace("CT_INFO", "Starting");
        }
        this.started = true;
      }
      tryShutdown(callback) {
        const wrappedCallback = (error) => {
          if (this.channelzEnabled) {
            (0, channelz_1.unregisterChannelzRef)(this.channelzRef);
          }
          callback(error);
        };
        let pendingChecks = 0;
        function maybeCallback() {
          pendingChecks--;
          if (pendingChecks === 0) {
            wrappedCallback();
          }
        }
        this.started = false;
        for (const { server: http2Server, channelzRef: ref } of this.http2ServerList) {
          if (http2Server.listening) {
            pendingChecks++;
            http2Server.close(() => {
              if (this.channelzEnabled) {
                this.listenerChildrenTracker.unrefChild(ref);
                (0, channelz_1.unregisterChannelzRef)(ref);
              }
              maybeCallback();
            });
          }
        }
        this.sessions.forEach((channelzInfo, session) => {
          if (!session.closed) {
            pendingChecks += 1;
            session.close(maybeCallback);
          }
        });
        if (pendingChecks === 0) {
          wrappedCallback();
        }
      }
      addHttp2Port() {
        throw new Error("Not yet implemented");
      }
      /**
       * Get the channelz reference object for this server. The returned value is
       * garbage if channelz is disabled for this server.
       * @returns
       */
      getChannelzRef() {
        return this.channelzRef;
      }
      _verifyContentType(stream, headers) {
        const contentType = headers[http2.constants.HTTP2_HEADER_CONTENT_TYPE];
        if (typeof contentType !== "string" || !contentType.startsWith("application/grpc")) {
          stream.respond({
            [http2.constants.HTTP2_HEADER_STATUS]: http2.constants.HTTP_STATUS_UNSUPPORTED_MEDIA_TYPE
          }, { endStream: true });
          return false;
        }
        return true;
      }
      _retrieveHandler(headers) {
        const path2 = headers[HTTP2_HEADER_PATH];
        this.trace("Received call to method " + path2 + " at address " + this.serverAddressString);
        const handler2 = this.handlers.get(path2);
        if (handler2 === void 0) {
          this.trace("No handler registered for method " + path2 + ". Sending UNIMPLEMENTED status.");
          throw getUnimplementedStatusResponse(path2);
        }
        return handler2;
      }
      _respondWithError(err, stream, channelzSessionInfo = null) {
        const call = new server_call_1.Http2ServerCallStream(stream, null, this.options);
        if (err.code === void 0) {
          err.code = constants_1.Status.INTERNAL;
        }
        if (this.channelzEnabled) {
          this.callTracker.addCallFailed();
          channelzSessionInfo === null || channelzSessionInfo === void 0 ? void 0 : channelzSessionInfo.streamTracker.addCallFailed();
        }
        call.sendError(err);
      }
      _channelzHandler(stream, headers) {
        var _a;
        const channelzSessionInfo = this.sessions.get(stream.session);
        this.callTracker.addCallStarted();
        channelzSessionInfo === null || channelzSessionInfo === void 0 ? void 0 : channelzSessionInfo.streamTracker.addCallStarted();
        if (!this._verifyContentType(stream, headers)) {
          this.callTracker.addCallFailed();
          channelzSessionInfo === null || channelzSessionInfo === void 0 ? void 0 : channelzSessionInfo.streamTracker.addCallFailed();
          return;
        }
        let handler2;
        try {
          handler2 = this._retrieveHandler(headers);
        } catch (err) {
          this._respondWithError({
            details: (0, error_1.getErrorMessage)(err),
            code: (_a = (0, error_1.getErrorCode)(err)) !== null && _a !== void 0 ? _a : void 0
          }, stream, channelzSessionInfo);
          return;
        }
        const call = new server_call_1.Http2ServerCallStream(stream, handler2, this.options);
        call.once("callEnd", (code) => {
          if (code === constants_1.Status.OK) {
            this.callTracker.addCallSucceeded();
          } else {
            this.callTracker.addCallFailed();
          }
        });
        if (channelzSessionInfo) {
          call.once("streamEnd", (success) => {
            if (success) {
              channelzSessionInfo.streamTracker.addCallSucceeded();
            } else {
              channelzSessionInfo.streamTracker.addCallFailed();
            }
          });
          call.on("sendMessage", () => {
            channelzSessionInfo.messagesSent += 1;
            channelzSessionInfo.lastMessageSentTimestamp = new Date();
          });
          call.on("receiveMessage", () => {
            channelzSessionInfo.messagesReceived += 1;
            channelzSessionInfo.lastMessageReceivedTimestamp = new Date();
          });
        }
        if (!this._runHandlerForCall(call, handler2, headers)) {
          this.callTracker.addCallFailed();
          channelzSessionInfo === null || channelzSessionInfo === void 0 ? void 0 : channelzSessionInfo.streamTracker.addCallFailed();
          call.sendError({
            code: constants_1.Status.INTERNAL,
            details: `Unknown handler type: ${handler2.type}`
          });
        }
      }
      _streamHandler(stream, headers) {
        var _a;
        if (this._verifyContentType(stream, headers) !== true) {
          return;
        }
        let handler2;
        try {
          handler2 = this._retrieveHandler(headers);
        } catch (err) {
          this._respondWithError({
            details: (0, error_1.getErrorMessage)(err),
            code: (_a = (0, error_1.getErrorCode)(err)) !== null && _a !== void 0 ? _a : void 0
          }, stream, null);
          return;
        }
        const call = new server_call_1.Http2ServerCallStream(stream, handler2, this.options);
        if (!this._runHandlerForCall(call, handler2, headers)) {
          call.sendError({
            code: constants_1.Status.INTERNAL,
            details: `Unknown handler type: ${handler2.type}`
          });
        }
      }
      _runHandlerForCall(call, handler2, headers) {
        var _a;
        const metadata = call.receiveMetadata(headers);
        const encoding = (_a = metadata.get("grpc-encoding")[0]) !== null && _a !== void 0 ? _a : "identity";
        metadata.remove("grpc-encoding");
        const { type } = handler2;
        if (type === "unary") {
          handleUnary(call, handler2, metadata, encoding);
        } else if (type === "clientStream") {
          handleClientStreaming(call, handler2, metadata, encoding);
        } else if (type === "serverStream") {
          handleServerStreaming(call, handler2, metadata, encoding);
        } else if (type === "bidi") {
          handleBidiStreaming(call, handler2, metadata, encoding);
        } else {
          return false;
        }
        return true;
      }
      _setupHandlers(http2Server) {
        if (http2Server === null) {
          return;
        }
        const serverAddress = http2Server.address();
        let serverAddressString = "null";
        if (serverAddress) {
          if (typeof serverAddress === "string") {
            serverAddressString = serverAddress;
          } else {
            serverAddressString = serverAddress.address + ":" + serverAddress.port;
          }
        }
        this.serverAddressString = serverAddressString;
        const handler2 = this.channelzEnabled ? this._channelzHandler : this._streamHandler;
        http2Server.on("stream", handler2.bind(this));
        http2Server.on("session", (session) => {
          var _a, _b, _c, _d, _e;
          if (!this.started) {
            session.destroy();
            return;
          }
          let channelzRef;
          channelzRef = (0, channelz_1.registerChannelzSocket)((_a = session.socket.remoteAddress) !== null && _a !== void 0 ? _a : "unknown", this.getChannelzSessionInfoGetter(session), this.channelzEnabled);
          const channelzSessionInfo = {
            ref: channelzRef,
            streamTracker: new channelz_1.ChannelzCallTracker(),
            messagesSent: 0,
            messagesReceived: 0,
            lastMessageSentTimestamp: null,
            lastMessageReceivedTimestamp: null
          };
          this.sessions.set(session, channelzSessionInfo);
          const clientAddress = session.socket.remoteAddress;
          if (this.channelzEnabled) {
            this.channelzTrace.addTrace("CT_INFO", "Connection established by client " + clientAddress);
            this.sessionChildrenTracker.refChild(channelzRef);
          }
          let connectionAgeTimer = null;
          let connectionAgeGraceTimer = null;
          let sessionClosedByServer = false;
          if (this.maxConnectionAgeMs !== UNLIMITED_CONNECTION_AGE_MS) {
            const jitterMagnitude = this.maxConnectionAgeMs / 10;
            const jitter = Math.random() * jitterMagnitude * 2 - jitterMagnitude;
            connectionAgeTimer = (_c = (_b = setTimeout(() => {
              var _a2, _b2;
              sessionClosedByServer = true;
              if (this.channelzEnabled) {
                this.channelzTrace.addTrace("CT_INFO", "Connection dropped by max connection age from " + clientAddress);
              }
              try {
                session.goaway(http2.constants.NGHTTP2_NO_ERROR, ~(1 << 31), Buffer.from("max_age"));
              } catch (e2) {
                session.destroy();
                return;
              }
              session.close();
              if (this.maxConnectionAgeGraceMs !== UNLIMITED_CONNECTION_AGE_MS) {
                connectionAgeGraceTimer = (_b2 = (_a2 = setTimeout(() => {
                  session.destroy();
                }, this.maxConnectionAgeGraceMs)).unref) === null || _b2 === void 0 ? void 0 : _b2.call(_a2);
              }
            }, this.maxConnectionAgeMs + jitter)).unref) === null || _c === void 0 ? void 0 : _c.call(_b);
          }
          const keeapliveTimeTimer = (_e = (_d = setInterval(() => {
            var _a2, _b2;
            const timeoutTImer = (_b2 = (_a2 = setTimeout(() => {
              sessionClosedByServer = true;
              if (this.channelzEnabled) {
                this.channelzTrace.addTrace("CT_INFO", "Connection dropped by keepalive timeout from " + clientAddress);
              }
              session.close();
            }, this.keepaliveTimeoutMs)).unref) === null || _b2 === void 0 ? void 0 : _b2.call(_a2);
            try {
              session.ping((err, duration, payload) => {
                clearTimeout(timeoutTImer);
              });
            } catch (e2) {
              session.destroy();
            }
          }, this.keepaliveTimeMs)).unref) === null || _e === void 0 ? void 0 : _e.call(_d);
          session.on("close", () => {
            if (this.channelzEnabled) {
              if (!sessionClosedByServer) {
                this.channelzTrace.addTrace("CT_INFO", "Connection dropped by client " + clientAddress);
              }
              this.sessionChildrenTracker.unrefChild(channelzRef);
              (0, channelz_1.unregisterChannelzRef)(channelzRef);
            }
            if (connectionAgeTimer) {
              clearTimeout(connectionAgeTimer);
            }
            if (connectionAgeGraceTimer) {
              clearTimeout(connectionAgeGraceTimer);
            }
            if (keeapliveTimeTimer) {
              clearTimeout(keeapliveTimeTimer);
            }
            this.sessions.delete(session);
          });
        });
      }
    };
    exports2.Server = Server;
    function handleUnary(call, handler2, metadata, encoding) {
      call.receiveUnaryMessage(encoding, (err, request) => {
        if (err) {
          call.sendError(err);
          return;
        }
        if (request === void 0 || call.cancelled) {
          return;
        }
        const emitter = new server_call_1.ServerUnaryCallImpl(call, metadata, request);
        handler2.func(emitter, (err2, value, trailer, flags) => {
          call.sendUnaryMessage(err2, value, trailer, flags);
        });
      });
    }
    function handleClientStreaming(call, handler2, metadata, encoding) {
      const stream = new server_call_1.ServerReadableStreamImpl(call, metadata, handler2.deserialize, encoding);
      function respond(err, value, trailer, flags) {
        stream.destroy();
        call.sendUnaryMessage(err, value, trailer, flags);
      }
      if (call.cancelled) {
        return;
      }
      stream.on("error", respond);
      handler2.func(stream, respond);
    }
    function handleServerStreaming(call, handler2, metadata, encoding) {
      call.receiveUnaryMessage(encoding, (err, request) => {
        if (err) {
          call.sendError(err);
          return;
        }
        if (request === void 0 || call.cancelled) {
          return;
        }
        const stream = new server_call_1.ServerWritableStreamImpl(call, metadata, handler2.serialize, request);
        handler2.func(stream);
      });
    }
    function handleBidiStreaming(call, handler2, metadata, encoding) {
      const stream = new server_call_1.ServerDuplexStreamImpl(call, metadata, handler2.serialize, handler2.deserialize, encoding);
      if (call.cancelled) {
        return;
      }
      handler2.func(stream);
    }
  }
});

// node_modules/@grpc/grpc-js/build/src/status-builder.js
var require_status_builder = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/status-builder.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.StatusBuilder = void 0;
    var StatusBuilder = class {
      constructor() {
        this.code = null;
        this.details = null;
        this.metadata = null;
      }
      /**
       * Adds a status code to the builder.
       */
      withCode(code) {
        this.code = code;
        return this;
      }
      /**
       * Adds details to the builder.
       */
      withDetails(details) {
        this.details = details;
        return this;
      }
      /**
       * Adds metadata to the builder.
       */
      withMetadata(metadata) {
        this.metadata = metadata;
        return this;
      }
      /**
       * Builds the status object.
       */
      build() {
        const status = {};
        if (this.code !== null) {
          status.code = this.code;
        }
        if (this.details !== null) {
          status.details = this.details;
        }
        if (this.metadata !== null) {
          status.metadata = this.metadata;
        }
        return status;
      }
    };
    exports2.StatusBuilder = StatusBuilder;
  }
});

// node_modules/@grpc/grpc-js/build/src/duration.js
var require_duration = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/duration.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isDuration = exports2.durationToMs = exports2.msToDuration = void 0;
    function msToDuration(millis) {
      return {
        seconds: millis / 1e3 | 0,
        nanos: millis % 1e3 * 1e6 | 0
      };
    }
    exports2.msToDuration = msToDuration;
    function durationToMs(duration) {
      return duration.seconds * 1e3 + duration.nanos / 1e6 | 0;
    }
    exports2.durationToMs = durationToMs;
    function isDuration(value) {
      return typeof value.seconds === "number" && typeof value.nanos === "number";
    }
    exports2.isDuration = isDuration;
  }
});

// node_modules/@grpc/grpc-js/build/src/subchannel-interface.js
var require_subchannel_interface = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/subchannel-interface.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.BaseSubchannelWrapper = void 0;
    var BaseSubchannelWrapper = class {
      constructor(child) {
        this.child = child;
      }
      getConnectivityState() {
        return this.child.getConnectivityState();
      }
      addConnectivityStateListener(listener) {
        this.child.addConnectivityStateListener(listener);
      }
      removeConnectivityStateListener(listener) {
        this.child.removeConnectivityStateListener(listener);
      }
      startConnecting() {
        this.child.startConnecting();
      }
      getAddress() {
        return this.child.getAddress();
      }
      ref() {
        this.child.ref();
      }
      unref() {
        this.child.unref();
      }
      getChannelzRef() {
        return this.child.getChannelzRef();
      }
      getRealSubchannel() {
        return this.child.getRealSubchannel();
      }
    };
    exports2.BaseSubchannelWrapper = BaseSubchannelWrapper;
  }
});

// node_modules/@grpc/grpc-js/build/src/load-balancer-outlier-detection.js
var require_load_balancer_outlier_detection = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/load-balancer-outlier-detection.js"(exports2) {
    "use strict";
    var _a;
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.setup = exports2.OutlierDetectionLoadBalancer = exports2.OutlierDetectionLoadBalancingConfig = void 0;
    var connectivity_state_1 = require_connectivity_state();
    var constants_1 = require_constants();
    var duration_1 = require_duration();
    var experimental_1 = require_experimental();
    var load_balancer_1 = require_load_balancer();
    var load_balancer_child_handler_1 = require_load_balancer_child_handler();
    var picker_1 = require_picker();
    var subchannel_address_1 = require_subchannel_address();
    var subchannel_interface_1 = require_subchannel_interface();
    var logging = require_logging();
    var TRACER_NAME = "outlier_detection";
    function trace(text) {
      logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, text);
    }
    var TYPE_NAME = "outlier_detection";
    var OUTLIER_DETECTION_ENABLED = ((_a = process.env.GRPC_EXPERIMENTAL_ENABLE_OUTLIER_DETECTION) !== null && _a !== void 0 ? _a : "true") === "true";
    var defaultSuccessRateEjectionConfig = {
      stdev_factor: 1900,
      enforcement_percentage: 100,
      minimum_hosts: 5,
      request_volume: 100
    };
    var defaultFailurePercentageEjectionConfig = {
      threshold: 85,
      enforcement_percentage: 100,
      minimum_hosts: 5,
      request_volume: 50
    };
    function validateFieldType(obj, fieldName, expectedType, objectName) {
      if (fieldName in obj && typeof obj[fieldName] !== expectedType) {
        const fullFieldName = objectName ? `${objectName}.${fieldName}` : fieldName;
        throw new Error(`outlier detection config ${fullFieldName} parse error: expected ${expectedType}, got ${typeof obj[fieldName]}`);
      }
    }
    function validatePositiveDuration(obj, fieldName, objectName) {
      const fullFieldName = objectName ? `${objectName}.${fieldName}` : fieldName;
      if (fieldName in obj) {
        if (!(0, duration_1.isDuration)(obj[fieldName])) {
          throw new Error(`outlier detection config ${fullFieldName} parse error: expected Duration, got ${typeof obj[fieldName]}`);
        }
        if (!(obj[fieldName].seconds >= 0 && obj[fieldName].seconds <= 315576e6 && obj[fieldName].nanos >= 0 && obj[fieldName].nanos <= 999999999)) {
          throw new Error(`outlier detection config ${fullFieldName} parse error: values out of range for non-negative Duaration`);
        }
      }
    }
    function validatePercentage(obj, fieldName, objectName) {
      const fullFieldName = objectName ? `${objectName}.${fieldName}` : fieldName;
      validateFieldType(obj, fieldName, "number", objectName);
      if (fieldName in obj && !(obj[fieldName] >= 0 && obj[fieldName] <= 100)) {
        throw new Error(`outlier detection config ${fullFieldName} parse error: value out of range for percentage (0-100)`);
      }
    }
    var OutlierDetectionLoadBalancingConfig = class {
      constructor(intervalMs, baseEjectionTimeMs, maxEjectionTimeMs, maxEjectionPercent, successRateEjection, failurePercentageEjection, childPolicy) {
        this.childPolicy = childPolicy;
        this.intervalMs = intervalMs !== null && intervalMs !== void 0 ? intervalMs : 1e4;
        this.baseEjectionTimeMs = baseEjectionTimeMs !== null && baseEjectionTimeMs !== void 0 ? baseEjectionTimeMs : 3e4;
        this.maxEjectionTimeMs = maxEjectionTimeMs !== null && maxEjectionTimeMs !== void 0 ? maxEjectionTimeMs : 3e5;
        this.maxEjectionPercent = maxEjectionPercent !== null && maxEjectionPercent !== void 0 ? maxEjectionPercent : 10;
        this.successRateEjection = successRateEjection ? Object.assign(Object.assign({}, defaultSuccessRateEjectionConfig), successRateEjection) : null;
        this.failurePercentageEjection = failurePercentageEjection ? Object.assign(Object.assign({}, defaultFailurePercentageEjectionConfig), failurePercentageEjection) : null;
      }
      getLoadBalancerName() {
        return TYPE_NAME;
      }
      toJsonObject() {
        return {
          interval: (0, duration_1.msToDuration)(this.intervalMs),
          base_ejection_time: (0, duration_1.msToDuration)(this.baseEjectionTimeMs),
          max_ejection_time: (0, duration_1.msToDuration)(this.maxEjectionTimeMs),
          max_ejection_percent: this.maxEjectionPercent,
          success_rate_ejection: this.successRateEjection,
          failure_percentage_ejection: this.failurePercentageEjection,
          child_policy: this.childPolicy.map((policy) => policy.toJsonObject())
        };
      }
      getIntervalMs() {
        return this.intervalMs;
      }
      getBaseEjectionTimeMs() {
        return this.baseEjectionTimeMs;
      }
      getMaxEjectionTimeMs() {
        return this.maxEjectionTimeMs;
      }
      getMaxEjectionPercent() {
        return this.maxEjectionPercent;
      }
      getSuccessRateEjectionConfig() {
        return this.successRateEjection;
      }
      getFailurePercentageEjectionConfig() {
        return this.failurePercentageEjection;
      }
      getChildPolicy() {
        return this.childPolicy;
      }
      copyWithChildPolicy(childPolicy) {
        return new OutlierDetectionLoadBalancingConfig(this.intervalMs, this.baseEjectionTimeMs, this.maxEjectionTimeMs, this.maxEjectionPercent, this.successRateEjection, this.failurePercentageEjection, childPolicy);
      }
      static createFromJson(obj) {
        var _a2;
        validatePositiveDuration(obj, "interval");
        validatePositiveDuration(obj, "base_ejection_time");
        validatePositiveDuration(obj, "max_ejection_time");
        validatePercentage(obj, "max_ejection_percent");
        if ("success_rate_ejection" in obj) {
          if (typeof obj.success_rate_ejection !== "object") {
            throw new Error("outlier detection config success_rate_ejection must be an object");
          }
          validateFieldType(obj.success_rate_ejection, "stdev_factor", "number", "success_rate_ejection");
          validatePercentage(obj.success_rate_ejection, "enforcement_percentage", "success_rate_ejection");
          validateFieldType(obj.success_rate_ejection, "minimum_hosts", "number", "success_rate_ejection");
          validateFieldType(obj.success_rate_ejection, "request_volume", "number", "success_rate_ejection");
        }
        if ("failure_percentage_ejection" in obj) {
          if (typeof obj.failure_percentage_ejection !== "object") {
            throw new Error("outlier detection config failure_percentage_ejection must be an object");
          }
          validatePercentage(obj.failure_percentage_ejection, "threshold", "failure_percentage_ejection");
          validatePercentage(obj.failure_percentage_ejection, "enforcement_percentage", "failure_percentage_ejection");
          validateFieldType(obj.failure_percentage_ejection, "minimum_hosts", "number", "failure_percentage_ejection");
          validateFieldType(obj.failure_percentage_ejection, "request_volume", "number", "failure_percentage_ejection");
        }
        return new OutlierDetectionLoadBalancingConfig(obj.interval ? (0, duration_1.durationToMs)(obj.interval) : null, obj.base_ejection_time ? (0, duration_1.durationToMs)(obj.base_ejection_time) : null, obj.max_ejection_time ? (0, duration_1.durationToMs)(obj.max_ejection_time) : null, (_a2 = obj.max_ejection_percent) !== null && _a2 !== void 0 ? _a2 : null, obj.success_rate_ejection, obj.failure_percentage_ejection, obj.child_policy.map(load_balancer_1.validateLoadBalancingConfig));
      }
    };
    exports2.OutlierDetectionLoadBalancingConfig = OutlierDetectionLoadBalancingConfig;
    var OutlierDetectionSubchannelWrapper = class extends subchannel_interface_1.BaseSubchannelWrapper {
      constructor(childSubchannel, mapEntry) {
        super(childSubchannel);
        this.mapEntry = mapEntry;
        this.stateListeners = [];
        this.ejected = false;
        this.refCount = 0;
        this.childSubchannelState = childSubchannel.getConnectivityState();
        childSubchannel.addConnectivityStateListener((subchannel, previousState, newState) => {
          this.childSubchannelState = newState;
          if (!this.ejected) {
            for (const listener of this.stateListeners) {
              listener(this, previousState, newState);
            }
          }
        });
      }
      getConnectivityState() {
        if (this.ejected) {
          return connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE;
        } else {
          return this.childSubchannelState;
        }
      }
      /**
       * Add a listener function to be called whenever the wrapper's
       * connectivity state changes.
       * @param listener
       */
      addConnectivityStateListener(listener) {
        this.stateListeners.push(listener);
      }
      /**
       * Remove a listener previously added with `addConnectivityStateListener`
       * @param listener A reference to a function previously passed to
       *     `addConnectivityStateListener`
       */
      removeConnectivityStateListener(listener) {
        const listenerIndex = this.stateListeners.indexOf(listener);
        if (listenerIndex > -1) {
          this.stateListeners.splice(listenerIndex, 1);
        }
      }
      ref() {
        this.child.ref();
        this.refCount += 1;
      }
      unref() {
        this.child.unref();
        this.refCount -= 1;
        if (this.refCount <= 0) {
          if (this.mapEntry) {
            const index = this.mapEntry.subchannelWrappers.indexOf(this);
            if (index >= 0) {
              this.mapEntry.subchannelWrappers.splice(index, 1);
            }
          }
        }
      }
      eject() {
        this.ejected = true;
        for (const listener of this.stateListeners) {
          listener(this, this.childSubchannelState, connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE);
        }
      }
      uneject() {
        this.ejected = false;
        for (const listener of this.stateListeners) {
          listener(this, connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE, this.childSubchannelState);
        }
      }
      getMapEntry() {
        return this.mapEntry;
      }
      getWrappedSubchannel() {
        return this.child;
      }
    };
    function createEmptyBucket() {
      return {
        success: 0,
        failure: 0
      };
    }
    var CallCounter = class {
      constructor() {
        this.activeBucket = createEmptyBucket();
        this.inactiveBucket = createEmptyBucket();
      }
      addSuccess() {
        this.activeBucket.success += 1;
      }
      addFailure() {
        this.activeBucket.failure += 1;
      }
      switchBuckets() {
        this.inactiveBucket = this.activeBucket;
        this.activeBucket = createEmptyBucket();
      }
      getLastSuccesses() {
        return this.inactiveBucket.success;
      }
      getLastFailures() {
        return this.inactiveBucket.failure;
      }
    };
    var OutlierDetectionPicker = class {
      constructor(wrappedPicker, countCalls) {
        this.wrappedPicker = wrappedPicker;
        this.countCalls = countCalls;
      }
      pick(pickArgs) {
        const wrappedPick = this.wrappedPicker.pick(pickArgs);
        if (wrappedPick.pickResultType === picker_1.PickResultType.COMPLETE) {
          const subchannelWrapper = wrappedPick.subchannel;
          const mapEntry = subchannelWrapper.getMapEntry();
          if (mapEntry) {
            let onCallEnded = wrappedPick.onCallEnded;
            if (this.countCalls) {
              onCallEnded = (statusCode) => {
                var _a2;
                if (statusCode === constants_1.Status.OK) {
                  mapEntry.counter.addSuccess();
                } else {
                  mapEntry.counter.addFailure();
                }
                (_a2 = wrappedPick.onCallEnded) === null || _a2 === void 0 ? void 0 : _a2.call(wrappedPick, statusCode);
              };
            }
            return Object.assign(Object.assign({}, wrappedPick), { subchannel: subchannelWrapper.getWrappedSubchannel(), onCallEnded });
          } else {
            return Object.assign(Object.assign({}, wrappedPick), { subchannel: subchannelWrapper.getWrappedSubchannel() });
          }
        } else {
          return wrappedPick;
        }
      }
    };
    var OutlierDetectionLoadBalancer = class {
      constructor(channelControlHelper) {
        this.addressMap = /* @__PURE__ */ new Map();
        this.latestConfig = null;
        this.timerStartTime = null;
        this.childBalancer = new load_balancer_child_handler_1.ChildLoadBalancerHandler((0, experimental_1.createChildChannelControlHelper)(channelControlHelper, {
          createSubchannel: (subchannelAddress, subchannelArgs) => {
            const originalSubchannel = channelControlHelper.createSubchannel(subchannelAddress, subchannelArgs);
            const mapEntry = this.addressMap.get((0, subchannel_address_1.subchannelAddressToString)(subchannelAddress));
            const subchannelWrapper = new OutlierDetectionSubchannelWrapper(originalSubchannel, mapEntry);
            if ((mapEntry === null || mapEntry === void 0 ? void 0 : mapEntry.currentEjectionTimestamp) !== null) {
              subchannelWrapper.eject();
            }
            mapEntry === null || mapEntry === void 0 ? void 0 : mapEntry.subchannelWrappers.push(subchannelWrapper);
            return subchannelWrapper;
          },
          updateState: (connectivityState, picker) => {
            if (connectivityState === connectivity_state_1.ConnectivityState.READY) {
              channelControlHelper.updateState(connectivityState, new OutlierDetectionPicker(picker, this.isCountingEnabled()));
            } else {
              channelControlHelper.updateState(connectivityState, picker);
            }
          }
        }));
        this.ejectionTimer = setInterval(() => {
        }, 0);
        clearInterval(this.ejectionTimer);
      }
      isCountingEnabled() {
        return this.latestConfig !== null && (this.latestConfig.getSuccessRateEjectionConfig() !== null || this.latestConfig.getFailurePercentageEjectionConfig() !== null);
      }
      getCurrentEjectionPercent() {
        let ejectionCount = 0;
        for (const mapEntry of this.addressMap.values()) {
          if (mapEntry.currentEjectionTimestamp !== null) {
            ejectionCount += 1;
          }
        }
        return ejectionCount * 100 / this.addressMap.size;
      }
      runSuccessRateCheck(ejectionTimestamp) {
        if (!this.latestConfig) {
          return;
        }
        const successRateConfig = this.latestConfig.getSuccessRateEjectionConfig();
        if (!successRateConfig) {
          return;
        }
        trace("Running success rate check");
        const targetRequestVolume = successRateConfig.request_volume;
        let addresesWithTargetVolume = 0;
        const successRates = [];
        for (const [address, mapEntry] of this.addressMap) {
          const successes = mapEntry.counter.getLastSuccesses();
          const failures = mapEntry.counter.getLastFailures();
          trace("Stats for " + address + ": successes=" + successes + " failures=" + failures + " targetRequestVolume=" + targetRequestVolume);
          if (successes + failures >= targetRequestVolume) {
            addresesWithTargetVolume += 1;
            successRates.push(successes / (successes + failures));
          }
        }
        trace("Found " + addresesWithTargetVolume + " success rate candidates; currentEjectionPercent=" + this.getCurrentEjectionPercent() + " successRates=[" + successRates + "]");
        if (addresesWithTargetVolume < successRateConfig.minimum_hosts) {
          return;
        }
        const successRateMean = successRates.reduce((a2, b2) => a2 + b2) / successRates.length;
        let successRateDeviationSum = 0;
        for (const rate of successRates) {
          const deviation = rate - successRateMean;
          successRateDeviationSum += deviation * deviation;
        }
        const successRateVariance = successRateDeviationSum / successRates.length;
        const successRateStdev = Math.sqrt(successRateVariance);
        const ejectionThreshold = successRateMean - successRateStdev * (successRateConfig.stdev_factor / 1e3);
        trace("stdev=" + successRateStdev + " ejectionThreshold=" + ejectionThreshold);
        for (const [address, mapEntry] of this.addressMap.entries()) {
          if (this.getCurrentEjectionPercent() >= this.latestConfig.getMaxEjectionPercent()) {
            break;
          }
          const successes = mapEntry.counter.getLastSuccesses();
          const failures = mapEntry.counter.getLastFailures();
          if (successes + failures < targetRequestVolume) {
            continue;
          }
          const successRate = successes / (successes + failures);
          trace("Checking candidate " + address + " successRate=" + successRate);
          if (successRate < ejectionThreshold) {
            const randomNumber = Math.random() * 100;
            trace("Candidate " + address + " randomNumber=" + randomNumber + " enforcement_percentage=" + successRateConfig.enforcement_percentage);
            if (randomNumber < successRateConfig.enforcement_percentage) {
              trace("Ejecting candidate " + address);
              this.eject(mapEntry, ejectionTimestamp);
            }
          }
        }
      }
      runFailurePercentageCheck(ejectionTimestamp) {
        if (!this.latestConfig) {
          return;
        }
        const failurePercentageConfig = this.latestConfig.getFailurePercentageEjectionConfig();
        if (!failurePercentageConfig) {
          return;
        }
        trace("Running failure percentage check. threshold=" + failurePercentageConfig.threshold + " request volume threshold=" + failurePercentageConfig.request_volume);
        let addressesWithTargetVolume = 0;
        for (const mapEntry of this.addressMap.values()) {
          const successes = mapEntry.counter.getLastSuccesses();
          const failures = mapEntry.counter.getLastFailures();
          if (successes + failures >= failurePercentageConfig.request_volume) {
            addressesWithTargetVolume += 1;
          }
        }
        if (addressesWithTargetVolume < failurePercentageConfig.minimum_hosts) {
          return;
        }
        for (const [address, mapEntry] of this.addressMap.entries()) {
          if (this.getCurrentEjectionPercent() >= this.latestConfig.getMaxEjectionPercent()) {
            break;
          }
          const successes = mapEntry.counter.getLastSuccesses();
          const failures = mapEntry.counter.getLastFailures();
          trace("Candidate successes=" + successes + " failures=" + failures);
          if (successes + failures < failurePercentageConfig.request_volume) {
            continue;
          }
          const failurePercentage = failures * 100 / (failures + successes);
          if (failurePercentage > failurePercentageConfig.threshold) {
            const randomNumber = Math.random() * 100;
            trace("Candidate " + address + " randomNumber=" + randomNumber + " enforcement_percentage=" + failurePercentageConfig.enforcement_percentage);
            if (randomNumber < failurePercentageConfig.enforcement_percentage) {
              trace("Ejecting candidate " + address);
              this.eject(mapEntry, ejectionTimestamp);
            }
          }
        }
      }
      eject(mapEntry, ejectionTimestamp) {
        mapEntry.currentEjectionTimestamp = new Date();
        mapEntry.ejectionTimeMultiplier += 1;
        for (const subchannelWrapper of mapEntry.subchannelWrappers) {
          subchannelWrapper.eject();
        }
      }
      uneject(mapEntry) {
        mapEntry.currentEjectionTimestamp = null;
        for (const subchannelWrapper of mapEntry.subchannelWrappers) {
          subchannelWrapper.uneject();
        }
      }
      switchAllBuckets() {
        for (const mapEntry of this.addressMap.values()) {
          mapEntry.counter.switchBuckets();
        }
      }
      startTimer(delayMs) {
        var _a2, _b;
        this.ejectionTimer = setTimeout(() => this.runChecks(), delayMs);
        (_b = (_a2 = this.ejectionTimer).unref) === null || _b === void 0 ? void 0 : _b.call(_a2);
      }
      runChecks() {
        const ejectionTimestamp = new Date();
        trace("Ejection timer running");
        this.switchAllBuckets();
        if (!this.latestConfig) {
          return;
        }
        this.timerStartTime = ejectionTimestamp;
        this.startTimer(this.latestConfig.getIntervalMs());
        this.runSuccessRateCheck(ejectionTimestamp);
        this.runFailurePercentageCheck(ejectionTimestamp);
        for (const [address, mapEntry] of this.addressMap.entries()) {
          if (mapEntry.currentEjectionTimestamp === null) {
            if (mapEntry.ejectionTimeMultiplier > 0) {
              mapEntry.ejectionTimeMultiplier -= 1;
            }
          } else {
            const baseEjectionTimeMs = this.latestConfig.getBaseEjectionTimeMs();
            const maxEjectionTimeMs = this.latestConfig.getMaxEjectionTimeMs();
            const returnTime = new Date(mapEntry.currentEjectionTimestamp.getTime());
            returnTime.setMilliseconds(returnTime.getMilliseconds() + Math.min(baseEjectionTimeMs * mapEntry.ejectionTimeMultiplier, Math.max(baseEjectionTimeMs, maxEjectionTimeMs)));
            if (returnTime < new Date()) {
              trace("Unejecting " + address);
              this.uneject(mapEntry);
            }
          }
        }
      }
      updateAddressList(addressList, lbConfig, attributes) {
        if (!(lbConfig instanceof OutlierDetectionLoadBalancingConfig)) {
          return;
        }
        const subchannelAddresses = /* @__PURE__ */ new Set();
        for (const address of addressList) {
          subchannelAddresses.add((0, subchannel_address_1.subchannelAddressToString)(address));
        }
        for (const address of subchannelAddresses) {
          if (!this.addressMap.has(address)) {
            trace("Adding map entry for " + address);
            this.addressMap.set(address, {
              counter: new CallCounter(),
              currentEjectionTimestamp: null,
              ejectionTimeMultiplier: 0,
              subchannelWrappers: []
            });
          }
        }
        for (const key of this.addressMap.keys()) {
          if (!subchannelAddresses.has(key)) {
            trace("Removing map entry for " + key);
            this.addressMap.delete(key);
          }
        }
        const childPolicy = (0, load_balancer_1.getFirstUsableConfig)(lbConfig.getChildPolicy(), true);
        this.childBalancer.updateAddressList(addressList, childPolicy, attributes);
        if (lbConfig.getSuccessRateEjectionConfig() || lbConfig.getFailurePercentageEjectionConfig()) {
          if (this.timerStartTime) {
            trace("Previous timer existed. Replacing timer");
            clearTimeout(this.ejectionTimer);
            const remainingDelay = lbConfig.getIntervalMs() - (new Date().getTime() - this.timerStartTime.getTime());
            this.startTimer(remainingDelay);
          } else {
            trace("Starting new timer");
            this.timerStartTime = new Date();
            this.startTimer(lbConfig.getIntervalMs());
            this.switchAllBuckets();
          }
        } else {
          trace("Counting disabled. Cancelling timer.");
          this.timerStartTime = null;
          clearTimeout(this.ejectionTimer);
          for (const mapEntry of this.addressMap.values()) {
            this.uneject(mapEntry);
            mapEntry.ejectionTimeMultiplier = 0;
          }
        }
        this.latestConfig = lbConfig;
      }
      exitIdle() {
        this.childBalancer.exitIdle();
      }
      resetBackoff() {
        this.childBalancer.resetBackoff();
      }
      destroy() {
        clearTimeout(this.ejectionTimer);
        this.childBalancer.destroy();
      }
      getTypeName() {
        return TYPE_NAME;
      }
    };
    exports2.OutlierDetectionLoadBalancer = OutlierDetectionLoadBalancer;
    function setup() {
      if (OUTLIER_DETECTION_ENABLED) {
        (0, experimental_1.registerLoadBalancerType)(TYPE_NAME, OutlierDetectionLoadBalancer, OutlierDetectionLoadBalancingConfig);
      }
    }
    exports2.setup = setup;
  }
});

// node_modules/@grpc/grpc-js/build/src/experimental.js
var require_experimental = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/experimental.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.OutlierDetectionLoadBalancingConfig = exports2.BaseSubchannelWrapper = exports2.registerAdminService = exports2.FilterStackFactory = exports2.BaseFilter = exports2.PickResultType = exports2.QueuePicker = exports2.UnavailablePicker = exports2.ChildLoadBalancerHandler = exports2.subchannelAddressToString = exports2.validateLoadBalancingConfig = exports2.getFirstUsableConfig = exports2.registerLoadBalancerType = exports2.createChildChannelControlHelper = exports2.BackoffTimeout = exports2.durationToMs = exports2.uriToString = exports2.registerResolver = exports2.log = exports2.trace = void 0;
    var logging_1 = require_logging();
    Object.defineProperty(exports2, "trace", { enumerable: true, get: function() {
      return logging_1.trace;
    } });
    Object.defineProperty(exports2, "log", { enumerable: true, get: function() {
      return logging_1.log;
    } });
    var resolver_1 = require_resolver();
    Object.defineProperty(exports2, "registerResolver", { enumerable: true, get: function() {
      return resolver_1.registerResolver;
    } });
    var uri_parser_1 = require_uri_parser();
    Object.defineProperty(exports2, "uriToString", { enumerable: true, get: function() {
      return uri_parser_1.uriToString;
    } });
    var duration_1 = require_duration();
    Object.defineProperty(exports2, "durationToMs", { enumerable: true, get: function() {
      return duration_1.durationToMs;
    } });
    var backoff_timeout_1 = require_backoff_timeout();
    Object.defineProperty(exports2, "BackoffTimeout", { enumerable: true, get: function() {
      return backoff_timeout_1.BackoffTimeout;
    } });
    var load_balancer_1 = require_load_balancer();
    Object.defineProperty(exports2, "createChildChannelControlHelper", { enumerable: true, get: function() {
      return load_balancer_1.createChildChannelControlHelper;
    } });
    Object.defineProperty(exports2, "registerLoadBalancerType", { enumerable: true, get: function() {
      return load_balancer_1.registerLoadBalancerType;
    } });
    Object.defineProperty(exports2, "getFirstUsableConfig", { enumerable: true, get: function() {
      return load_balancer_1.getFirstUsableConfig;
    } });
    Object.defineProperty(exports2, "validateLoadBalancingConfig", { enumerable: true, get: function() {
      return load_balancer_1.validateLoadBalancingConfig;
    } });
    var subchannel_address_1 = require_subchannel_address();
    Object.defineProperty(exports2, "subchannelAddressToString", { enumerable: true, get: function() {
      return subchannel_address_1.subchannelAddressToString;
    } });
    var load_balancer_child_handler_1 = require_load_balancer_child_handler();
    Object.defineProperty(exports2, "ChildLoadBalancerHandler", { enumerable: true, get: function() {
      return load_balancer_child_handler_1.ChildLoadBalancerHandler;
    } });
    var picker_1 = require_picker();
    Object.defineProperty(exports2, "UnavailablePicker", { enumerable: true, get: function() {
      return picker_1.UnavailablePicker;
    } });
    Object.defineProperty(exports2, "QueuePicker", { enumerable: true, get: function() {
      return picker_1.QueuePicker;
    } });
    Object.defineProperty(exports2, "PickResultType", { enumerable: true, get: function() {
      return picker_1.PickResultType;
    } });
    var filter_1 = require_filter();
    Object.defineProperty(exports2, "BaseFilter", { enumerable: true, get: function() {
      return filter_1.BaseFilter;
    } });
    var filter_stack_1 = require_filter_stack();
    Object.defineProperty(exports2, "FilterStackFactory", { enumerable: true, get: function() {
      return filter_stack_1.FilterStackFactory;
    } });
    var admin_1 = require_admin();
    Object.defineProperty(exports2, "registerAdminService", { enumerable: true, get: function() {
      return admin_1.registerAdminService;
    } });
    var subchannel_interface_1 = require_subchannel_interface();
    Object.defineProperty(exports2, "BaseSubchannelWrapper", { enumerable: true, get: function() {
      return subchannel_interface_1.BaseSubchannelWrapper;
    } });
    var load_balancer_outlier_detection_1 = require_load_balancer_outlier_detection();
    Object.defineProperty(exports2, "OutlierDetectionLoadBalancingConfig", { enumerable: true, get: function() {
      return load_balancer_outlier_detection_1.OutlierDetectionLoadBalancingConfig;
    } });
  }
});

// node_modules/@grpc/grpc-js/build/src/resolver-dns.js
var require_resolver_dns = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/resolver-dns.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.setup = void 0;
    var resolver_1 = require_resolver();
    var dns = require("dns");
    var util = require("util");
    var service_config_1 = require_service_config();
    var constants_1 = require_constants();
    var metadata_1 = require_metadata();
    var logging = require_logging();
    var constants_2 = require_constants();
    var uri_parser_1 = require_uri_parser();
    var net_1 = require("net");
    var backoff_timeout_1 = require_backoff_timeout();
    var TRACER_NAME = "dns_resolver";
    function trace(text) {
      logging.trace(constants_2.LogVerbosity.DEBUG, TRACER_NAME, text);
    }
    var DEFAULT_PORT = 443;
    var DEFAULT_MIN_TIME_BETWEEN_RESOLUTIONS_MS = 3e4;
    var resolveTxtPromise = util.promisify(dns.resolveTxt);
    var dnsLookupPromise = util.promisify(dns.lookup);
    function mergeArrays(...arrays) {
      const result = [];
      for (let i = 0; i < Math.max.apply(null, arrays.map((array) => array.length)); i++) {
        for (const array of arrays) {
          if (i < array.length) {
            result.push(array[i]);
          }
        }
      }
      return result;
    }
    var DnsResolver = class {
      constructor(target, listener, channelOptions) {
        var _a, _b, _c;
        this.target = target;
        this.listener = listener;
        this.pendingLookupPromise = null;
        this.pendingTxtPromise = null;
        this.latestLookupResult = null;
        this.latestServiceConfig = null;
        this.latestServiceConfigError = null;
        this.continueResolving = false;
        this.isNextResolutionTimerRunning = false;
        this.isServiceConfigEnabled = true;
        trace("Resolver constructed for target " + (0, uri_parser_1.uriToString)(target));
        const hostPort = (0, uri_parser_1.splitHostPort)(target.path);
        if (hostPort === null) {
          this.ipResult = null;
          this.dnsHostname = null;
          this.port = null;
        } else {
          if ((0, net_1.isIPv4)(hostPort.host) || (0, net_1.isIPv6)(hostPort.host)) {
            this.ipResult = [
              {
                host: hostPort.host,
                port: (_a = hostPort.port) !== null && _a !== void 0 ? _a : DEFAULT_PORT
              }
            ];
            this.dnsHostname = null;
            this.port = null;
          } else {
            this.ipResult = null;
            this.dnsHostname = hostPort.host;
            this.port = (_b = hostPort.port) !== null && _b !== void 0 ? _b : DEFAULT_PORT;
          }
        }
        this.percentage = Math.random() * 100;
        if (channelOptions["grpc.service_config_disable_resolution"] === 1) {
          this.isServiceConfigEnabled = false;
        }
        this.defaultResolutionError = {
          code: constants_1.Status.UNAVAILABLE,
          details: `Name resolution failed for target ${(0, uri_parser_1.uriToString)(this.target)}`,
          metadata: new metadata_1.Metadata()
        };
        const backoffOptions = {
          initialDelay: channelOptions["grpc.initial_reconnect_backoff_ms"],
          maxDelay: channelOptions["grpc.max_reconnect_backoff_ms"]
        };
        this.backoff = new backoff_timeout_1.BackoffTimeout(() => {
          if (this.continueResolving) {
            this.startResolutionWithBackoff();
          }
        }, backoffOptions);
        this.backoff.unref();
        this.minTimeBetweenResolutionsMs = (_c = channelOptions["grpc.dns_min_time_between_resolutions_ms"]) !== null && _c !== void 0 ? _c : DEFAULT_MIN_TIME_BETWEEN_RESOLUTIONS_MS;
        this.nextResolutionTimer = setTimeout(() => {
        }, 0);
        clearTimeout(this.nextResolutionTimer);
      }
      /**
       * If the target is an IP address, just provide that address as a result.
       * Otherwise, initiate A, AAAA, and TXT lookups
       */
      startResolution() {
        if (this.ipResult !== null) {
          trace("Returning IP address for target " + (0, uri_parser_1.uriToString)(this.target));
          setImmediate(() => {
            this.listener.onSuccessfulResolution(this.ipResult, null, null, null, {});
          });
          this.backoff.stop();
          this.backoff.reset();
          return;
        }
        if (this.dnsHostname === null) {
          trace("Failed to parse DNS address " + (0, uri_parser_1.uriToString)(this.target));
          setImmediate(() => {
            this.listener.onError({
              code: constants_1.Status.UNAVAILABLE,
              details: `Failed to parse DNS address ${(0, uri_parser_1.uriToString)(this.target)}`,
              metadata: new metadata_1.Metadata()
            });
          });
          this.stopNextResolutionTimer();
        } else {
          if (this.pendingLookupPromise !== null) {
            return;
          }
          trace("Looking up DNS hostname " + this.dnsHostname);
          this.latestLookupResult = null;
          const hostname = this.dnsHostname;
          this.pendingLookupPromise = dnsLookupPromise(hostname, { all: true });
          this.pendingLookupPromise.then((addressList) => {
            this.pendingLookupPromise = null;
            this.backoff.reset();
            this.backoff.stop();
            const ip4Addresses = addressList.filter((addr) => addr.family === 4);
            const ip6Addresses = addressList.filter((addr) => addr.family === 6);
            this.latestLookupResult = mergeArrays(ip6Addresses, ip4Addresses).map((addr) => ({ host: addr.address, port: +this.port }));
            const allAddressesString = "[" + this.latestLookupResult.map((addr) => addr.host + ":" + addr.port).join(",") + "]";
            trace("Resolved addresses for target " + (0, uri_parser_1.uriToString)(this.target) + ": " + allAddressesString);
            if (this.latestLookupResult.length === 0) {
              this.listener.onError(this.defaultResolutionError);
              return;
            }
            this.listener.onSuccessfulResolution(this.latestLookupResult, this.latestServiceConfig, this.latestServiceConfigError, null, {});
          }, (err) => {
            trace("Resolution error for target " + (0, uri_parser_1.uriToString)(this.target) + ": " + err.message);
            this.pendingLookupPromise = null;
            this.stopNextResolutionTimer();
            this.listener.onError(this.defaultResolutionError);
          });
          if (this.isServiceConfigEnabled && this.pendingTxtPromise === null) {
            this.pendingTxtPromise = resolveTxtPromise(hostname);
            this.pendingTxtPromise.then((txtRecord) => {
              this.pendingTxtPromise = null;
              try {
                this.latestServiceConfig = (0, service_config_1.extractAndSelectServiceConfig)(txtRecord, this.percentage);
              } catch (err) {
                this.latestServiceConfigError = {
                  code: constants_1.Status.UNAVAILABLE,
                  details: "Parsing service config failed",
                  metadata: new metadata_1.Metadata()
                };
              }
              if (this.latestLookupResult !== null) {
                this.listener.onSuccessfulResolution(this.latestLookupResult, this.latestServiceConfig, this.latestServiceConfigError, null, {});
              }
            }, (err) => {
            });
          }
        }
      }
      startNextResolutionTimer() {
        var _a, _b;
        clearTimeout(this.nextResolutionTimer);
        this.nextResolutionTimer = (_b = (_a = setTimeout(() => {
          this.stopNextResolutionTimer();
          if (this.continueResolving) {
            this.startResolutionWithBackoff();
          }
        }, this.minTimeBetweenResolutionsMs)).unref) === null || _b === void 0 ? void 0 : _b.call(_a);
        this.isNextResolutionTimerRunning = true;
      }
      stopNextResolutionTimer() {
        clearTimeout(this.nextResolutionTimer);
        this.isNextResolutionTimerRunning = false;
      }
      startResolutionWithBackoff() {
        if (this.pendingLookupPromise === null) {
          this.continueResolving = false;
          this.startResolution();
          this.backoff.runOnce();
          this.startNextResolutionTimer();
        }
      }
      updateResolution() {
        if (this.pendingLookupPromise === null) {
          if (this.isNextResolutionTimerRunning || this.backoff.isRunning()) {
            this.continueResolving = true;
          } else {
            this.startResolutionWithBackoff();
          }
        }
      }
      destroy() {
        this.continueResolving = false;
        this.backoff.stop();
        this.stopNextResolutionTimer();
      }
      /**
       * Get the default authority for the given target. For IP targets, that is
       * the IP address. For DNS targets, it is the hostname.
       * @param target
       */
      static getDefaultAuthority(target) {
        return target.path;
      }
    };
    function setup() {
      (0, resolver_1.registerResolver)("dns", DnsResolver);
      (0, resolver_1.registerDefaultScheme)("dns");
    }
    exports2.setup = setup;
  }
});

// node_modules/@grpc/grpc-js/build/src/resolver-uds.js
var require_resolver_uds = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/resolver-uds.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.setup = void 0;
    var resolver_1 = require_resolver();
    var UdsResolver = class {
      constructor(target, listener, channelOptions) {
        this.listener = listener;
        this.addresses = [];
        let path2;
        if (target.authority === "") {
          path2 = "/" + target.path;
        } else {
          path2 = target.path;
        }
        this.addresses = [{ path: path2 }];
      }
      updateResolution() {
        process.nextTick(this.listener.onSuccessfulResolution, this.addresses, null, null, null, {});
      }
      destroy() {
      }
      static getDefaultAuthority(target) {
        return "localhost";
      }
    };
    function setup() {
      (0, resolver_1.registerResolver)("unix", UdsResolver);
    }
    exports2.setup = setup;
  }
});

// node_modules/@grpc/grpc-js/build/src/resolver-ip.js
var require_resolver_ip = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/resolver-ip.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.setup = void 0;
    var net_1 = require("net");
    var constants_1 = require_constants();
    var metadata_1 = require_metadata();
    var resolver_1 = require_resolver();
    var uri_parser_1 = require_uri_parser();
    var logging = require_logging();
    var TRACER_NAME = "ip_resolver";
    function trace(text) {
      logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, text);
    }
    var IPV4_SCHEME = "ipv4";
    var IPV6_SCHEME = "ipv6";
    var DEFAULT_PORT = 443;
    var IpResolver = class {
      constructor(target, listener, channelOptions) {
        var _a;
        this.target = target;
        this.listener = listener;
        this.addresses = [];
        this.error = null;
        trace("Resolver constructed for target " + (0, uri_parser_1.uriToString)(target));
        const addresses = [];
        if (!(target.scheme === IPV4_SCHEME || target.scheme === IPV6_SCHEME)) {
          this.error = {
            code: constants_1.Status.UNAVAILABLE,
            details: `Unrecognized scheme ${target.scheme} in IP resolver`,
            metadata: new metadata_1.Metadata()
          };
          return;
        }
        const pathList = target.path.split(",");
        for (const path2 of pathList) {
          const hostPort = (0, uri_parser_1.splitHostPort)(path2);
          if (hostPort === null) {
            this.error = {
              code: constants_1.Status.UNAVAILABLE,
              details: `Failed to parse ${target.scheme} address ${path2}`,
              metadata: new metadata_1.Metadata()
            };
            return;
          }
          if (target.scheme === IPV4_SCHEME && !(0, net_1.isIPv4)(hostPort.host) || target.scheme === IPV6_SCHEME && !(0, net_1.isIPv6)(hostPort.host)) {
            this.error = {
              code: constants_1.Status.UNAVAILABLE,
              details: `Failed to parse ${target.scheme} address ${path2}`,
              metadata: new metadata_1.Metadata()
            };
            return;
          }
          addresses.push({
            host: hostPort.host,
            port: (_a = hostPort.port) !== null && _a !== void 0 ? _a : DEFAULT_PORT
          });
        }
        this.addresses = addresses;
        trace("Parsed " + target.scheme + " address list " + this.addresses);
      }
      updateResolution() {
        process.nextTick(() => {
          if (this.error) {
            this.listener.onError(this.error);
          } else {
            this.listener.onSuccessfulResolution(this.addresses, null, null, null, {});
          }
        });
      }
      destroy() {
      }
      static getDefaultAuthority(target) {
        return target.path.split(",")[0];
      }
    };
    function setup() {
      (0, resolver_1.registerResolver)(IPV4_SCHEME, IpResolver);
      (0, resolver_1.registerResolver)(IPV6_SCHEME, IpResolver);
    }
    exports2.setup = setup;
  }
});

// node_modules/@grpc/grpc-js/build/src/load-balancer-pick-first.js
var require_load_balancer_pick_first = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/load-balancer-pick-first.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.setup = exports2.PickFirstLoadBalancer = exports2.PickFirstLoadBalancingConfig = void 0;
    var load_balancer_1 = require_load_balancer();
    var connectivity_state_1 = require_connectivity_state();
    var picker_1 = require_picker();
    var subchannel_address_1 = require_subchannel_address();
    var logging = require_logging();
    var constants_1 = require_constants();
    var TRACER_NAME = "pick_first";
    function trace(text) {
      logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, text);
    }
    var TYPE_NAME = "pick_first";
    var CONNECTION_DELAY_INTERVAL_MS = 250;
    var PickFirstLoadBalancingConfig = class {
      getLoadBalancerName() {
        return TYPE_NAME;
      }
      constructor() {
      }
      toJsonObject() {
        return {
          [TYPE_NAME]: {}
        };
      }
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      static createFromJson(obj) {
        return new PickFirstLoadBalancingConfig();
      }
    };
    exports2.PickFirstLoadBalancingConfig = PickFirstLoadBalancingConfig;
    var PickFirstPicker = class {
      constructor(subchannel) {
        this.subchannel = subchannel;
      }
      pick(pickArgs) {
        return {
          pickResultType: picker_1.PickResultType.COMPLETE,
          subchannel: this.subchannel,
          status: null,
          onCallStarted: null,
          onCallEnded: null
        };
      }
    };
    var PickFirstLoadBalancer = class {
      /**
       * Load balancer that attempts to connect to each backend in the address list
       * in order, and picks the first one that connects, using it for every
       * request.
       * @param channelControlHelper `ChannelControlHelper` instance provided by
       *     this load balancer's owner.
       */
      constructor(channelControlHelper) {
        this.channelControlHelper = channelControlHelper;
        this.latestAddressList = [];
        this.subchannels = [];
        this.currentState = connectivity_state_1.ConnectivityState.IDLE;
        this.currentSubchannelIndex = 0;
        this.currentPick = null;
        this.triedAllSubchannels = false;
        this.subchannelStateCounts = {
          [connectivity_state_1.ConnectivityState.CONNECTING]: 0,
          [connectivity_state_1.ConnectivityState.IDLE]: 0,
          [connectivity_state_1.ConnectivityState.READY]: 0,
          [connectivity_state_1.ConnectivityState.SHUTDOWN]: 0,
          [connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE]: 0
        };
        this.subchannelStateListener = (subchannel, previousState, newState) => {
          this.subchannelStateCounts[previousState] -= 1;
          this.subchannelStateCounts[newState] += 1;
          if (subchannel === this.subchannels[this.currentSubchannelIndex] && newState === connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE) {
            this.startNextSubchannelConnecting();
          }
          if (newState === connectivity_state_1.ConnectivityState.READY) {
            this.pickSubchannel(subchannel);
            return;
          } else {
            if (this.triedAllSubchannels && this.subchannelStateCounts[connectivity_state_1.ConnectivityState.IDLE] === this.subchannels.length) {
              this.resetSubchannelList(false);
              this.updateState(connectivity_state_1.ConnectivityState.IDLE, new picker_1.QueuePicker(this));
              return;
            }
            if (this.currentPick === null) {
              if (this.triedAllSubchannels) {
                let newLBState;
                if (this.subchannelStateCounts[connectivity_state_1.ConnectivityState.CONNECTING] > 0) {
                  newLBState = connectivity_state_1.ConnectivityState.CONNECTING;
                } else if (this.subchannelStateCounts[connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE] > 0) {
                  newLBState = connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE;
                } else {
                  newLBState = connectivity_state_1.ConnectivityState.IDLE;
                }
                if (newLBState !== this.currentState) {
                  if (newLBState === connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE) {
                    this.updateState(newLBState, new picker_1.UnavailablePicker());
                  } else {
                    this.updateState(newLBState, new picker_1.QueuePicker(this));
                  }
                }
              } else {
                this.updateState(connectivity_state_1.ConnectivityState.CONNECTING, new picker_1.QueuePicker(this));
              }
            }
          }
        };
        this.pickedSubchannelStateListener = (subchannel, previousState, newState) => {
          if (newState !== connectivity_state_1.ConnectivityState.READY) {
            this.currentPick = null;
            subchannel.unref();
            subchannel.removeConnectivityStateListener(this.pickedSubchannelStateListener);
            this.channelControlHelper.removeChannelzChild(subchannel.getChannelzRef());
            if (this.subchannels.length > 0) {
              if (this.triedAllSubchannels) {
                let newLBState;
                if (this.subchannelStateCounts[connectivity_state_1.ConnectivityState.CONNECTING] > 0) {
                  newLBState = connectivity_state_1.ConnectivityState.CONNECTING;
                } else if (this.subchannelStateCounts[connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE] > 0) {
                  newLBState = connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE;
                } else {
                  newLBState = connectivity_state_1.ConnectivityState.IDLE;
                }
                if (newLBState === connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE) {
                  this.updateState(newLBState, new picker_1.UnavailablePicker());
                } else {
                  this.updateState(newLBState, new picker_1.QueuePicker(this));
                }
              } else {
                this.updateState(connectivity_state_1.ConnectivityState.CONNECTING, new picker_1.QueuePicker(this));
              }
            } else {
              this.updateState(connectivity_state_1.ConnectivityState.IDLE, new picker_1.QueuePicker(this));
            }
          }
        };
        this.connectionDelayTimeout = setTimeout(() => {
        }, 0);
        clearTimeout(this.connectionDelayTimeout);
      }
      startNextSubchannelConnecting() {
        if (this.triedAllSubchannels) {
          return;
        }
        for (const [index, subchannel] of this.subchannels.entries()) {
          if (index > this.currentSubchannelIndex) {
            const subchannelState = subchannel.getConnectivityState();
            if (subchannelState === connectivity_state_1.ConnectivityState.IDLE || subchannelState === connectivity_state_1.ConnectivityState.CONNECTING) {
              this.startConnecting(index);
              return;
            }
          }
        }
        this.triedAllSubchannels = true;
      }
      /**
       * Have a single subchannel in the `subchannels` list start connecting.
       * @param subchannelIndex The index into the `subchannels` list.
       */
      startConnecting(subchannelIndex) {
        clearTimeout(this.connectionDelayTimeout);
        this.currentSubchannelIndex = subchannelIndex;
        if (this.subchannels[subchannelIndex].getConnectivityState() === connectivity_state_1.ConnectivityState.IDLE) {
          trace("Start connecting to subchannel with address " + this.subchannels[subchannelIndex].getAddress());
          process.nextTick(() => {
            this.subchannels[subchannelIndex].startConnecting();
          });
        }
        this.connectionDelayTimeout = setTimeout(() => {
          this.startNextSubchannelConnecting();
        }, CONNECTION_DELAY_INTERVAL_MS);
      }
      pickSubchannel(subchannel) {
        trace("Pick subchannel with address " + subchannel.getAddress());
        if (this.currentPick !== null) {
          this.currentPick.unref();
          this.currentPick.removeConnectivityStateListener(this.pickedSubchannelStateListener);
        }
        this.currentPick = subchannel;
        this.updateState(connectivity_state_1.ConnectivityState.READY, new PickFirstPicker(subchannel));
        subchannel.addConnectivityStateListener(this.pickedSubchannelStateListener);
        subchannel.ref();
        this.channelControlHelper.addChannelzChild(subchannel.getChannelzRef());
        this.resetSubchannelList();
        clearTimeout(this.connectionDelayTimeout);
      }
      updateState(newState, picker) {
        trace(connectivity_state_1.ConnectivityState[this.currentState] + " -> " + connectivity_state_1.ConnectivityState[newState]);
        this.currentState = newState;
        this.channelControlHelper.updateState(newState, picker);
      }
      resetSubchannelList(resetTriedAllSubchannels = true) {
        for (const subchannel of this.subchannels) {
          subchannel.removeConnectivityStateListener(this.subchannelStateListener);
          subchannel.unref();
          this.channelControlHelper.removeChannelzChild(subchannel.getChannelzRef());
        }
        this.currentSubchannelIndex = 0;
        this.subchannelStateCounts = {
          [connectivity_state_1.ConnectivityState.CONNECTING]: 0,
          [connectivity_state_1.ConnectivityState.IDLE]: 0,
          [connectivity_state_1.ConnectivityState.READY]: 0,
          [connectivity_state_1.ConnectivityState.SHUTDOWN]: 0,
          [connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE]: 0
        };
        this.subchannels = [];
        if (resetTriedAllSubchannels) {
          this.triedAllSubchannels = false;
        }
      }
      /**
       * Start connecting to the address list most recently passed to
       * `updateAddressList`.
       */
      connectToAddressList() {
        this.resetSubchannelList();
        trace("Connect to address list " + this.latestAddressList.map((address) => (0, subchannel_address_1.subchannelAddressToString)(address)));
        this.subchannels = this.latestAddressList.map((address) => this.channelControlHelper.createSubchannel(address, {}));
        for (const subchannel of this.subchannels) {
          subchannel.ref();
          this.channelControlHelper.addChannelzChild(subchannel.getChannelzRef());
        }
        for (const subchannel of this.subchannels) {
          subchannel.addConnectivityStateListener(this.subchannelStateListener);
          this.subchannelStateCounts[subchannel.getConnectivityState()] += 1;
          if (subchannel.getConnectivityState() === connectivity_state_1.ConnectivityState.READY) {
            this.pickSubchannel(subchannel);
            this.resetSubchannelList();
            return;
          }
        }
        for (const [index, subchannel] of this.subchannels.entries()) {
          const subchannelState = subchannel.getConnectivityState();
          if (subchannelState === connectivity_state_1.ConnectivityState.IDLE || subchannelState === connectivity_state_1.ConnectivityState.CONNECTING) {
            this.startConnecting(index);
            if (this.currentPick === null) {
              this.updateState(connectivity_state_1.ConnectivityState.CONNECTING, new picker_1.QueuePicker(this));
            }
            return;
          }
        }
        if (this.currentPick === null) {
          this.updateState(connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE, new picker_1.UnavailablePicker());
        }
      }
      updateAddressList(addressList, lbConfig) {
        if (this.subchannels.length === 0 || !this.latestAddressList.every((value, index) => addressList[index] === value)) {
          this.latestAddressList = addressList;
          this.connectToAddressList();
        }
      }
      exitIdle() {
        if (this.currentState === connectivity_state_1.ConnectivityState.IDLE || this.triedAllSubchannels) {
          this.channelControlHelper.requestReresolution();
        }
        for (const subchannel of this.subchannels) {
          subchannel.startConnecting();
        }
        if (this.currentState === connectivity_state_1.ConnectivityState.IDLE) {
          if (this.latestAddressList.length > 0) {
            this.connectToAddressList();
          }
        }
      }
      resetBackoff() {
      }
      destroy() {
        this.resetSubchannelList();
        if (this.currentPick !== null) {
          const currentPick = this.currentPick;
          currentPick.unref();
          currentPick.removeConnectivityStateListener(this.pickedSubchannelStateListener);
          this.channelControlHelper.removeChannelzChild(currentPick.getChannelzRef());
        }
      }
      getTypeName() {
        return TYPE_NAME;
      }
    };
    exports2.PickFirstLoadBalancer = PickFirstLoadBalancer;
    function setup() {
      (0, load_balancer_1.registerLoadBalancerType)(TYPE_NAME, PickFirstLoadBalancer, PickFirstLoadBalancingConfig);
      (0, load_balancer_1.registerDefaultLoadBalancerType)(TYPE_NAME);
    }
    exports2.setup = setup;
  }
});

// node_modules/@grpc/grpc-js/build/src/load-balancer-round-robin.js
var require_load_balancer_round_robin = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/load-balancer-round-robin.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.setup = exports2.RoundRobinLoadBalancer = void 0;
    var load_balancer_1 = require_load_balancer();
    var connectivity_state_1 = require_connectivity_state();
    var picker_1 = require_picker();
    var subchannel_address_1 = require_subchannel_address();
    var logging = require_logging();
    var constants_1 = require_constants();
    var TRACER_NAME = "round_robin";
    function trace(text) {
      logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, text);
    }
    var TYPE_NAME = "round_robin";
    var RoundRobinLoadBalancingConfig = class {
      getLoadBalancerName() {
        return TYPE_NAME;
      }
      constructor() {
      }
      toJsonObject() {
        return {
          [TYPE_NAME]: {}
        };
      }
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      static createFromJson(obj) {
        return new RoundRobinLoadBalancingConfig();
      }
    };
    var RoundRobinPicker = class {
      constructor(subchannelList, nextIndex = 0) {
        this.subchannelList = subchannelList;
        this.nextIndex = nextIndex;
      }
      pick(pickArgs) {
        const pickedSubchannel = this.subchannelList[this.nextIndex];
        this.nextIndex = (this.nextIndex + 1) % this.subchannelList.length;
        return {
          pickResultType: picker_1.PickResultType.COMPLETE,
          subchannel: pickedSubchannel,
          status: null,
          onCallStarted: null,
          onCallEnded: null
        };
      }
      /**
       * Check what the next subchannel returned would be. Used by the load
       * balancer implementation to preserve this part of the picker state if
       * possible when a subchannel connects or disconnects.
       */
      peekNextSubchannel() {
        return this.subchannelList[this.nextIndex];
      }
    };
    var RoundRobinLoadBalancer = class {
      constructor(channelControlHelper) {
        this.channelControlHelper = channelControlHelper;
        this.subchannels = [];
        this.currentState = connectivity_state_1.ConnectivityState.IDLE;
        this.currentReadyPicker = null;
        this.subchannelStateCounts = {
          [connectivity_state_1.ConnectivityState.CONNECTING]: 0,
          [connectivity_state_1.ConnectivityState.IDLE]: 0,
          [connectivity_state_1.ConnectivityState.READY]: 0,
          [connectivity_state_1.ConnectivityState.SHUTDOWN]: 0,
          [connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE]: 0
        };
        this.subchannelStateListener = (subchannel, previousState, newState) => {
          this.subchannelStateCounts[previousState] -= 1;
          this.subchannelStateCounts[newState] += 1;
          this.calculateAndUpdateState();
          if (newState === connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE || newState === connectivity_state_1.ConnectivityState.IDLE) {
            this.channelControlHelper.requestReresolution();
            subchannel.startConnecting();
          }
        };
      }
      calculateAndUpdateState() {
        if (this.subchannelStateCounts[connectivity_state_1.ConnectivityState.READY] > 0) {
          const readySubchannels = this.subchannels.filter((subchannel) => subchannel.getConnectivityState() === connectivity_state_1.ConnectivityState.READY);
          let index = 0;
          if (this.currentReadyPicker !== null) {
            index = readySubchannels.indexOf(this.currentReadyPicker.peekNextSubchannel());
            if (index < 0) {
              index = 0;
            }
          }
          this.updateState(connectivity_state_1.ConnectivityState.READY, new RoundRobinPicker(readySubchannels, index));
        } else if (this.subchannelStateCounts[connectivity_state_1.ConnectivityState.CONNECTING] > 0) {
          this.updateState(connectivity_state_1.ConnectivityState.CONNECTING, new picker_1.QueuePicker(this));
        } else if (this.subchannelStateCounts[connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE] > 0) {
          this.updateState(connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE, new picker_1.UnavailablePicker());
        } else {
          this.updateState(connectivity_state_1.ConnectivityState.IDLE, new picker_1.QueuePicker(this));
        }
      }
      updateState(newState, picker) {
        trace(connectivity_state_1.ConnectivityState[this.currentState] + " -> " + connectivity_state_1.ConnectivityState[newState]);
        if (newState === connectivity_state_1.ConnectivityState.READY) {
          this.currentReadyPicker = picker;
        } else {
          this.currentReadyPicker = null;
        }
        this.currentState = newState;
        this.channelControlHelper.updateState(newState, picker);
      }
      resetSubchannelList() {
        for (const subchannel of this.subchannels) {
          subchannel.removeConnectivityStateListener(this.subchannelStateListener);
          subchannel.unref();
          this.channelControlHelper.removeChannelzChild(subchannel.getChannelzRef());
        }
        this.subchannelStateCounts = {
          [connectivity_state_1.ConnectivityState.CONNECTING]: 0,
          [connectivity_state_1.ConnectivityState.IDLE]: 0,
          [connectivity_state_1.ConnectivityState.READY]: 0,
          [connectivity_state_1.ConnectivityState.SHUTDOWN]: 0,
          [connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE]: 0
        };
        this.subchannels = [];
      }
      updateAddressList(addressList, lbConfig) {
        this.resetSubchannelList();
        trace("Connect to address list " + addressList.map((address) => (0, subchannel_address_1.subchannelAddressToString)(address)));
        this.subchannels = addressList.map((address) => this.channelControlHelper.createSubchannel(address, {}));
        for (const subchannel of this.subchannels) {
          subchannel.ref();
          subchannel.addConnectivityStateListener(this.subchannelStateListener);
          this.channelControlHelper.addChannelzChild(subchannel.getChannelzRef());
          const subchannelState = subchannel.getConnectivityState();
          this.subchannelStateCounts[subchannelState] += 1;
          if (subchannelState === connectivity_state_1.ConnectivityState.IDLE || subchannelState === connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE) {
            subchannel.startConnecting();
          }
        }
        this.calculateAndUpdateState();
      }
      exitIdle() {
        for (const subchannel of this.subchannels) {
          subchannel.startConnecting();
        }
      }
      resetBackoff() {
      }
      destroy() {
        this.resetSubchannelList();
      }
      getTypeName() {
        return TYPE_NAME;
      }
    };
    exports2.RoundRobinLoadBalancer = RoundRobinLoadBalancer;
    function setup() {
      (0, load_balancer_1.registerLoadBalancerType)(TYPE_NAME, RoundRobinLoadBalancer, RoundRobinLoadBalancingConfig);
    }
    exports2.setup = setup;
  }
});

// node_modules/@grpc/grpc-js/build/src/index.js
var require_src3 = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.experimental = exports2.addAdminServicesToServer = exports2.getChannelzHandlers = exports2.getChannelzServiceDefinition = exports2.InterceptorConfigurationError = exports2.InterceptingCall = exports2.RequesterBuilder = exports2.ListenerBuilder = exports2.StatusBuilder = exports2.getClientChannel = exports2.ServerCredentials = exports2.Server = exports2.setLogVerbosity = exports2.setLogger = exports2.load = exports2.loadObject = exports2.CallCredentials = exports2.ChannelCredentials = exports2.waitForClientReady = exports2.closeClient = exports2.Channel = exports2.makeGenericClientConstructor = exports2.makeClientConstructor = exports2.loadPackageDefinition = exports2.Client = exports2.compressionAlgorithms = exports2.propagate = exports2.connectivityState = exports2.status = exports2.logVerbosity = exports2.Metadata = exports2.credentials = void 0;
    var call_credentials_1 = require_call_credentials();
    Object.defineProperty(exports2, "CallCredentials", { enumerable: true, get: function() {
      return call_credentials_1.CallCredentials;
    } });
    var channel_1 = require_channel();
    Object.defineProperty(exports2, "Channel", { enumerable: true, get: function() {
      return channel_1.ChannelImplementation;
    } });
    var compression_algorithms_1 = require_compression_algorithms();
    Object.defineProperty(exports2, "compressionAlgorithms", { enumerable: true, get: function() {
      return compression_algorithms_1.CompressionAlgorithms;
    } });
    var connectivity_state_1 = require_connectivity_state();
    Object.defineProperty(exports2, "connectivityState", { enumerable: true, get: function() {
      return connectivity_state_1.ConnectivityState;
    } });
    var channel_credentials_1 = require_channel_credentials();
    Object.defineProperty(exports2, "ChannelCredentials", { enumerable: true, get: function() {
      return channel_credentials_1.ChannelCredentials;
    } });
    var client_1 = require_client();
    Object.defineProperty(exports2, "Client", { enumerable: true, get: function() {
      return client_1.Client;
    } });
    var constants_1 = require_constants();
    Object.defineProperty(exports2, "logVerbosity", { enumerable: true, get: function() {
      return constants_1.LogVerbosity;
    } });
    Object.defineProperty(exports2, "status", { enumerable: true, get: function() {
      return constants_1.Status;
    } });
    Object.defineProperty(exports2, "propagate", { enumerable: true, get: function() {
      return constants_1.Propagate;
    } });
    var logging = require_logging();
    var make_client_1 = require_make_client();
    Object.defineProperty(exports2, "loadPackageDefinition", { enumerable: true, get: function() {
      return make_client_1.loadPackageDefinition;
    } });
    Object.defineProperty(exports2, "makeClientConstructor", { enumerable: true, get: function() {
      return make_client_1.makeClientConstructor;
    } });
    Object.defineProperty(exports2, "makeGenericClientConstructor", { enumerable: true, get: function() {
      return make_client_1.makeClientConstructor;
    } });
    var metadata_1 = require_metadata();
    Object.defineProperty(exports2, "Metadata", { enumerable: true, get: function() {
      return metadata_1.Metadata;
    } });
    var server_1 = require_server();
    Object.defineProperty(exports2, "Server", { enumerable: true, get: function() {
      return server_1.Server;
    } });
    var server_credentials_1 = require_server_credentials();
    Object.defineProperty(exports2, "ServerCredentials", { enumerable: true, get: function() {
      return server_credentials_1.ServerCredentials;
    } });
    var status_builder_1 = require_status_builder();
    Object.defineProperty(exports2, "StatusBuilder", { enumerable: true, get: function() {
      return status_builder_1.StatusBuilder;
    } });
    exports2.credentials = {
      /**
       * Combine a ChannelCredentials with any number of CallCredentials into a
       * single ChannelCredentials object.
       * @param channelCredentials The ChannelCredentials object.
       * @param callCredentials Any number of CallCredentials objects.
       * @return The resulting ChannelCredentials object.
       */
      combineChannelCredentials: (channelCredentials, ...callCredentials) => {
        return callCredentials.reduce((acc, other) => acc.compose(other), channelCredentials);
      },
      /**
       * Combine any number of CallCredentials into a single CallCredentials
       * object.
       * @param first The first CallCredentials object.
       * @param additional Any number of additional CallCredentials objects.
       * @return The resulting CallCredentials object.
       */
      combineCallCredentials: (first, ...additional) => {
        return additional.reduce((acc, other) => acc.compose(other), first);
      },
      // from channel-credentials.ts
      createInsecure: channel_credentials_1.ChannelCredentials.createInsecure,
      createSsl: channel_credentials_1.ChannelCredentials.createSsl,
      createFromSecureContext: channel_credentials_1.ChannelCredentials.createFromSecureContext,
      // from call-credentials.ts
      createFromMetadataGenerator: call_credentials_1.CallCredentials.createFromMetadataGenerator,
      createFromGoogleCredential: call_credentials_1.CallCredentials.createFromGoogleCredential,
      createEmpty: call_credentials_1.CallCredentials.createEmpty
    };
    var closeClient = (client) => client.close();
    exports2.closeClient = closeClient;
    var waitForClientReady = (client, deadline, callback) => client.waitForReady(deadline, callback);
    exports2.waitForClientReady = waitForClientReady;
    var loadObject = (value, options) => {
      throw new Error("Not available in this library. Use @grpc/proto-loader and loadPackageDefinition instead");
    };
    exports2.loadObject = loadObject;
    var load = (filename, format, options) => {
      throw new Error("Not available in this library. Use @grpc/proto-loader and loadPackageDefinition instead");
    };
    exports2.load = load;
    var setLogger = (logger) => {
      logging.setLogger(logger);
    };
    exports2.setLogger = setLogger;
    var setLogVerbosity = (verbosity) => {
      logging.setLoggerVerbosity(verbosity);
    };
    exports2.setLogVerbosity = setLogVerbosity;
    var getClientChannel = (client) => {
      return client_1.Client.prototype.getChannel.call(client);
    };
    exports2.getClientChannel = getClientChannel;
    var client_interceptors_1 = require_client_interceptors();
    Object.defineProperty(exports2, "ListenerBuilder", { enumerable: true, get: function() {
      return client_interceptors_1.ListenerBuilder;
    } });
    Object.defineProperty(exports2, "RequesterBuilder", { enumerable: true, get: function() {
      return client_interceptors_1.RequesterBuilder;
    } });
    Object.defineProperty(exports2, "InterceptingCall", { enumerable: true, get: function() {
      return client_interceptors_1.InterceptingCall;
    } });
    Object.defineProperty(exports2, "InterceptorConfigurationError", { enumerable: true, get: function() {
      return client_interceptors_1.InterceptorConfigurationError;
    } });
    var channelz_1 = require_channelz();
    Object.defineProperty(exports2, "getChannelzServiceDefinition", { enumerable: true, get: function() {
      return channelz_1.getChannelzServiceDefinition;
    } });
    Object.defineProperty(exports2, "getChannelzHandlers", { enumerable: true, get: function() {
      return channelz_1.getChannelzHandlers;
    } });
    var admin_1 = require_admin();
    Object.defineProperty(exports2, "addAdminServicesToServer", { enumerable: true, get: function() {
      return admin_1.addAdminServicesToServer;
    } });
    var experimental = require_experimental();
    exports2.experimental = experimental;
    var resolver_dns = require_resolver_dns();
    var resolver_uds = require_resolver_uds();
    var resolver_ip = require_resolver_ip();
    var load_balancer_pick_first = require_load_balancer_pick_first();
    var load_balancer_round_robin = require_load_balancer_round_robin();
    var load_balancer_outlier_detection = require_load_balancer_outlier_detection();
    var channelz = require_channelz();
    var clientVersion = require_package().version;
    (() => {
      logging.trace(constants_1.LogVerbosity.DEBUG, "index", "Loading @grpc/grpc-js version " + clientVersion);
      resolver_dns.setup();
      resolver_uds.setup();
      resolver_ip.setup();
      load_balancer_pick_first.setup();
      load_balancer_round_robin.setup();
      load_balancer_outlier_detection.setup();
      channelz.setup();
    })();
  }
});

// static-codegen5/tfplugin5.3_grpc_pb.js
var require_tfplugin5_3_grpc_pb = __commonJS({
  "static-codegen5/tfplugin5.3_grpc_pb.js"(exports2) {
    "use strict";
    var grpc2 = require_src3();
    var tfplugin5_3_pb = require_tfplugin5_3_pb();
    function serialize_tfplugin5_ApplyResourceChange_Request(arg) {
      if (!(arg instanceof tfplugin5_3_pb.ApplyResourceChange.Request)) {
        throw new Error("Expected argument of type tfplugin5.ApplyResourceChange.Request");
      }
      return Buffer.from(arg.serializeBinary());
    }
    function deserialize_tfplugin5_ApplyResourceChange_Request(buffer_arg) {
      return tfplugin5_3_pb.ApplyResourceChange.Request.deserializeBinary(new Uint8Array(buffer_arg));
    }
    function serialize_tfplugin5_ApplyResourceChange_Response(arg) {
      if (!(arg instanceof tfplugin5_3_pb.ApplyResourceChange.Response)) {
        throw new Error("Expected argument of type tfplugin5.ApplyResourceChange.Response");
      }
      return Buffer.from(arg.serializeBinary());
    }
    function deserialize_tfplugin5_ApplyResourceChange_Response(buffer_arg) {
      return tfplugin5_3_pb.ApplyResourceChange.Response.deserializeBinary(new Uint8Array(buffer_arg));
    }
    function serialize_tfplugin5_Configure_Request(arg) {
      if (!(arg instanceof tfplugin5_3_pb.Configure.Request)) {
        throw new Error("Expected argument of type tfplugin5.Configure.Request");
      }
      return Buffer.from(arg.serializeBinary());
    }
    function deserialize_tfplugin5_Configure_Request(buffer_arg) {
      return tfplugin5_3_pb.Configure.Request.deserializeBinary(new Uint8Array(buffer_arg));
    }
    function serialize_tfplugin5_Configure_Response(arg) {
      if (!(arg instanceof tfplugin5_3_pb.Configure.Response)) {
        throw new Error("Expected argument of type tfplugin5.Configure.Response");
      }
      return Buffer.from(arg.serializeBinary());
    }
    function deserialize_tfplugin5_Configure_Response(buffer_arg) {
      return tfplugin5_3_pb.Configure.Response.deserializeBinary(new Uint8Array(buffer_arg));
    }
    function serialize_tfplugin5_GetProviderSchema_Request(arg) {
      if (!(arg instanceof tfplugin5_3_pb.GetProviderSchema.Request)) {
        throw new Error("Expected argument of type tfplugin5.GetProviderSchema.Request");
      }
      return Buffer.from(arg.serializeBinary());
    }
    function deserialize_tfplugin5_GetProviderSchema_Request(buffer_arg) {
      return tfplugin5_3_pb.GetProviderSchema.Request.deserializeBinary(new Uint8Array(buffer_arg));
    }
    function serialize_tfplugin5_GetProviderSchema_Response(arg) {
      if (!(arg instanceof tfplugin5_3_pb.GetProviderSchema.Response)) {
        throw new Error("Expected argument of type tfplugin5.GetProviderSchema.Response");
      }
      return Buffer.from(arg.serializeBinary());
    }
    function deserialize_tfplugin5_GetProviderSchema_Response(buffer_arg) {
      return tfplugin5_3_pb.GetProviderSchema.Response.deserializeBinary(new Uint8Array(buffer_arg));
    }
    function serialize_tfplugin5_GetProvisionerSchema_Request(arg) {
      if (!(arg instanceof tfplugin5_3_pb.GetProvisionerSchema.Request)) {
        throw new Error("Expected argument of type tfplugin5.GetProvisionerSchema.Request");
      }
      return Buffer.from(arg.serializeBinary());
    }
    function deserialize_tfplugin5_GetProvisionerSchema_Request(buffer_arg) {
      return tfplugin5_3_pb.GetProvisionerSchema.Request.deserializeBinary(new Uint8Array(buffer_arg));
    }
    function serialize_tfplugin5_GetProvisionerSchema_Response(arg) {
      if (!(arg instanceof tfplugin5_3_pb.GetProvisionerSchema.Response)) {
        throw new Error("Expected argument of type tfplugin5.GetProvisionerSchema.Response");
      }
      return Buffer.from(arg.serializeBinary());
    }
    function deserialize_tfplugin5_GetProvisionerSchema_Response(buffer_arg) {
      return tfplugin5_3_pb.GetProvisionerSchema.Response.deserializeBinary(new Uint8Array(buffer_arg));
    }
    function serialize_tfplugin5_ImportResourceState_Request(arg) {
      if (!(arg instanceof tfplugin5_3_pb.ImportResourceState.Request)) {
        throw new Error("Expected argument of type tfplugin5.ImportResourceState.Request");
      }
      return Buffer.from(arg.serializeBinary());
    }
    function deserialize_tfplugin5_ImportResourceState_Request(buffer_arg) {
      return tfplugin5_3_pb.ImportResourceState.Request.deserializeBinary(new Uint8Array(buffer_arg));
    }
    function serialize_tfplugin5_ImportResourceState_Response(arg) {
      if (!(arg instanceof tfplugin5_3_pb.ImportResourceState.Response)) {
        throw new Error("Expected argument of type tfplugin5.ImportResourceState.Response");
      }
      return Buffer.from(arg.serializeBinary());
    }
    function deserialize_tfplugin5_ImportResourceState_Response(buffer_arg) {
      return tfplugin5_3_pb.ImportResourceState.Response.deserializeBinary(new Uint8Array(buffer_arg));
    }
    function serialize_tfplugin5_PlanResourceChange_Request(arg) {
      if (!(arg instanceof tfplugin5_3_pb.PlanResourceChange.Request)) {
        throw new Error("Expected argument of type tfplugin5.PlanResourceChange.Request");
      }
      return Buffer.from(arg.serializeBinary());
    }
    function deserialize_tfplugin5_PlanResourceChange_Request(buffer_arg) {
      return tfplugin5_3_pb.PlanResourceChange.Request.deserializeBinary(new Uint8Array(buffer_arg));
    }
    function serialize_tfplugin5_PlanResourceChange_Response(arg) {
      if (!(arg instanceof tfplugin5_3_pb.PlanResourceChange.Response)) {
        throw new Error("Expected argument of type tfplugin5.PlanResourceChange.Response");
      }
      return Buffer.from(arg.serializeBinary());
    }
    function deserialize_tfplugin5_PlanResourceChange_Response(buffer_arg) {
      return tfplugin5_3_pb.PlanResourceChange.Response.deserializeBinary(new Uint8Array(buffer_arg));
    }
    function serialize_tfplugin5_PrepareProviderConfig_Request(arg) {
      if (!(arg instanceof tfplugin5_3_pb.PrepareProviderConfig.Request)) {
        throw new Error("Expected argument of type tfplugin5.PrepareProviderConfig.Request");
      }
      return Buffer.from(arg.serializeBinary());
    }
    function deserialize_tfplugin5_PrepareProviderConfig_Request(buffer_arg) {
      return tfplugin5_3_pb.PrepareProviderConfig.Request.deserializeBinary(new Uint8Array(buffer_arg));
    }
    function serialize_tfplugin5_PrepareProviderConfig_Response(arg) {
      if (!(arg instanceof tfplugin5_3_pb.PrepareProviderConfig.Response)) {
        throw new Error("Expected argument of type tfplugin5.PrepareProviderConfig.Response");
      }
      return Buffer.from(arg.serializeBinary());
    }
    function deserialize_tfplugin5_PrepareProviderConfig_Response(buffer_arg) {
      return tfplugin5_3_pb.PrepareProviderConfig.Response.deserializeBinary(new Uint8Array(buffer_arg));
    }
    function serialize_tfplugin5_ProvisionResource_Request(arg) {
      if (!(arg instanceof tfplugin5_3_pb.ProvisionResource.Request)) {
        throw new Error("Expected argument of type tfplugin5.ProvisionResource.Request");
      }
      return Buffer.from(arg.serializeBinary());
    }
    function deserialize_tfplugin5_ProvisionResource_Request(buffer_arg) {
      return tfplugin5_3_pb.ProvisionResource.Request.deserializeBinary(new Uint8Array(buffer_arg));
    }
    function serialize_tfplugin5_ProvisionResource_Response(arg) {
      if (!(arg instanceof tfplugin5_3_pb.ProvisionResource.Response)) {
        throw new Error("Expected argument of type tfplugin5.ProvisionResource.Response");
      }
      return Buffer.from(arg.serializeBinary());
    }
    function deserialize_tfplugin5_ProvisionResource_Response(buffer_arg) {
      return tfplugin5_3_pb.ProvisionResource.Response.deserializeBinary(new Uint8Array(buffer_arg));
    }
    function serialize_tfplugin5_ReadDataSource_Request(arg) {
      if (!(arg instanceof tfplugin5_3_pb.ReadDataSource.Request)) {
        throw new Error("Expected argument of type tfplugin5.ReadDataSource.Request");
      }
      return Buffer.from(arg.serializeBinary());
    }
    function deserialize_tfplugin5_ReadDataSource_Request(buffer_arg) {
      return tfplugin5_3_pb.ReadDataSource.Request.deserializeBinary(new Uint8Array(buffer_arg));
    }
    function serialize_tfplugin5_ReadDataSource_Response(arg) {
      if (!(arg instanceof tfplugin5_3_pb.ReadDataSource.Response)) {
        throw new Error("Expected argument of type tfplugin5.ReadDataSource.Response");
      }
      return Buffer.from(arg.serializeBinary());
    }
    function deserialize_tfplugin5_ReadDataSource_Response(buffer_arg) {
      return tfplugin5_3_pb.ReadDataSource.Response.deserializeBinary(new Uint8Array(buffer_arg));
    }
    function serialize_tfplugin5_ReadResource_Request(arg) {
      if (!(arg instanceof tfplugin5_3_pb.ReadResource.Request)) {
        throw new Error("Expected argument of type tfplugin5.ReadResource.Request");
      }
      return Buffer.from(arg.serializeBinary());
    }
    function deserialize_tfplugin5_ReadResource_Request(buffer_arg) {
      return tfplugin5_3_pb.ReadResource.Request.deserializeBinary(new Uint8Array(buffer_arg));
    }
    function serialize_tfplugin5_ReadResource_Response(arg) {
      if (!(arg instanceof tfplugin5_3_pb.ReadResource.Response)) {
        throw new Error("Expected argument of type tfplugin5.ReadResource.Response");
      }
      return Buffer.from(arg.serializeBinary());
    }
    function deserialize_tfplugin5_ReadResource_Response(buffer_arg) {
      return tfplugin5_3_pb.ReadResource.Response.deserializeBinary(new Uint8Array(buffer_arg));
    }
    function serialize_tfplugin5_Stop_Request(arg) {
      if (!(arg instanceof tfplugin5_3_pb.Stop.Request)) {
        throw new Error("Expected argument of type tfplugin5.Stop.Request");
      }
      return Buffer.from(arg.serializeBinary());
    }
    function deserialize_tfplugin5_Stop_Request(buffer_arg) {
      return tfplugin5_3_pb.Stop.Request.deserializeBinary(new Uint8Array(buffer_arg));
    }
    function serialize_tfplugin5_Stop_Response(arg) {
      if (!(arg instanceof tfplugin5_3_pb.Stop.Response)) {
        throw new Error("Expected argument of type tfplugin5.Stop.Response");
      }
      return Buffer.from(arg.serializeBinary());
    }
    function deserialize_tfplugin5_Stop_Response(buffer_arg) {
      return tfplugin5_3_pb.Stop.Response.deserializeBinary(new Uint8Array(buffer_arg));
    }
    function serialize_tfplugin5_UpgradeResourceState_Request(arg) {
      if (!(arg instanceof tfplugin5_3_pb.UpgradeResourceState.Request)) {
        throw new Error("Expected argument of type tfplugin5.UpgradeResourceState.Request");
      }
      return Buffer.from(arg.serializeBinary());
    }
    function deserialize_tfplugin5_UpgradeResourceState_Request(buffer_arg) {
      return tfplugin5_3_pb.UpgradeResourceState.Request.deserializeBinary(new Uint8Array(buffer_arg));
    }
    function serialize_tfplugin5_UpgradeResourceState_Response(arg) {
      if (!(arg instanceof tfplugin5_3_pb.UpgradeResourceState.Response)) {
        throw new Error("Expected argument of type tfplugin5.UpgradeResourceState.Response");
      }
      return Buffer.from(arg.serializeBinary());
    }
    function deserialize_tfplugin5_UpgradeResourceState_Response(buffer_arg) {
      return tfplugin5_3_pb.UpgradeResourceState.Response.deserializeBinary(new Uint8Array(buffer_arg));
    }
    function serialize_tfplugin5_ValidateDataSourceConfig_Request(arg) {
      if (!(arg instanceof tfplugin5_3_pb.ValidateDataSourceConfig.Request)) {
        throw new Error("Expected argument of type tfplugin5.ValidateDataSourceConfig.Request");
      }
      return Buffer.from(arg.serializeBinary());
    }
    function deserialize_tfplugin5_ValidateDataSourceConfig_Request(buffer_arg) {
      return tfplugin5_3_pb.ValidateDataSourceConfig.Request.deserializeBinary(new Uint8Array(buffer_arg));
    }
    function serialize_tfplugin5_ValidateDataSourceConfig_Response(arg) {
      if (!(arg instanceof tfplugin5_3_pb.ValidateDataSourceConfig.Response)) {
        throw new Error("Expected argument of type tfplugin5.ValidateDataSourceConfig.Response");
      }
      return Buffer.from(arg.serializeBinary());
    }
    function deserialize_tfplugin5_ValidateDataSourceConfig_Response(buffer_arg) {
      return tfplugin5_3_pb.ValidateDataSourceConfig.Response.deserializeBinary(new Uint8Array(buffer_arg));
    }
    function serialize_tfplugin5_ValidateProvisionerConfig_Request(arg) {
      if (!(arg instanceof tfplugin5_3_pb.ValidateProvisionerConfig.Request)) {
        throw new Error("Expected argument of type tfplugin5.ValidateProvisionerConfig.Request");
      }
      return Buffer.from(arg.serializeBinary());
    }
    function deserialize_tfplugin5_ValidateProvisionerConfig_Request(buffer_arg) {
      return tfplugin5_3_pb.ValidateProvisionerConfig.Request.deserializeBinary(new Uint8Array(buffer_arg));
    }
    function serialize_tfplugin5_ValidateProvisionerConfig_Response(arg) {
      if (!(arg instanceof tfplugin5_3_pb.ValidateProvisionerConfig.Response)) {
        throw new Error("Expected argument of type tfplugin5.ValidateProvisionerConfig.Response");
      }
      return Buffer.from(arg.serializeBinary());
    }
    function deserialize_tfplugin5_ValidateProvisionerConfig_Response(buffer_arg) {
      return tfplugin5_3_pb.ValidateProvisionerConfig.Response.deserializeBinary(new Uint8Array(buffer_arg));
    }
    function serialize_tfplugin5_ValidateResourceTypeConfig_Request(arg) {
      if (!(arg instanceof tfplugin5_3_pb.ValidateResourceTypeConfig.Request)) {
        throw new Error("Expected argument of type tfplugin5.ValidateResourceTypeConfig.Request");
      }
      return Buffer.from(arg.serializeBinary());
    }
    function deserialize_tfplugin5_ValidateResourceTypeConfig_Request(buffer_arg) {
      return tfplugin5_3_pb.ValidateResourceTypeConfig.Request.deserializeBinary(new Uint8Array(buffer_arg));
    }
    function serialize_tfplugin5_ValidateResourceTypeConfig_Response(arg) {
      if (!(arg instanceof tfplugin5_3_pb.ValidateResourceTypeConfig.Response)) {
        throw new Error("Expected argument of type tfplugin5.ValidateResourceTypeConfig.Response");
      }
      return Buffer.from(arg.serializeBinary());
    }
    function deserialize_tfplugin5_ValidateResourceTypeConfig_Response(buffer_arg) {
      return tfplugin5_3_pb.ValidateResourceTypeConfig.Response.deserializeBinary(new Uint8Array(buffer_arg));
    }
    var ProviderService = exports2.ProviderService = {
      // ////// Information about what a provider supports/expects
      getSchema: {
        path: "/tfplugin5.Provider/GetSchema",
        requestStream: false,
        responseStream: false,
        requestType: tfplugin5_3_pb.GetProviderSchema.Request,
        responseType: tfplugin5_3_pb.GetProviderSchema.Response,
        requestSerialize: serialize_tfplugin5_GetProviderSchema_Request,
        requestDeserialize: deserialize_tfplugin5_GetProviderSchema_Request,
        responseSerialize: serialize_tfplugin5_GetProviderSchema_Response,
        responseDeserialize: deserialize_tfplugin5_GetProviderSchema_Response
      },
      prepareProviderConfig: {
        path: "/tfplugin5.Provider/PrepareProviderConfig",
        requestStream: false,
        responseStream: false,
        requestType: tfplugin5_3_pb.PrepareProviderConfig.Request,
        responseType: tfplugin5_3_pb.PrepareProviderConfig.Response,
        requestSerialize: serialize_tfplugin5_PrepareProviderConfig_Request,
        requestDeserialize: deserialize_tfplugin5_PrepareProviderConfig_Request,
        responseSerialize: serialize_tfplugin5_PrepareProviderConfig_Response,
        responseDeserialize: deserialize_tfplugin5_PrepareProviderConfig_Response
      },
      validateResourceTypeConfig: {
        path: "/tfplugin5.Provider/ValidateResourceTypeConfig",
        requestStream: false,
        responseStream: false,
        requestType: tfplugin5_3_pb.ValidateResourceTypeConfig.Request,
        responseType: tfplugin5_3_pb.ValidateResourceTypeConfig.Response,
        requestSerialize: serialize_tfplugin5_ValidateResourceTypeConfig_Request,
        requestDeserialize: deserialize_tfplugin5_ValidateResourceTypeConfig_Request,
        responseSerialize: serialize_tfplugin5_ValidateResourceTypeConfig_Response,
        responseDeserialize: deserialize_tfplugin5_ValidateResourceTypeConfig_Response
      },
      validateDataSourceConfig: {
        path: "/tfplugin5.Provider/ValidateDataSourceConfig",
        requestStream: false,
        responseStream: false,
        requestType: tfplugin5_3_pb.ValidateDataSourceConfig.Request,
        responseType: tfplugin5_3_pb.ValidateDataSourceConfig.Response,
        requestSerialize: serialize_tfplugin5_ValidateDataSourceConfig_Request,
        requestDeserialize: deserialize_tfplugin5_ValidateDataSourceConfig_Request,
        responseSerialize: serialize_tfplugin5_ValidateDataSourceConfig_Response,
        responseDeserialize: deserialize_tfplugin5_ValidateDataSourceConfig_Response
      },
      upgradeResourceState: {
        path: "/tfplugin5.Provider/UpgradeResourceState",
        requestStream: false,
        responseStream: false,
        requestType: tfplugin5_3_pb.UpgradeResourceState.Request,
        responseType: tfplugin5_3_pb.UpgradeResourceState.Response,
        requestSerialize: serialize_tfplugin5_UpgradeResourceState_Request,
        requestDeserialize: deserialize_tfplugin5_UpgradeResourceState_Request,
        responseSerialize: serialize_tfplugin5_UpgradeResourceState_Response,
        responseDeserialize: deserialize_tfplugin5_UpgradeResourceState_Response
      },
      // ////// One-time initialization, called before other functions below
      configure: {
        path: "/tfplugin5.Provider/Configure",
        requestStream: false,
        responseStream: false,
        requestType: tfplugin5_3_pb.Configure.Request,
        responseType: tfplugin5_3_pb.Configure.Response,
        requestSerialize: serialize_tfplugin5_Configure_Request,
        requestDeserialize: deserialize_tfplugin5_Configure_Request,
        responseSerialize: serialize_tfplugin5_Configure_Response,
        responseDeserialize: deserialize_tfplugin5_Configure_Response
      },
      // ////// Managed Resource Lifecycle
      readResource: {
        path: "/tfplugin5.Provider/ReadResource",
        requestStream: false,
        responseStream: false,
        requestType: tfplugin5_3_pb.ReadResource.Request,
        responseType: tfplugin5_3_pb.ReadResource.Response,
        requestSerialize: serialize_tfplugin5_ReadResource_Request,
        requestDeserialize: deserialize_tfplugin5_ReadResource_Request,
        responseSerialize: serialize_tfplugin5_ReadResource_Response,
        responseDeserialize: deserialize_tfplugin5_ReadResource_Response
      },
      planResourceChange: {
        path: "/tfplugin5.Provider/PlanResourceChange",
        requestStream: false,
        responseStream: false,
        requestType: tfplugin5_3_pb.PlanResourceChange.Request,
        responseType: tfplugin5_3_pb.PlanResourceChange.Response,
        requestSerialize: serialize_tfplugin5_PlanResourceChange_Request,
        requestDeserialize: deserialize_tfplugin5_PlanResourceChange_Request,
        responseSerialize: serialize_tfplugin5_PlanResourceChange_Response,
        responseDeserialize: deserialize_tfplugin5_PlanResourceChange_Response
      },
      applyResourceChange: {
        path: "/tfplugin5.Provider/ApplyResourceChange",
        requestStream: false,
        responseStream: false,
        requestType: tfplugin5_3_pb.ApplyResourceChange.Request,
        responseType: tfplugin5_3_pb.ApplyResourceChange.Response,
        requestSerialize: serialize_tfplugin5_ApplyResourceChange_Request,
        requestDeserialize: deserialize_tfplugin5_ApplyResourceChange_Request,
        responseSerialize: serialize_tfplugin5_ApplyResourceChange_Response,
        responseDeserialize: deserialize_tfplugin5_ApplyResourceChange_Response
      },
      importResourceState: {
        path: "/tfplugin5.Provider/ImportResourceState",
        requestStream: false,
        responseStream: false,
        requestType: tfplugin5_3_pb.ImportResourceState.Request,
        responseType: tfplugin5_3_pb.ImportResourceState.Response,
        requestSerialize: serialize_tfplugin5_ImportResourceState_Request,
        requestDeserialize: deserialize_tfplugin5_ImportResourceState_Request,
        responseSerialize: serialize_tfplugin5_ImportResourceState_Response,
        responseDeserialize: deserialize_tfplugin5_ImportResourceState_Response
      },
      readDataSource: {
        path: "/tfplugin5.Provider/ReadDataSource",
        requestStream: false,
        responseStream: false,
        requestType: tfplugin5_3_pb.ReadDataSource.Request,
        responseType: tfplugin5_3_pb.ReadDataSource.Response,
        requestSerialize: serialize_tfplugin5_ReadDataSource_Request,
        requestDeserialize: deserialize_tfplugin5_ReadDataSource_Request,
        responseSerialize: serialize_tfplugin5_ReadDataSource_Response,
        responseDeserialize: deserialize_tfplugin5_ReadDataSource_Response
      },
      // ////// Graceful Shutdown
      stop: {
        path: "/tfplugin5.Provider/Stop",
        requestStream: false,
        responseStream: false,
        requestType: tfplugin5_3_pb.Stop.Request,
        responseType: tfplugin5_3_pb.Stop.Response,
        requestSerialize: serialize_tfplugin5_Stop_Request,
        requestDeserialize: deserialize_tfplugin5_Stop_Request,
        responseSerialize: serialize_tfplugin5_Stop_Response,
        responseDeserialize: deserialize_tfplugin5_Stop_Response
      }
    };
    exports2.ProviderClient = grpc2.makeGenericClientConstructor(ProviderService);
    var ProvisionerService = exports2.ProvisionerService = {
      getSchema: {
        path: "/tfplugin5.Provisioner/GetSchema",
        requestStream: false,
        responseStream: false,
        requestType: tfplugin5_3_pb.GetProvisionerSchema.Request,
        responseType: tfplugin5_3_pb.GetProvisionerSchema.Response,
        requestSerialize: serialize_tfplugin5_GetProvisionerSchema_Request,
        requestDeserialize: deserialize_tfplugin5_GetProvisionerSchema_Request,
        responseSerialize: serialize_tfplugin5_GetProvisionerSchema_Response,
        responseDeserialize: deserialize_tfplugin5_GetProvisionerSchema_Response
      },
      validateProvisionerConfig: {
        path: "/tfplugin5.Provisioner/ValidateProvisionerConfig",
        requestStream: false,
        responseStream: false,
        requestType: tfplugin5_3_pb.ValidateProvisionerConfig.Request,
        responseType: tfplugin5_3_pb.ValidateProvisionerConfig.Response,
        requestSerialize: serialize_tfplugin5_ValidateProvisionerConfig_Request,
        requestDeserialize: deserialize_tfplugin5_ValidateProvisionerConfig_Request,
        responseSerialize: serialize_tfplugin5_ValidateProvisionerConfig_Response,
        responseDeserialize: deserialize_tfplugin5_ValidateProvisionerConfig_Response
      },
      provisionResource: {
        path: "/tfplugin5.Provisioner/ProvisionResource",
        requestStream: false,
        responseStream: true,
        requestType: tfplugin5_3_pb.ProvisionResource.Request,
        responseType: tfplugin5_3_pb.ProvisionResource.Response,
        requestSerialize: serialize_tfplugin5_ProvisionResource_Request,
        requestDeserialize: deserialize_tfplugin5_ProvisionResource_Request,
        responseSerialize: serialize_tfplugin5_ProvisionResource_Response,
        responseDeserialize: deserialize_tfplugin5_ProvisionResource_Response
      },
      stop: {
        path: "/tfplugin5.Provisioner/Stop",
        requestStream: false,
        responseStream: false,
        requestType: tfplugin5_3_pb.Stop.Request,
        responseType: tfplugin5_3_pb.Stop.Response,
        requestSerialize: serialize_tfplugin5_Stop_Request,
        requestDeserialize: deserialize_tfplugin5_Stop_Request,
        responseSerialize: serialize_tfplugin5_Stop_Response,
        responseDeserialize: deserialize_tfplugin5_Stop_Response
      }
    };
    exports2.ProvisionerClient = grpc2.makeGenericClientConstructor(ProvisionerService);
  }
});

// src/handlers/index.ts
var handlers_exports = {};
__export(handlers_exports, {
  handler: () => handler
});
module.exports = __toCommonJS(handlers_exports);
var import_client_secrets_manager = require("@aws-sdk/client-secrets-manager");
var import_msgpack_lite2 = __toESM(require_msgpack_lite());

// src/handlers/deployment.ts
var import_msgpack_lite = __toESM(require_msgpack_lite());
var config = __toESM(require_tfplugin5_3_pb());
var Unknown = class {
};
var codec = (0, import_msgpack_lite.createCodec)();
codec.addExtPacker(0, Unknown, () => {
  return (0, import_msgpack_lite.encode)([0]);
});
codec.addExtUnpacker(0, () => {
  return new Unknown();
});
var Deployment = class {
  constructor(options) {
    this.provider = options.provider;
    this.resourceType = options.resourceType;
    this.resourceEventType = options.resourceOrDataType;
    this.id = options.id;
    this.schema = options.resourceOrDataType === "DATA" ? this.provider.dataSchemaToCfn(this.resourceType) : this.provider.resourceSchemaToCfn(this.resourceType);
    if (!this.schema) {
      throw new Error(`Cannot find schema for resource type ${this.resourceType}`);
    }
    if (options.oldCfnState) {
      this.oldState = this.convertCfnToTerraformState(options.oldCfnState);
    } else {
      this.oldState = getDynamicValue({});
    }
    if (options.newCfnState) {
      this.newState = this.convertCfnToTerraformState(options.newCfnState);
    } else {
      this.newState = getDynamicValue({});
    }
    console.log("State: ", JSON.stringify({
      newState: this.newState,
      newStateCfn: options.newCfnState
    }));
  }
  async deploy() {
    try {
      await this.validateConfig(this.newState);
    } catch (e2) {
      console.error("Resource validation failed: ", e2);
      throw e2;
    }
    if (this.resourceEventType === "RESOURCE") {
      const plan = await this.planResourceChange();
      console.error("Plan\n", decodeDynamicValue(plan.plannedState));
      console.error("RequiresReplace\n", plan.requiresReplaceList);
      if ((plan.requiresReplaceList ?? []).length > 0) {
        console.log("Resource requires replacement");
        await this.applyResourceChange(new config.DynamicValue().setMsgpack((0, import_msgpack_lite.encode)(void 0)));
      }
      const resp = await this.applyResourceChange(plan.plannedState);
      return resp;
    } else {
      const resp = await this.readDataSource();
      return resp;
    }
  }
  convertCfnToTerraformState(cfnState, asState) {
    const finalConfig = Object.keys(this.schema).reduce((acc, prev) => {
      acc[prev] = void 0;
      return acc;
    }, {});
    let entries = cfnState;
    if (cfnState instanceof config.DynamicValue) {
      entries = (0, import_msgpack_lite.decode)(Buffer.from(cfnState.getMsgpack()), { codec });
    }
    for (const [key, value] of Object.entries(entries)) {
      finalConfig[key] = value;
    }
    if (asState && this.id) {
      finalConfig.id = this.id;
    }
    return getDynamicValue(finalConfig);
  }
  parseDiagnosticsList(diagnostics, severity) {
    const severities = severity ?? [
      config.Diagnostic.Severity.ERROR,
      config.Diagnostic.Severity.INVALID
    ];
    return diagnostics.reduce((acc, prev) => {
      if (severities.includes(prev.severity)) {
        acc.push(prev);
      }
      return acc;
    }, []);
  }
  async validateConfig(conf) {
    const request = new config.ValidateResourceTypeConfig.Request().setConfig(conf).setTypeName(this.resourceType);
    return new Promise((resolve, reject) => {
      this.provider.client.validateResourceTypeConfig(request, (err, resp) => {
        if (err && err !== null) {
          reject(`Error validating config: ${err}`);
        }
        const respObject = resp.toObject();
        const diagnostics = this.parseDiagnosticsList(respObject.diagnosticsList);
        if (diagnostics.length > 0) {
          reject(`Resource validation failed for resource ${this.resourceType}: 
Error: ${formatDiagnostic(diagnostics)}`);
        }
        resolve();
      });
    });
  }
  async planResourceChange() {
    const newState = this.convertCfnToTerraformState(this.newState, true);
    const oldState = this.convertCfnToTerraformState(this.oldState, true);
    const request = new config.PlanResourceChange.Request().setConfig(newState).setPriorState(oldState).setTypeName(this.resourceType).setProposedNewState(newState);
    return new Promise((resolve, reject) => {
      this.provider.client.planResourceChange(request, (err, resp) => {
        if (err && err !== null) {
          reject(`Error planning resource change: ${err}`);
        }
        const respObject = resp.toObject();
        const diagnostics = this.parseDiagnosticsList(respObject.diagnosticsList);
        if (diagnostics.length > 0) {
          reject(`Plan failed for resource ${this.resourceType}: 
Error: ${formatDiagnostic(diagnostics)}`);
        }
        const requiresReplaceList = respObject.requiresReplaceList.flatMap((r) => r.stepsList.map((s) => s.attributeName));
        const plannedState = resp.getPlannedState();
        if (!plannedState) {
          reject(`Plan failed! No planned state exists for resource ${this.resourceType}`);
        }
        resolve({
          requiresReplaceList,
          plannedState
        });
      });
    });
  }
  async applyResourceChange(plan) {
    const request = new config.ApplyResourceChange.Request().setTypeName(this.resourceType).setConfig(plan).setPriorState(this.convertCfnToTerraformState(this.oldState, true)).setPlannedState(plan);
    return new Promise((resolve, reject) => {
      this.provider.client.applyResourceChange(request, (err, resp) => {
        if (err && err !== null) {
          reject(`Error applying resource change: ${err}`);
        }
        const respObject = resp.toObject();
        const diagnostics = this.parseDiagnosticsList(respObject.diagnosticsList, [
          config.Diagnostic.Severity.ERROR,
          config.Diagnostic.Severity.INVALID,
          config.Diagnostic.Severity.WARNING
        ]);
        if (diagnostics.length > 0) {
          reject(`Apply failed for resource ${this.resourceType}: 
Error: ${formatDiagnostic(diagnostics)}`);
        }
        const state = resp.getNewState();
        if (state) {
          const r = (0, import_msgpack_lite.decode)(Buffer.from(state.getMsgpack()));
          resolve(r);
        }
      });
    });
  }
  async readDataSource() {
    const request = new config.ReadDataSource.Request().setTypeName(this.resourceType).setConfig(this.newState);
    return new Promise((resolve, reject) => {
      this.provider.client.readDataSource(request, (err, resp) => {
        if (err && err !== null)
          reject(err);
        const diag = resp.getDiagnosticsList();
        if (diag.length > 0)
          reject(diag.map((d2) => d2.toObject()));
        const state = resp.getState();
        if (state) {
          const r = (0, import_msgpack_lite.decode)(Buffer.from(state.getMsgpack()));
          resolve(r);
        }
      });
    });
  }
};
function formatDiagnostic(diagnostic) {
  return JSON.stringify({
    errors: diagnostic.map((d2) => {
      var _a, _b;
      return {
        attribute: (_b = (_a = d2.attribute) == null ? void 0 : _a.stepsList) == null ? void 0 : _b.map((a2) => a2.attributeName),
        ...d2
      };
    })
  });
}
function getDynamicValue(value) {
  return new config.DynamicValue().setJson(Buffer.from(JSON.stringify(value), "utf-8")).setMsgpack((0, import_msgpack_lite.encode)(value, { codec }));
}
function decodeDynamicValue(value) {
  return (0, import_msgpack_lite.decode)(Buffer.from(value.getMsgpack()), { codec });
}

// src/handlers/provider.ts
var import_child_process = require("child_process");
var fs = __toESM(require("fs"));
var path = __toESM(require("path"));
var grpc = __toESM(require_src3());
var services = __toESM(require_tfplugin5_3_grpc_pb());
var config2 = __toESM(require_tfplugin5_3_pb());
var Provider = class {
  constructor(_providerName) {
    const pluginPath = path.join(__dirname, ".bin", "terraform-provider-github");
    this.child = shell([pluginPath], {
      env: {
        PLUGIN_TRANSPORTS: "unix,tcp",
        PLUGIN_MAX_PORT: "25000",
        PLUGIN_MIN_PORT: "10000",
        PLUGIN_PROTOCOL_VERSIONS: "5",
        TF_PLUGIN_MAGIC_COOKIE: "d602bf8f470bc67ca7faa0386276bbdd4330efaf76d1a219cb4d6991ca9872b2"
        // TF_LOG: 'TRACE',
        // TF_LOG_LEVEL: 'VERBOSE',
      }
    });
  }
  async start() {
    await new Promise((resolve, reject) => {
      this.child.stdout.on("data", (chunk) => {
        const res = Buffer.from(chunk).toString("utf-8");
        this.path = res.split("|")[3];
        this._client = new services.ProviderClient(`unix://${this.path}`, grpc.credentials.createInsecure());
        resolve();
      });
      this.child.once("error", (err) => {
        reject(err);
      });
      this.child.once("exit", (code) => {
        if (code === 0) {
          this.stop();
        } else {
          reject(`command exited with error code ${code}`);
        }
      });
    });
  }
  stop() {
    this.client.stop(new config2.Stop.Request(), (err, _resp) => {
      this.child.kill();
      if (this.path)
        fs.rmSync(this.path);
      if (err) {
        console.error("stop had an error %s", err);
        throw new Error(err);
      }
    });
  }
  get client() {
    if (!this._client) {
      throw new Error("client has not been created yet!");
    }
    return this._client;
  }
  async configure(opts) {
    const configRequest = new config2.Configure.Request().setConfig(opts);
    await new Promise((resolve, reject) => {
      this.client.configure(configRequest, (err, resp) => {
        if (err)
          reject(err);
        if (resp.getDiagnosticsList().length > 0) {
          reject(resp.getDiagnosticsList());
        }
        resolve();
      });
    });
    await this.loadSchemas();
  }
  resourceSchemaToCfn(resourceType) {
    var _a;
    const cfn = {};
    if (this._resourceSchemasMap && this._resourceSchemasMap.has(resourceType)) {
      const block = (_a = this._resourceSchemasMap.get(resourceType)) == null ? void 0 : _a.getBlock();
      block == null ? void 0 : block.getAttributesList().forEach((att) => {
        cfn[att.getName()] = [att.toObject()];
      });
      block == null ? void 0 : block.getBlockTypesList().forEach((att) => {
        var _a2;
        cfn[att.getTypeName()] = ((_a2 = att.toObject().block) == null ? void 0 : _a2.attributesList) ?? [];
      });
    }
    return cfn;
  }
  dataSchemaToCfn(resourceType) {
    var _a;
    const cfn = {};
    if (this._dataSchemasMap && this._dataSchemasMap.has(resourceType)) {
      const block = (_a = this._dataSchemasMap.get(resourceType)) == null ? void 0 : _a.getBlock();
      block == null ? void 0 : block.getAttributesList().forEach((att) => {
        cfn[att.getName()] = [att.toObject()];
      });
      block == null ? void 0 : block.getBlockTypesList().forEach((att) => {
        var _a2;
        cfn[att.getTypeName()] = ((_a2 = att.toObject().block) == null ? void 0 : _a2.attributesList) ?? [];
      });
    }
    return cfn;
  }
  async loadSchemas() {
    const request = new config2.GetProviderSchema.Request();
    return new Promise((resolve, reject) => {
      this.client.getSchema(request, (err, resp) => {
        if (err)
          reject(err);
        const providerConfig = resp.getProvider();
        console.log("providerConfig", providerConfig == null ? void 0 : providerConfig.toObject().block);
        this._dataSchemasMap = resp.getDataSourceSchemasMap();
        this._resourceSchemasMap = resp.getResourceSchemasMap();
        resolve();
      });
    });
  }
};
function shell(command, opts) {
  const child = (0, import_child_process.spawn)(command[0], command.slice(1), {
    env: {
      ...process.env,
      ...opts.env
    },
    cwd: __dirname,
    stdio: ["ignore", "pipe", "inherit"]
  });
  return child;
}

// src/handlers/index.ts
var config3 = __toESM(require_tfplugin5_3_pb());
async function getProviderConfig(secretId) {
  const client = new import_client_secrets_manager.SecretsManagerClient({});
  const command = new import_client_secrets_manager.GetSecretValueCommand({
    SecretId: secretId
  });
  try {
    const data = await client.send(command);
    const jsonResponse = JSON.parse(data.SecretString);
    return {
      owner: jsonResponse.owner,
      token: jsonResponse.token,
      app_auth: jsonResponse.app_auth ?? void 0,
      base_url: jsonResponse.base_url ?? void 0,
      insecure: jsonResponse.insecure ?? void 0,
      organization: jsonResponse.organization ?? void 0,
      read_delay_ms: jsonResponse.read_delay_ms ?? void 0,
      write_delay_ms: jsonResponse.write_delay_ms ?? void 0
    };
  } catch (e2) {
    throw new Error(`Not a valid provider config ${e2}`);
  }
}
function getDynamicValue2(value) {
  return new config3.DynamicValue().setJson(Buffer.from(JSON.stringify(value), "utf-8")).setMsgpack((0, import_msgpack_lite2.encode)(value, { codec: (0, import_msgpack_lite2.createCodec)() }));
}
async function handler(event) {
  console.log("event: ", JSON.stringify(event));
  let oldAttributes;
  let physicalResourceId = void 0;
  let attributes = event.ResourceProperties.tfAttributes;
  const providerConfig = await getProviderConfig(process.env.PROVIDER_CONFIG_SECRET_ID);
  switch (event.RequestType) {
    case "Delete":
      attributes = void 0;
      break;
    case "Update":
      oldAttributes = event.OldResourceProperties.tfAttributes;
      physicalResourceId = event.PhysicalResourceId;
  }
  const tfInfo = event.ResourceType.split("::")[1].split("@");
  const tfProviderName = tfInfo[0];
  const tfResourceName = tfInfo[1];
  const tfType = event.ResourceProperties.resourceMode ?? "DATA";
  if (!attributes)
    throw new Error("Attributes not available!");
  const provider = new Provider(tfProviderName);
  console.log("Provider created");
  await provider.start();
  console.log("provider started");
  console.log("providerConfig: ", JSON.stringify(providerConfig));
  try {
    await provider.loadSchemas();
    console.log("configuring provider");
    await provider.configure(getDynamicValue2(providerConfig));
    const deployment = new Deployment({
      provider,
      id: physicalResourceId,
      resourceOrDataType: tfType,
      resourceType: tfResourceName,
      newCfnState: attributes,
      oldCfnState: oldAttributes
    });
    const resp = await deployment.deploy();
    console.error("resp: ", resp);
    return {
      PhysicalResourceId: resp.id,
      Data: resp
    };
  } finally {
    provider.stop();
  }
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  handler
});
/*! Bundled license information:

ieee754/index.js:
  (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)

event-lite/event-lite.js:
  (**
   * event-lite.js - Light-weight EventEmitter (less than 1KB when gzipped)
   *
   * @copyright Yusuke Kawasaki
   * @license MIT
   * @constructor
   * @see https://github.com/kawanet/event-lite
   * @see http://kawanet.github.io/event-lite/EventLite.html
   * @example
   * var EventLite = require("event-lite");
   *
   * function MyClass() {...}             // your class
   *
   * EventLite.mixin(MyClass.prototype);  // import event methods
   *
   * var obj = new MyClass();
   * obj.on("foo", function() {...});     // add event listener
   * obj.once("bar", function() {...});   // add one-time event listener
   * obj.emit("foo");                     // dispatch event
   * obj.emit("bar");                     // dispatch another event
   * obj.off("foo");                      // remove event listener
   *)

@grpc/proto-loader/build/src/util.js:
  (**
   * @license
   * Copyright 2018 gRPC authors.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   *)

@grpc/proto-loader/build/src/index.js:
  (**
   * @license
   * Copyright 2018 gRPC authors.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   *)
*/
